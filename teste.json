[{
		"path":	"src/"
	}, {
		"path":	"src/b64/"
	}, {
		"path":	"src/b64/b64.c",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse  * base64_encode_file(LuaCEmbed *args){\n    char *source = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n    char * b64_string =  dtw_convert_binary_file_to_base64(source);\n    if(!b64_string){\n        char *formated  = private_LuaCembed_format(FILE_NOT_FOUND, source);\n        LuaCEmbedResponse  *response = LuaCEmbed_send_error(formated);\n        free(formated);\n        return response;\n    }\n\n    LuaCEmbedResponse  *response = LuaCEmbed_send_str(b64_string);\n    free(b64_string);\n    return response;\n}\n\n\nLuaCEmbedResponse  * base64_decode(LuaCEmbed *args){\n\n    char *source = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n    long size;\n    unsigned char *content = dtw_base64_decode(source,&size);\n    content[size] = '\\0';\n    LuaCEmbedResponse* response =  LuaCEmbed_send_raw_string((char*)content,size);\n    free(content);\n    return response;\n\n}\n\nLuaCEmbedResponse  * base64_encode(LuaCEmbed *args){\n    Writeble  *write_obj = create_writeble(args,0);\n    if(write_obj->error){\n        LuaCEmbedResponse *response =  write_obj->error;\n        Writeble_free(write_obj);\n        return  response;\n    }\n    char *created = dtw_base64_encode(write_obj->content,write_obj->size);\n    Writeble_free(write_obj);\n    LuaCEmbedResponse *response = LuaCEmbed_send_str(created);\n    free(created);\n    return response;\n}\n\n"
	}, {
		"path":	"src/b64/b64.h",
		"is_binary":	false,
		"contet":	"\nLuaCEmbedResponse  * base64_encode_file(LuaCEmbed *args);\n\nLuaCEmbedResponse  * base64_decode(LuaCEmbed *args);\n\nLuaCEmbedResponse  * base64_encode(LuaCEmbed *args);\n\n"
	}, {
		"path":	"src/constants/"
	}, {
		"path":	"src/constants/all.h",
		"is_binary":	false,
		"content":	"#include \"props.h\"\n#include \"commun_methods.h\"\n#include \"type_codes.h\"\n#include \"errors.h\"\n#include \"func_names.h\"\n#include \"schema_methods.h\"\n#include \"resource_methods.h\"\n#include \"hasher_methods.h\"\n#include \"transactions_methods.h\"\n#include \"path_methods.h\"\n#include \"tree_methods.h\"\n#include \"tree_props.h\"\n#include \"tree_part_methods.h\"\n#include \"randonizer_methods.h\"\n#include \"fork_process.h\"\n#include \"locker.h\"\n#include \"database_schema.h\"\n"
	}, {
		"path":	"src/constants/commun_methods.h",
		"is_binary":	false,
		"content":	"#define DELETE_METHOD \"__gc\"\n#define TO_STRING_METHOD \"__tostring\"\n#define TO_NUMBER_METHOD \"__tonumber\"\n#define TO_BOOLEAN_METHOD \"__tobolean\"\n#define INDEX_METHOD \"__index\"\n#define SET_VALUE_METHOD \"set_value\"\n#define GET_VALUE_METHOD \"get_value\"\n#define COMMIT_METHOD \"commit\"\n#define DESTROY_METHOD \"destroy\"\n\n#define SIZE_METHOD \"size\"\n#define GET_PATH_METHOD \"get_path\"\n\n#define GET_DIR_METHOD \"get_dir\"\n#define GET_NAME_METHOD \"get_name\"\n#define GET_NAME_WITHOUT_EXTENSION \"get_name_without_extension\"\n#define GET_EXTENSION_METHOD  \"get_extension\"\n#define GET_ONLY_NAME_METHOD \"get_only_name\"\n\n#define WRITE_METHOD \"write\"\n#define REMOVE_ANY_METHOD \"remove_any\"\n#define MOVE_ANY_METHOD \"move_any\"\n#define COPY_ANY_METHOD \"copy_any\"\n#define DUMP_TO_JSON_FILE_METHOD \"dump_to_json_file\"\n#define DUMP_TO_JSON_STRING \"dump_to_json_string\"\n#define EACH_METHOD \"each\"\n#define MAP_METHOD \"map\"\n#define COUNT_METHOD \"count\"\n#define FIND_METHOD \"find\"\n#define LIST_METHOD \"list\"\n#define FILTER_METHOD \"filter\"\n#define GET_SIZE_METHOD \"get_size\"\n#define SET_EXTENSION_METHOD \"set_extension\"\n\n"
	}, {
		"path":	"src/constants/database_schema.h",
		"is_binary":	false,
		"content":	"\n#define DATABASE_SCHEMA_POINTER \"schema_pointer\"\n"
	}, {
		"path":	"src/constants/errors.h",
		"is_binary":	false,
		"content":	"#define NOT_EXPECTED_TYPE \"table its not a %s  type\"\n#define FILE_NOT_FOUND \"file %s not found\"\n#define FOLDER_NOT_FOUND \"folder %s not found\"\n\n#define ARGUMENT_NOT_PROVIDED \"argument not provided\"\n\n#define NOT_WRITEBLE_ELEMENT \"element of type %s its not in (string,bool,bytes,number)\"\n#define INVALID_INDEX \"invalid index\"\n#define INVALID_JSON_FILE \"file %s its not a valid json\"\n#define INVALID_JSON_STRING \"content its not a valid json\"\n#define ARGUMENT_NOT_IN_STRING_OR_STRING_ARRAY \"arg type in string, string[]\"\n#define IMPOSSIBLE_TO_FORK \"impossible to fork\""
	}, {
		"path":	"src/constants/fork_process.h",
		"is_binary":	false,
		"content":	"#define  PID_PROP \"pid_prop\"\n#define KILL_FORK_METHOD \"kill\"\n#define IS_FORK_ALIVE_METHOD \"is_alive\"\n#define FORK_STATUS_METHOD \"status\"\n#define FORK_SLEEP_DEFAULT_TIME 100\n#define FORK_SLEEP_PROP \"sleep_time\"\n#define FORK_WAIT_METHOD \"wait\""
	}, {
		"path":	"src/constants/func_names.h",
		"is_binary":	false,
		"content":	"#define LOAD_FILE \"load_file\"\n#define WRITE_FILE \"write_file\"\n\n#define COPY_ANY_OVERWRITING \"copy_any_overwriting\"\n#define COPY_ANY_MERGING \"copy_any_merging\"\n#define MOVE_ANY_OVERWRITING \"move_any_overwriting\"\n#define MOVE_ANY_MERGING \"move_any_merging\"\n#define REMOVE_ANY \"remove_any\"\n\n#define LIST_FILES \"list_files\"\n#define LIST_FILES_RECURSIVELY \"list_files_recursively\"\n#define LIST_DIRS \"list_dirs\"\n#define LIST_DIRS_RECURSIVELY \"list_dirs_recursively\"\n#define LIST_ALL \"list_all\"\n#define LIST_ALL_RECURSIVELY \"list_all_recursively\"\n\n#define BBASE_64_ENCODE_FILE \"base64_encode_file\"\n#define BBASE_64_ENCODE \"base64_encode\"\n#define BBASE_64_DECODE \"base64_decode\"\n\n#define GENERATE_SHA \"generate_sha\"\n#define GENERATE_SHA_FROM_FILE \"generate_sha_from_file\"\n#define NEW_HASHER \"newHasher\"\n#define NEW_RESOURCE \"newResource\"\n#define IS_BLOB_FUNC \"is_blob\"\n\n#define IS_DIR_FUNC \"isdir\"\n#define IS_FILE_FUNC \"isfile\"\n#define IS_FILE_BLOB \"isfile_blob\"\n\n#define GENERATE_SHA_FROM_FOLDER_BY_CONTENT \"generate_sha_from_folder_by_content\"\n#define GENERATE_SHA_FROM_FOLDER_BY_LAST_MODIFICATION \"generate_sha_from_folder_by_last_modification\"\n#define CONCAT_PATH \"concat_path\"\n#define NEW_TRANSACTION_FROM_JSON_STRING \"new_transaction_from_json_string\"\n#define NEW_TRANSACTION_FROM_JSON_FILE \"new_transaction_from_file\"\n#define TRY_NEW_TRANSACTION_FROM_JSON_STRING \"try_new_transaction_from_string\"\n#define TRY_NEW_TRANSACTION_FROM_JSON_FILE \"try_new_transaction_from_file\"\n#define NEW_TRANSACTION \"newTransaction\"\n#define NEW_SCHEMA \"newSchema\"\n#define NEW_PATH \"newPath\"\n#define NEW_TREE \"newTree\"\n#define NEW_TREE_FROM_HARWARE \"newTree_from_hardware\"\n#define STARTS_WITH \"starts_with\"\n#define ENDS_WITH \"ends_with\"\n#define NEW_RANDONIZER \"newRandonizer\"\n#define NEW_FORK \"newFork\"\n#define NEW_LOCKER \"newLocker\"\n#define GET_ENTITY_LAST_MODIFICATION_IN_UNIX \"get_entity_last_modification_in_unix\"\n#define  GET_ENTITY_LAST_MODIFICATION \"get_entity_last_modification\"\n\n"
	}, {
		"path":	"src/constants/hasher_methods.h",
		"is_binary":	false,
		"content":	"#define DIGESST_METHOD \"digest\"\n#define DIGESST_FOLDER_BY_CONTENT_METHOD \"digest_folder_by_content\"\n#define DIGESST_FOLDER_BY_LAST_MODIFICATION_METHOD \"digest_folder_by_last_modification\"\n#define DIGESST_FILE_METHOD \"digest_file\"\n#define DIGEST_PATH \"digest_path\""
	}, {
		"path":	"src/constants/locker.h",
		"is_binary":	false,
		"content":	"#define LOCKER_POINTER \"locker_pointer\"\n#define LOCKER_LOCK_METHOD \"lock\"\n#define LOCKER_UNLOCK_METHOD \"unlock\"\n"
	}, {
		"path":	"src/constants/path_methods.h",
		"is_binary":	false,
		"content":	"\n#define PATH_CHANGED_METHOD \"path_changed\"\n#define PATH_ADD_END_DIR_METHOD \"path_add_end_dir\"\n#define PATH_CHANGED_METHOD \"path_changed\"\n#define PATH_ADD_START_DIR_METHOD \"add_start_dir\"\n#define PATH_GET_FULL_PATH_METHOD \"get_full_path\"\n#define PATH_TO_STRING_METHOD \"to_string\"\n#define PATH_REPLACE_DIRS_METHOD \"replace_dirs\"\n#define PATH_GET_TOTAL_DIRS_METHOD \"get_total_dirs\"\n#define PATH_GET_SUB_DIRS_FROM_INDEX_METHOD \"get_sub_dirs_from_index\"\n#define PATH_INSERT_DIR_AT_INDEX_METHOD \"insert_dir_at_index\"\n#define PATH_REMOVE_SUB_DIR_AT_INDEX_METHOD \"remove_sub_dir_at_index\"\n#define PATH_INSERT_DIR_AFTER_METHOD \"insert_dir_after\"\n#define PATH_INSERT_DIR_BEFORE_METHOD \"insert_dir_before\"\n#define PATH_REMOVE_SUB_DIRS_AT_METHOD \"remove_sub_dirs_at\"\n\n#define PATH_SET_NAME_METHOD \"set_name\"\n#define PATH_SET_DIR_METHOD \"set_dir\"\n#define PATH_SET_PATH_METHOD \"set_path\"\n#define PATH_SET_ONLY_NAME_METHOD \"set_only_name\"\n#define PATH_UNPACK \"unpack\"\n"
	}, {
		"path":	"src/constants/props.h",
		"is_binary":	false,
		"content":	"#define DTW_TYPE \"dtw_type\"\n#define SIZE \"size\"\n#define CONTENT_POINTER \"dtw_content_pointer\"\n#define HASH_POINTER \"dtw_hash_pointer\"\n#define RESOURCE_POINTER \"dtw_resource_pointer\"\n#define ACTION_TRANSACTION_POINTER \"dtw_action_transaction_pointer\"\n#define IS_A_REF \"dtw_is_a_ref\"\n#define TRANSACTION_POINTER \"dtw_transaction\"\n#define SCHEMA_POINTER \"dtw_schema\"\n#define TREE_PART_POINTER \"dtw_tree_part\"\n#define PATH_POINTER \"dtw_path_pointer\"\n#define TREE_POINTER \"dtw_tree\"\n#define TREE_PART_POINTER \"dtw_tree_part\"\n#define PATH_PROPS \"path\"\n#define RANDONIZER_POINTER \"randonizer\"\n\n"
	}, {
		"path":	"src/constants/randonizer_methods.h",
		"is_binary":	false,
		"content":	"\n\n#define SET_RANDONIZER_SEED_METHOD \"set_seed\"\n#define SET_RANDONIZER_INTERNAL_SEED_METHOD \"set_internal_seed\"\n#define GENERATE_RANDONIZER_TOKEN \"generate_token\"\n#define GENERATE_RANDONIZER_NUM_METHOD \"generate_num\""
	}, {
		"path":	"src/constants/resource_methods.h",
		"is_binary":	false,
		"content":	"#define ADD_PRIMARY_KEYS \"add_primary_keys\"\n#define  DANGEROUS_REMOVE_PROP_METHOD \"dangerous_remove_prop\"\n#define  DANGEROUS_RENAME_PROP_METHOD \"dangerous_rename_prop\"\n#define  GET_RESOURCE_MATCHING_PRIMARY_KEY_METHOD \"get_resource_matching_primary_key\"\n#define GET_RESOURCE_BY_NAME_ID \"get_resource_by_name_id\"\n#define SCHEMA_NEW_INSERTION \"schema_new_insertion\"\n#define SET_VALUE_IN_SUB_RESOURCE_METHOD \"set_value_in_sub_resource\"\n#define GET_VALUE_FROM_SUB_RESOURCE_METHOD \"get_value_from_sub_resource\"\n#define GET_PATH_STRING_METHOD \"get_path_string\"\n#define RESOURCE_RENAME_METHOD  \"rename\"\n#define SCHEMA_COUNT_RESOURCE_METHOD \"schema_count\"\n#define SCHEMA_LIST_RESOURCE_METHOD \"schema_list\"\n#define SCHEMA_FIND_RESOURCE_METHOD \"schema_find\"\n#define SCHEMA_MAP_RESOURCE_METHOD \"schema_map\"\n#define SCHEMA_EACH_METHOD \"schema_each\"\n#define SCHEMA_FILTER_METHOD \"schema_filter\"\n#define SUB_RESOURCE_NEXT_METHOD \"sub_resource_next\"\n#define SUB_RESOURCE_NOW_METHOD \"sub_resource_now\"\n#define SUB_RESOURCE_NOW_IN_UNIX \"sub_resource_now_in_unix\"\n#define SUB_RESOURCE_RANDOM \"sub_resource_random\"\n#define SUB_RESOURCE_METHOD \"sub_resource\"\n#define RESOURCE_GET_STRING \"get_string\"\n#define RESOURCE_GET_NUMBER \"get_number\"\n#define RESOURCE_GET_BOOL \"get_bool\"\n\n#define UNLOAD_METHOD \"unload\"\n#define UNLOCK_METHOD \"unlock\"\n#define LOCK_METHOD \"lock\"\n#define RESOURCE_NEW_DATABASE_SCHEMA \"newDatabaseSchema\"\n\n#define RESOURCE_TRY_RENAME_METHOD \"try_rename\"\n#define RESOURCE_TRY_SET_VALUE_METHOD \"try_set_value\"\n#define RESOURCE_TRY_DESTROY \"try_destroy\"\n#define RESOURCE_TRY_NEW_SCHEMA \"try_newSchema\"\n#define RESOURCE_TRY_SET_VALUE_IN_SUB_RESOURCE_METHOD \"try_set_value_in_sub_resource\"\n#define RESOURCE_TRY_NEW_INSERTION_METHOD \"try_new_insertion\"\n#define TRY_GET_RESOURCE_MATCHING_PRIMARY_KEY_METHOD \"try_fget_resource_matching_primary_key\"\n#define TRY_GET_RESOURCE_BY_NAME_ID \"try_get_resource_by_name_id\"\n#define  TRY_DANGEROUS_REMOVE_PROP_METHOD \"try_dangerous_remove_prop\"\n#define  TRY_DANGEROUS_RENAME_PROP_METHOD \"try_dangerous_rename_prop\"\n#define TRY_SUB_RESOURCE_METHOD \"try_sub_resource\"\n#define TRY_SUB_RESOURCE_NEXT_METHOD \"try_sub_resource_next\"\n#define TRY_SUB_RESOURCE_NOW_METHOD \"try_sub_resource_now\"\n#define TRY_SUB_RESOURCE_NOW_IN_UNIX \"try_sub_resource_now_in_unix\"\n#define TRY_SUB_RESOURCE_RANDON \"try_sub_resource_random\"\n#define TRY_SCHEMA_LIST \"try_schema_list\"\n#define RESOURCE_GET_TYPE \"get_type\"\n#define RESOURCE_LISTAGE_PROP \"resources\"\n\n"
	}, {
		"path":	"src/constants/schema_methods.h",
		"is_binary":	false,
		"content":	"#define ADD_SUB_SCHEMA_METHOD \"sub_schema\"\n#define SUB_SCHEMA_METHOD \"sub_schema\"\n#define SET_INDEX_NAME_METHOD \"set_index_name\"\n#define SET_VALUE_NAME_METHOD \"set_value_name\""
	}, {
		"path":	"src/constants/transactions_methods.h",
		"is_binary":	false,
		"content":	"\n#define LUA_DO_THE_WORLD_GET_DEST \"get_dest\"\n#define LUA_DO_THE_WORLD_SET_DEST \"set_dest\"\n#define LUA_DO_THE_WORLD_GET_SOURCE \"get_source\"\n#define LUA_DO_THE_WORLD_SET_SOURCE \"set_source\"\n#define LUA_DO_THE_WORLD_GET_CONTENT \"get_content\"\n#define LUA_DO_THE_WORLD_SET_CONTENT \"set_content\"\n#define LUA_DO_THE_WORLD_GET_TRANSACTION_TYPE_CODE \"get_type_code\"\n#define LUA_DO_THE_WORLD_GET_TRANSACTION_TYPE_TEXT \"get_type\"\n#define LUA_DO_THE_WORLD_GET_ACTION \"get_action\""
	}, {
		"path":	"src/constants/tree_methods.h",
		"is_binary":	false,
		"content":	"#define ADD_TREE_PART_METHOD \"add_tree_part\"\n#define GET_TREE_PART_BY_INDEX_METHOD \"get_tree_part_by_index\"\n#define INSECURE_HARDWARE_REMOVE_TREE \"insecure_hardware_remove\"\n#define INSECURE_HARDWARE_WRITE_TREE \"insecure_hardware_write_tree\"\n#define GET_TREE_PART_BY_NAME \"get_tree_part_by_name\"\n#define GET_TREE_PART_BY_PATH \"get_tree_part_by_path\"\n\n\n#define TREE_PART_CONTENT_EXIST_IN_HARDWARE \"content_exist_in_hardware\"\n#define TREE_PART_CONTENT_EXIST \"content_exist\"\n"
	}, {
		"path":	"src/constants/tree_part_methods.h",
		"is_binary":	false,
		"content":	"\n#define HARDWARE_REMOVE_METHOD \"hardware_remove\"\n#define HARWARE_WRITE_METHOD \"hardware_write\"\n#define HARDWARE_MODIFY_METHOD \"hardware_modify\"\n#define GET_SHA_METHOD \"get_sha\"\n#define LOAD_METHOD \"load\""
	}, {
		"path":	"src/constants/tree_props.h",
		"is_binary":	false,
		"content":	"#define TREE_PROPS_CONTENT \"include_content\"\n#define TREE_PROPS_CONTENT_DATA \"include_content_data\"\n#define TREE_PROPS_HARDWARE_DATA \"include_hardware_data\"\n#define TREE_PROPS_IGNORED_ELEMENTS \"include_ignored_elements\"\n#define TREE_PROPS_MIMIFICATION \"mimify_json\"\n#define TREE_PROPS_PATH_ATTRIBUTES \"include_path_attributes\"\n#define TREE_NEW_TREE_PART_EMPTY \"newTreePart_empty\"\n#define TREE_NEW_TREE_PART_LOADING \"newTreePart_loading\"\n#define TREE_NEW_TREE_PART \"newTreePart\""
	}, {
		"path":	"src/constants/type_codes.h",
		"is_binary":	false,
		"content":	"#define DTW_RESOURCE_TYPE 1\n#define DTW_ACTION_TRANSACTION_TYPE 3\n#define DTW_TREE_PART_TYPE 4"
	}, {
		"path":	"src/declaration.h",
		"is_binary":	false,
		"content":	"#include \"macros/all.h\"\n#include \"constants/all.h\"\n#include \"writeble/writble.h\"\n#include \"io/io.h\"\n#include \"types/types.h\"\n#include \"listage/listage.h\"\n#include \"b64/b64.h\"\n#include \"sha/sha.h\"\n#include \"hasher/hasher.h\"\n#include \"resource/declaration.h\"\n#include \"transaction/declaration.h\"\n#include \"tree/declaration.h\"\n#include \"path/path.h\"\n#include \"extra/extra.h\"\n#include \"randonizer/randonizer.h\"\n#include \"fork_process/fork_process.h\"\n#include \"locker/locker.h\"\n#include \"entity_modification/entity_modification.h\""
	}, {
		"path":	"src/definition.h",
		"is_binary":	false,
		"content":	"#include \"io/io.c\"\n#include \"writeble/writble.c\"\n#include \"types/types.c\"\n#include \"listage/listage.c\"\n#include \"b64/b64.c\"\n#include \"sha/sha.c\"\n#include \"hasher/hasher.c\"\n#include \"resource/definition.h\"\n#include \"transaction/definition.h\"\n#include \"tree/definition.h\"\n#include \"path/path.c\"\n#include \"extra/extra.c\"\n#include \"randonizer/randonizer.c\"\n#include \"fork_process/fork_process.c\"\n#include \"locker/locker.c\"\n#include \"entity_modification/entity_modification.c\""
	}, {
		"path":	"src/dependecies.h",
		"is_binary":	false,
		"content":	"\n#include \"dependencies/luaCEmbed/one.c\"\n#include \"dependencies/doTheWorld/one.c\"\n#include \"dependencies/UniversalGarbage/one.h\""
	}, {
		"path":	"src/dependencies/"
	}, {
		"path":	"src/dependencies/UniversalGarbage/"
	}, {
		"path":	"src/dependencies/UniversalGarbage/declaration.h",
		"is_binary":	false,
		"content":	"\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n\n\n#include \"macros.h\"\n#include \"garbage_element/garbage_element.h\"\n#include \"garbage/garbage.h\"\n"
	}, {
		"path":	"src/dependencies/UniversalGarbage/definition.h",
		"is_binary":	false,
		"content":	"#include \"garbage_element/garbage_element.c\"\n#include \"garbage/garbage.c\"\n\n"
	}, {
		"path":	"src/dependencies/UniversalGarbage/garbage/"
	}, {
		"path":	"src/dependencies/UniversalGarbage/garbage/garbage.c",
		"is_binary":	false,
		"content":	"UniversalGarbage * private_new_MainUniversalGarbage(){\n    UniversalGarbage *self = UniversalGarbage_create_empty_struct(self,UniversalGarbage)\n    self->elements = (privateUniversalGarbageElement**)malloc(0);\n    self->is_the_root = false;\n    return self;\n}\n\nUniversalGarbage * newUniversalGarbage(){\n    UniversalGarbage *self = UniversalGarbage_create_empty_struct(self,UniversalGarbage)\n    self->is_the_root = true;\n    self->elements = (privateUniversalGarbageElement**)malloc(0);\n    self->return_values =private_new_MainUniversalGarbage();\n\n    return self;\n}\n\n\n\n\nbool  rawUniversalGarbage_reallocate(UniversalGarbage *self, void **pointer){\n\n    if(self->is_the_root){\n\n        if(rawUniversalGarbage_reallocate(self->return_values,pointer)){\n            return true;\n        }\n    }\n\n\n    for(int i = 0; i < self->elements_size; i++){\n\n        privateUniversalGarbageElement *current = self->elements[i];\n        bool reallocate = current->pointer == pointer;\n\n        if(reallocate){\n            current->pointed_value = *pointer;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool rawUniversalGarbage_resset(UniversalGarbage *self, void **pointer){\n\n    if(self->is_the_root){\n        if(rawUniversalGarbage_resset(self->return_values,pointer)){\n            return true;\n        }\n    }\n\n\n    for(int i = 0; i < self->elements_size; i++){\n        privateUniversalGarbageElement *current = self->elements[i];\n        bool resset = current->pointer == pointer;\n        if(resset){\n            private_UniversalGarbageSimpleElement_free_pointed_value(current);\n            current->pointed_value = *pointer;\n            return true;\n        }\n    }\n    return  false;\n\n}\nbool  rawUniversalGarbage_remove(UniversalGarbage *self, void **pointer){\n    if(self->is_the_root){\n        if(rawUniversalGarbage_remove(self->return_values,pointer)){\n            *pointer = NULL;\n            return true;\n        }\n    }\n\n    for(int i = 0; i < self->elements_size; i++){\n        privateUniversalGarbageElement *current = self->elements[i];\n        if(current->pointer == pointer){\n            private_UniversalGarbageSimpleElement_free(current);\n            self->elements_size-=1;\n            bool its_not_the_last = i < self->elements_size;\n            if(its_not_the_last){\n                self->elements[i] = self->elements[self->elements_size];\n\n            }\n            *pointer = NULL;\n            return  true;\n        }\n    }\n    return  false;\n}\nbool  rawUniversalGarbage_disconnect(UniversalGarbage *self, void **pointer){\n    if(self->is_the_root){\n        if(rawUniversalGarbage_disconnect(self->return_values,pointer)){\n            return true;\n        }\n    }\n\n    for(int i = 0; i < self->elements_size; i++){\n        privateUniversalGarbageElement *current = self->elements[i];\n        if(current->pointer == pointer){\n            free(current);\n            self->elements_size-=1;\n            bool its_not_the_last = i < self->elements_size;\n            if(its_not_the_last){\n                self->elements[i] = self->elements[self->elements_size];\n            }\n            return true;\n        }\n    }\n    return  false;\n\n\n\n}\nbool  rawUniversalGarbage_add(UniversalGarbage *self, void *release_callback, void **pointer){\n\n    if(!pointer){\n        return false;\n    }\n\n\n    for(int i = 0; i < self->elements_size; i++){\n        privateUniversalGarbageElement *current = self->elements[i];\n        if(current->pointer == pointer){\n            return false;\n        }\n    }\n\n    self->elements = (privateUniversalGarbageElement**)realloc(\n            self->elements,\n            (self->elements_size + 1) * sizeof(privateUniversalGarbageElement*)\n    );\n    void (*dealocator_callback)(void *element);\n#ifdef __cplusplus\n    dealocator_callback =reinterpret_cast<void(*)(void*)>(release_callback);\n#else\n    dealocator_callback = (void*)(void*)release_callback;\n\n#endif\n\n\n\n    self->elements[self->elements_size] = private_newUniversalGarbageSimpleElement(dealocator_callback, pointer);\n    self->elements_size+=1;\n    return  true;\n}\n\n\n\nvoid  private_UniversalGarbage_free_all_sub_elements(UniversalGarbage *self){\n    for(int i = 0; i < self->elements_size; i++){\n        private_UniversalGarbageSimpleElement_free(self->elements[i]);\n    }\n    free(self->elements);\n}\n\nvoid UniversalGarbage_free_including_return(UniversalGarbage *self){\n    private_UniversalGarbage_free_all_sub_elements(self);\n    if(self->is_the_root){\n        UniversalGarbage_free(self->return_values);\n    }\n    free(self);\n}\n\nvoid UniversalGarbage_free(UniversalGarbage *self){\n    private_UniversalGarbage_free_all_sub_elements(self);\n\n    if(self->is_the_root){\n\n        UniversalGarbage *return_garbage = self->return_values;\n        for(int i = 0; i < return_garbage->elements_size; i++){\n            free(return_garbage->elements[i]);\n        }\n\n        free(return_garbage->elements);\n        free(return_garbage);\n    }\n\n\n    free(self);\n}\n"
	}, {
		"path":	"src/dependencies/UniversalGarbage/garbage/garbage.h",
		"is_binary":	false,
		"content":	"\n\ntypedef  struct UniversalGarbage{\n\n    struct UniversalGarbage *return_values;\n    privateUniversalGarbageElement **elements;\n    int  elements_size;\n    bool is_the_root;\n\n}UniversalGarbage;\n\nUniversalGarbage * newUniversalGarbage();\n\nUniversalGarbage * private_new_MainUniversalGarbage();\n\n\n\nbool  rawUniversalGarbage_resset(UniversalGarbage *self, void **pointer);\n\nbool  rawUniversalGarbage_remove(UniversalGarbage *self, void **pointer);\n\nbool  rawUniversalGarbage_disconnect(UniversalGarbage *self, void **pointer);\n\nbool rawUniversalGarbage_reallocate(UniversalGarbage *self, void **pointer);\n\nbool  rawUniversalGarbage_add(UniversalGarbage *self,  void *release_callback, void **pointer);\n\nvoid private_UniversalGarbage_free_all_sub_elements(UniversalGarbage *self);\n\nvoid UniversalGarbage_free_including_return(UniversalGarbage *self);\n\nvoid UniversalGarbage_free(UniversalGarbage *self);\n"
	}, {
		"path":	"src/dependencies/UniversalGarbage/garbage_element/"
	}, {
		"path":	"src/dependencies/UniversalGarbage/garbage_element/garbage_element.c",
		"is_binary":	false,
		"content":	"\n\n\nprivateUniversalGarbageElement * private_newUniversalGarbageSimpleElement(void (*dealocator_callback)(void *element), void **pointer){\n\n    privateUniversalGarbageElement * self = UniversalGarbage_create_empty_struct(\n        self,\n        privateUniversalGarbageElement\n    );\n    self->pointer = pointer;\n    self->deallocator_callback = dealocator_callback;\n    self->pointed_value = *pointer;\n    return  self;\n}\nvoid private_UniversalGarbageSimpleElement_free_pointed_value(privateUniversalGarbageElement *self){\n    if(self->pointed_value){\n        self->deallocator_callback(self->pointed_value);\n        self->pointed_value = NULL;\n    }\n}\n\nvoid private_UniversalGarbageSimpleElement_free(privateUniversalGarbageElement *self){\n    private_UniversalGarbageSimpleElement_free_pointed_value(self);\n    free(self);\n}\n"
	}, {
		"path":	"src/dependencies/UniversalGarbage/garbage_element/garbage_element.h",
		"is_binary":	false,
		"content":	"\n\n\ntypedef struct privateUniversalGarbageElement{\n    void **pointer;\n    void (*deallocator_callback)(void *element);\n    void *pointed_value;\n}privateUniversalGarbageElement;\n\nvoid private_UniversalGarbageSimpleElement_free_pointed_value(privateUniversalGarbageElement *self);\n\n\nvoid private_UniversalGarbageSimpleElement_free(privateUniversalGarbageElement *self);\n\nprivateUniversalGarbageElement * private_newUniversalGarbageSimpleElement(void (*dealocator_callback)(void *element), void **pointer);"
	}, {
		"path":	"src/dependencies/UniversalGarbage/macros.h",
		"is_binary":	false,
		"content":	"\n#define UniversalGarbage_create_empty_struct(name,element_type) \\\n(element_type*)malloc(sizeof(element_type));    \\\n*name = (element_type){0};\n\n\n#define UniversalGarbage_cast(value) ((void**)&value)\n\n\n#define UniversalGarbage_add(garbage,deallocator_callback,value) \\\n    rawUniversalGarbage_add(garbage,(void*)deallocator_callback,UniversalGarbage_cast(value))\n\n#define UniversalGarbage_add_simple(garbage,value) \\\n     UniversalGarbage_add(garbage,free,value)\n\n\n#define UniversalGarbage_add_return(garbage,deallocator_callback,value) \\\n        UniversalGarbage_add(garbage->return_values,deallocator_callback,value)\n\n\n#define UniversalGarbage_add_simple_return(garbage,value) \\\n    UniversalGarbage_add_simple(garbage->return_values,value)\n\n\n\n#define  UniversalGarbage_remove(garbage,value) \\\n    rawUniversalGarbage_remove(garbage,UniversalGarbage_cast(value));\n\n\n#define  UniversalGarbage_disconnect(garbage,value) \\\n    rawUniversalGarbage_disconnect(garbage,UniversalGarbage_cast(value));\n\n\n\n\n#define UniversalGarbage_reallocate(garbage,value) \\\n    rawUniversalGarbage_reallocate(garbage,UniversalGarbage_cast(value))\n\n\n#define UniversalGarbage_resset(garbage,value) \\\n    rawUniversalGarbage_resset(garbage,UniversalGarbage_cast(value))\n\n"
	}, {
		"path":	"src/dependencies/UniversalGarbage/one.h",
		"is_binary":	false,
		"content":	"\n\n#ifndef UNIVERSAL_GARBAGE_H\n#include \"declaration.h\"\n#include \"definition.h\"\n\n#define UNIVERSAL_GARBAGE_H\n#endif"
	}, {
		"path":	"src/dependencies/doTheWorld/"
	}, {
		"path":	"src/dependencies/doTheWorld/base64/"
	}, {
		"path":	"src/dependencies/doTheWorld/base64/base64.c",
		"is_binary":	false,
		"content":	"\n\nchar *dtw_base64_encode(unsigned char *data, long input_length){\n    if (data == NULL) return NULL;\n\n    size_t output_length = 4 * ((input_length + 2) / 3);\n\n    char *encoded_data = (char *)malloc(output_length + 1);\n\n\n    long i, j;\n    for (i = 0, j = 0; i < input_length; ) {\n        unsigned char b0 = i < input_length ? data[i++] : 0;\n        unsigned char b1 = i < input_length ? data[i++] : 0;\n        unsigned char b2 = i < input_length ? data[i++] : 0;\n\n        unsigned char b = b0 >> 2;\n        encoded_data[j++] = dtw_base64_table[b];\n\n        b = (b0 << 4) & 0x3F;\n        b |= b1 >> 4;\n        encoded_data[j++] = dtw_base64_table[b];\n\n        b = (b1 << 2) & 0x3F;\n        b |= b2 >> 6;\n        encoded_data[j++] = i <= input_length + 1 ? dtw_base64_table[b] : '=';\n\n        b = b2 & 0x3F;\n        encoded_data[j++] = i <= input_length ? dtw_base64_table[b] : '=';\n    }\n\n    encoded_data[j] = '\\0';\n    return encoded_data;\n}\n\n\nunsigned char *dtw_base64_decode(const char *data, long *output_length){\n    long input_length = (long)strlen(data);\n    if (input_length % 4 != 0) return NULL;\n\n    *output_length = input_length / 4 * 3;\n    if (data[input_length - 1] == '=') (*output_length)--;\n    if (data[input_length - 2] == '=') (*output_length)--;\n\n    unsigned char *decoded_data = (unsigned char*) malloc(*output_length +2);\n\n\n    long i, j;\n    for (i = 0, j = 0; i < input_length; ) {\n        unsigned char b0 = data[i] == '=' ? 0 & i++ : strchr(dtw_base64_table, data[i++]) - dtw_base64_table;\n        unsigned char b1 = data[i] == '=' ? 0 & i++ : strchr(dtw_base64_table, data[i++]) - dtw_base64_table;\n        unsigned char b2 = data[i] == '=' ? 0 & i++ : strchr(dtw_base64_table, data[i++]) - dtw_base64_table;\n        unsigned char b3 = data[i] == '=' ? 0 & i++ : strchr(dtw_base64_table, data[i++]) - dtw_base64_table;\n\n        unsigned char b = (b0 << 2) | (b1 >> 4);\n        decoded_data[j++] = b;\n\n        if (j < *output_length) {\n            b = (b1 << 4) | (b2 >> 2);\n            decoded_data[j++] = b;\n        }\n        if (j < *output_length) {\n            b = (b2 << 6) | b3;\n            decoded_data[j++] = b;\n        }\n    }\n    decoded_data[*output_length] = '\\0';\n\n    return decoded_data;\n}\n\nchar *dtw_convert_binary_file_to_base64(const char *path){\n     long size;\n     unsigned char *data  = dtw_load_binary_content(path, &size);\n    char *b64   = dtw_base64_encode(data, size);\n    free(data);\n    return b64;\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/base64/base64.h",
		"is_binary":	false,
		"content":	"\n\nchar *dtw_base64_encode(unsigned char *data, long input_length);\n\n\nunsigned char *dtw_base64_decode(const char *data, long *output_length);\n\n\nchar *dtw_convert_binary_file_to_base64(const char *path);"
	}, {
		"path":	"src/dependencies/doTheWorld/declaration.h",
		"is_binary":	false,
		"content":	"\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifndef DO_THE_WORLD_H\n\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <time.h>\n\n#include <stdarg.h>\n\n#include <errno.h>\n#include <sys/file.h>\n#include <sys/time.h>\n\n\n\n#ifdef __linux__\n#include <sys/wait.h>\n  #include <dirent.h>\n  #include <unistd.h>\n#elif _WIN32\n  #include <windows.h>\n  #include <tchar.h>\n  #include <wchar.h>\n  #include <locale.h>\n  #include <direct.h>\n#endif\n\n#include \"dependencies/declaration.h\"\n#include \"string_array/string_array.h\"\n#include \"sha256/sha256.h\"\n#include \"base64/base64.h\"\n#include \"randonizer/randonizer.h\"\n#include \"extras/extras.h\"\n#include \"string_functions/string_functions.h\"\n#include \"io/io.h\"\n#include \"numeral_io/numeral_io.h\"\n#include \"listage_wrappers/listage_wrappers.h\"\n#include \"monodimension_listage/monodimension_listage.h\"\n#include \"multidimension_listage/multidimension_listage.h\"\n#include \"path/declaration.h\"\n#include \"tree/declarations.h\"\n\n#include \"lockers/declaration.h\"\n\n#include \"transaction/declaration.h\"\n#include \"resource/declaration.h\"\n#include \"hash/hash.h\"\n#include \"namespace/declaration.h\"\n#define DO_THE_WORLD_H\n#endif\n\n#ifdef __cplusplus\n}\n#endif"
	}, {
		"path":	"src/dependencies/doTheWorld/definition.c",
		"is_binary":	false,
		"content":	"\n\n\n#include \"declaration.h\"\n#include \"globals.c\"\n\n#include \"sha256/sha256.c\"\n#include \"base64/base64.c\"\n#include \"randonizer/randonizer.c\"\n#include \"extras/extras.c\"\n#include \"string_functions/string_functions.c\"\n#include \"io/io.c\"\n#include \"numeral_io/numeral_io.c\"\n#include \"listage_wrappers/listage_wrappers.c\"\n#include \"monodimension_listage/monodimension_listage_linux.c\"\n#include \"monodimension_listage/monodimension_listage_win32.c\"\n#include \"multidimension_listage/multidimension_listage.c\"\n#include \"path/definition.c\"\n#include \"string_array/string_array.c\"\n#include \"tree/definition.c\"\n\n#include \"lockers/definition.c\"\n\n#include \"resource/definition.c\"\n#include \"transaction/definition.c\"\n#include \"hash/hash.c\"\n#include \"namespace/definition.c\"\n\n\n\n\n\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/dependencies/"
	}, {
		"path":	"src/dependencies/doTheWorld/dependencies/cJSON/"
	}, {
		"path":	"src/dependencies/doTheWorld/dependencies/cJSON/cJSON.c",
		"is_binary":	false,
		"content":	"/*\n  Copyright (c) 2009-2017 Dave Gamble and cJSON contributors\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.\n*/\n\n/* cJSON */\n/* JSON parser in C. */\n\n/* disable warnings about old C89 functions in MSVC */\n#if !defined(_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER)\n#define _CRT_SECURE_NO_DEPRECATE\n#endif\n\n#ifdef __GNUC__\n#pragma GCC visibility push(default)\n#endif\n#if defined(_MSC_VER)\n#pragma warning (push)\n/* disable warning about single line comments in system headers */\n#pragma warning (disable : 4001)\n#endif\n\n#include <string.h>\n#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <ctype.h>\n#include <float.h>\n\n#ifdef ENABLE_LOCALES\n#include <locale.h>\n#endif\n\n#if defined(_MSC_VER)\n#pragma warning (pop)\n#endif\n#ifdef __GNUC__\n#pragma GCC visibility pop\n#endif\n\n#include \"cJSON.h\"\n\n/* define our own boolean type */\n#ifdef true\n#undef true\n#endif\n#define true ((cJSON_bool)1)\n\n#ifdef false\n#undef false\n#endif\n#define false ((cJSON_bool)0)\n\n/* define isnan and isinf for ANSI C, if in C99 or above, isnan and isinf has been defined in math.h */\n#ifndef isinf\n#define isinf(d) (isnan((d - d)) && !isnan(d))\n#endif\n#ifndef isnan\n#define isnan(d) (d != d)\n#endif\n\n#ifndef NAN\n#ifdef _WIN32\n#define NAN sqrt(-1.0)\n#else\n#define NAN 0.0/0.0\n#endif\n#endif\n\ntypedef struct {\n    const unsigned char *json;\n    size_t position;\n} error;\nstatic error global_error = { NULL, 0 };\n\nCJSON_PUBLIC(const char *) cJSON_GetErrorPtr(void)\n{\n    return (const char*) (global_error.json + global_error.position);\n}\n\nCJSON_PUBLIC(char *) cJSON_GetStringValue(const cJSON * const item)\n{\n    if (!cJSON_IsString(item))\n    {\n        return NULL;\n    }\n\n    return item->valuestring;\n}\n\nCJSON_PUBLIC(double) cJSON_GetNumberValue(const cJSON * const item)\n{\n    if (!cJSON_IsNumber(item))\n    {\n        return (double) NAN;\n    }\n\n    return item->valuedouble;\n}\n\n/* This is a safeguard to prevent copy-pasters from using incompatible C and header files */\n#if (CJSON_VERSION_MAJOR != 1) || (CJSON_VERSION_MINOR != 7) || (CJSON_VERSION_PATCH != 18)\n    #error cJSON.h and cJSON.c have different versions. Make sure that both have the same.\n#endif\n\nCJSON_PUBLIC(const char*) cJSON_Version(void)\n{\n    static char version[15];\n    sprintf(version, \"%i.%i.%i\", CJSON_VERSION_MAJOR, CJSON_VERSION_MINOR, CJSON_VERSION_PATCH);\n\n    return version;\n}\n\n/* Case insensitive string comparison, doesn't consider two NULL pointers equal though */\nstatic int case_insensitive_strcmp(const unsigned char *string1, const unsigned char *string2)\n{\n    if ((string1 == NULL) || (string2 == NULL))\n    {\n        return 1;\n    }\n\n    if (string1 == string2)\n    {\n        return 0;\n    }\n\n    for(; tolower(*string1) == tolower(*string2); (void)string1++, string2++)\n    {\n        if (*string1 == '\\0')\n        {\n            return 0;\n        }\n    }\n\n    return tolower(*string1) - tolower(*string2);\n}\n\ntypedef struct internal_hooks\n{\n    void *(CJSON_CDECL *allocate)(size_t size);\n    void (CJSON_CDECL *deallocate)(void *pointer);\n    void *(CJSON_CDECL *reallocate)(void *pointer, size_t size);\n} internal_hooks;\n\n#if defined(_MSC_VER)\n/* work around MSVC error C2322: '...' address of dllimport '...' is not static */\nstatic void * CJSON_CDECL internal_malloc(size_t size)\n{\n    return malloc(size);\n}\nstatic void CJSON_CDECL internal_free(void *pointer)\n{\n    free(pointer);\n}\nstatic void * CJSON_CDECL internal_realloc(void *pointer, size_t size)\n{\n    return realloc(pointer, size);\n}\n#else\n#define internal_malloc malloc\n#define internal_free free\n#define internal_realloc realloc\n#endif\n\n/* strlen of character literals resolved at compile time */\n#define static_strlen(string_literal) (sizeof(string_literal) - sizeof(\"\"))\n\nstatic internal_hooks global_hooks = { internal_malloc, internal_free, internal_realloc };\n\nstatic unsigned char* cJSON_strdup(const unsigned char* string, const internal_hooks * const hooks)\n{\n    size_t length = 0;\n    unsigned char *copy = NULL;\n\n    if (string == NULL)\n    {\n        return NULL;\n    }\n\n    length = strlen((const char*)string) + sizeof(\"\");\n    copy = (unsigned char*)hooks->allocate(length);\n    if (copy == NULL)\n    {\n        return NULL;\n    }\n    memcpy(copy, string, length);\n\n    return copy;\n}\n\nCJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks)\n{\n    if (hooks == NULL)\n    {\n        /* Reset hooks */\n        global_hooks.allocate = malloc;\n        global_hooks.deallocate = free;\n        global_hooks.reallocate = realloc;\n        return;\n    }\n\n    global_hooks.allocate = malloc;\n    if (hooks->malloc_fn != NULL)\n    {\n        global_hooks.allocate = hooks->malloc_fn;\n    }\n\n    global_hooks.deallocate = free;\n    if (hooks->free_fn != NULL)\n    {\n        global_hooks.deallocate = hooks->free_fn;\n    }\n\n    /* use realloc only if both free and malloc are used */\n    global_hooks.reallocate = NULL;\n    if ((global_hooks.allocate == malloc) && (global_hooks.deallocate == free))\n    {\n        global_hooks.reallocate = realloc;\n    }\n}\n\n/* Internal constructor. */\nstatic cJSON *cJSON_New_Item(const internal_hooks * const hooks)\n{\n    cJSON* node = (cJSON*)hooks->allocate(sizeof(cJSON));\n    if (node)\n    {\n        memset(node, '\\0', sizeof(cJSON));\n    }\n\n    return node;\n}\n\n/* Delete a cJSON structure. */\nCJSON_PUBLIC(void) cJSON_Delete(cJSON *item)\n{\n    cJSON *next = NULL;\n    while (item != NULL)\n    {\n        next = item->next;\n        if (!(item->type & cJSON_IsReference) && (item->child != NULL))\n        {\n            cJSON_Delete(item->child);\n        }\n        if (!(item->type & cJSON_IsReference) && (item->valuestring != NULL))\n        {\n            global_hooks.deallocate(item->valuestring);\n            item->valuestring = NULL;\n        }\n        if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))\n        {\n            global_hooks.deallocate(item->string);\n            item->string = NULL;\n        }\n        global_hooks.deallocate(item);\n        item = next;\n    }\n}\n\n/* get the decimal point character of the current locale */\nstatic unsigned char get_decimal_point(void)\n{\n#ifdef ENABLE_LOCALES\n    struct lconv *lconv = localeconv();\n    return (unsigned char) lconv->decimal_point[0];\n#else\n    return '.';\n#endif\n}\n\ntypedef struct\n{\n    const unsigned char *content;\n    size_t length;\n    size_t offset;\n    size_t depth; /* How deeply nested (in arrays/objects) is the input at the current offset. */\n    internal_hooks hooks;\n} parse_buffer;\n\n/* check if the given size is left to read in a given parse buffer (starting with 1) */\n#define can_read(buffer, size) ((buffer != NULL) && (((buffer)->offset + size) <= (buffer)->length))\n/* check if the buffer can be accessed at the given index (starting with 0) */\n#define can_access_at_index(buffer, index) ((buffer != NULL) && (((buffer)->offset + index) < (buffer)->length))\n#define cannot_access_at_index(buffer, index) (!can_access_at_index(buffer, index))\n/* get a pointer to the buffer at the position */\n#define buffer_at_offset(buffer) ((buffer)->content + (buffer)->offset)\n\n/* Parse the input text to generate a number, and populate the result into item. */\nstatic cJSON_bool parse_number(cJSON * const item, parse_buffer * const input_buffer)\n{\n    double number = 0;\n    unsigned char *after_end = NULL;\n    unsigned char number_c_string[64];\n    unsigned char decimal_point = get_decimal_point();\n    size_t i = 0;\n\n    if ((input_buffer == NULL) || (input_buffer->content == NULL))\n    {\n        return false;\n    }\n\n    /* copy the number into a temporary buffer and replace '.' with the decimal point\n     * of the current locale (for strtod)\n     * This also takes care of '\\0' not necessarily being available for marking the end of the input */\n    for (i = 0; (i < (sizeof(number_c_string) - 1)) && can_access_at_index(input_buffer, i); i++)\n    {\n        switch (buffer_at_offset(input_buffer)[i])\n        {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            case '+':\n            case '-':\n            case 'e':\n            case 'E':\n                number_c_string[i] = buffer_at_offset(input_buffer)[i];\n                break;\n\n            case '.':\n                number_c_string[i] = decimal_point;\n                break;\n\n            default:\n                goto loop_end;\n        }\n    }\nloop_end:\n    number_c_string[i] = '\\0';\n\n    number = strtod((const char*)number_c_string, (char**)&after_end);\n    if (number_c_string == after_end)\n    {\n        return false; /* parse_error */\n    }\n\n    item->valuedouble = number;\n\n    /* use saturation in case of overflow */\n    if (number >= INT_MAX)\n    {\n        item->valueint = INT_MAX;\n    }\n    else if (number <= (double)INT_MIN)\n    {\n        item->valueint = INT_MIN;\n    }\n    else\n    {\n        item->valueint = (int)number;\n    }\n\n    item->type = cJSON_Number;\n\n    input_buffer->offset += (size_t)(after_end - number_c_string);\n    return true;\n}\n\n/* don't ask me, but the original cJSON_SetNumberValue returns an integer or double */\nCJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number)\n{\n    if (number >= INT_MAX)\n    {\n        object->valueint = INT_MAX;\n    }\n    else if (number <= (double)INT_MIN)\n    {\n        object->valueint = INT_MIN;\n    }\n    else\n    {\n        object->valueint = (int)number;\n    }\n\n    return object->valuedouble = number;\n}\n\n/* Note: when passing a NULL valuestring, cJSON_SetValuestring treats this as an error and return NULL */\nCJSON_PUBLIC(char*) cJSON_SetValuestring(cJSON *object, const char *valuestring)\n{\n    char *copy = NULL;\n    /* if object's type is not cJSON_String or is cJSON_IsReference, it should not set valuestring */\n    if ((object == NULL) || !(object->type & cJSON_String) || (object->type & cJSON_IsReference))\n    {\n        return NULL;\n    }\n    /* return NULL if the object is corrupted or valuestring is NULL */\n    if (object->valuestring == NULL || valuestring == NULL)\n    {\n        return NULL;\n    }\n    if (strlen(valuestring) <= strlen(object->valuestring))\n    {\n        strcpy(object->valuestring, valuestring);\n        return object->valuestring;\n    }\n    copy = (char*) cJSON_strdup((const unsigned char*)valuestring, &global_hooks);\n    if (copy == NULL)\n    {\n        return NULL;\n    }\n    if (object->valuestring != NULL)\n    {\n        cJSON_free(object->valuestring);\n    }\n    object->valuestring = copy;\n\n    return copy;\n}\n\ntypedef struct\n{\n    unsigned char *buffer;\n    size_t length;\n    size_t offset;\n    size_t depth; /* current nesting depth (for formatted printing) */\n    cJSON_bool noalloc;\n    cJSON_bool format; /* is this print a formatted print */\n    internal_hooks hooks;\n} printbuffer;\n\n/* realloc printbuffer if necessary to have at least \"needed\" bytes more */\nstatic unsigned char* ensure(printbuffer * const p, size_t needed)\n{\n    unsigned char *newbuffer = NULL;\n    size_t newsize = 0;\n\n    if ((p == NULL) || (p->buffer == NULL))\n    {\n        return NULL;\n    }\n\n    if ((p->length > 0) && (p->offset >= p->length))\n    {\n        /* make sure that offset is valid */\n        return NULL;\n    }\n\n    if (needed > INT_MAX)\n    {\n        /* sizes bigger than INT_MAX are currently not supported */\n        return NULL;\n    }\n\n    needed += p->offset + 1;\n    if (needed <= p->length)\n    {\n        return p->buffer + p->offset;\n    }\n\n    if (p->noalloc) {\n        return NULL;\n    }\n\n    /* calculate new buffer size */\n    if (needed > (INT_MAX / 2))\n    {\n        /* overflow of int, use INT_MAX if possible */\n        if (needed <= INT_MAX)\n        {\n            newsize = INT_MAX;\n        }\n        else\n        {\n            return NULL;\n        }\n    }\n    else\n    {\n        newsize = needed * 2;\n    }\n\n    if (p->hooks.reallocate != NULL)\n    {\n        /* reallocate with realloc if available */\n        newbuffer = (unsigned char*)p->hooks.reallocate(p->buffer, newsize);\n        if (newbuffer == NULL)\n        {\n            p->hooks.deallocate(p->buffer);\n            p->length = 0;\n            p->buffer = NULL;\n\n            return NULL;\n        }\n    }\n    else\n    {\n        /* otherwise reallocate manually */\n        newbuffer = (unsigned char*)p->hooks.allocate(newsize);\n        if (!newbuffer)\n        {\n            p->hooks.deallocate(p->buffer);\n            p->length = 0;\n            p->buffer = NULL;\n\n            return NULL;\n        }\n\n        memcpy(newbuffer, p->buffer, p->offset + 1);\n        p->hooks.deallocate(p->buffer);\n    }\n    p->length = newsize;\n    p->buffer = newbuffer;\n\n    return newbuffer + p->offset;\n}\n\n/* calculate the new length of the string in a printbuffer and update the offset */\nstatic void update_offset(printbuffer * const buffer)\n{\n    const unsigned char *buffer_pointer = NULL;\n    if ((buffer == NULL) || (buffer->buffer == NULL))\n    {\n        return;\n    }\n    buffer_pointer = buffer->buffer + buffer->offset;\n\n    buffer->offset += strlen((const char*)buffer_pointer);\n}\n\n/* securely comparison of floating-point variables */\nstatic cJSON_bool compare_double(double a, double b)\n{\n    double maxVal = fabs(a) > fabs(b) ? fabs(a) : fabs(b);\n    return (fabs(a - b) <= maxVal * DBL_EPSILON);\n}\n\n/* Render the number nicely from the given item into a string. */\nstatic cJSON_bool print_number(const cJSON * const item, printbuffer * const output_buffer)\n{\n    unsigned char *output_pointer = NULL;\n    double d = item->valuedouble;\n    int length = 0;\n    size_t i = 0;\n    unsigned char number_buffer[26] = {0}; /* temporary buffer to print the number into */\n    unsigned char decimal_point = get_decimal_point();\n    double test = 0.0;\n\n    if (output_buffer == NULL)\n    {\n        return false;\n    }\n\n    /* This checks for NaN and Infinity */\n    if (isnan(d) || isinf(d))\n    {\n        length = sprintf((char*)number_buffer, \"null\");\n    }\n    else if(d == (double)item->valueint)\n    {\n        length = sprintf((char*)number_buffer, \"%d\", item->valueint);\n    }\n    else\n    {\n        /* Try 15 decimal places of precision to avoid nonsignificant nonzero digits */\n        length = sprintf((char*)number_buffer, \"%1.15g\", d);\n\n        /* Check whether the original double can be recovered */\n        if ((sscanf((char*)number_buffer, \"%lg\", &test) != 1) || !compare_double((double)test, d))\n        {\n            /* If not, print with 17 decimal places of precision */\n            length = sprintf((char*)number_buffer, \"%1.17g\", d);\n        }\n    }\n\n    /* sprintf failed or buffer overrun occurred */\n    if ((length < 0) || (length > (int)(sizeof(number_buffer) - 1)))\n    {\n        return false;\n    }\n\n    /* reserve appropriate space in the output */\n    output_pointer = ensure(output_buffer, (size_t)length + sizeof(\"\"));\n    if (output_pointer == NULL)\n    {\n        return false;\n    }\n\n    /* copy the printed number to the output and replace locale\n     * dependent decimal point with '.' */\n    for (i = 0; i < ((size_t)length); i++)\n    {\n        if (number_buffer[i] == decimal_point)\n        {\n            output_pointer[i] = '.';\n            continue;\n        }\n\n        output_pointer[i] = number_buffer[i];\n    }\n    output_pointer[i] = '\\0';\n\n    output_buffer->offset += (size_t)length;\n\n    return true;\n}\n\n/* parse 4 digit hexadecimal number */\nstatic unsigned parse_hex4(const unsigned char * const input)\n{\n    unsigned int h = 0;\n    size_t i = 0;\n\n    for (i = 0; i < 4; i++)\n    {\n        /* parse digit */\n        if ((input[i] >= '0') && (input[i] <= '9'))\n        {\n            h += (unsigned int) input[i] - '0';\n        }\n        else if ((input[i] >= 'A') && (input[i] <= 'F'))\n        {\n            h += (unsigned int) 10 + input[i] - 'A';\n        }\n        else if ((input[i] >= 'a') && (input[i] <= 'f'))\n        {\n            h += (unsigned int) 10 + input[i] - 'a';\n        }\n        else /* invalid */\n        {\n            return 0;\n        }\n\n        if (i < 3)\n        {\n            /* shift left to make place for the next nibble */\n            h = h << 4;\n        }\n    }\n\n    return h;\n}\n\n/* converts a UTF-16 literal to UTF-8\n * A literal can be one or two sequences of the form \\uXXXX */\nstatic unsigned char utf16_literal_to_utf8(const unsigned char * const input_pointer, const unsigned char * const input_end, unsigned char **output_pointer)\n{\n    long unsigned int codepoint = 0;\n    unsigned int first_code = 0;\n    const unsigned char *first_sequence = input_pointer;\n    unsigned char utf8_length = 0;\n    unsigned char utf8_position = 0;\n    unsigned char sequence_length = 0;\n    unsigned char first_byte_mark = 0;\n\n    if ((input_end - first_sequence) < 6)\n    {\n        /* input ends unexpectedly */\n        goto fail;\n    }\n\n    /* get the first utf16 sequence */\n    first_code = parse_hex4(first_sequence + 2);\n\n    /* check that the code is valid */\n    if (((first_code >= 0xDC00) && (first_code <= 0xDFFF)))\n    {\n        goto fail;\n    }\n\n    /* UTF16 surrogate pair */\n    if ((first_code >= 0xD800) && (first_code <= 0xDBFF))\n    {\n        const unsigned char *second_sequence = first_sequence + 6;\n        unsigned int second_code = 0;\n        sequence_length = 12; /* \\uXXXX\\uXXXX */\n\n        if ((input_end - second_sequence) < 6)\n        {\n            /* input ends unexpectedly */\n            goto fail;\n        }\n\n        if ((second_sequence[0] != '\\\\') || (second_sequence[1] != 'u'))\n        {\n            /* missing second half of the surrogate pair */\n            goto fail;\n        }\n\n        /* get the second utf16 sequence */\n        second_code = parse_hex4(second_sequence + 2);\n        /* check that the code is valid */\n        if ((second_code < 0xDC00) || (second_code > 0xDFFF))\n        {\n            /* invalid second half of the surrogate pair */\n            goto fail;\n        }\n\n\n        /* calculate the unicode codepoint from the surrogate pair */\n        codepoint = 0x10000 + (((first_code & 0x3FF) << 10) | (second_code & 0x3FF));\n    }\n    else\n    {\n        sequence_length = 6; /* \\uXXXX */\n        codepoint = first_code;\n    }\n\n    /* encode as UTF-8\n     * takes at maximum 4 bytes to encode:\n     * 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */\n    if (codepoint < 0x80)\n    {\n        /* normal ascii, encoding 0xxxxxxx */\n        utf8_length = 1;\n    }\n    else if (codepoint < 0x800)\n    {\n        /* two bytes, encoding 110xxxxx 10xxxxxx */\n        utf8_length = 2;\n        first_byte_mark = 0xC0; /* 11000000 */\n    }\n    else if (codepoint < 0x10000)\n    {\n        /* three bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx */\n        utf8_length = 3;\n        first_byte_mark = 0xE0; /* 11100000 */\n    }\n    else if (codepoint <= 0x10FFFF)\n    {\n        /* four bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx */\n        utf8_length = 4;\n        first_byte_mark = 0xF0; /* 11110000 */\n    }\n    else\n    {\n        /* invalid unicode codepoint */\n        goto fail;\n    }\n\n    /* encode as utf8 */\n    for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position > 0; utf8_position--)\n    {\n        /* 10xxxxxx */\n        (*output_pointer)[utf8_position] = (unsigned char)((codepoint | 0x80) & 0xBF);\n        codepoint >>= 6;\n    }\n    /* encode first byte */\n    if (utf8_length > 1)\n    {\n        (*output_pointer)[0] = (unsigned char)((codepoint | first_byte_mark) & 0xFF);\n    }\n    else\n    {\n        (*output_pointer)[0] = (unsigned char)(codepoint & 0x7F);\n    }\n\n    *output_pointer += utf8_length;\n\n    return sequence_length;\n\nfail:\n    return 0;\n}\n\n/* Parse the input text into an unescaped cinput, and populate item. */\nstatic cJSON_bool parse_string(cJSON * const item, parse_buffer * const input_buffer)\n{\n    const unsigned char *input_pointer = buffer_at_offset(input_buffer) + 1;\n    const unsigned char *input_end = buffer_at_offset(input_buffer) + 1;\n    unsigned char *output_pointer = NULL;\n    unsigned char *output = NULL;\n\n    /* not a string */\n    if (buffer_at_offset(input_buffer)[0] != '\\\"')\n    {\n        goto fail;\n    }\n\n    {\n        /* calculate approximate size of the output (overestimate) */\n        size_t allocation_length = 0;\n        size_t skipped_bytes = 0;\n        while (((size_t)(input_end - input_buffer->content) < input_buffer->length) && (*input_end != '\\\"'))\n        {\n            /* is escape sequence */\n            if (input_end[0] == '\\\\')\n            {\n                if ((size_t)(input_end + 1 - input_buffer->content) >= input_buffer->length)\n                {\n                    /* prevent buffer overflow when last input character is a backslash */\n                    goto fail;\n                }\n                skipped_bytes++;\n                input_end++;\n            }\n            input_end++;\n        }\n        if (((size_t)(input_end - input_buffer->content) >= input_buffer->length) || (*input_end != '\\\"'))\n        {\n            goto fail; /* string ended unexpectedly */\n        }\n\n        /* This is at most how much we need for the output */\n        allocation_length = (size_t) (input_end - buffer_at_offset(input_buffer)) - skipped_bytes;\n        output = (unsigned char*)input_buffer->hooks.allocate(allocation_length + sizeof(\"\"));\n        if (output == NULL)\n        {\n            goto fail; /* allocation failure */\n        }\n    }\n\n    output_pointer = output;\n    /* loop through the string literal */\n    while (input_pointer < input_end)\n    {\n        if (*input_pointer != '\\\\')\n        {\n            *output_pointer++ = *input_pointer++;\n        }\n        /* escape sequence */\n        else\n        {\n            unsigned char sequence_length = 2;\n            if ((input_end - input_pointer) < 1)\n            {\n                goto fail;\n            }\n\n            switch (input_pointer[1])\n            {\n                case 'b':\n                    *output_pointer++ = '\\b';\n                    break;\n                case 'f':\n                    *output_pointer++ = '\\f';\n                    break;\n                case 'n':\n                    *output_pointer++ = '\\n';\n                    break;\n                case 'r':\n                    *output_pointer++ = '\\r';\n                    break;\n                case 't':\n                    *output_pointer++ = '\\t';\n                    break;\n                case '\\\"':\n                case '\\\\':\n                case '/':\n                    *output_pointer++ = input_pointer[1];\n                    break;\n\n                /* UTF-16 literal */\n                case 'u':\n                    sequence_length = utf16_literal_to_utf8(input_pointer, input_end, &output_pointer);\n                    if (sequence_length == 0)\n                    {\n                        /* failed to convert UTF16-literal to UTF-8 */\n                        goto fail;\n                    }\n                    break;\n\n                default:\n                    goto fail;\n            }\n            input_pointer += sequence_length;\n        }\n    }\n\n    /* zero terminate the output */\n    *output_pointer = '\\0';\n\n    item->type = cJSON_String;\n    item->valuestring = (char*)output;\n\n    input_buffer->offset = (size_t) (input_end - input_buffer->content);\n    input_buffer->offset++;\n\n    return true;\n\nfail:\n    if (output != NULL)\n    {\n        input_buffer->hooks.deallocate(output);\n        output = NULL;\n    }\n\n    if (input_pointer != NULL)\n    {\n        input_buffer->offset = (size_t)(input_pointer - input_buffer->content);\n    }\n\n    return false;\n}\n\n/* Render the cstring provided to an escaped version that can be printed. */\nstatic cJSON_bool print_string_ptr(const unsigned char * const input, printbuffer * const output_buffer)\n{\n    const unsigned char *input_pointer = NULL;\n    unsigned char *output = NULL;\n    unsigned char *output_pointer = NULL;\n    size_t output_length = 0;\n    /* numbers of additional characters needed for escaping */\n    size_t escape_characters = 0;\n\n    if (output_buffer == NULL)\n    {\n        return false;\n    }\n\n    /* empty string */\n    if (input == NULL)\n    {\n        output = ensure(output_buffer, sizeof(\"\\\"\\\"\"));\n        if (output == NULL)\n        {\n            return false;\n        }\n        strcpy((char*)output, \"\\\"\\\"\");\n\n        return true;\n    }\n\n    /* set \"flag\" to 1 if something needs to be escaped */\n    for (input_pointer = input; *input_pointer; input_pointer++)\n    {\n        switch (*input_pointer)\n        {\n            case '\\\"':\n            case '\\\\':\n            case '\\b':\n            case '\\f':\n            case '\\n':\n            case '\\r':\n            case '\\t':\n                /* one character escape sequence */\n                escape_characters++;\n                break;\n            default:\n                if (*input_pointer < 32)\n                {\n                    /* UTF-16 escape sequence uXXXX */\n                    escape_characters += 5;\n                }\n                break;\n        }\n    }\n    output_length = (size_t)(input_pointer - input) + escape_characters;\n\n    output = ensure(output_buffer, output_length + sizeof(\"\\\"\\\"\"));\n    if (output == NULL)\n    {\n        return false;\n    }\n\n    /* no characters have to be escaped */\n    if (escape_characters == 0)\n    {\n        output[0] = '\\\"';\n        memcpy(output + 1, input, output_length);\n        output[output_length + 1] = '\\\"';\n        output[output_length + 2] = '\\0';\n\n        return true;\n    }\n\n    output[0] = '\\\"';\n    output_pointer = output + 1;\n    /* copy the string */\n    for (input_pointer = input; *input_pointer != '\\0'; (void)input_pointer++, output_pointer++)\n    {\n        if ((*input_pointer > 31) && (*input_pointer != '\\\"') && (*input_pointer != '\\\\'))\n        {\n            /* normal character, copy */\n            *output_pointer = *input_pointer;\n        }\n        else\n        {\n            /* character needs to be escaped */\n            *output_pointer++ = '\\\\';\n            switch (*input_pointer)\n            {\n                case '\\\\':\n                    *output_pointer = '\\\\';\n                    break;\n                case '\\\"':\n                    *output_pointer = '\\\"';\n                    break;\n                case '\\b':\n                    *output_pointer = 'b';\n                    break;\n                case '\\f':\n                    *output_pointer = 'f';\n                    break;\n                case '\\n':\n                    *output_pointer = 'n';\n                    break;\n                case '\\r':\n                    *output_pointer = 'r';\n                    break;\n                case '\\t':\n                    *output_pointer = 't';\n                    break;\n                default:\n                    /* escape and print as unicode codepoint */\n                    sprintf((char*)output_pointer, \"u%04x\", *input_pointer);\n                    output_pointer += 4;\n                    break;\n            }\n        }\n    }\n    output[output_length + 1] = '\\\"';\n    output[output_length + 2] = '\\0';\n\n    return true;\n}\n\n/* Invoke print_string_ptr (which is useful) on an item. */\nstatic cJSON_bool print_string(const cJSON * const item, printbuffer * const p)\n{\n    return print_string_ptr((unsigned char*)item->valuestring, p);\n}\n\n/* Predeclare these prototypes. */\nstatic cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer);\nstatic cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer);\nstatic cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer);\nstatic cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer);\nstatic cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer);\nstatic cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer);\n\n/* Utility to jump whitespace and cr/lf */\nstatic parse_buffer *buffer_skip_whitespace(parse_buffer * const buffer)\n{\n    if ((buffer == NULL) || (buffer->content == NULL))\n    {\n        return NULL;\n    }\n\n    if (cannot_access_at_index(buffer, 0))\n    {\n        return buffer;\n    }\n\n    while (can_access_at_index(buffer, 0) && (buffer_at_offset(buffer)[0] <= 32))\n    {\n       buffer->offset++;\n    }\n\n    if (buffer->offset == buffer->length)\n    {\n        buffer->offset--;\n    }\n\n    return buffer;\n}\n\n/* skip the UTF-8 BOM (byte order mark) if it is at the beginning of a buffer */\nstatic parse_buffer *skip_utf8_bom(parse_buffer * const buffer)\n{\n    if ((buffer == NULL) || (buffer->content == NULL) || (buffer->offset != 0))\n    {\n        return NULL;\n    }\n\n    if (can_access_at_index(buffer, 4) && (strncmp((const char*)buffer_at_offset(buffer), \"\\xEF\\xBB\\xBF\", 3) == 0))\n    {\n        buffer->offset += 3;\n    }\n\n    return buffer;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated)\n{\n    size_t buffer_length;\n\n    if (NULL == value)\n    {\n        return NULL;\n    }\n\n    /* Adding null character size due to require_null_terminated. */\n    buffer_length = strlen(value) + sizeof(\"\");\n\n    return cJSON_ParseWithLengthOpts(value, buffer_length, return_parse_end, require_null_terminated);\n}\n\n/* Parse an object - create a new root, and populate. */\nCJSON_PUBLIC(cJSON *) cJSON_ParseWithLengthOpts(const char *value, size_t buffer_length, const char **return_parse_end, cJSON_bool require_null_terminated)\n{\n    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };\n    cJSON *item = NULL;\n\n    /* reset error position */\n    global_error.json = NULL;\n    global_error.position = 0;\n\n    if (value == NULL || 0 == buffer_length)\n    {\n        goto fail;\n    }\n\n    buffer.content = (const unsigned char*)value;\n    buffer.length = buffer_length;\n    buffer.offset = 0;\n    buffer.hooks = global_hooks;\n\n    item = cJSON_New_Item(&global_hooks);\n    if (item == NULL) /* memory fail */\n    {\n        goto fail;\n    }\n\n    if (!parse_value(item, buffer_skip_whitespace(skip_utf8_bom(&buffer))))\n    {\n        /* parse failure. ep is set. */\n        goto fail;\n    }\n\n    /* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */\n    if (require_null_terminated)\n    {\n        buffer_skip_whitespace(&buffer);\n        if ((buffer.offset >= buffer.length) || buffer_at_offset(&buffer)[0] != '\\0')\n        {\n            goto fail;\n        }\n    }\n    if (return_parse_end)\n    {\n        *return_parse_end = (const char*)buffer_at_offset(&buffer);\n    }\n\n    return item;\n\nfail:\n    if (item != NULL)\n    {\n        cJSON_Delete(item);\n    }\n\n    if (value != NULL)\n    {\n        error local_error;\n        local_error.json = (const unsigned char*)value;\n        local_error.position = 0;\n\n        if (buffer.offset < buffer.length)\n        {\n            local_error.position = buffer.offset;\n        }\n        else if (buffer.length > 0)\n        {\n            local_error.position = buffer.length - 1;\n        }\n\n        if (return_parse_end != NULL)\n        {\n            *return_parse_end = (const char*)local_error.json + local_error.position;\n        }\n\n        global_error = local_error;\n    }\n\n    return NULL;\n}\n\n/* Default options for cJSON_Parse */\nCJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value)\n{\n    return cJSON_ParseWithOpts(value, 0, 0);\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_ParseWithLength(const char *value, size_t buffer_length)\n{\n    return cJSON_ParseWithLengthOpts(value, buffer_length, 0, 0);\n}\n\n#define cjson_min(a, b) (((a) < (b)) ? (a) : (b))\n\nstatic unsigned char *print(const cJSON * const item, cJSON_bool format, const internal_hooks * const hooks)\n{\n    static const size_t default_buffer_size = 256;\n    printbuffer buffer[1];\n    unsigned char *printed = NULL;\n\n    memset(buffer, 0, sizeof(buffer));\n\n    /* create buffer */\n    buffer->buffer = (unsigned char*) hooks->allocate(default_buffer_size);\n    buffer->length = default_buffer_size;\n    buffer->format = format;\n    buffer->hooks = *hooks;\n    if (buffer->buffer == NULL)\n    {\n        goto fail;\n    }\n\n    /* print the value */\n    if (!print_value(item, buffer))\n    {\n        goto fail;\n    }\n    update_offset(buffer);\n\n    /* check if reallocate is available */\n    if (hooks->reallocate != NULL)\n    {\n        printed = (unsigned char*) hooks->reallocate(buffer->buffer, buffer->offset + 1);\n        if (printed == NULL) {\n            goto fail;\n        }\n        buffer->buffer = NULL;\n    }\n    else /* otherwise copy the JSON over to a new buffer */\n    {\n        printed = (unsigned char*) hooks->allocate(buffer->offset + 1);\n        if (printed == NULL)\n        {\n            goto fail;\n        }\n        memcpy(printed, buffer->buffer, cjson_min(buffer->length, buffer->offset + 1));\n        printed[buffer->offset] = '\\0'; /* just to be sure */\n\n        /* free the buffer */\n        hooks->deallocate(buffer->buffer);\n        buffer->buffer = NULL;\n    }\n\n    return printed;\n\nfail:\n    if (buffer->buffer != NULL)\n    {\n        hooks->deallocate(buffer->buffer);\n        buffer->buffer = NULL;\n    }\n\n    if (printed != NULL)\n    {\n        hooks->deallocate(printed);\n        printed = NULL;\n    }\n\n    return NULL;\n}\n\n/* Render a cJSON item/entity/structure to text. */\nCJSON_PUBLIC(char *) cJSON_Print(const cJSON *item)\n{\n    return (char*)print(item, true, &global_hooks);\n}\n\nCJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item)\n{\n    return (char*)print(item, false, &global_hooks);\n}\n\nCJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt)\n{\n    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };\n\n    if (prebuffer < 0)\n    {\n        return NULL;\n    }\n\n    p.buffer = (unsigned char*)global_hooks.allocate((size_t)prebuffer);\n    if (!p.buffer)\n    {\n        return NULL;\n    }\n\n    p.length = (size_t)prebuffer;\n    p.offset = 0;\n    p.noalloc = false;\n    p.format = fmt;\n    p.hooks = global_hooks;\n\n    if (!print_value(item, &p))\n    {\n        global_hooks.deallocate(p.buffer);\n        p.buffer = NULL;\n        return NULL;\n    }\n\n    return (char*)p.buffer;\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buffer, const int length, const cJSON_bool format)\n{\n    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };\n\n    if ((length < 0) || (buffer == NULL))\n    {\n        return false;\n    }\n\n    p.buffer = (unsigned char*)buffer;\n    p.length = (size_t)length;\n    p.offset = 0;\n    p.noalloc = true;\n    p.format = format;\n    p.hooks = global_hooks;\n\n    return print_value(item, &p);\n}\n\n/* Parser core - when encountering text, process appropriately. */\nstatic cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer)\n{\n    if ((input_buffer == NULL) || (input_buffer->content == NULL))\n    {\n        return false; /* no input */\n    }\n\n    /* parse the different types of values */\n    /* null */\n    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), \"null\", 4) == 0))\n    {\n        item->type = cJSON_NULL;\n        input_buffer->offset += 4;\n        return true;\n    }\n    /* false */\n    if (can_read(input_buffer, 5) && (strncmp((const char*)buffer_at_offset(input_buffer), \"false\", 5) == 0))\n    {\n        item->type = cJSON_False;\n        input_buffer->offset += 5;\n        return true;\n    }\n    /* true */\n    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), \"true\", 4) == 0))\n    {\n        item->type = cJSON_True;\n        item->valueint = 1;\n        input_buffer->offset += 4;\n        return true;\n    }\n    /* string */\n    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '\\\"'))\n    {\n        return parse_string(item, input_buffer);\n    }\n    /* number */\n    if (can_access_at_index(input_buffer, 0) && ((buffer_at_offset(input_buffer)[0] == '-') || ((buffer_at_offset(input_buffer)[0] >= '0') && (buffer_at_offset(input_buffer)[0] <= '9'))))\n    {\n        return parse_number(item, input_buffer);\n    }\n    /* array */\n    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '['))\n    {\n        return parse_array(item, input_buffer);\n    }\n    /* object */\n    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '{'))\n    {\n        return parse_object(item, input_buffer);\n    }\n\n    return false;\n}\n\n/* Render a value to text. */\nstatic cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer)\n{\n    unsigned char *output = NULL;\n\n    if ((item == NULL) || (output_buffer == NULL))\n    {\n        return false;\n    }\n\n    switch ((item->type) & 0xFF)\n    {\n        case cJSON_NULL:\n            output = ensure(output_buffer, 5);\n            if (output == NULL)\n            {\n                return false;\n            }\n            strcpy((char*)output, \"null\");\n            return true;\n\n        case cJSON_False:\n            output = ensure(output_buffer, 6);\n            if (output == NULL)\n            {\n                return false;\n            }\n            strcpy((char*)output, \"false\");\n            return true;\n\n        case cJSON_True:\n            output = ensure(output_buffer, 5);\n            if (output == NULL)\n            {\n                return false;\n            }\n            strcpy((char*)output, \"true\");\n            return true;\n\n        case cJSON_Number:\n            return print_number(item, output_buffer);\n\n        case cJSON_Raw:\n        {\n            size_t raw_length = 0;\n            if (item->valuestring == NULL)\n            {\n                return false;\n            }\n\n            raw_length = strlen(item->valuestring) + sizeof(\"\");\n            output = ensure(output_buffer, raw_length);\n            if (output == NULL)\n            {\n                return false;\n            }\n            memcpy(output, item->valuestring, raw_length);\n            return true;\n        }\n\n        case cJSON_String:\n            return print_string(item, output_buffer);\n\n        case cJSON_Array:\n            return print_array(item, output_buffer);\n\n        case cJSON_Object:\n            return print_object(item, output_buffer);\n\n        default:\n            return false;\n    }\n}\n\n/* Build an array from input text. */\nstatic cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer)\n{\n    cJSON *head = NULL; /* head of the linked list */\n    cJSON *current_item = NULL;\n\n    if (input_buffer->depth >= CJSON_NESTING_LIMIT)\n    {\n        return false; /* to deeply nested */\n    }\n    input_buffer->depth++;\n\n    if (buffer_at_offset(input_buffer)[0] != '[')\n    {\n        /* not an array */\n        goto fail;\n    }\n\n    input_buffer->offset++;\n    buffer_skip_whitespace(input_buffer);\n    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ']'))\n    {\n        /* empty array */\n        goto success;\n    }\n\n    /* check if we skipped to the end of the buffer */\n    if (cannot_access_at_index(input_buffer, 0))\n    {\n        input_buffer->offset--;\n        goto fail;\n    }\n\n    /* step back to character in front of the first element */\n    input_buffer->offset--;\n    /* loop through the comma separated array elements */\n    do\n    {\n        /* allocate next item */\n        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));\n        if (new_item == NULL)\n        {\n            goto fail; /* allocation failure */\n        }\n\n        /* attach next item to list */\n        if (head == NULL)\n        {\n            /* start the linked list */\n            current_item = head = new_item;\n        }\n        else\n        {\n            /* add to the end and advance */\n            current_item->next = new_item;\n            new_item->prev = current_item;\n            current_item = new_item;\n        }\n\n        /* parse next value */\n        input_buffer->offset++;\n        buffer_skip_whitespace(input_buffer);\n        if (!parse_value(current_item, input_buffer))\n        {\n            goto fail; /* failed to parse value */\n        }\n        buffer_skip_whitespace(input_buffer);\n    }\n    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));\n\n    if (cannot_access_at_index(input_buffer, 0) || buffer_at_offset(input_buffer)[0] != ']')\n    {\n        goto fail; /* expected end of array */\n    }\n\nsuccess:\n    input_buffer->depth--;\n\n    if (head != NULL) {\n        head->prev = current_item;\n    }\n\n    item->type = cJSON_Array;\n    item->child = head;\n\n    input_buffer->offset++;\n\n    return true;\n\nfail:\n    if (head != NULL)\n    {\n        cJSON_Delete(head);\n    }\n\n    return false;\n}\n\n/* Render an array to text */\nstatic cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer)\n{\n    unsigned char *output_pointer = NULL;\n    size_t length = 0;\n    cJSON *current_element = item->child;\n\n    if (output_buffer == NULL)\n    {\n        return false;\n    }\n\n    /* Compose the output array. */\n    /* opening square bracket */\n    output_pointer = ensure(output_buffer, 1);\n    if (output_pointer == NULL)\n    {\n        return false;\n    }\n\n    *output_pointer = '[';\n    output_buffer->offset++;\n    output_buffer->depth++;\n\n    while (current_element != NULL)\n    {\n        if (!print_value(current_element, output_buffer))\n        {\n            return false;\n        }\n        update_offset(output_buffer);\n        if (current_element->next)\n        {\n            length = (size_t) (output_buffer->format ? 2 : 1);\n            output_pointer = ensure(output_buffer, length + 1);\n            if (output_pointer == NULL)\n            {\n                return false;\n            }\n            *output_pointer++ = ',';\n            if(output_buffer->format)\n            {\n                *output_pointer++ = ' ';\n            }\n            *output_pointer = '\\0';\n            output_buffer->offset += length;\n        }\n        current_element = current_element->next;\n    }\n\n    output_pointer = ensure(output_buffer, 2);\n    if (output_pointer == NULL)\n    {\n        return false;\n    }\n    *output_pointer++ = ']';\n    *output_pointer = '\\0';\n    output_buffer->depth--;\n\n    return true;\n}\n\n/* Build an object from the text. */\nstatic cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer)\n{\n    cJSON *head = NULL; /* linked list head */\n    cJSON *current_item = NULL;\n\n    if (input_buffer->depth >= CJSON_NESTING_LIMIT)\n    {\n        return false; /* to deeply nested */\n    }\n    input_buffer->depth++;\n\n    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '{'))\n    {\n        goto fail; /* not an object */\n    }\n\n    input_buffer->offset++;\n    buffer_skip_whitespace(input_buffer);\n    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '}'))\n    {\n        goto success; /* empty object */\n    }\n\n    /* check if we skipped to the end of the buffer */\n    if (cannot_access_at_index(input_buffer, 0))\n    {\n        input_buffer->offset--;\n        goto fail;\n    }\n\n    /* step back to character in front of the first element */\n    input_buffer->offset--;\n    /* loop through the comma separated array elements */\n    do\n    {\n        /* allocate next item */\n        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));\n        if (new_item == NULL)\n        {\n            goto fail; /* allocation failure */\n        }\n\n        /* attach next item to list */\n        if (head == NULL)\n        {\n            /* start the linked list */\n            current_item = head = new_item;\n        }\n        else\n        {\n            /* add to the end and advance */\n            current_item->next = new_item;\n            new_item->prev = current_item;\n            current_item = new_item;\n        }\n\n        if (cannot_access_at_index(input_buffer, 1))\n        {\n            goto fail; /* nothing comes after the comma */\n        }\n\n        /* parse the name of the child */\n        input_buffer->offset++;\n        buffer_skip_whitespace(input_buffer);\n        if (!parse_string(current_item, input_buffer))\n        {\n            goto fail; /* failed to parse name */\n        }\n        buffer_skip_whitespace(input_buffer);\n\n        /* swap valuestring and string, because we parsed the name */\n        current_item->string = current_item->valuestring;\n        current_item->valuestring = NULL;\n\n        if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != ':'))\n        {\n            goto fail; /* invalid object */\n        }\n\n        /* parse the value */\n        input_buffer->offset++;\n        buffer_skip_whitespace(input_buffer);\n        if (!parse_value(current_item, input_buffer))\n        {\n            goto fail; /* failed to parse value */\n        }\n        buffer_skip_whitespace(input_buffer);\n    }\n    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));\n\n    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '}'))\n    {\n        goto fail; /* expected end of object */\n    }\n\nsuccess:\n    input_buffer->depth--;\n\n    if (head != NULL) {\n        head->prev = current_item;\n    }\n\n    item->type = cJSON_Object;\n    item->child = head;\n\n    input_buffer->offset++;\n    return true;\n\nfail:\n    if (head != NULL)\n    {\n        cJSON_Delete(head);\n    }\n\n    return false;\n}\n\n/* Render an object to text. */\nstatic cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer)\n{\n    unsigned char *output_pointer = NULL;\n    size_t length = 0;\n    cJSON *current_item = item->child;\n\n    if (output_buffer == NULL)\n    {\n        return false;\n    }\n\n    /* Compose the output: */\n    length = (size_t) (output_buffer->format ? 2 : 1); /* fmt: {\\n */\n    output_pointer = ensure(output_buffer, length + 1);\n    if (output_pointer == NULL)\n    {\n        return false;\n    }\n\n    *output_pointer++ = '{';\n    output_buffer->depth++;\n    if (output_buffer->format)\n    {\n        *output_pointer++ = '\\n';\n    }\n    output_buffer->offset += length;\n\n    while (current_item)\n    {\n        if (output_buffer->format)\n        {\n            size_t i;\n            output_pointer = ensure(output_buffer, output_buffer->depth);\n            if (output_pointer == NULL)\n            {\n                return false;\n            }\n            for (i = 0; i < output_buffer->depth; i++)\n            {\n                *output_pointer++ = '\\t';\n            }\n            output_buffer->offset += output_buffer->depth;\n        }\n\n        /* print key */\n        if (!print_string_ptr((unsigned char*)current_item->string, output_buffer))\n        {\n            return false;\n        }\n        update_offset(output_buffer);\n\n        length = (size_t) (output_buffer->format ? 2 : 1);\n        output_pointer = ensure(output_buffer, length);\n        if (output_pointer == NULL)\n        {\n            return false;\n        }\n        *output_pointer++ = ':';\n        if (output_buffer->format)\n        {\n            *output_pointer++ = '\\t';\n        }\n        output_buffer->offset += length;\n\n        /* print value */\n        if (!print_value(current_item, output_buffer))\n        {\n            return false;\n        }\n        update_offset(output_buffer);\n\n        /* print comma if not last */\n        length = ((size_t)(output_buffer->format ? 1 : 0) + (size_t)(current_item->next ? 1 : 0));\n        output_pointer = ensure(output_buffer, length + 1);\n        if (output_pointer == NULL)\n        {\n            return false;\n        }\n        if (current_item->next)\n        {\n            *output_pointer++ = ',';\n        }\n\n        if (output_buffer->format)\n        {\n            *output_pointer++ = '\\n';\n        }\n        *output_pointer = '\\0';\n        output_buffer->offset += length;\n\n        current_item = current_item->next;\n    }\n\n    output_pointer = ensure(output_buffer, output_buffer->format ? (output_buffer->depth + 1) : 2);\n    if (output_pointer == NULL)\n    {\n        return false;\n    }\n    if (output_buffer->format)\n    {\n        size_t i;\n        for (i = 0; i < (output_buffer->depth - 1); i++)\n        {\n            *output_pointer++ = '\\t';\n        }\n    }\n    *output_pointer++ = '}';\n    *output_pointer = '\\0';\n    output_buffer->depth--;\n\n    return true;\n}\n\n/* Get Array size/item / object item. */\nCJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array)\n{\n    cJSON *child = NULL;\n    size_t size = 0;\n\n    if (array == NULL)\n    {\n        return 0;\n    }\n\n    child = array->child;\n\n    while(child != NULL)\n    {\n        size++;\n        child = child->next;\n    }\n\n    /* FIXME: Can overflow here. Cannot be fixed without breaking the API */\n\n    return (int)size;\n}\n\nstatic cJSON* get_array_item(const cJSON *array, size_t index)\n{\n    cJSON *current_child = NULL;\n\n    if (array == NULL)\n    {\n        return NULL;\n    }\n\n    current_child = array->child;\n    while ((current_child != NULL) && (index > 0))\n    {\n        index--;\n        current_child = current_child->next;\n    }\n\n    return current_child;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index)\n{\n    if (index < 0)\n    {\n        return NULL;\n    }\n\n    return get_array_item(array, (size_t)index);\n}\n\nstatic cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)\n{\n    cJSON *current_element = NULL;\n\n    if ((object == NULL) || (name == NULL))\n    {\n        return NULL;\n    }\n\n    current_element = object->child;\n    if (case_sensitive)\n    {\n        while ((current_element != NULL) && (current_element->string != NULL) && (strcmp(name, current_element->string) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n    else\n    {\n        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n\n    if ((current_element == NULL) || (current_element->string == NULL)) {\n        return NULL;\n    }\n\n    return current_element;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string)\n{\n    return get_object_item(object, string, false);\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string)\n{\n    return get_object_item(object, string, true);\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_HasObjectItem(const cJSON *object, const char *string)\n{\n    return cJSON_GetObjectItem(object, string) ? 1 : 0;\n}\n\n/* Utility for array list handling. */\nstatic void suffix_object(cJSON *prev, cJSON *item)\n{\n    prev->next = item;\n    item->prev = prev;\n}\n\n/* Utility for handling references. */\nstatic cJSON *create_reference(const cJSON *item, const internal_hooks * const hooks)\n{\n    cJSON *reference = NULL;\n    if (item == NULL)\n    {\n        return NULL;\n    }\n\n    reference = cJSON_New_Item(hooks);\n    if (reference == NULL)\n    {\n        return NULL;\n    }\n\n    memcpy(reference, item, sizeof(cJSON));\n    reference->string = NULL;\n    reference->type |= cJSON_IsReference;\n    reference->next = reference->prev = NULL;\n    return reference;\n}\n\nstatic cJSON_bool add_item_to_array(cJSON *array, cJSON *item)\n{\n    cJSON *child = NULL;\n\n    if ((item == NULL) || (array == NULL) || (array == item))\n    {\n        return false;\n    }\n\n    child = array->child;\n    /*\n     * To find the last item in array quickly, we use prev in array\n     */\n    if (child == NULL)\n    {\n        /* list is empty, start new one */\n        array->child = item;\n        item->prev = item;\n        item->next = NULL;\n    }\n    else\n    {\n        /* append to the end */\n        if (child->prev)\n        {\n            suffix_object(child->prev, item);\n            array->child->prev = item;\n        }\n    }\n\n    return true;\n}\n\n/* Add item to array/object. */\nCJSON_PUBLIC(cJSON_bool) cJSON_AddItemToArray(cJSON *array, cJSON *item)\n{\n    return add_item_to_array(array, item);\n}\n\n#if defined(__clang__) || (defined(__GNUC__)  && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5))))\n    #pragma GCC diagnostic push\n#endif\n#ifdef __GNUC__\n#pragma GCC diagnostic ignored \"-Wcast-qual\"\n#endif\n/* helper function to cast away const */\nstatic void* cast_away_const(const void* string)\n{\n    return (void*)string;\n}\n#if defined(__clang__) || (defined(__GNUC__)  && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5))))\n    #pragma GCC diagnostic pop\n#endif\n\n\nstatic cJSON_bool add_item_to_object(cJSON * const object, const char * const string, cJSON * const item, const internal_hooks * const hooks, const cJSON_bool constant_key)\n{\n    char *new_key = NULL;\n    int new_type = cJSON_Invalid;\n\n    if ((object == NULL) || (string == NULL) || (item == NULL) || (object == item))\n    {\n        return false;\n    }\n\n    if (constant_key)\n    {\n        new_key = (char*)cast_away_const(string);\n        new_type = item->type | cJSON_StringIsConst;\n    }\n    else\n    {\n        new_key = (char*)cJSON_strdup((const unsigned char*)string, hooks);\n        if (new_key == NULL)\n        {\n            return false;\n        }\n\n        new_type = item->type & ~cJSON_StringIsConst;\n    }\n\n    if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))\n    {\n        hooks->deallocate(item->string);\n    }\n\n    item->string = new_key;\n    item->type = new_type;\n\n    return add_item_to_array(object, item);\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item)\n{\n    return add_item_to_object(object, string, item, &global_hooks, false);\n}\n\n/* Add an item to an object with constant string as key */\nCJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item)\n{\n    return add_item_to_object(object, string, item, &global_hooks, true);\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)\n{\n    if (array == NULL)\n    {\n        return false;\n    }\n\n    return add_item_to_array(array, create_reference(item, &global_hooks));\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item)\n{\n    if ((object == NULL) || (string == NULL))\n    {\n        return false;\n    }\n\n    return add_item_to_object(object, string, create_reference(item, &global_hooks), &global_hooks, false);\n}\n\nCJSON_PUBLIC(cJSON*) cJSON_AddNullToObject(cJSON * const object, const char * const name)\n{\n    cJSON *null = cJSON_CreateNull();\n    if (add_item_to_object(object, name, null, &global_hooks, false))\n    {\n        return null;\n    }\n\n    cJSON_Delete(null);\n    return NULL;\n}\n\nCJSON_PUBLIC(cJSON*) cJSON_AddTrueToObject(cJSON * const object, const char * const name)\n{\n    cJSON *true_item = cJSON_CreateTrue();\n    if (add_item_to_object(object, name, true_item, &global_hooks, false))\n    {\n        return true_item;\n    }\n\n    cJSON_Delete(true_item);\n    return NULL;\n}\n\nCJSON_PUBLIC(cJSON*) cJSON_AddFalseToObject(cJSON * const object, const char * const name)\n{\n    cJSON *false_item = cJSON_CreateFalse();\n    if (add_item_to_object(object, name, false_item, &global_hooks, false))\n    {\n        return false_item;\n    }\n\n    cJSON_Delete(false_item);\n    return NULL;\n}\n\nCJSON_PUBLIC(cJSON*) cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean)\n{\n    cJSON *bool_item = cJSON_CreateBool(boolean);\n    if (add_item_to_object(object, name, bool_item, &global_hooks, false))\n    {\n        return bool_item;\n    }\n\n    cJSON_Delete(bool_item);\n    return NULL;\n}\n\nCJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number)\n{\n    cJSON *number_item = cJSON_CreateNumber(number);\n    if (add_item_to_object(object, name, number_item, &global_hooks, false))\n    {\n        return number_item;\n    }\n\n    cJSON_Delete(number_item);\n    return NULL;\n}\n\nCJSON_PUBLIC(cJSON*) cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string)\n{\n    cJSON *string_item = cJSON_CreateString(string);\n    if (add_item_to_object(object, name, string_item, &global_hooks, false))\n    {\n        return string_item;\n    }\n\n    cJSON_Delete(string_item);\n    return NULL;\n}\n\nCJSON_PUBLIC(cJSON*) cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw)\n{\n    cJSON *raw_item = cJSON_CreateRaw(raw);\n    if (add_item_to_object(object, name, raw_item, &global_hooks, false))\n    {\n        return raw_item;\n    }\n\n    cJSON_Delete(raw_item);\n    return NULL;\n}\n\nCJSON_PUBLIC(cJSON*) cJSON_AddObjectToObject(cJSON * const object, const char * const name)\n{\n    cJSON *object_item = cJSON_CreateObject();\n    if (add_item_to_object(object, name, object_item, &global_hooks, false))\n    {\n        return object_item;\n    }\n\n    cJSON_Delete(object_item);\n    return NULL;\n}\n\nCJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name)\n{\n    cJSON *array = cJSON_CreateArray();\n    if (add_item_to_object(object, name, array, &global_hooks, false))\n    {\n        return array;\n    }\n\n    cJSON_Delete(array);\n    return NULL;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item)\n{\n    if ((parent == NULL) || (item == NULL))\n    {\n        return NULL;\n    }\n\n    if (item != parent->child)\n    {\n        /* not the first element */\n        item->prev->next = item->next;\n    }\n    if (item->next != NULL)\n    {\n        /* not the last element */\n        item->next->prev = item->prev;\n    }\n\n    if (item == parent->child)\n    {\n        /* first element */\n        parent->child = item->next;\n    }\n    else if (item->next == NULL)\n    {\n        /* last element */\n        parent->child->prev = item->prev;\n    }\n\n    /* make sure the detached item doesn't point anywhere anymore */\n    item->prev = NULL;\n    item->next = NULL;\n\n    return item;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_DetachItemFromArray(cJSON *array, int which)\n{\n    if (which < 0)\n    {\n        return NULL;\n    }\n\n    return cJSON_DetachItemViaPointer(array, get_array_item(array, (size_t)which));\n}\n\nCJSON_PUBLIC(void) cJSON_DeleteItemFromArray(cJSON *array, int which)\n{\n    cJSON_Delete(cJSON_DetachItemFromArray(array, which));\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObject(cJSON *object, const char *string)\n{\n    cJSON *to_detach = cJSON_GetObjectItem(object, string);\n\n    return cJSON_DetachItemViaPointer(object, to_detach);\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string)\n{\n    cJSON *to_detach = cJSON_GetObjectItemCaseSensitive(object, string);\n\n    return cJSON_DetachItemViaPointer(object, to_detach);\n}\n\nCJSON_PUBLIC(void) cJSON_DeleteItemFromObject(cJSON *object, const char *string)\n{\n    cJSON_Delete(cJSON_DetachItemFromObject(object, string));\n}\n\nCJSON_PUBLIC(void) cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string)\n{\n    cJSON_Delete(cJSON_DetachItemFromObjectCaseSensitive(object, string));\n}\n\n/* Replace array/object items with new ones. */\nCJSON_PUBLIC(cJSON_bool) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem)\n{\n    cJSON *after_inserted = NULL;\n\n    if (which < 0 || newitem == NULL)\n    {\n        return false;\n    }\n\n    after_inserted = get_array_item(array, (size_t)which);\n    if (after_inserted == NULL)\n    {\n        return add_item_to_array(array, newitem);\n    }\n\n    if (after_inserted != array->child && after_inserted->prev == NULL) {\n        /* return false if after_inserted is a corrupted array item */\n        return false;\n    }\n\n    newitem->next = after_inserted;\n    newitem->prev = after_inserted->prev;\n    after_inserted->prev = newitem;\n    if (after_inserted == array->child)\n    {\n        array->child = newitem;\n    }\n    else\n    {\n        newitem->prev->next = newitem;\n    }\n    return true;\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement)\n{\n    if ((parent == NULL) || (parent->child == NULL) || (replacement == NULL) || (item == NULL))\n    {\n        return false;\n    }\n\n    if (replacement == item)\n    {\n        return true;\n    }\n\n    replacement->next = item->next;\n    replacement->prev = item->prev;\n\n    if (replacement->next != NULL)\n    {\n        replacement->next->prev = replacement;\n    }\n    if (parent->child == item)\n    {\n        if (parent->child->prev == parent->child)\n        {\n            replacement->prev = replacement;\n        }\n        parent->child = replacement;\n    }\n    else\n    {   /*\n         * To find the last item in array quickly, we use prev in array.\n         * We can't modify the last item's next pointer where this item was the parent's child\n         */\n        if (replacement->prev != NULL)\n        {\n            replacement->prev->next = replacement;\n        }\n        if (replacement->next == NULL)\n        {\n            parent->child->prev = replacement;\n        }\n    }\n\n    item->next = NULL;\n    item->prev = NULL;\n    cJSON_Delete(item);\n\n    return true;\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem)\n{\n    if (which < 0)\n    {\n        return false;\n    }\n\n    return cJSON_ReplaceItemViaPointer(array, get_array_item(array, (size_t)which), newitem);\n}\n\nstatic cJSON_bool replace_item_in_object(cJSON *object, const char *string, cJSON *replacement, cJSON_bool case_sensitive)\n{\n    if ((replacement == NULL) || (string == NULL))\n    {\n        return false;\n    }\n\n    /* replace the name in the replacement */\n    if (!(replacement->type & cJSON_StringIsConst) && (replacement->string != NULL))\n    {\n        cJSON_free(replacement->string);\n    }\n    replacement->string = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);\n    if (replacement->string == NULL)\n    {\n        return false;\n    }\n\n    replacement->type &= ~cJSON_StringIsConst;\n\n    return cJSON_ReplaceItemViaPointer(object, get_object_item(object, string, case_sensitive), replacement);\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInObject(cJSON *object, const char *string, cJSON *newitem)\n{\n    return replace_item_in_object(object, string, newitem, false);\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object, const char *string, cJSON *newitem)\n{\n    return replace_item_in_object(object, string, newitem, true);\n}\n\n/* Create basic types: */\nCJSON_PUBLIC(cJSON *) cJSON_CreateNull(void)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if(item)\n    {\n        item->type = cJSON_NULL;\n    }\n\n    return item;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if(item)\n    {\n        item->type = cJSON_True;\n    }\n\n    return item;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if(item)\n    {\n        item->type = cJSON_False;\n    }\n\n    return item;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool boolean)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if(item)\n    {\n        item->type = boolean ? cJSON_True : cJSON_False;\n    }\n\n    return item;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if(item)\n    {\n        item->type = cJSON_Number;\n        item->valuedouble = num;\n\n        /* use saturation in case of overflow */\n        if (num >= INT_MAX)\n        {\n            item->valueint = INT_MAX;\n        }\n        else if (num <= (double)INT_MIN)\n        {\n            item->valueint = INT_MIN;\n        }\n        else\n        {\n            item->valueint = (int)num;\n        }\n    }\n\n    return item;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if(item)\n    {\n        item->type = cJSON_String;\n        item->valuestring = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);\n        if(!item->valuestring)\n        {\n            cJSON_Delete(item);\n            return NULL;\n        }\n    }\n\n    return item;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_CreateStringReference(const char *string)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if (item != NULL)\n    {\n        item->type = cJSON_String | cJSON_IsReference;\n        item->valuestring = (char*)cast_away_const(string);\n    }\n\n    return item;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_CreateObjectReference(const cJSON *child)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if (item != NULL) {\n        item->type = cJSON_Object | cJSON_IsReference;\n        item->child = (cJSON*)cast_away_const(child);\n    }\n\n    return item;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_CreateArrayReference(const cJSON *child) {\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if (item != NULL) {\n        item->type = cJSON_Array | cJSON_IsReference;\n        item->child = (cJSON*)cast_away_const(child);\n    }\n\n    return item;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_CreateRaw(const char *raw)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if(item)\n    {\n        item->type = cJSON_Raw;\n        item->valuestring = (char*)cJSON_strdup((const unsigned char*)raw, &global_hooks);\n        if(!item->valuestring)\n        {\n            cJSON_Delete(item);\n            return NULL;\n        }\n    }\n\n    return item;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_CreateArray(void)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if(item)\n    {\n        item->type=cJSON_Array;\n    }\n\n    return item;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_CreateObject(void)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if (item)\n    {\n        item->type = cJSON_Object;\n    }\n\n    return item;\n}\n\n/* Create Arrays: */\nCJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count)\n{\n    size_t i = 0;\n    cJSON *n = NULL;\n    cJSON *p = NULL;\n    cJSON *a = NULL;\n\n    if ((count < 0) || (numbers == NULL))\n    {\n        return NULL;\n    }\n\n    a = cJSON_CreateArray();\n\n    for(i = 0; a && (i < (size_t)count); i++)\n    {\n        n = cJSON_CreateNumber(numbers[i]);\n        if (!n)\n        {\n            cJSON_Delete(a);\n            return NULL;\n        }\n        if(!i)\n        {\n            a->child = n;\n        }\n        else\n        {\n            suffix_object(p, n);\n        }\n        p = n;\n    }\n\n    if (a && a->child) {\n        a->child->prev = n;\n    }\n\n    return a;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count)\n{\n    size_t i = 0;\n    cJSON *n = NULL;\n    cJSON *p = NULL;\n    cJSON *a = NULL;\n\n    if ((count < 0) || (numbers == NULL))\n    {\n        return NULL;\n    }\n\n    a = cJSON_CreateArray();\n\n    for(i = 0; a && (i < (size_t)count); i++)\n    {\n        n = cJSON_CreateNumber((double)numbers[i]);\n        if(!n)\n        {\n            cJSON_Delete(a);\n            return NULL;\n        }\n        if(!i)\n        {\n            a->child = n;\n        }\n        else\n        {\n            suffix_object(p, n);\n        }\n        p = n;\n    }\n\n    if (a && a->child) {\n        a->child->prev = n;\n    }\n\n    return a;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count)\n{\n    size_t i = 0;\n    cJSON *n = NULL;\n    cJSON *p = NULL;\n    cJSON *a = NULL;\n\n    if ((count < 0) || (numbers == NULL))\n    {\n        return NULL;\n    }\n\n    a = cJSON_CreateArray();\n\n    for(i = 0; a && (i < (size_t)count); i++)\n    {\n        n = cJSON_CreateNumber(numbers[i]);\n        if(!n)\n        {\n            cJSON_Delete(a);\n            return NULL;\n        }\n        if(!i)\n        {\n            a->child = n;\n        }\n        else\n        {\n            suffix_object(p, n);\n        }\n        p = n;\n    }\n\n    if (a && a->child) {\n        a->child->prev = n;\n    }\n\n    return a;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char *const *strings, int count)\n{\n    size_t i = 0;\n    cJSON *n = NULL;\n    cJSON *p = NULL;\n    cJSON *a = NULL;\n\n    if ((count < 0) || (strings == NULL))\n    {\n        return NULL;\n    }\n\n    a = cJSON_CreateArray();\n\n    for (i = 0; a && (i < (size_t)count); i++)\n    {\n        n = cJSON_CreateString(strings[i]);\n        if(!n)\n        {\n            cJSON_Delete(a);\n            return NULL;\n        }\n        if(!i)\n        {\n            a->child = n;\n        }\n        else\n        {\n            suffix_object(p,n);\n        }\n        p = n;\n    }\n\n    if (a && a->child) {\n        a->child->prev = n;\n    }\n\n    return a;\n}\n\n/* Duplication */\nCJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse)\n{\n    cJSON *newitem = NULL;\n    cJSON *child = NULL;\n    cJSON *next = NULL;\n    cJSON *newchild = NULL;\n\n    /* Bail on bad ptr */\n    if (!item)\n    {\n        goto fail;\n    }\n    /* Create new item */\n    newitem = cJSON_New_Item(&global_hooks);\n    if (!newitem)\n    {\n        goto fail;\n    }\n    /* Copy over all vars */\n    newitem->type = item->type & (~cJSON_IsReference);\n    newitem->valueint = item->valueint;\n    newitem->valuedouble = item->valuedouble;\n    if (item->valuestring)\n    {\n        newitem->valuestring = (char*)cJSON_strdup((unsigned char*)item->valuestring, &global_hooks);\n        if (!newitem->valuestring)\n        {\n            goto fail;\n        }\n    }\n    if (item->string)\n    {\n        newitem->string = (item->type&cJSON_StringIsConst) ? item->string : (char*)cJSON_strdup((unsigned char*)item->string, &global_hooks);\n        if (!newitem->string)\n        {\n            goto fail;\n        }\n    }\n    /* If non-recursive, then we're done! */\n    if (!recurse)\n    {\n        return newitem;\n    }\n    /* Walk the ->next chain for the child. */\n    child = item->child;\n    while (child != NULL)\n    {\n        newchild = cJSON_Duplicate(child, true); /* Duplicate (with recurse) each item in the ->next chain */\n        if (!newchild)\n        {\n            goto fail;\n        }\n        if (next != NULL)\n        {\n            /* If newitem->child already set, then crosswire ->prev and ->next and move on */\n            next->next = newchild;\n            newchild->prev = next;\n            next = newchild;\n        }\n        else\n        {\n            /* Set newitem->child and move to it */\n            newitem->child = newchild;\n            next = newchild;\n        }\n        child = child->next;\n    }\n    if (newitem && newitem->child)\n    {\n        newitem->child->prev = newchild;\n    }\n\n    return newitem;\n\nfail:\n    if (newitem != NULL)\n    {\n        cJSON_Delete(newitem);\n    }\n\n    return NULL;\n}\n\nstatic void skip_oneline_comment(char **input)\n{\n    *input += static_strlen(\"//\");\n\n    for (; (*input)[0] != '\\0'; ++(*input))\n    {\n        if ((*input)[0] == '\\n') {\n            *input += static_strlen(\"\\n\");\n            return;\n        }\n    }\n}\n\nstatic void skip_multiline_comment(char **input)\n{\n    *input += static_strlen(\"/*\");\n\n    for (; (*input)[0] != '\\0'; ++(*input))\n    {\n        if (((*input)[0] == '*') && ((*input)[1] == '/'))\n        {\n            *input += static_strlen(\"*/\");\n            return;\n        }\n    }\n}\n\nstatic void minify_string(char **input, char **output) {\n    (*output)[0] = (*input)[0];\n    *input += static_strlen(\"\\\"\");\n    *output += static_strlen(\"\\\"\");\n\n\n    for (; (*input)[0] != '\\0'; (void)++(*input), ++(*output)) {\n        (*output)[0] = (*input)[0];\n\n        if ((*input)[0] == '\\\"') {\n            (*output)[0] = '\\\"';\n            *input += static_strlen(\"\\\"\");\n            *output += static_strlen(\"\\\"\");\n            return;\n        } else if (((*input)[0] == '\\\\') && ((*input)[1] == '\\\"')) {\n            (*output)[1] = (*input)[1];\n            *input += static_strlen(\"\\\"\");\n            *output += static_strlen(\"\\\"\");\n        }\n    }\n}\n\nCJSON_PUBLIC(void) cJSON_Minify(char *json)\n{\n    char *into = json;\n\n    if (json == NULL)\n    {\n        return;\n    }\n\n    while (json[0] != '\\0')\n    {\n        switch (json[0])\n        {\n            case ' ':\n            case '\\t':\n            case '\\r':\n            case '\\n':\n                json++;\n                break;\n\n            case '/':\n                if (json[1] == '/')\n                {\n                    skip_oneline_comment(&json);\n                }\n                else if (json[1] == '*')\n                {\n                    skip_multiline_comment(&json);\n                } else {\n                    json++;\n                }\n                break;\n\n            case '\\\"':\n                minify_string(&json, (char**)&into);\n                break;\n\n            default:\n                into[0] = json[0];\n                json++;\n                into++;\n        }\n    }\n\n    /* and null-terminate. */\n    *into = '\\0';\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_IsInvalid(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xFF) == cJSON_Invalid;\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xFF) == cJSON_False;\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xff) == cJSON_True;\n}\n\n\nCJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & (cJSON_True | cJSON_False)) != 0;\n}\nCJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xFF) == cJSON_NULL;\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xFF) == cJSON_Number;\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xFF) == cJSON_String;\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xFF) == cJSON_Array;\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xFF) == cJSON_Object;\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_IsRaw(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xFF) == cJSON_Raw;\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive)\n{\n    if ((a == NULL) || (b == NULL) || ((a->type & 0xFF) != (b->type & 0xFF)))\n    {\n        return false;\n    }\n\n    /* check if type is valid */\n    switch (a->type & 0xFF)\n    {\n        case cJSON_False:\n        case cJSON_True:\n        case cJSON_NULL:\n        case cJSON_Number:\n        case cJSON_String:\n        case cJSON_Raw:\n        case cJSON_Array:\n        case cJSON_Object:\n            break;\n\n        default:\n            return false;\n    }\n\n    /* identical objects are equal */\n    if (a == b)\n    {\n        return true;\n    }\n\n    switch (a->type & 0xFF)\n    {\n        /* in these cases and equal type is enough */\n        case cJSON_False:\n        case cJSON_True:\n        case cJSON_NULL:\n            return true;\n\n        case cJSON_Number:\n            if (compare_double(a->valuedouble, b->valuedouble))\n            {\n                return true;\n            }\n            return false;\n\n        case cJSON_String:\n        case cJSON_Raw:\n            if ((a->valuestring == NULL) || (b->valuestring == NULL))\n            {\n                return false;\n            }\n            if (strcmp(a->valuestring, b->valuestring) == 0)\n            {\n                return true;\n            }\n\n            return false;\n\n        case cJSON_Array:\n        {\n            cJSON *a_element = a->child;\n            cJSON *b_element = b->child;\n\n            for (; (a_element != NULL) && (b_element != NULL);)\n            {\n                if (!cJSON_Compare(a_element, b_element, case_sensitive))\n                {\n                    return false;\n                }\n\n                a_element = a_element->next;\n                b_element = b_element->next;\n            }\n\n            /* one of the arrays is longer than the other */\n            if (a_element != b_element) {\n                return false;\n            }\n\n            return true;\n        }\n\n        case cJSON_Object:\n        {\n            cJSON *a_element = NULL;\n            cJSON *b_element = NULL;\n            cJSON_ArrayForEach(a_element, a)\n            {\n                /* TODO This has O(n^2) runtime, which is horrible! */\n                b_element = get_object_item(b, a_element->string, case_sensitive);\n                if (b_element == NULL)\n                {\n                    return false;\n                }\n\n                if (!cJSON_Compare(a_element, b_element, case_sensitive))\n                {\n                    return false;\n                }\n            }\n\n            /* doing this twice, once on a and b to prevent true comparison if a subset of b\n             * TODO: Do this the proper way, this is just a fix for now */\n            cJSON_ArrayForEach(b_element, b)\n            {\n                a_element = get_object_item(a, b_element->string, case_sensitive);\n                if (a_element == NULL)\n                {\n                    return false;\n                }\n\n                if (!cJSON_Compare(b_element, a_element, case_sensitive))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        default:\n            return false;\n    }\n}\n\nCJSON_PUBLIC(void *) cJSON_malloc(size_t size)\n{\n    return global_hooks.allocate(size);\n}\n\nCJSON_PUBLIC(void) cJSON_free(void *object)\n{\n    global_hooks.deallocate(object);\n    object = NULL;\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/dependencies/cJSON/cJSON.h",
		"is_binary":	false,
		"content":	"/*\n  Copyright (c) 2009-2017 Dave Gamble and cJSON contributors\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.\n*/\n\n#ifndef cJSON__h\n#define cJSON__h\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n#if !defined(__WINDOWS__) && (defined(WIN32) || defined(WIN64) || defined(_MSC_VER) || defined(_WIN32))\n#define __WINDOWS__\n#endif\n\n#ifdef __WINDOWS__\n\n/* When compiling for windows, we specify a specific calling convention to avoid issues where we are being called from a project with a different default calling convention.  For windows you have 3 define options:\n\nCJSON_HIDE_SYMBOLS - Define this in the case where you don't want to ever dllexport symbols\nCJSON_EXPORT_SYMBOLS - Define this on library build when you want to dllexport symbols (default)\nCJSON_IMPORT_SYMBOLS - Define this if you want to dllimport symbol\n\nFor *nix builds that support visibility attribute, you can define similar behavior by\n\nsetting default visibility to hidden by adding\n-fvisibility=hidden (for gcc)\nor\n-xldscope=hidden (for sun cc)\nto CFLAGS\n\nthen using the CJSON_API_VISIBILITY flag to \"export\" the same symbols the way CJSON_EXPORT_SYMBOLS does\n\n*/\n\n#define CJSON_CDECL __cdecl\n#define CJSON_STDCALL __stdcall\n\n/* export symbols by default, this is necessary for copy pasting the C and header file */\n#if !defined(CJSON_HIDE_SYMBOLS) && !defined(CJSON_IMPORT_SYMBOLS) && !defined(CJSON_EXPORT_SYMBOLS)\n#define CJSON_EXPORT_SYMBOLS\n#endif\n\n#if defined(CJSON_HIDE_SYMBOLS)\n#define CJSON_PUBLIC(type)   type CJSON_STDCALL\n#elif defined(CJSON_EXPORT_SYMBOLS)\n#define CJSON_PUBLIC(type)   __declspec(dllexport) type CJSON_STDCALL\n#elif defined(CJSON_IMPORT_SYMBOLS)\n#define CJSON_PUBLIC(type)   __declspec(dllimport) type CJSON_STDCALL\n#endif\n#else /* !__WINDOWS__ */\n#define CJSON_CDECL\n#define CJSON_STDCALL\n\n#if (defined(__GNUC__) || defined(__SUNPRO_CC) || defined (__SUNPRO_C)) && defined(CJSON_API_VISIBILITY)\n#define CJSON_PUBLIC(type)   __attribute__((visibility(\"default\"))) type\n#else\n#define CJSON_PUBLIC(type) type\n#endif\n#endif\n\n/* project version */\n#define CJSON_VERSION_MAJOR 1\n#define CJSON_VERSION_MINOR 7\n#define CJSON_VERSION_PATCH 18\n\n#include <stddef.h>\n\n/* cJSON Types: */\n#define cJSON_Invalid (0)\n#define cJSON_False  (1 << 0)\n#define cJSON_True   (1 << 1)\n#define cJSON_NULL   (1 << 2)\n#define cJSON_Number (1 << 3)\n#define cJSON_String (1 << 4)\n#define cJSON_Array  (1 << 5)\n#define cJSON_Object (1 << 6)\n#define cJSON_Raw    (1 << 7) /* raw json */\n\n#define cJSON_IsReference 256\n#define cJSON_StringIsConst 512\n\n/* The cJSON structure: */\ntypedef struct cJSON\n{\n    /* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */\n    struct cJSON *next;\n    struct cJSON *prev;\n    /* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */\n    struct cJSON *child;\n\n    /* The type of the item, as above. */\n    int type;\n\n    /* The item's string, if type==cJSON_String  and type == cJSON_Raw */\n    char *valuestring;\n    /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */\n    int valueint;\n    /* The item's number, if type==cJSON_Number */\n    double valuedouble;\n\n    /* The item's name string, if this item is the child of, or is in the list of subitems of an object. */\n    char *string;\n} cJSON;\n\ntypedef struct cJSON_Hooks\n{\n      /* malloc/free are CDECL on Windows regardless of the default calling convention of the compiler, so ensure the hooks allow passing those functions directly. */\n      void *(CJSON_CDECL *malloc_fn)(size_t sz);\n      void (CJSON_CDECL *free_fn)(void *ptr);\n} cJSON_Hooks;\n\ntypedef int cJSON_bool;\n\n/* Limits how deeply nested arrays/objects can be before cJSON rejects to parse them.\n * This is to prevent stack overflows. */\n#ifndef CJSON_NESTING_LIMIT\n#define CJSON_NESTING_LIMIT 1000\n#endif\n\n/* returns the version of cJSON as a string */\nCJSON_PUBLIC(const char*) cJSON_Version(void);\n\n/* Supply malloc, realloc and free functions to cJSON */\nCJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks);\n\n/* Memory Management: the caller is always responsible to free the results from all variants of cJSON_Parse (with cJSON_Delete) and cJSON_Print (with stdlib free, cJSON_Hooks.free_fn, or cJSON_free as appropriate). The exception is cJSON_PrintPreallocated, where the caller has full responsibility of the buffer. */\n/* Supply a block of JSON, and this returns a cJSON object you can interrogate. */\nCJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value);\nCJSON_PUBLIC(cJSON *) cJSON_ParseWithLength(const char *value, size_t buffer_length);\n/* ParseWithOpts allows you to require (and check) that the JSON is null terminated, and to retrieve the pointer to the final byte parsed. */\n/* If you supply a ptr in return_parse_end and parsing fails, then return_parse_end will contain a pointer to the error so will match cJSON_GetErrorPtr(). */\nCJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated);\nCJSON_PUBLIC(cJSON *) cJSON_ParseWithLengthOpts(const char *value, size_t buffer_length, const char **return_parse_end, cJSON_bool require_null_terminated);\n\n/* Render a cJSON entity to text for transfer/storage. */\nCJSON_PUBLIC(char *) cJSON_Print(const cJSON *item);\n/* Render a cJSON entity to text for transfer/storage without any formatting. */\nCJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item);\n/* Render a cJSON entity to text using a buffered strategy. prebuffer is a guess at the final size. guessing well reduces reallocation. fmt=0 gives unformatted, =1 gives formatted */\nCJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt);\n/* Render a cJSON entity to text using a buffer already allocated in memory with given length. Returns 1 on success and 0 on failure. */\n/* NOTE: cJSON is not always 100% accurate in estimating how much memory it will use, so to be safe allocate 5 bytes more than you actually need */\nCJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buffer, const int length, const cJSON_bool format);\n/* Delete a cJSON entity and all subentities. */\nCJSON_PUBLIC(void) cJSON_Delete(cJSON *item);\n\n/* Returns the number of items in an array (or object). */\nCJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array);\n/* Retrieve item number \"index\" from array \"array\". Returns NULL if unsuccessful. */\nCJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index);\n/* Get item \"string\" from object. Case insensitive. */\nCJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string);\nCJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string);\nCJSON_PUBLIC(cJSON_bool) cJSON_HasObjectItem(const cJSON *object, const char *string);\n/* For analysing failed parses. This returns a pointer to the parse error. You'll probably need to look a few chars back to make sense of it. Defined when cJSON_Parse() returns 0. 0 when cJSON_Parse() succeeds. */\nCJSON_PUBLIC(const char *) cJSON_GetErrorPtr(void);\n\n/* Check item type and return its value */\nCJSON_PUBLIC(char *) cJSON_GetStringValue(const cJSON * const item);\nCJSON_PUBLIC(double) cJSON_GetNumberValue(const cJSON * const item);\n\n/* These functions check the type of an item */\nCJSON_PUBLIC(cJSON_bool) cJSON_IsInvalid(const cJSON * const item);\nCJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item);\nCJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item);\nCJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item);\nCJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item);\nCJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item);\nCJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item);\nCJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item);\nCJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item);\nCJSON_PUBLIC(cJSON_bool) cJSON_IsRaw(const cJSON * const item);\n\n/* These calls create a cJSON item of the appropriate type. */\nCJSON_PUBLIC(cJSON *) cJSON_CreateNull(void);\nCJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void);\nCJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void);\nCJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool boolean);\nCJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num);\nCJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string);\n/* raw json */\nCJSON_PUBLIC(cJSON *) cJSON_CreateRaw(const char *raw);\nCJSON_PUBLIC(cJSON *) cJSON_CreateArray(void);\nCJSON_PUBLIC(cJSON *) cJSON_CreateObject(void);\n\n/* Create a string where valuestring references a string so\n * it will not be freed by cJSON_Delete */\nCJSON_PUBLIC(cJSON *) cJSON_CreateStringReference(const char *string);\n/* Create an object/array that only references it's elements so\n * they will not be freed by cJSON_Delete */\nCJSON_PUBLIC(cJSON *) cJSON_CreateObjectReference(const cJSON *child);\nCJSON_PUBLIC(cJSON *) cJSON_CreateArrayReference(const cJSON *child);\n\n/* These utilities create an Array of count items.\n * The parameter count cannot be greater than the number of elements in the number array, otherwise array access will be out of bounds.*/\nCJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count);\nCJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count);\nCJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count);\nCJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char *const *strings, int count);\n\n/* Append item to the specified array/object. */\nCJSON_PUBLIC(cJSON_bool) cJSON_AddItemToArray(cJSON *array, cJSON *item);\nCJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item);\n/* Use this when string is definitely const (i.e. a literal, or as good as), and will definitely survive the cJSON object.\n * WARNING: When this function was used, make sure to always check that (item->type & cJSON_StringIsConst) is zero before\n * writing to `item->string` */\nCJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item);\n/* Append reference to item to the specified array/object. Use this when you want to add an existing cJSON to a new cJSON, but don't want to corrupt your existing cJSON. */\nCJSON_PUBLIC(cJSON_bool) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item);\nCJSON_PUBLIC(cJSON_bool) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item);\n\n/* Remove/Detach items from Arrays/Objects. */\nCJSON_PUBLIC(cJSON *) cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item);\nCJSON_PUBLIC(cJSON *) cJSON_DetachItemFromArray(cJSON *array, int which);\nCJSON_PUBLIC(void) cJSON_DeleteItemFromArray(cJSON *array, int which);\nCJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObject(cJSON *object, const char *string);\nCJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string);\nCJSON_PUBLIC(void) cJSON_DeleteItemFromObject(cJSON *object, const char *string);\nCJSON_PUBLIC(void) cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string);\n\n/* Update array items. */\nCJSON_PUBLIC(cJSON_bool) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem); /* Shifts pre-existing items to the right. */\nCJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement);\nCJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem);\nCJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem);\nCJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object,const char *string,cJSON *newitem);\n\n/* Duplicate a cJSON item */\nCJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse);\n/* Duplicate will create a new, identical cJSON item to the one you pass, in new memory that will\n * need to be released. With recurse!=0, it will duplicate any children connected to the item.\n * The item->next and ->prev pointers are always zero on return from Duplicate. */\n/* Recursively compare two cJSON items for equality. If either a or b is NULL or invalid, they will be considered unequal.\n * case_sensitive determines if object keys are treated case sensitive (1) or case insensitive (0) */\nCJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive);\n\n/* Minify a strings, remove blank characters(such as ' ', '\\t', '\\r', '\\n') from strings.\n * The input pointer json cannot point to a read-only address area, such as a string constant,\n * but should point to a readable and writable address area. */\nCJSON_PUBLIC(void) cJSON_Minify(char *json);\n\n/* Helper functions for creating and adding items to an object at the same time.\n * They return the added item or NULL on failure. */\nCJSON_PUBLIC(cJSON*) cJSON_AddNullToObject(cJSON * const object, const char * const name);\nCJSON_PUBLIC(cJSON*) cJSON_AddTrueToObject(cJSON * const object, const char * const name);\nCJSON_PUBLIC(cJSON*) cJSON_AddFalseToObject(cJSON * const object, const char * const name);\nCJSON_PUBLIC(cJSON*) cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean);\nCJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number);\nCJSON_PUBLIC(cJSON*) cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string);\nCJSON_PUBLIC(cJSON*) cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw);\nCJSON_PUBLIC(cJSON*) cJSON_AddObjectToObject(cJSON * const object, const char * const name);\nCJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name);\n\n/* When assigning an integer value, it needs to be propagated to valuedouble too. */\n#define cJSON_SetIntValue(object, number) ((object) ? (object)->valueint = (object)->valuedouble = (number) : (number))\n/* helper for the cJSON_SetNumberValue macro */\nCJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number);\n#define cJSON_SetNumberValue(object, number) ((object != NULL) ? cJSON_SetNumberHelper(object, (double)number) : (number))\n/* Change the valuestring of a cJSON_String object, only takes effect when type of object is cJSON_String */\nCJSON_PUBLIC(char*) cJSON_SetValuestring(cJSON *object, const char *valuestring);\n\n/* If the object is not a boolean type this does nothing and returns cJSON_Invalid else it returns the new type*/\n#define cJSON_SetBoolValue(object, boolValue) ( \\\n    (object != NULL && ((object)->type & (cJSON_False|cJSON_True))) ? \\\n    (object)->type=((object)->type &(~(cJSON_False|cJSON_True)))|((boolValue)?cJSON_True:cJSON_False) : \\\n    cJSON_Invalid\\\n)\n\n/* Macro for iterating over an array or object */\n#define cJSON_ArrayForEach(element, array) for(element = (array != NULL) ? (array)->child : NULL; element != NULL; element = element->next)\n\n/* malloc/free objects using the malloc/free functions that have been set with cJSON_InitHooks */\nCJSON_PUBLIC(void *) cJSON_malloc(size_t size);\nCJSON_PUBLIC(void) cJSON_free(void *object);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif"
	}, {
		"path":	"src/dependencies/doTheWorld/dependencies/declaration.h",
		"is_binary":	false,
		"content":	"#ifndef cJSON__h\n#include \"cJSON/cJSON.h\"\n#define PRIVATE_DTW_CJSON_DEFINED_IN_DO_THE_WORLD\n#endif //cJSON__h\n\n#ifndef SHA_256_H\n#include \"sha256/sha-256.h\"\n#define PRIVATE_DTW_SHA_DEFINED_IN_DO_THE_WORLD\n#endif  //SHA_256_H"
	}, {
		"path":	"src/dependencies/doTheWorld/dependencies/definition.c",
		"is_binary":	false,
		"content":	"\n#ifdef PRIVATE_DTW_CJSON_DEFINED_IN_DO_THE_WORLD\n#include \"cJSON/cJSON.c\"\n#undef true\n#define true 1\n#undef false\n#define false 0\n#endif\n\n#ifdef PRIVATE_DTW_SHA_DEFINED_IN_DO_THE_WORLD\n#include \"sha256/sha-256.c\"\n#endif"
	}, {
		"path":	"src/dependencies/doTheWorld/dependencies/sha256/"
	}, {
		"path":	"src/dependencies/doTheWorld/dependencies/sha256/sha-256.c",
		"is_binary":	false,
		"content":	"#include \"sha-256.h\"\n\n#define TOTAL_LEN_LEN 8\n\n/*\n * Comments from pseudo-code at https://en.wikipedia.org/wiki/SHA-2 are reproduced here.\n * When useful for clarification, portions of the pseudo-code are reproduced here too.\n */\n\n/*\n * @brief Rotate a 32-bit value by a number of bits to the right.\n * @param value The value to be rotated.\n * @param count The number of bits to rotate by.\n * @return The rotated value.\n */\nstatic inline uint32_t right_rot(uint32_t value, unsigned int count)\n{\n\t/*\n\t * Defined behaviour in standard C for all count where 0 < count < 32, which is what we need here.\n\t */\n\treturn value >> count | value << (32 - count);\n}\n\n/*\n * @brief Update a hash value under calculation with a new chunk of data.\n * @param h Pointer to the first hash item, of a total of eight.\n * @param p Pointer to the chunk data, which has a standard length.\n *\n * @note This is the SHA-256 work horse.\n */\nstatic inline void consume_chunk(uint32_t *h, const uint8_t *p)\n{\n\tunsigned i, j;\n\tuint32_t ah[8];\n\n\t/* Initialize working variables to current hash value: */\n\tfor (i = 0; i < 8; i++)\n\t\tah[i] = h[i];\n\n\t/*\n\t * The w-array is really w[64], but since we only need 16 of them at a time, we save stack by\n\t * calculating 16 at a time.\n\t *\n\t * This optimization was not there initially and the rest of the comments about w[64] are kept in their\n\t * initial state.\n\t */\n\n\t/*\n\t * create a 64-entry message schedule array w[0..63] of 32-bit words (The initial values in w[0..63]\n\t * don't matter, so many implementations zero them here) copy chunk into first 16 words w[0..15] of the\n\t * message schedule array\n\t */\n\tuint32_t w[16];\n\n\t/* Compression function main loop: */\n\tfor (i = 0; i < 4; i++) {\n\t\tfor (j = 0; j < 16; j++) {\n\t\t\tif (i == 0) {\n\t\t\t\tw[j] =\n\t\t\t\t    (uint32_t)p[0] << 24 | (uint32_t)p[1] << 16 | (uint32_t)p[2] << 8 | (uint32_t)p[3];\n\t\t\t\tp += 4;\n\t\t\t} else {\n\t\t\t\t/* Extend the first 16 words into the remaining 48 words w[16..63] of the\n\t\t\t\t * message schedule array: */\n\t\t\t\tconst uint32_t s0 = right_rot(w[(j + 1) & 0xf], 7) ^ right_rot(w[(j + 1) & 0xf], 18) ^\n\t\t\t\t\t\t    (w[(j + 1) & 0xf] >> 3);\n\t\t\t\tconst uint32_t s1 = right_rot(w[(j + 14) & 0xf], 17) ^\n\t\t\t\t\t\t    right_rot(w[(j + 14) & 0xf], 19) ^ (w[(j + 14) & 0xf] >> 10);\n\t\t\t\tw[j] = w[j] + s0 + w[(j + 9) & 0xf] + s1;\n\t\t\t}\n\t\t\tconst uint32_t s1 = right_rot(ah[4], 6) ^ right_rot(ah[4], 11) ^ right_rot(ah[4], 25);\n\t\t\tconst uint32_t ch = (ah[4] & ah[5]) ^ (~ah[4] & ah[6]);\n\n\t\t\t/*\n\t\t\t * Initialize array of round constants:\n\t\t\t * (first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311):\n\t\t\t */\n\t\t\tstatic const uint32_t k[] = {\n\t\t\t    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4,\n\t\t\t    0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe,\n\t\t\t    0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f,\n\t\t\t    0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n\t\t\t    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,\n\t\t\t    0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,\n\t\t\t    0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116,\n\t\t\t    0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n\t\t\t    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7,\n\t\t\t    0xc67178f2};\n\n\t\t\tconst uint32_t temp1 = ah[7] + s1 + ch + k[i << 4 | j] + w[j];\n\t\t\tconst uint32_t s0 = right_rot(ah[0], 2) ^ right_rot(ah[0], 13) ^ right_rot(ah[0], 22);\n\t\t\tconst uint32_t maj = (ah[0] & ah[1]) ^ (ah[0] & ah[2]) ^ (ah[1] & ah[2]);\n\t\t\tconst uint32_t temp2 = s0 + maj;\n\n\t\t\tah[7] = ah[6];\n\t\t\tah[6] = ah[5];\n\t\t\tah[5] = ah[4];\n\t\t\tah[4] = ah[3] + temp1;\n\t\t\tah[3] = ah[2];\n\t\t\tah[2] = ah[1];\n\t\t\tah[1] = ah[0];\n\t\t\tah[0] = temp1 + temp2;\n\t\t}\n\t}\n\n\t/* Add the compressed chunk to the current hash value: */\n\tfor (i = 0; i < 8; i++)\n\t\th[i] += ah[i];\n}\n\n/*\n * Public functions. See header file for documentation.\n */\n\nvoid sha_256_init(struct Sha_256 *sha_256, uint8_t hash[SIZE_OF_SHA_256_HASH])\n{\n\tsha_256->hash = hash;\n\tsha_256->chunk_pos = sha_256->chunk;\n\tsha_256->space_left = SIZE_OF_SHA_256_CHUNK;\n\tsha_256->total_len = 0;\n\t/*\n\t * Initialize hash values (first 32 bits of the fractional parts of the square roots of the first 8 primes\n\t * 2..19):\n\t */\n\tsha_256->h[0] = 0x6a09e667;\n\tsha_256->h[1] = 0xbb67ae85;\n\tsha_256->h[2] = 0x3c6ef372;\n\tsha_256->h[3] = 0xa54ff53a;\n\tsha_256->h[4] = 0x510e527f;\n\tsha_256->h[5] = 0x9b05688c;\n\tsha_256->h[6] = 0x1f83d9ab;\n\tsha_256->h[7] = 0x5be0cd19;\n}\n\nvoid sha_256_write(struct Sha_256 *sha_256, const void *data, size_t len)\n{\n\tsha_256->total_len += len;\n\n\t/*\n\t * The following cast is not necessary, and could even be considered as poor practice. However, it makes this\n\t * file valid C++, which could be a good thing for some use cases.\n\t */\n\tconst uint8_t *p = (const uint8_t *)data;\n\n\twhile (len > 0) {\n\t\t/*\n\t\t * If the input chunks have sizes that are multiples of the calculation chunk size, no copies are\n\t\t * necessary. We operate directly on the input data instead.\n\t\t */\n\t\tif (sha_256->space_left == SIZE_OF_SHA_256_CHUNK && len >= SIZE_OF_SHA_256_CHUNK) {\n\t\t\tconsume_chunk(sha_256->h, p);\n\t\t\tlen -= SIZE_OF_SHA_256_CHUNK;\n\t\t\tp += SIZE_OF_SHA_256_CHUNK;\n\t\t\tcontinue;\n\t\t}\n\t\t/* General case, no particular optimization. */\n\t\tconst size_t consumed_len = len < sha_256->space_left ? len : sha_256->space_left;\n\t\tmemcpy(sha_256->chunk_pos, p, consumed_len);\n\t\tsha_256->space_left -= consumed_len;\n\t\tlen -= consumed_len;\n\t\tp += consumed_len;\n\t\tif (sha_256->space_left == 0) {\n\t\t\tconsume_chunk(sha_256->h, sha_256->chunk);\n\t\t\tsha_256->chunk_pos = sha_256->chunk;\n\t\t\tsha_256->space_left = SIZE_OF_SHA_256_CHUNK;\n\t\t} else {\n\t\t\tsha_256->chunk_pos += consumed_len;\n\t\t}\n\t}\n}\n\nuint8_t *sha_256_close(struct Sha_256 *sha_256)\n{\n\tuint8_t *pos = sha_256->chunk_pos;\n\tsize_t space_left = sha_256->space_left;\n\tuint32_t *const h = sha_256->h;\n\n\t/*\n\t * The current chunk cannot be full. Otherwise, it would already have been consumed. I.e. there is space left\n\t * for at least one byte. The next step in the calculation is to add a single one-bit to the data.\n\t */\n\t*pos++ = 0x80;\n\t--space_left;\n\n\t/*\n\t * Now, the last step is to add the total data length at the end of the last chunk, and zero padding before\n\t * that. But we do not necessarily have enough space left. If not, we pad the current chunk with zeroes, and add\n\t * an extra chunk at the end.\n\t */\n\tif (space_left < TOTAL_LEN_LEN) {\n\t\tmemset(pos, 0x00, space_left);\n\t\tconsume_chunk(h, sha_256->chunk);\n\t\tpos = sha_256->chunk;\n\t\tspace_left = SIZE_OF_SHA_256_CHUNK;\n\t}\n\tconst size_t left = space_left - TOTAL_LEN_LEN;\n\tmemset(pos, 0x00, left);\n\tpos += left;\n\tuint64_t len = sha_256->total_len;\n\tpos[7] = (uint8_t)(len << 3);\n\tlen >>= 5;\n\tint i;\n\tfor (i = 6; i >= 0; --i) {\n\t\tpos[i] = (uint8_t)len;\n\t\tlen >>= 8;\n\t}\n\tconsume_chunk(h, sha_256->chunk);\n\t/* Produce the final hash value (big-endian): */\n\tint j;\n\tuint8_t *const hash = sha_256->hash;\n\tfor (i = 0, j = 0; i < 8; i++) {\n\t\thash[j++] = (uint8_t)(h[i] >> 24);\n\t\thash[j++] = (uint8_t)(h[i] >> 16);\n\t\thash[j++] = (uint8_t)(h[i] >> 8);\n\t\thash[j++] = (uint8_t)h[i];\n\t}\n\treturn sha_256->hash;\n}\n\nvoid calc_sha_256(uint8_t hash[SIZE_OF_SHA_256_HASH], const void *input, size_t len)\n{\n\tstruct Sha_256 sha_256;\n\tsha_256_init(&sha_256, hash);\n\tsha_256_write(&sha_256, input, len);\n\t(void)sha_256_close(&sha_256);\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/dependencies/sha256/sha-256.h",
		"is_binary":	false,
		"content":	"#ifndef SHA_256_H\n#define SHA_256_H\n\n#include <stdint.h>\n#include <string.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * @brief Size of the SHA-256 sum. This times eight is 256 bits.\n */\n#define SIZE_OF_SHA_256_HASH 32\n\n/*\n * @brief Size of the chunks used for the calculations.\n *\n * @note This should mostly be ignored by the user, although when using the streaming API, it has an impact for\n * performance. Add chunks whose size is a multiple of this, and you will avoid a lot of superfluous copying in RAM!\n */\n#define SIZE_OF_SHA_256_CHUNK 64\n\n/*\n * @brief The opaque SHA-256 type, that should be instantiated when using the streaming API.\n *\n * @note Although the details are exposed here, in order to make instantiation easy, you should refrain from directly\n * accessing the fields, as they may change in the future.\n */\nstruct Sha_256 {\n\tuint8_t *hash;\n\tuint8_t chunk[SIZE_OF_SHA_256_CHUNK];\n\tuint8_t *chunk_pos;\n\tsize_t space_left;\n\tuint64_t total_len;\n\tuint32_t h[8];\n};\n\n/*\n * @brief The simple SHA-256 calculation function.\n * @param hash Hash array, where the result is delivered.\n * @param input Pointer to the data the hash shall be calculated on.\n * @param len Length of the input data, in byte.\n *\n * @note If all of the data you are calculating the hash value on is available in a contiguous buffer in memory, this is\n * the function you should use.\n *\n * @note If either of the passed pointers is NULL, the results are unpredictable.\n *\n * @note See note about maximum data length for sha_256_write, as it applies for this function's len argument too.\n */\nvoid calc_sha_256(uint8_t hash[SIZE_OF_SHA_256_HASH], const void *input, size_t len);\n\n/*\n * @brief Initialize a SHA-256 streaming calculation.\n * @param sha_256 A pointer to a SHA-256 structure.\n * @param hash Hash array, where the result will be delivered.\n *\n * @note If all of the data you are calculating the hash value on is not available in a contiguous buffer in memory,\n * this is where you should start. Instantiate a SHA-256 structure, for instance by simply declaring it locally, make\n * your hash buffer available, and invoke this function. Once a SHA-256 hash has been calculated (see further below) a\n * SHA-256 structure can be initialized again for the next calculation.\n *\n * @note If either of the passed pointers is NULL, the results are unpredictable.\n */\nvoid sha_256_init(struct Sha_256 *sha_256, uint8_t hash[SIZE_OF_SHA_256_HASH]);\n\n/*\n * @brief Stream more input data for an on-going SHA-256 calculation.\n * @param sha_256 A pointer to a previously initialized SHA-256 structure.\n * @param data Pointer to the data to be added to the calculation.\n * @param len Length of the data to add, in byte.\n *\n * @note This function may be invoked an arbitrary number of times between initialization and closing, but the maximum\n * data length is limited by the SHA-256 algorithm: the total number of bits (i.e. the total number of bytes times\n * eight) must be representable by a 64-bit unsigned integer. While that is not a practical limitation, the results are\n * unpredictable if that limit is exceeded.\n *\n * @note This function may be invoked on empty data (zero length), although that obviously will not add any data.\n *\n * @note If either of the passed pointers is NULL, the results are unpredictable.\n */\nvoid sha_256_write(struct Sha_256 *sha_256, const void *data, size_t len);\n\n/*\n * @brief Conclude a SHA-256 streaming calculation, making the hash value available.\n * @param sha_256 A pointer to a previously initialized SHA-256 structure.\n * @return Pointer to the hash array, where the result is delivered.\n *\n * @note After this function has been invoked, the result is available in the hash buffer that initially was provided. A\n * pointer to the hash value is returned for convenience, but you should feel free to ignore it: it is simply a pointer\n * to the first byte of your initially provided hash array.\n *\n * @note If the passed pointer is NULL, the results are unpredictable.\n *\n * @note Invoking this function for a calculation with no data (the writing function has never been invoked, or it only\n * has been invoked with empty data) is legal. It will calculate the SHA-256 value of the empty string.\n */\nuint8_t *sha_256_close(struct Sha_256 *sha_256);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif"
	}, {
		"path":	"src/dependencies/doTheWorld/extras/"
	}, {
		"path":	"src/dependencies/doTheWorld/extras/extras.c",
		"is_binary":	false,
		"content":	"\nchar * dtw_generate_sha_from_file(const char *path){\n    return calc_sha_256_from_file_returning_string(path);\n}\n\nchar * dtw_generate_sha_from_any(void *anything , long size){\n    if(anything ==NULL) {\n        return NULL;\n    }\n    return calc_sha_256_returning_string(anything,size);\n}   \n\nchar * dtw_generate_sha_from_string(const char *string){\n    if(string == NULL) {\n        return  NULL;\n    }\n    return calc_sha_256_from_string_returning_string(string);\n}\n\n\nlong int dtw_get_entity_last_motification_in_unix(const char *path){\n    struct stat attr;\n    if(stat(path, &attr) != 0) {\n        return -1;\n    }\n\n    time_t last_modification_in_unix = attr.st_mtime;\n\n    return last_modification_in_unix;\n}\n\nchar * dtw_convert_unix_time_to_string(long int unix_time){\n    struct tm * timeinfo;\n    #ifdef _WIN32\n        //get timeinfo from windows\n        time_t rawtime = unix_time;\n        timeinfo = localtime(&rawtime);\n    #else\n        timeinfo = localtime(&unix_time);\n    #endif\n    char *time_string = (char *)malloc(100);\n    strftime(time_string, 100, \"%Y-%m-%d %H:%M:%S\", timeinfo);\n    return time_string;\n}\n\nchar * dtw_get_entity_last_motification_in_string(const char *path){\n    long int last_modification_in_unix = dtw_get_entity_last_motification_in_unix(path);\n    char *last_modification_in_string = dtw_convert_unix_time_to_string(last_modification_in_unix);\n    return last_modification_in_string;\n}\n\nconst char * private_dtw_convert_action_to_string(short action){\n    switch (action){\n        case DTW_REMOVE:\n            return \"remove\";\n        case DTW_WRITE:\n            return \"write\";\n        case DTW_MODIFY:\n            return \"modify\";\n    }\n    return NULL;\n}\n\nshort private_dtw_convert_string_to_action(const char *action){\n    if(strcmp(action,\"remove\") == 0){\n        return DTW_REMOVE;\n    }\n    if(strcmp(action,\"write\") == 0){\n        return DTW_WRITE;\n    }\n    if(strcmp(action,\"modify\") == 0){\n        return DTW_MODIFY;\n    }\n    return -1;\n}\n\nvoid private_dtw_add_end_bar_to_dirs_string_array(struct DtwStringArray * dirs){\n    for(int i = 0; i < dirs->size; i++){\n  \n        if(!dtw_ends_with(dirs->strings[i], \"/\") || !dtw_ends_with(dirs->strings[i],\"\\\\\")){\n            char *formated_dir =  (char*)malloc(strlen(dirs->strings[i]) + 3);\n            sprintf(formated_dir,\"%s/\",dirs->strings[i]);\n            DtwStringArray_set_value(dirs, i, formated_dir);\n            free(formated_dir);\n        }    \n            \n         \n    }\n}\n\n\n\nstruct DtwStringArray* private_dtw_remove_start_path(struct DtwStringArray *paths,const char *rm_path){\n\n    char *path_to_remove = dtw_replace_string(rm_path,\"//\",\"/\");\n\n    int size_to_remove = strlen(path_to_remove) +1;\n\n    if(dtw_ends_with(path_to_remove,\"/\")){\n        size_to_remove-=1;\n    }\n\n\n    struct DtwStringArray *new_array = newDtwStringArray();\n\n    for(int i =0; i < paths->size; i++){\n\n        char *current_path_string = paths->strings[i];\n        int current_path_string_size = strlen(current_path_string);\n\n        char *new_string = (char*)malloc(current_path_string_size +2);\n        new_string[current_path_string_size] =0;\n\n        strcpy(new_string,current_path_string);\n        memmove(\n                new_string,\n                current_path_string+size_to_remove,\n                strlen(current_path_string) - size_to_remove +1\n        );\n        if(strcmp(new_string,\"/\") == 0  || strcmp(new_string,\"\") == 0){\n            free(new_string);\n            continue;\n        }\n\n        DtwStringArray_append(new_array, new_string);\n        free(new_string);\n\n    }\n    free(path_to_remove);\n    return new_array;\n}\n\n\nlong dtw_get_time(){\n#ifdef DTW_DEBUG_TIME\n    return 0;\n#endif\n    return time(NULL);\n}\nlong private_dtw_convert_index(long index,long size){\n\n    long converted_index = index;\n\n    if(converted_index < 0){\n        converted_index = size + converted_index;\n    }\n\n    if(converted_index >= size){\n       return -1;\n    }\n\n    if(converted_index < 0){\n        return -1;\n    }\n\n    return converted_index;\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/extras/extras.h",
		"is_binary":	false,
		"content":	"\nchar * dtw_generate_sha_from_file(const char *path);\nchar * dtw_generate_sha_from_string(const char *string);\nchar * dtw_generate_sha_from_any(void *anything , long size);\n\nlong int dtw_get_entity_last_motification_in_unix(const char *path);\nchar * dtw_convert_unix_time_to_string(long int unix_time);\nchar * dtw_get_entity_last_motification_in_string(const char *path);\nconst char * private_dtw_convert_action_to_string(short action);\nshort private_dtw_convert_string_to_action(const char *action);\nvoid private_dtw_add_end_bar_to_dirs_string_array(struct DtwStringArray * dirs);\n\nlong private_dtw_convert_index(long index,long size);\n\n\nlong dtw_get_time();\n\n\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/globals.c",
		"is_binary":	false,
		"content":	"\n\n\nconst char dtw_base64_table[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n"
	}, {
		"path":	"src/dependencies/doTheWorld/hash/"
	}, {
		"path":	"src/dependencies/doTheWorld/hash/hash.c",
		"is_binary":	false,
		"content":	"\n\n\n\n\n\nDtwHash * newDtwHash(){\n    DtwHash *self = (DtwHash*) malloc(sizeof(DtwHash));\n    self->hash = dtw_generate_sha_from_string(\"\");\n    return self;\n}\n\nbool  DtwHash_digest_any(DtwHash *self,unsigned char *content,long size){\n    if(content == NULL){\n        return false;\n    }\n    char *generated = dtw_generate_sha_from_any(content,size);\n    char result[300] ={0};\n    sprintf(result,\"%s%s\",self->hash,generated);\n    free(generated);\n    free(self->hash);\n    self->hash = dtw_generate_sha_from_string(result);\n    return true;\n}\n\nbool  DtwHash_digest_string(DtwHash * self, const char *content){\n    return DtwHash_digest_any(self,(unsigned char *)content, (long)strlen(content));\n}\n\nvoid DtwHash_digest_long(DtwHash * self,long content){\n    char formated[20] ={0};\n    sprintf(formated,\"%ld\",content);\n    DtwHash_digest_string(self,formated);\n}\n\nvoid DtwHash_digest_double(DtwHash * self,double content){\n    char formated[20] ={0};\n    sprintf(formated,\"%lf\",content);\n    DtwHash_digest_string(self,formated);\n}\n\nvoid DtwHash_digest_bool(DtwHash * self,bool content){\n    char formated[20] ={0};\n    sprintf(formated,\"%d\",(bool)content);\n    DtwHash_digest_string(self,formated);\n}\n\nbool  DtwHash_digest_file(DtwHash * self, const char *path){\n\n    long size;\n    unsigned  char *content = dtw_load_binary_content(path,&size);\n    if(!content){\n        return false;\n    }\n    DtwHash_digest_any(self,content,size);\n    free(content);\n    return true;\n}\n\nbool  DtwHash_digest_entity_last_modification(DtwHash * self, const char *path){\n    long last_modification = dtw_get_entity_last_motification_in_unix(path);\n    if(last_modification == -1){\n        return false;\n    }\n    DtwHash_digest_long(self,last_modification);\n    return true;\n}\n\n\nbool  DtwHash_digest_string_array(DtwHash *self,DtwStringArray *element){\n    if(element->size == 0){\n        return false;\n    }\n    DtwStringArray  *clone = DtwStringArray_clone(element);\n    DtwStringArray_sort(clone);\n\n    for(int i =0 ; i < clone->size; i++){\n        DtwHash_digest_string(self,clone->strings[i]);\n    }\n    DtwStringArray_free(clone);\n    return  true;\n}\n\nbool  DtwHash_digest_string_array_last_modifications(DtwHash *self,DtwStringArray *element){\n    if(element->size == 0){\n        return false;\n    }\n    DtwStringArray  *clone = DtwStringArray_clone(element);\n    DtwStringArray_sort(clone);\n    for(int i =0 ; i < clone->size; i++){\n        DtwHash_digest_entity_last_modification(self, clone->strings[i]);\n    }\n    DtwStringArray_free(clone);\n    return true;\n}\n\nbool DtwHash_digest_string_array_last_modifications_adding_name(DtwHash *self,DtwStringArray *element){\n    if(element->size == 0){\n        return false;\n    }\n    DtwStringArray  *clone = DtwStringArray_clone(element);\n    DtwStringArray_sort(clone);\n    for(int i =0 ; i < clone->size; i++){\n        DtwHash_digest_string(self,clone->strings[i]);\n        DtwHash_digest_entity_last_modification(self, clone->strings[i]);\n    }\n    DtwStringArray_free(clone);\n    return true;\n}\n\n\nbool DtwHash_digest_string_array_content(DtwHash *self,DtwStringArray *element){\n    if(element->size == 0){\n        return false;\n    }\n    DtwStringArray  *clone = DtwStringArray_clone(element);\n    DtwStringArray_sort(clone);\n    for(int i =0 ; i < clone->size; i++){\n        DtwHash_digest_file(self,clone->strings[i]);\n    }\n    DtwStringArray_free(clone);\n    return true;\n}\n\nbool DtwHash_digest_string_array_content_adding_name(DtwHash *self,DtwStringArray *element){\n    if(element->size == 0){\n        return false;\n    }\n    DtwStringArray  *clone = DtwStringArray_clone(element);\n    DtwStringArray_sort(clone);\n    for(int i =0; i < clone->size; i++){\n        DtwHash_digest_string(self,clone->strings[i]);\n        DtwHash_digest_file(self,clone->strings[i]);\n    }\n    DtwStringArray_free(clone);\n    return true;\n}\n\n\nbool DtwHash_digest_folder_by_last_modification(DtwHash *self,const char *path){\n    DtwStringArray  *folder = dtw_list_all_recursively(path,DTW_NOT_CONCAT_PATH);\n    if(folder->size == 0){\n        DtwStringArray_free(folder);\n        return false;\n    }\n    DtwStringArray_sort(folder);\n    for(int i =0; i < folder->size; i++){\n        DtwHash_digest_string(self,folder->strings[i]);\n        char *formated_path = dtw_concat_path(path,folder->strings[i]);\n\n        DtwHash_digest_entity_last_modification(self, formated_path);\n        free(formated_path);\n    }\n    DtwStringArray_free(folder);\n    return true;\n}\n\nbool DtwHash_digest_folder_by_content(DtwHash *self,const char *path){\n\n    DtwStringArray  *folder = dtw_list_all_recursively(path,DTW_NOT_CONCAT_PATH);\n    if(folder->size == 0){\n        DtwStringArray_free(folder);\n        return false;\n    }\n    DtwStringArray_sort(folder);\n    for(int i =0; i < folder->size; i++){\n        DtwHash_digest_string(self,folder->strings[i]);\n        char *formated_path = dtw_concat_path(path,folder->strings[i]);\n        DtwHash_digest_file(self,formated_path);\n        free(formated_path);\n    }\n    DtwStringArray_free(folder);\n    return true;\n}\n\nvoid  DtwHash_free(DtwHash *self){\n    free(self->hash);\n    free(self);\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/hash/hash.h",
		"is_binary":	false,
		"content":	"\n\ntypedef  struct DtwHash{\n    char *hash;\n}DtwHash;\n\n\nDtwHash * newDtwHash();\n\nbool  DtwHash_digest_any(DtwHash *self,unsigned char *content,long size);\n\nbool DtwHash_digest_string(DtwHash * self, const char *content);\n\nvoid DtwHash_digest_long(DtwHash * self,long content);\n\nvoid DtwHash_digest_double(DtwHash * self,double content);\n\nvoid DtwHash_digest_bool(DtwHash * self,bool content);\n\nbool  DtwHash_digest_file(DtwHash * self, const char *path);\n\nbool DtwHash_digest_entity_last_modification(DtwHash * self, const char *path);\n\nbool DtwHash_digest_folder_by_last_modification(DtwHash *self,const char *path);\n\nbool DtwHash_digest_folder_by_content(DtwHash *self,const char *path);\n\n\nbool DtwHash_digest_string_array(DtwHash *self,DtwStringArray *element);\n\nbool DtwHash_digest_string_array_last_modifications(DtwHash *self,DtwStringArray *element);\n\nbool DtwHash_digest_string_array_last_modifications_adding_name(DtwHash *self,DtwStringArray *element);\n\n\nbool DtwHash_digest_string_array_content(DtwHash *self,DtwStringArray *element);\n\nbool DtwHash_digest_string_array_content_adding_name(DtwHash *self,DtwStringArray *element);\n\n\nvoid  DtwHash_free(DtwHash *self);\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/io/"
	}, {
		"path":	"src/dependencies/doTheWorld/io/io.c",
		"is_binary":	false,
		"content":	"\n#ifdef __linux__\n#define dtw_create_dir(path) mkdir(path,0777)\n#elif _WIN32\n#define dtw_create_dir(path) _mkdir(path)\n\n#endif\n\n\n\nvoid dtw_create_dir_recursively(const char *path){\n\n    int entity =dtw_entity_type(path);\n\n    if(entity == DTW_FOLDER_TYPE){\n        return;\n    }\n\n    if(entity == DTW_FILE_TYPE){\n        remove(path);\n    }\n\n\n    long size_path = strlen(path);\n    for(int i=0;i <  size_path;i++){\n        if((path[i] == '\\\\'  || path[i] == '/' )  &&( i != size_path - 1)){\n            \n            char * current_path = (char*)malloc(i + 1);\n            current_path[i] = '\\0';\n            strncpy(current_path,path,i);\n\n            if(dtw_entity_type(current_path) == DTW_FILE_TYPE){\n                remove(current_path);\n            }\n\n            dtw_create_dir(current_path);\n\n            free(current_path);\n        }\n    }\n\n    dtw_create_dir(path);\n}\n\nchar *dtw_get_current_dir(){\n    char *path = (char*)malloc(1024);\n    getcwd(path,1024);\n    char*path_with_bar = (char*)malloc(strlen(path) + 2);\n    sprintf(path_with_bar,\"%s/\",path);\n    free(path);\n    return path_with_bar;\n}\n\n\n\nbool dtw_remove_any(const char* path) {\n    //means is an file\n    if(remove(path) == 0){\n        return true;\n    }\n    \n    struct DtwStringArray *files = dtw_list_files_recursively(path,DTW_CONCAT_PATH);\n    int files_size = files->size;\n    for(int i = 0; i < files_size; i++){\n        remove(files->strings[i]);\n    }\n    DtwStringArray_free(files);\n\n\n    struct DtwStringArray *dirs = dtw_list_dirs_recursively(path,DTW_CONCAT_PATH);\n    int dirs_size = dirs->size;\n    for(int i = dirs->size -1; i >=0; i--){\n        rmdir(dirs->strings[i]);\n    }\n    DtwStringArray_free(dirs);\n    //remove / to the path \n    if(files_size ||dirs_size){\n        return true;\n    }    \n    return false;\n    \n \n}\n\n\n\nunsigned char *dtw_load_any_content(const char * path,long *size,bool *is_binary){\n\n    *is_binary = false;\n    *size = 0;\n\n    int entity = dtw_entity_type(path);\n    if(entity != DTW_FILE_TYPE){\n        return NULL;\n    }\n    FILE  *file = fopen(path,\"rb\");\n\n    if(file ==NULL){\n        return NULL;\n    }\n\n\n    if(fseek(file,0,SEEK_END) == -1){\n        fclose(file);\n        return NULL;\n    }\n\n\n    *size = ftell(file);\n\n    if(*size == -1){\n        fclose(file);\n        return NULL;\n    }\n\n    if(*size == 0){\n        fclose(file);\n        return (unsigned char*)strdup(\"\");\n    }\n\n\n    if(fseek(file,0,SEEK_SET) == -1){\n        fclose(file);\n        return NULL;\n    }\n\n    unsigned char *content = (unsigned char*)malloc(*size +1);\n    int bytes_read = fread(content,1,*size,file);\n    if(bytes_read <=0 ){\n        free(content);\n        fclose(file);\n        return NULL;\n    }\n\n\n    *is_binary = false;\n    for(int i = 0;i < *size;i++){\n        if(content[i] == 0){\n            *is_binary = true;\n            break;\n        }\n    }\n    content[*size] = '\\0';\n\n    fclose(file);\n    return content;\n}\n\n\nchar *dtw_load_string_file_content(const char * path){\n    long size;\n    bool is_binary;\n    unsigned char *element = dtw_load_any_content(path,&size,&is_binary);\n    if(element == NULL){\n        return NULL;\n    }\n\n    if(is_binary){\n        free(element);\n        return NULL;\n    }\n    return (char*)element;\n}\n\n\nunsigned char *dtw_load_binary_content(const char * path,long *size){\n    bool is_binary;\n    return dtw_load_any_content(path,size,&is_binary);\n}\n\n\nbool dtw_write_any_content(const char *path,unsigned  char *content,long size){\n    //Iterate through the path and create directories if they don't exist\n    int entity_type =dtw_entity_type(path);\n    if(entity_type == DTW_FOLDER_TYPE){\n        dtw_remove_any(path);\n    }\n\n\n    if(entity_type == DTW_NOT_FOUND){\n        long path_size = (long)strlen(path);\n        for(long i = path_size-1;i > 0;i--){\n            //runs in negative mode til / or \\ is found\n            if(path[i] == '\\\\' || path[i] == '/'){\n                char *dir_path =(char*)malloc(i +2);\n                dir_path[i] = '\\0';\n                strncpy(dir_path,path,i);\n\n                dtw_create_dir_recursively(dir_path);\n                free(dir_path);\n\n                break;\n            }\n        }\n    }\n\n    FILE *file = fopen(path,\"wb\");\n    if(file == NULL){\n   \n        return false;\n    }\n    \n    fwrite(content, sizeof(char),size, file);\n    \n    fclose(file);\n    return true;\n}\n\n\nbool dtw_write_string_file_content(const char *path,const char *content){\n    long size;\n    if(content == NULL){\n        size = 0;\n    }\n    else{\n        size = (long)strlen(content);\n    }\n    return dtw_write_any_content(path,(unsigned char*)content,size);\n}\n\n\nint dtw_entity_type(const char *path){\n    //returns 1 for file, 2 for directory, -1 for not found\n    struct stat path_stat; \n\n    if(stat(path,&path_stat) == 0){\n        if(S_ISREG(path_stat.st_mode)){\n            return DTW_FILE_TYPE;\n        }else if(S_ISDIR(path_stat.st_mode)){\n            return DTW_FOLDER_TYPE;\n        }\n    }\n    return DTW_NOT_FOUND;\n\n}\n\n\nint dtw_complex_entity_type(const char *path){\n    int entity = dtw_entity_type(path);\n    if(entity != DTW_FILE_TYPE){\n        return entity;\n    }\n    long size;\n    bool is_binary;\n    char *data = (char*)dtw_load_any_content(path,&size,&is_binary);\n    if(is_binary){\n        free(data);\n        return DTW_COMPLEX_BINARY;\n    }\n\n    if(\n       strcmp(data,\"t\") == 0 ||\n       strcmp(data,\"f\") == 0 ||\n       strcmp(data,\"true\") == 0 ||\n       strcmp(data,\"false\") == 0\n       ){\n        free(data);\n        return DTW_COMPLEX_BOOL_TYPE;\n    }\n\n    \n    double value;\n    int result = sscanf(data,\"%lf\",&value);\n    if(result == 0){\n        free(data);\n        return DTW_COMPLEX_STRING_TYPE;\n    }\n    for(int i = 0; i < size; i++){\n        char current = data[i];\n        if(current == '.'){\n            free(data);\n            return DTW_COMPLEX_DOUBLE_TYPE;\n        }\n    }\n    free(data);\n    return DTW_COMPLEX_LONG_TYPE;\n}\n\nlong dtw_get_total_itens_of_dir(const char *path){\n\n    #ifdef __linux__\n\n        DIR *dir = opendir(path);\n        if (dir == NULL) {\n        return -1;\n        }\n        int i = 0;\n        while ((readdir(dir)) != NULL){\n            i++;\n        }\n        closedir(dir);\n        return i -2;\n    #else \n        WIN32_FIND_DATA findFileData;\n            HANDLE hFind = FindFirstFile(path, &findFileData);\n\n            if (hFind == INVALID_HANDLE_VALUE) {\n                return -1;\n            }\n\n            int i = 0;\n            do {\n                if (!(findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {\n                    i++;\n                }\n            } while (FindNextFile(hFind, &findFileData) != 0);\n\n            FindClose(hFind);\n            return i;\n    \n    #endif \n}\n\nconst char *dtw_convert_entity(int entity_type){\n    if(entity_type == DTW_FILE_TYPE){\n        return \"file\";\n    }\n    if(entity_type == DTW_FOLDER_TYPE){\n        return \"folder\";\n    }\n    if(entity_type == DTW_NOT_FOUND){\n        return \"null\";\n    }\n    if(entity_type == DTW_COMPLEX_BINARY){\n        return \"binary\";\n    }\n    if(entity_type == DTW_COMPLEX_STRING_TYPE){\n        return \"string\";\n    }\n    if(entity_type == DTW_COMPLEX_BOOL_TYPE){\n        return \"bool\";\n    }\n    if(entity_type == DTW_COMPLEX_LONG_TYPE){\n        return \"long\";\n    }\n    if(entity_type == DTW_COMPLEX_DOUBLE_TYPE){\n        return \"double\";\n    }\n    return \"invalid\";\n}   \n\nbool dtw_copy_any(const char* src_path,const  char* dest_path,bool merge) {\n\n    //verify if is an file\n    int type = dtw_entity_type(src_path);\n    if(type == DTW_NOT_FOUND){\n        return false;\n    }\n\n    if(type == DTW_FILE_TYPE){\n    \n        long size;\n        bool is_binary;\n        unsigned char *content = dtw_load_any_content(src_path,&size,&is_binary);\n        bool result =  dtw_write_any_content(dest_path,content,size);\n        free(content);\n        return result;\n    }\n    //means is an directory\n\n    //remove the previous directory if merge is false\n    if(!merge){\n        dtw_remove_any(dest_path);\n    }\n    //creating dirs\n    struct DtwStringArray *dirs = dtw_list_dirs_recursively(src_path,DTW_CONCAT_PATH);\n    \n    int size = dirs->size;\n    int src_path_size = strlen(src_path);\n\n    for(int i = 0; i < size; i++){        \n        char *new_path_dir = private_dtw_change_beginning_of_string(dirs->strings[i],src_path_size,dest_path);\n        dtw_create_dir_recursively(new_path_dir);\n        free(new_path_dir);\n    }\n    DtwStringArray_free(dirs);\n\n\n    struct DtwStringArray *files = dtw_list_files_recursively(src_path,DTW_CONCAT_PATH);\n   \n    for(int i = 0; i < files->size; i++){\n        long file_size;\n        bool is_binary;\n        unsigned char *content = dtw_load_any_content(files->strings[i],&file_size,&is_binary);\n        char *new_path = private_dtw_change_beginning_of_string(files->strings[i],src_path_size,dest_path);\n\n        dtw_write_any_content(new_path,content,file_size);\n        free(content);\n        free(new_path);\n\n       \n    }\n\n    DtwStringArray_free(files);\n    \n    return true;\n    \n}\n\nbool dtw_move_any(const char* src_path, const char* dest_path,bool merge) {\n    bool result = dtw_copy_any(src_path,dest_path,merge);\n    dtw_remove_any(src_path);\n    return result;\n}\n"
	}, {
		"path":	"src/dependencies/doTheWorld/io/io.h",
		"is_binary":	false,
		"content":	"\n#define DTW_FILE_TYPE 1\n#define DTW_FOLDER_TYPE 2\n#define DTW_ALL_TYPE 3\n#define DTW_NOT_FOUND -1\n\n#define DTW_COMPLEX_BINARY 10\n#define DTW_COMPLEX_STRING_TYPE 11\n#define DTW_COMPLEX_LONG_TYPE 12\n#define DTW_COMPLEX_DOUBLE_TYPE 13\n#define DTW_COMPLEX_BOOL_TYPE 14\n\n#define DTW_MERGE true\n\n\n#define DTW_NOT_MERGE false\n#ifdef __linux__\n#define dtw_create_dir(path) mkdir(path,0777)\n#elif _WIN32\n#define dtw_create_dir(path) _mkdir(path)\n#endif\n\nvoid dtw_create_dir_recursively(const char *path);\n\nbool dtw_remove_any(const char* path);\n\nchar *dtw_get_current_dir();\n\nlong dtw_get_total_itens_of_dir(const char *path);\n\nunsigned char *dtw_load_any_content(const char * path,long *size,bool *is_binary);\n\nchar *dtw_load_string_file_content(const char * path);\n\nunsigned char *dtw_load_binary_content(const char * path,long *size);\n\n\nbool dtw_write_any_content(const char *path,unsigned  char *content,long size);\nbool dtw_write_string_file_content(const char *path,const char *content);\n\n\n\nint dtw_entity_type(const char *path);\n\n\n\nint dtw_complex_entity_type(const char *path);\n\nconst char *dtw_convert_entity(int entity_type);\n\n\nbool dtw_copy_any(const char* src_path,const  char* dest_path,bool merge);\n\n\n\nbool dtw_move_any(const char* src_path, const char* dest_path,bool merge);"
	}, {
		"path":	"src/dependencies/doTheWorld/listage_wrappers/"
	}, {
		"path":	"src/dependencies/doTheWorld/listage_wrappers/listage_wrappers.c",
		"is_binary":	false,
		"content":	"\n\n DtwStringArray * dtw_list_files(const char *path, bool concat_path){\n    return dtw_list_basic(path,  DTW_FILE_TYPE, concat_path);\n}\n\n DtwStringArray * dtw_list_dirs(const char *path, bool concat_path){\n    return dtw_list_basic(path,DTW_FOLDER_TYPE, concat_path);\n}\n\n DtwStringArray *  dtw_list_all(const char *path,  bool concat_path){\n    return dtw_list_basic(path, DTW_ALL_TYPE, concat_path);\n}\n"
	}, {
		"path":	"src/dependencies/doTheWorld/listage_wrappers/listage_wrappers.h",
		"is_binary":	false,
		"content":	"#define DTW_CONCAT_PATH true\n#define DTW_NOT_CONCAT_PATH false\n\n\n DtwStringArray * dtw_list_files(const char *path, bool concat_path);\nDtwStringArray * dtw_list_dirs(const char *path, bool concat_path);\n\nDtwStringArray *  dtw_list_all(const char *path,  bool concat_path);"
	}, {
		"path":	"src/dependencies/doTheWorld/lockers/"
	}, {
		"path":	"src/dependencies/doTheWorld/lockers/declaration.h",
		"is_binary":	false,
		"content":	"#include \"multifile_locker/multifile_locker.h\"\n#ifdef __linux__\n#include \"flock_locker/declaration.h\"\n#endif\n#include \"locker/locker.h\""
	}, {
		"path":	"src/dependencies/doTheWorld/lockers/definition.c",
		"is_binary":	false,
		"content":	"\n#include \"multifile_locker/multifile_locker.c\"\n#ifdef __linux__\n    #include \"flock_locker/definition.c\"\n#endif\n\n#include \"locker/locker.c\""
	}, {
		"path":	"src/dependencies/doTheWorld/lockers/flock_locker/"
	}, {
		"path":	"src/dependencies/doTheWorld/lockers/flock_locker/declaration.h",
		"is_binary":	false,
		"content":	"#include \"flockarray/declaration.h\"\n#include \"flock_locker/flock_locker.h\""
	}, {
		"path":	"src/dependencies/doTheWorld/lockers/flock_locker/definition.c",
		"is_binary":	false,
		"content":	"#include \"flockarray/definition.c\"\n#include \"flock_locker/flock_locker.c\""
	}, {
		"path":	"src/dependencies/doTheWorld/lockers/flock_locker/flock_locker/"
	}, {
		"path":	"src/dependencies/doTheWorld/lockers/flock_locker/flock_locker/flock_locker.c",
		"is_binary":	false,
		"content":	"\nDtwFlockLocker * newFlockLocker(){\n\n    DtwFlockLocker *self = (DtwFlockLocker*) malloc(sizeof (DtwFlockLocker));\n    *self  = (DtwFlockLocker){0};\n    self->locked_files = private_new_privateFlockArray();\n    self->temp_folder = \"/tmp/\";\n\n    return self;\n}\nint  DtwFlockLocker_lock(DtwFlockLocker *self, const char *filename) {\n    if (privateDtwFlockArray_index_of(self->locked_files, filename) != -1) {\n        return DTW_LOCKER_LOCKED;\n    }\n\n    char *file_sha = dtw_generate_sha_from_string(filename);\n    const char *EXTENSION = \"lock\";\n    char *formatted = (char *) malloc(\n            strlen(file_sha) +\n            strlen(self->temp_folder) +\n            strlen(EXTENSION) +\n            3\n    );\n    sprintf(formatted, \"%s/%s.%s\", self->temp_folder, file_sha, EXTENSION);\n\n    free(file_sha);\n    int fd = open(formatted, O_RDWR | O_CREAT, 0644);\n    free(formatted);\n    if (fd == -1) {\n        return DTW_LOCKER_IMPOSSIBLE_TO_CREATE_FILE_DESCRIPTOR;\n    }\n    if (flock(fd, LOCK_EX) == -1) {\n        close(fd);\n        return DTW_LOCKER_FLCTL_FAIL;\n    }\n    privateDtwFlockArray_append(self->locked_files, filename, fd);\n    return  DTW_LOCKER_LOCKED;\n}\n\nvoid private_FlockLocker_unlock_by_index(DtwFlockLocker *self, int index){\n    privateDtwFlockLockedElement  *element = self->locked_files->elements[index];\n    flock(element->file_descriptor, LOCK_UN);\n    close(element->file_descriptor);\n}\nvoid DtwFlockLocker_unlock(DtwFlockLocker *self, const char *filename){\n    int index = privateDtwFlockArray_index_of(self->locked_files, filename);\n    if(index == -1){\n        return;\n    }\n    private_FlockLocker_unlock_by_index(self,index);\n}\nvoid  DtwFlockLocker_represent(DtwFlockLocker *self){\n    privateDtwFlockArray_represent(self->locked_files);\n}\nvoid  DtwFlockLocker_free(DtwFlockLocker *self){\n    for(int i = 0 ; i < self->locked_files->size; i++){\n        private_FlockLocker_unlock_by_index(self,i);\n    }\n    privateDtwFlockArray_free(self->locked_files);\n    free(self);\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/lockers/flock_locker/flock_locker/flock_locker.h",
		"is_binary":	false,
		"content":	"\ntypedef struct {\n   const char *temp_folder;\n   privateDtwFlockArray  *locked_files;\n}DtwFlockLocker;\n\nDtwFlockLocker * newFlockLocker();\n\nvoid private_FlockLocker_unlock_by_index(DtwFlockLocker *self, int index);\n\nvoid DtwFlockLocker_unlock(DtwFlockLocker *self, const char *filename);\n\nint DtwFlockLocker_lock(DtwFlockLocker *self, const char *filename);\n\nvoid  DtwFlockLocker_represent(DtwFlockLocker *self);\n\nvoid  DtwFlockLocker_free(DtwFlockLocker *self);"
	}, {
		"path":	"src/dependencies/doTheWorld/lockers/flock_locker/flockarray/"
	}, {
		"path":	"src/dependencies/doTheWorld/lockers/flock_locker/flockarray/declaration.h",
		"is_binary":	false,
		"content":	"#include \"flock_locked_element/flock_locked_element.h\"\n#include \"flock_array/flock_array.h\"\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/lockers/flock_locker/flockarray/definition.c",
		"is_binary":	false,
		"content":	"#include \"flock_locked_element/flock_locked_element.c\"\n#include \"flock_array/flock_array.c\""
	}, {
		"path":	"src/dependencies/doTheWorld/lockers/flock_locker/flockarray/flock_array/"
	}, {
		"path":	"src/dependencies/doTheWorld/lockers/flock_locker/flockarray/flock_array/flock_array.c",
		"is_binary":	false,
		"content":	"\nprivateDtwFlockArray * private_new_privateFlockArray(){\n    privateDtwFlockArray * self = (privateDtwFlockArray*) malloc(sizeof (privateDtwFlockArray));\n    self->elements = (privateDtwFlockLockedElement **) malloc(0);\n    self->size = 0;\n    return self;\n}\n\n\nint  privateDtwFlockArray_index_of(privateDtwFlockArray *self, const char *filename){\n    for(int i = 0 ; i <self->size;i++){\n        privateDtwFlockLockedElement  *current = self->elements[i];\n        if(strcmp(current->filename,filename) ==0){\n            return  i;\n        }\n    }\n    return  -1;\n}\nvoid privateDtwFlockArray_append(privateDtwFlockArray *self, const char *filename, int file_descriptor){\n\n    self->elements = (privateDtwFlockLockedElement**) realloc(\n            self->elements,\n            sizeof(privateDtwFlockLockedElement**) * (self->size + 1)\n            );\n    privateDtwFlockLockedElement  *created = private_new_privateDtwFlockLockedElement(filename, file_descriptor);\n    self->elements[self->size] = created;\n    self->size+=1;\n}\n\nvoid privateDtwFlockArray_destroy_by_index(privateDtwFlockArray *self, int position){\n    if(position >= self->size){\n        return ;\n    }\n    privateDtwFlockLockedElement *finded = self->elements[position];\n    privateDtwFlockLockedElement_free(finded);\n    for(int i = position; i  < self->size-1; i++){\n        self->elements[i] = self->elements[i+1];\n    }\n    self->size-=1;\n}\n\n\nvoid privateDtwFlockArray_represent(privateDtwFlockArray *self){\n    for(int i = 0 ; i <self->size;i++){\n\n        privateDtwFlockLockedElement  *current = self->elements[i];\n        printf(\"=============================\\n\");\n        privateDtwFlockLockedElement_represent(current);\n    }\n}\n\nvoid privateDtwFlockArray_free(privateDtwFlockArray *self){\n    for(int i = 0 ; i <self->size;i++){\n        privateDtwFlockLockedElement  *current = self->elements[i];\n        privateDtwFlockLockedElement_free(current);\n    }\n    free(self->elements);\n    free(self);\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/lockers/flock_locker/flockarray/flock_array/flock_array.h",
		"is_binary":	false,
		"content":	"\n\n\ntypedef struct {\n    privateDtwFlockLockedElement **elements;\n    int size;\n}privateDtwFlockArray;\n\n\nprivateDtwFlockArray * private_new_privateFlockArray();\n\nint  privateDtwFlockArray_index_of(privateDtwFlockArray *self, const char *filename);\n\nvoid privateDtwFlockArray_append(privateDtwFlockArray *self, const char *filename, int file_descriptor);\n\nvoid privateDtwFlockArray_destroy_by_index(privateDtwFlockArray *self, int position);\n\nvoid privateDtwFlockArray_represent(privateDtwFlockArray *self);\n\nvoid privateDtwFlockArray_free(privateDtwFlockArray *self);"
	}, {
		"path":	"src/dependencies/doTheWorld/lockers/flock_locker/flockarray/flock_locked_element/"
	}, {
		"path":	"src/dependencies/doTheWorld/lockers/flock_locker/flockarray/flock_locked_element/flock_locked_element.c",
		"is_binary":	false,
		"content":	"\n\nprivateDtwFlockLockedElement * private_new_privateDtwFlockLockedElement(const char *filename, int file_descriptor){\n    privateDtwFlockLockedElement *self = (privateDtwFlockLockedElement*) malloc(sizeof (privateDtwFlockLockedElement));\n    self->filename = strdup(filename);\n    self->file_descriptor = file_descriptor;\n    return  self;\n}\n\nvoid privateDtwFlockLockedElement_represent(privateDtwFlockLockedElement *self){\n    printf(\"file: %s\\n\",self->filename);\n    printf(\"if: %d\\n\",self->file_descriptor);\n\n}\nvoid privateDtwFlockLockedElement_free(privateDtwFlockLockedElement *self){\n    free(self->filename);\n    free(self);\n\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/lockers/flock_locker/flockarray/flock_locked_element/flock_locked_element.h",
		"is_binary":	false,
		"content":	"\ntypedef struct {\n\n    char *filename;\n    int file_descriptor;\n\n\n}privateDtwFlockLockedElement;\n\nprivateDtwFlockLockedElement * private_new_privateDtwFlockLockedElement(const char *filename, int file_descriptor);\n\nvoid privateDtwFlockLockedElement_represent(privateDtwFlockLockedElement *self);\n\nvoid privateDtwFlockLockedElement_free(privateDtwFlockLockedElement *self);"
	}, {
		"path":	"src/dependencies/doTheWorld/lockers/locker/"
	}, {
		"path":	"src/dependencies/doTheWorld/lockers/locker/locker.c",
		"is_binary":	false,
		"content":	"\n\nDtwLocker *newDtwLocker(){\n\n    DtwLocker *self = (DtwLocker*)malloc(sizeof(DtwLocker));\n#ifdef __linux__\n    self->locker = newFlockLocker();\n#endif\n#ifdef _WIN32\n    self->locker = newDtwMultiFileLocker();\n#endif\n    return self;\n}\n\nint DtwLocker_lock(DtwLocker *self, const  char *element){\n\n#ifdef __linux__\n    return DtwFlockLocker_lock(self->locker,element);\n#endif\n#ifdef _WIN32\n    return DtwMultiFIleLocker_lock(self->locker,element);\n#endif\n    return  DTW_LOCKER_OS_NOT_PREDICTIBLE;\n}\n\nvoid DtwLocker_unlock(DtwLocker *self, const  char *element){\n\n#ifdef __linux__\n    DtwFlockLocker_unlock(self->locker,element);\n#endif\n    #ifdef _WIN32\n         DtwMultifileLocker_unlock(self->locker,element);\n    #endif\n}\n\nvoid DtwLocker_represemt(DtwLocker *self){\n\n#ifdef __linux__\n    DtwFlockLocker_represent(self->locker);\n#endif\n#ifdef _WIN32\n     DtwMultiFileLocker_represemt(self->locker);\n#endif\n}\n\nvoid DtwLocker_free(DtwLocker *self){\n\n#ifdef __linux__\n    DtwFlockLocker_free(self->locker);\n#endif\n\n#ifdef _WIN32\n     DtwMultiFileLocker_free(self->locker);\n#endif\n    free(self);\n}\n"
	}, {
		"path":	"src/dependencies/doTheWorld/lockers/locker/locker.h",
		"is_binary":	false,
		"content":	"\n#define DTW_LOCKER_LOCKED 0\n#define DTW_LOCKER_IMPOSSIBLE_TO_CREATE_FILE_DESCRIPTOR 5\n#define DTW_LOCKER_FLCTL_FAIL 6\n#define DTW_LOCKER_WAIT_ERROR 21\n#define DTW_LOCKER_OS_NOT_PREDICTIBLE -1\ntypedef struct {\n#ifdef __linux__\n    DtwFlockLocker *locker;\n#endif\n#ifdef _WIN32\n    DtwMultiFileLocker  *locker;\n#endif\n\n} DtwLocker;\n\n\nDtwLocker *newDtwLocker();\n\nint DtwLocker_lock(DtwLocker *self, const  char *element);\n\nvoid DtwLocker_unlock(DtwLocker *self, const  char *element);\n\nvoid DtwLocker_represemt(DtwLocker *self);\n\nvoid DtwLocker_free(DtwLocker *self);\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/lockers/multifile_locker/"
	}, {
		"path":	"src/dependencies/doTheWorld/lockers/multifile_locker/multifile_locker.c",
		"is_binary":	false,
		"content":	"\n\nDtwMultiFileLocker *newDtwMultiFileLocker(){\n    DtwMultiFileLocker *self = (DtwMultiFileLocker*) malloc(sizeof (DtwMultiFileLocker));\n\n    self->process = getpid();\n    self->total_checks = DTW_MULTIFILE_LOCKER_TOTAL_CHECK;\n    self->max_lock_time = DTW_MULTIFILE_LOCKER_MAX_TIMEOUT;\n    self->max_wait = DTW_MULFILE_LOCKER_MAX_WAIT;\n    self->locked_elements = newDtwStringArray();\n\n    return self;\n}\n\n\n\n\nint  DtwMultiFIleLocker_lock(DtwMultiFileLocker *self, const char *element) {\n\n    if(DtwStringArray_find_position(self->locked_elements,element) != -1){\n        return DTW_LOCKER_LOCKED;\n    }\n\n    const char *LOCK_FOLDER = \".lock\";\n    const int LOCK_FOLDER_SIZE = (int)strlen(LOCK_FOLDER);\n    char *file = (char*)malloc(strlen(element) +  LOCK_FOLDER_SIZE + 10);\n    sprintf(file,\"%s%s\",element,LOCK_FOLDER);\n    long started_time = time(NULL);\n\n    while (true){\n\n\n        long now = time(NULL);\n        if((now - started_time) > self->max_wait){\n            free(file);\n            return DTW_LOCKER_WAIT_ERROR;\n        }\n\n\n         bool write = false;\n         int entity_type = dtw_entity_type(file);\n         if(entity_type== DTW_NOT_FOUND){\n            write = true;\n         }\n\n         if(entity_type== DTW_FILE_TYPE){\n             long last_modification  = dtw_get_entity_last_motification_in_unix(file);\n             if ((now - self->max_lock_time) > last_modification ) {\n                 write = true;\n             }\n         }\n\n         if(entity_type == DTW_FOLDER_TYPE){\n             dtw_remove_any(file);\n             continue;\n         }\n\n\n         if(!write) {\n             continue;\n         }\n        dtw_write_long_file_content(file,self->process);\n        bool break_loop = true;\n         for(int i = 0;i < self->total_checks;i++){\n            long result = dtw_load_long_file_content(file);\n            if(result != self->process && result != -1){\n                break_loop = false;\n                break;\n            }\n        }\n\n        if(break_loop){\n            break;\n\n        }\n\n\n    }\n    DtwStringArray_append(self->locked_elements,element);\n    free(file);\n    return DTW_LOCKER_LOCKED;\n\n}\n\nvoid DtwMultifileLocker_unlock(DtwMultiFileLocker *self, const  char *element){\n    bool found = false;\n    for(long i = 0; i < self->locked_elements->size;i++){\n        if(strcmp(self->locked_elements->strings[i],element)==0){\n            found = true;\n            break;\n        }\n    }\n\n    if(!found){\n        return;\n    }\n\n\n    const char *LOCK_FOLDER = \".lock\";\n    const int LOCK_FOLDER_SIZE = (int)strlen(LOCK_FOLDER);\n    char *file = (char*)malloc(strlen(element) +  LOCK_FOLDER_SIZE + 10);\n    sprintf(file,\"%s%s\",element,LOCK_FOLDER);\n    dtw_remove_any(file);\n    free(file);\n}\n\n\nvoid DtwMultiFileLocker_represemt(DtwMultiFileLocker *self){\n    printf(\"locked:\\n\");\n    for(int i = 0 ; i < self->locked_elements->size;i++){\n        char *element = self->locked_elements->strings[i];\n        char *unformated = dtw_replace_string(element,\".lock\",\"\");\n        printf(\"\\t%s\\n\",unformated);\n        free(unformated);\n    }\n}\n\nvoid DtwMultiFileLocker_free(DtwMultiFileLocker *self){\n\n    for(int i = 0 ; i < self->locked_elements->size;i++){\n        char *element = self->locked_elements->strings[i];\n        DtwMultifileLocker_unlock(self, element);\n    }\n\n    DtwStringArray_free(self->locked_elements);\n    free(self);\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/lockers/multifile_locker/multifile_locker.h",
		"is_binary":	false,
		"content":	"#define DTW_MULTIFILE_LOCKER_TOTAL_CHECK 500\n#define DTW_MULTIFILE_LOCKER_MAX_TIMEOUT 10\n#define DTW_MULFILE_LOCKER_MAX_WAIT 10\n\n\ntypedef struct {\n\n   int total_checks;\n   int process;\n   int max_wait;\n   int max_lock_time;\n   DtwStringArray *locked_elements;\n\n\n}DtwMultiFileLocker;\n\n\nDtwMultiFileLocker *newDtwMultiFileLocker();\n\nint DtwMultiFIleLocker_lock(DtwMultiFileLocker *self, const  char *element);\n\nvoid DtwMultifileLocker_unlock(DtwMultiFileLocker *self, const  char *element);\n\nvoid DtwMultiFileLocker_represemt(DtwMultiFileLocker *self);\n\nvoid DtwMultiFileLocker_free(DtwMultiFileLocker *self);\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/monodimension_listage/"
	}, {
		"path":	"src/dependencies/doTheWorld/monodimension_listage/monodimension_listage.h",
		"is_binary":	false,
		"content":	"\n#ifdef __linux__\n\nbool private_dtw_verify_if_add(const int expected_type, int d_type);\nbool private_dtw_verify_if_skip(struct dirent *entry);\n\n#endif\n\n\n#ifdef _WIN32\n\nbool private_dtw_verify_if_add(const int expected_type, WIN32_FIND_DATAA entry);\nbool private_dtw_verify_if_skip(WIN32_FIND_DATAA *entry);\n#endif\n\n\n\nstruct DtwStringArray * dtw_list_basic(const char *path,int expected_type,bool concat_path);\n "
	}, {
		"path":	"src/dependencies/doTheWorld/monodimension_listage/monodimension_listage_linux.c",
		"is_binary":	false,
		"content":	"\n\n#ifdef __linux__\n\nbool private_dtw_verify_if_add(const int expected_type, int d_type){\n    if (expected_type == DTW_FILE_TYPE  && d_type == DT_REG) {\n        return true;\n    }\n\n    if (expected_type == DTW_FOLDER_TYPE && d_type == DT_DIR) {\n        return true;\n    }\n\n    if (expected_type == DTW_ALL_TYPE) {\n      \n        return true;\n    }\n    return false;\n}\nbool private_dtw_verify_if_skip(struct dirent *entry){\n        if (strcmp(entry->d_name, \".\") == 0 || strcmp(entry->d_name, \"..\") == 0) {\n            return true;\n        }\n        return false;\n}\n\nstruct DtwStringArray * dtw_list_basic(const char *path,int expected_type,bool concat_path){\n\n    DIR *dir;\n    struct dirent *entry;\n\n    //array of directories\n    struct DtwStringArray *dirs = newDtwStringArray();\n    int i = 0;\n\n    //means that the directory is not found\n    if ((dir = opendir(path)) == NULL) {\n        return dirs;\n    }\n\n    //reads the directory and adds the directories to the array\n    while ((entry = readdir(dir)) != NULL) {\n        //means is not a directory\n        if (private_dtw_verify_if_skip(entry)){\n            continue;\n        }\n    \n        if (private_dtw_verify_if_add(expected_type,entry->d_type)) {\n            \n            \n            if(concat_path){\n                //allocates memory for the directory\n                char *generated_dir = (char*)malloc(strlen(path) + strlen(entry->d_name) + 2);\n                if(path[strlen(path) - 1] == '/'){\n                    sprintf(generated_dir, \"%s%s\", path, entry->d_name);\n                }\n                else{\n                    sprintf(generated_dir, \"%s/%s\", path, entry->d_name);\n                }\n\n                DtwStringArray_append(dirs, generated_dir);\n                free(generated_dir);\n            }\n            else{\n                DtwStringArray_append(dirs, entry->d_name);\n                \n            }\n\n            i++;\n        }\n    }\n\n    if(expected_type == DTW_FOLDER_TYPE){\n        private_dtw_add_end_bar_to_dirs_string_array(dirs);   \n    }\n    closedir(dir);\n\n    return dirs;\n}\n\n#endif"
	}, {
		"path":	"src/dependencies/doTheWorld/monodimension_listage/monodimension_listage_win32.c",
		"is_binary":	false,
		"content":	"\n#ifdef _WIN32\n\n\nbool private_dtw_verify_if_add(const int expected_type, WIN32_FIND_DATAA entry){\n    #define WIN32_FILETYPE 32\n\n    if (expected_type == DTW_FILE_TYPE && entry.dwFileAttributes == WIN32_FILETYPE) {\n        return true;\n    }\n\n    if (expected_type == DTW_FOLDER_TYPE && entry.dwFileAttributes != WIN32_FILETYPE){\n        return true;\n    }\n\n    if (expected_type == DTW_ALL_TYPE) {\n        return true;\n    }\n    \n    return false;\n}\n\nbool private_dtw_verify_if_skip(WIN32_FIND_DATAA *entry){\n    if (strcmp(entry->cFileName, \".\") == 0 || strcmp(entry->cFileName, \"..\") == 0) {\n        return true;\n    }\n    return false;\n}\n\nstruct DtwStringArray *  dtw_list_basic(const char *path,int expected_type,bool concat_path){\n\n    WIN32_FIND_DATAA file_data;\n    HANDLE file_handle;\n    char search_path[MAX_PATH];\n\n    //array of directories\n    struct DtwStringArray *dirs = newDtwStringArray();\n    int i = 0;\n\n    // build the search path string\n    snprintf(search_path, MAX_PATH, \"%s\\\\*\", path);\n\n    // try to open the directory\n    if ((file_handle = FindFirstFileA(search_path, &file_data)) == INVALID_HANDLE_VALUE) {\n        return dirs;\n    }\n\n    do {\n        // skip \".\" and \"..\" directories\n        if (private_dtw_verify_if_skip(&file_data)){\n            continue;\n        }\n\n        // verify if it's a file or directory\n        if (private_dtw_verify_if_add(expected_type, file_data)) {\n            \n            if(concat_path){\n                // allocate memory for the directory\n                if(path[strlen(path) - 1] == '\\\\' || path[strlen(path) - 1] == '/'){\n                    char *generated_dir = (char*)malloc(strlen(path) + strlen(file_data.cFileName) + 1);\n                    sprintf(generated_dir, \"%s%s\", path, file_data.cFileName);\n                    DtwStringArray_append(dirs, generated_dir);\n                    free(generated_dir);\n                }\n                else{\n                    char *generated_dir = (char*)malloc(strlen(path) + strlen(file_data.cFileName) + 2);\n                    \n\n                    sprintf(generated_dir, \"%s/%s\", path, file_data.cFileName);\n                   \n                    DtwStringArray_append(dirs, generated_dir);\n                    free(generated_dir);\n                }\n                \n    \n            }\n            else{\n                DtwStringArray_append(dirs, file_data.cFileName);\n            \n            }\n\n            i++;\n        }\n    } while (FindNextFileA(file_handle, &file_data) != 0);\n\n        if(expected_type == DTW_FOLDER_TYPE){\n            private_dtw_add_end_bar_to_dirs_string_array(dirs);   \n        }\n    \n    FindClose(file_handle);\n\n    return dirs;\n}\n#endif"
	}, {
		"path":	"src/dependencies/doTheWorld/multidimension_listage/"
	}, {
		"path":	"src/dependencies/doTheWorld/multidimension_listage/multidimension_listage.c",
		"is_binary":	false,
		"content":	"\n DtwStringArray * dtw_list_dirs_recursively(const char *path,bool concat_path){\n\n        struct  DtwStringArray *dirs  = newDtwStringArray();\n        //verify if the path is a directory\n    \n        int entity_type = dtw_entity_type(path);\n        if(entity_type != DTW_FOLDER_TYPE){\n                return dirs;\n        }\n      \n        \n        DtwStringArray_append(dirs, (char*)path);\n\n        private_dtw_add_end_bar_to_dirs_string_array(dirs);\n        int i = 0;\n        //The size of dirs will increase til it reaches the end of the array\n        while(i < dirs->size){                \n                struct DtwStringArray *sub_dirs = dtw_list_basic(\n                    dirs->strings[i],\n                    DTW_FOLDER_TYPE,\n                    true\n                    );\n                //merge the two dirs\n            DtwStringArray_merge(dirs, sub_dirs);\n                DtwStringArray_free(sub_dirs);\n                i++;\n               \n        }\n        //unsifth path in dirs \n     private_dtw_remove_double_bars_from_string_array(dirs);\n\n        if(!concat_path){\n\n            struct DtwStringArray *removed =  private_dtw_remove_start_path(dirs,path);\n            DtwStringArray_free(dirs);\n            return removed;\n        }\n        return dirs;\n}\n\n\n\n DtwStringArray *  dtw_list_files_recursively(const char *path,bool concat_path){\n    \n    struct DtwStringArray *dirs = dtw_list_dirs_recursively(path,DTW_CONCAT_PATH);\n    \n    struct  DtwStringArray *files = newDtwStringArray();\n    for(int i = 0; i < dirs->size; i++){\n        struct DtwStringArray *sub_files = dtw_list_basic(dirs->strings[i],DTW_FILE_TYPE,DTW_CONCAT_PATH);\n        DtwStringArray_merge(files, sub_files);\n        DtwStringArray_free(sub_files);\n    }\n\n    DtwStringArray_free(dirs);\n\n    if(!concat_path){\n\n        struct DtwStringArray *removed =  private_dtw_remove_start_path(files,path);\n        DtwStringArray_free(files);\n        return removed;\n    }\n\n    return files;\n}\n\n\n DtwStringArray * dtw_list_all_recursively(const char *path,bool concat_path){\n\n    struct DtwStringArray *dirs = dtw_list_dirs_recursively(path,DTW_CONCAT_PATH);\n    \n    struct DtwStringArray *all = newDtwStringArray();\n    \n    for(int i = 0; i < dirs->size; i++){\n\n        if(!dtw_ends_with(dirs->strings[i], \"/\") || !dtw_ends_with(dirs->strings[i], \"\\\\\") ){\n\n            char *formated_dir =  (char*)malloc(strlen(dirs->strings[i]) + 2);\n            sprintf(formated_dir,\"%s/\",dirs->strings[i]);\n            DtwStringArray_append(all, formated_dir);\n            free(formated_dir);\n        }\n\n        else{\n            DtwStringArray_append(all, dirs->strings[i]);\n        }\n\n        struct DtwStringArray *sub_files = dtw_list_basic(dirs->strings[i],DTW_FILE_TYPE,true);\n        DtwStringArray_merge(all,sub_files);\n        DtwStringArray_free(sub_files);\n    }\n    DtwStringArray_free(dirs);\n     private_dtw_remove_double_bars_from_string_array(all);\n    if(!concat_path){\n\n        struct DtwStringArray *removed =  private_dtw_remove_start_path(all,path);\n        DtwStringArray_free(all);\n        return removed;\n    }\n    return all;\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/multidimension_listage/multidimension_listage.h",
		"is_binary":	false,
		"content":	"\n DtwStringArray * dtw_list_dirs_recursively(const char *path,bool concat_path);\n\n\n DtwStringArray *  dtw_list_files_recursively(const char *path,bool concat_path);\n\n\n DtwStringArray * dtw_list_all_recursively(const char *path,bool concat_path);\n"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/database_schema_module/"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/database_schema_module/database_schema_module.c",
		"is_binary":	false,
		"content":	"\n\nDtwDatabaseSchemaModule newDtwDatabaseSchemaModule(){\n    DtwDatabaseSchemaModule  self = {0};\n    self.sub_schema = DtwDtatabaseSchema_new_subSchema;\n    return  self;\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/database_schema_module/database_schema_module.h",
		"is_binary":	false,
		"content":	"\ntypedef struct {\n    DtwSchema * (*sub_schema)(DtwDatabaseSchema *self,const char *name);\n}DtwDatabaseSchemaModule;\n\nDtwDatabaseSchemaModule newDtwDatabaseSchemaModule();"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/declaration.h",
		"is_binary":	false,
		"content":	"#include \"randonizer_module/randonizer_module.h\"\n#include \"path_module/path_module.h\"\n#include \"string_array_module/string_array_module.h\"\n#include \"tree_module/declaration.h\"\n#include \"locker/locker.h\"\n#include \"transaction_module/declaration.h\"\n#include \"resource_module/declaration.h\"\n#include \"hash_module/hash_module.h\"\n#include \"schema_module/schema_module.h\"\n#include \"database_schema_module/database_schema_module.h\"\n#include \"namespace/namespace.h\"\n"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/definition.c",
		"is_binary":	false,
		"content":	"#include \"randonizer_module/randonizer_module.c\"\n#include \"path_module/path_module.c\"\n#include \"string_array_module/string_array_module.c\"\n#include \"tree_module/definition.c\"\n#include \"locker/locker.c\"\n#include \"transaction_module/definition.c\"\n#include \"resource_module/definition.c\"\n#include \"hash_module/hash_module.c\"\n#include \"schema_module/schema_module.c\"\n#include \"database_schema_module/database_schema_module.c\"\n#include \"namespace/namespace.c\""
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/hash_module/"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/hash_module/hash_module.c",
		"is_binary":	false,
		"content":	"\n\nDtwHashModule newDtwHashModule(){\n    DtwHashModule self = {0};\n    self.newHash =newDtwHash;\n    self.digest_any = DtwHash_digest_any;\n    self.digest_string = DtwHash_digest_string;\n    self.digest_long = DtwHash_digest_long;\n    self.digest_double = DtwHash_digest_double;\n    self.digest_bool = DtwHash_digest_bool;\n    self.digest_file = DtwHash_digest_file;\n    self.digest_entity_last_modification =DtwHash_digest_entity_last_modification;\n    self.digest_string_array = DtwHash_digest_string_array;\n    self.digest_string_array_last_modifications = DtwHash_digest_string_array_last_modifications;\n    self.digest_string_array_last_modifications_adding_name = DtwHash_digest_string_array_last_modifications_adding_name;\n    self.digest_string_array_content = DtwHash_digest_string_array_content;\n    self.digest_string_array_content_adding_name = DtwHash_digest_string_array_content_adding_name;\n    self.digest_folder_by_last_modification = DtwHash_digest_folder_by_last_modification;\n    self.digest_folder_by_content = DtwHash_digest_folder_by_content;\n    self.free = DtwHash_free;\n    return self;\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/hash_module/hash_module.h",
		"is_binary":	false,
		"content":	"\ntypedef struct DtwHashModule{\n    DtwHash * (*newHash)();\n    bool  (*digest_any)(DtwHash *self,unsigned char *content,long size);\n    bool (*digest_string)(DtwHash * self, const char *content);\n    void (*digest_long)(DtwHash * self,long content);\n    void (*digest_double)(DtwHash * self,double content);\n    void (*digest_bool)(DtwHash * self,bool content);\n    bool  (*digest_file)(DtwHash * self, const char *path);\n    bool  (*digest_entity_last_modification)(DtwHash * self, const char *path);\n    bool (*digest_string_array)(DtwHash *self,DtwStringArray *element);\n    bool (*digest_string_array_last_modifications)(DtwHash *self,DtwStringArray *element);\n    bool (*digest_string_array_last_modifications_adding_name)(DtwHash *self,DtwStringArray *element);\n    bool (*digest_string_array_content)(DtwHash *self,DtwStringArray *element);\n    bool (*digest_string_array_content_adding_name)(DtwHash *self,DtwStringArray *element);\n    bool (*digest_folder_by_last_modification)(DtwHash *self,const char *path);\n    bool (*digest_folder_by_content)(DtwHash *self,const char *path);\n    void  (*free)(DtwHash *self);\n\n}DtwHashModule;\n\nDtwHashModule newDtwHashModule();"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/locker/"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/locker/locker.c",
		"is_binary":	false,
		"content":	"\nDtwLockerModule newDtwLockerModule(){\n    DtwLockerModule  self = {0};\n    self.newLocker = newDtwLocker;\n    self.lock = DtwLocker_lock;\n    self.unlock = DtwLocker_unlock;\n    self.represemt = DtwLocker_represemt;\n    self.free = DtwLocker_free;\n    return self;\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/locker/locker.h",
		"is_binary":	false,
		"content":	"\n\ntypedef struct DtwLockerModule{\n    DtwLocker * (*newLocker)();\n    int (*lock)(DtwLocker *self, const  char *element);\n    void (*unlock)(DtwLocker *self, const  char *element);\n    void (*represemt)(DtwLocker *self);\n    void (*free)(DtwLocker *self);\n\n}DtwLockerModule;\n\nDtwLockerModule newDtwLockerModule();"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/namespace/"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/namespace/namespace.c",
		"is_binary":	false,
		"content":	"\nDtwNamespace newDtwNamespace(){\n    DtwNamespace self = {0};\n    //io\n    self.create_dir_recursively = dtw_create_dir_recursively;\n    self.remove_any = dtw_remove_any;\n    self.get_current_dir = dtw_get_current_dir;\n    self.load_any_content = dtw_load_any_content;\n    self.load_string_file_content = dtw_load_string_file_content;\n    self.load_binary_content = dtw_load_binary_content;\n    self.write_any_content = dtw_write_any_content;\n    self.write_string_file_content =dtw_write_string_file_content;\n    self.entity_type = dtw_entity_type;\n    self.complex_entity_type = dtw_complex_entity_type;\n    self.convert_entity  = dtw_convert_entity;\n    self.copy_any = dtw_copy_any;\n    self.move_any = dtw_move_any;\n    //numeral io\n    self.load_long_file_content = dtw_load_long_file_content;\n    self.load_double_file_content =  dtw_load_double_file_content;\n    self.load_bool_file_content = dtw_load_bool_file_content;\n\n    self.write_long_file_content = dtw_write_long_file_content;\n    self.write_double_file_content = dtw_write_double_file_content;\n    self.write_bool_file_content = dtw_write_bool_file_content;\n\n    //listage\n    self.list_files = dtw_list_files;\n    self.list_dirs = dtw_list_dirs;\n    self.list_all = dtw_list_all;\n\n    self.list_files_recursively = dtw_list_files_recursively;\n    self.list_dirs_recursively = dtw_list_dirs_recursively;\n    self.list_all_recursively = dtw_list_all_recursively;\n\n    //extras\n    self.generate_sha_from_file = dtw_generate_sha_from_file;\n    self.generate_sha_from_string = dtw_generate_sha_from_string;\n    self.generate_sha_from_any = dtw_generate_sha_from_any;\n    self.get_entity_last_motification_in_unix = dtw_get_entity_last_motification_in_unix;\n    self.get_entity_last_motification_in_string = dtw_get_entity_last_motification_in_string;\n    self.concat_path = dtw_concat_path;\n    //bas64\n    self.base64_encode = dtw_base64_encode;\n    self.base64_decode  = dtw_base64_decode;\n    self.convert_binary_file_to_base64 = dtw_convert_binary_file_to_base64;\n\n    self.string_array = newDtwStringArrayModule();\n    self.path = newDtwPathModule();\n    self.locker = newDtwLockerModule();\n    \n    self.schema = newDtwSchemaModule();\n    self.database_schema = newDtwDatabaseSchemaModule();\n    self.tree = newDtwTreeModule();\n    self.hash = newDtwHashModule();\n    self.transaction = newDtwTransactionModule();\n    self.resource = newDtwResourceModule();\n    self.randonizer = newDtwRandonizerModule();\n\n    return self;\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/namespace/namespace.h",
		"is_binary":	false,
		"content":	"\ntypedef struct DtwNamespace{\n    //IO\n    void (*create_dir_recursively)(const char *path);\n\n    bool (*remove_any)(const char* path);\n\n    char *(*get_current_dir)();\n\n    unsigned char *(*load_any_content)(const char * path,long *size,bool *is_binary);\n\n    char *(*load_string_file_content)(const char * path);\n\n    unsigned char *(*load_binary_content)(const char * path,long *size);\n    \n    bool (*write_any_content)(const char *path,unsigned  char *content,long size);\n\n    bool (*write_string_file_content)(const char *path,const char *content);\n\n    int (*entity_type)(const char *path);\n\n    int (*complex_entity_type)(const char *path);\n\n    const char *(*convert_entity)(int entity_type);\n\n    bool (*copy_any)(const char* src_path,const  char* dest_path,bool merge);\n\n    bool (*move_any)(const char* src_path, const char* dest_path,bool merge);\n\n    //numeral io\n\n    long (*load_long_file_content)(const char * path);\n\n    double (*load_double_file_content)(const char * path);\n\n    bool (*load_bool_file_content)(const char * path);\n\n\n\n    void (*write_long_file_content)(const char *path, long value);\n\n    void (*write_bool_file_content)(const char *path, bool value);\n\n    void (*write_double_file_content)(const char *path,double value);\n\n\n\n    //listage\n\n    DtwStringArray * (*list_files)(const char *path, bool concat_path);\n    DtwStringArray * (*list_dirs)(const char *path, bool concat_path);\n\n    DtwStringArray *  (*list_all)(const char *path,  bool concat_path);\n    DtwStringArray * (*list_dirs_recursively)(const char *path,bool concat_path);\n    DtwStringArray *  (*list_files_recursively)(const char *path,bool concat_path);\n    DtwStringArray * (*list_all_recursively)(const char *path,bool concat_path);\n\n\n    //extras\n\n    char * (*generate_sha_from_file)(const char *path);\n\n    char * (*generate_sha_from_string)(const char *string);\n\n    char * (*generate_sha_from_any)(void *anything , long size);\n\n    long int (*get_entity_last_motification_in_unix)(const char *path);\n\n    char * (*convert_unix_time_to_string)(long int unix_time);\n\n    char * (*get_entity_last_motification_in_string)(const char *path);\n\n    char *(*concat_path)(const char *path1, const char *path2);\n\n\n    //base64\n\n    char *(*base64_encode)(unsigned char *data, long input_length);\n\n    unsigned char *(*base64_decode)(const char *data, long *output_length);\n\n    char *(*convert_binary_file_to_base64)(const char *path);\n    //string array\n\n    DtwStringArrayModule string_array;\n\n    DtwPathModule path;\n\n    DtwLockerModule locker;\n\n    DtwSchemaModule schema;\n    DtwDatabaseSchemaModule database_schema;\n    DtwTreeModule tree;\n    DtwHashModule  hash;\n    DtwTransactionModule transaction;\n\n    DtwResourceModule resource;\n    DtwRandonizerModule randonizer;\n\n}DtwNamespace;\n\nDtwNamespace newDtwNamespace();"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/path_module/"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/path_module/path_module.c",
		"is_binary":	false,
		"content":	"\nDtwPathModule newDtwPathModule(){\n    DtwPathModule  self = {0};\n    self.newPath = newDtwPath;\n    self.changed =DtwPath_changed;\n    self.get_full_name = DtwPath_get_full_name;\n    self.get_name = DtwPath_get_name;\n    self.get_extension = DtwPath_get_extension;\n    self.get_path = DtwPath_get_path;\n    self.get_dir = DtwPath_get_dir;\n    self.get_total_dirs = DtwPath_get_total_dirs;\n    self.get_sub_dirs_from_index = DtwPath_get_sub_dirs_from_index;\n    self.insert_dir_at_index = DtwPath_insert_dir_at_index;\n    self.remove_sub_dirs_at_index =  DtwPath_remove_sub_dirs_at_index;\n    self.insert_dir_after= DtwPath_insert_dir_after;\n    self.insert_dir_before = DtwPath_insert_dir_before;\n    self.replace_dirs = DtwPath_replace_dirs;\n    self.remove_sub_dirs_at = DtwPath_remove_sub_dirs_at;\n\n    self.set_extension = DtwPath_set_extension;\n    self.set_name = DtwPath_set_name;\n    self.set_dir = DtwPath_set_dir;\n    self.set_full_name =DtwPath_set_full_name;\n    self.set_path = DtwPath_set_path;\n\n    self.add_start_dir =DtwPath_add_start_dir;\n    self.add_end_dir = DtwPath_add_end_dir;\n    self.represent = DtwPath_represent;\n    self.free = DtwPath_free;\n\n    return self;\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/path_module/path_module.h",
		"is_binary":	false,
		"content":	"\n\ntypedef struct DtwPathModule{\n    //Getters\n\n    DtwPath * (*newPath)(const char *path);\n    bool  (*changed)(struct DtwPath *self);\n    char *(*get_full_name) (struct DtwPath *self);\n    char *(*get_name) (struct DtwPath *self);\n    char *(*get_extension) (struct DtwPath *self);\n\n    char *(*get_path) (struct DtwPath *self);\n    char *(*get_dir) (struct DtwPath *self);\n\n    int (*get_total_dirs)(DtwPath *self);\n    char *(*get_sub_dirs_from_index)(DtwPath *self, int start,int end);\n    void (*insert_dir_at_index)(DtwPath *self,int index,const char *dir);\n    void (*remove_sub_dirs_at_index)(DtwPath *self,int start,int end);\n    void (*insert_dir_after)(DtwPath *self,const char *str,const char *dir);\n    void (*insert_dir_before)(DtwPath *self,const char *str,const char *dir);\n    void (*replace_dirs)(DtwPath *self,const char *str,const char *dir);\n    void (*remove_sub_dirs_at)(DtwPath *self,const char *str);\n\n\n    //Setters\n    void (*set_extension) (struct DtwPath *self, const char *extension);\n    void (*set_name) (struct DtwPath *self, const char *name);\n    void (*set_dir) (struct DtwPath *self, const char *path);\n    void (*set_full_name) (struct DtwPath *self, const char *full_name);\n    void (*set_path) (struct DtwPath *self, const char *target_path);\n    \n    void (*add_start_dir)(struct DtwPath *self, const char *start_dir);\n    void (*add_end_dir)(struct DtwPath *self, const char *end_dir);\n\n    void (*represent)(struct DtwPath *self);\n    void (*free) (struct DtwPath *self);\n\n}DtwPathModule;\n\nDtwPathModule newDtwPathModule();"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/randonizer_module/"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/randonizer_module/randonizer_module.c",
		"is_binary":	false,
		"content":	"\n\nDtwRandonizerModule newDtwRandonizerModule(){\n    DtwRandonizerModule self = {0};\n    self.newRandonizer = newDtwRandonizer;\n    self.generate_num = DtwRandonizer_generate_num;\n    self.generate_token =DtwRandonizer_generate_token;\n    self.free = DtwRandonizer_free;\n    return self;\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/randonizer_module/randonizer_module.h",
		"is_binary":	false,
		"content":	"\ntypedef struct  DtwRandonizerModule{\n    DtwRandonizer * (*newRandonizer)();\n    int (*generate_num)(DtwRandonizer *self,int max);\n    char * (*generate_token)(DtwRandonizer*self, int size);\n    void (*free)(DtwRandonizer *self);\n}DtwRandonizerModule;\n\nDtwRandonizerModule newDtwRandonizerModule();"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/resource_module/"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/resource_module/declaration.h",
		"is_binary":	false,
		"content":	"#include \"resource_array_module/resource_array_module.h\"\n#include \"resource_module/resource_module.h\""
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/resource_module/definition.c",
		"is_binary":	false,
		"content":	"#include \"resource_array_module/resource_array_module.c\"\n#include \"resource_module/resource_module.c\""
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/resource_module/resource_array_module/"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/resource_module/resource_array_module/resource_array_module.c",
		"is_binary":	false,
		"content":	"DtwResourceArrayModule newDtwResourceArrayModule(){\n    DtwResourceArrayModule self = {0};\n    self.append = DtwResourceArray_append;\n    self.represent = DtwResourceArray_represent;\n    self.get_by_name = DtwResourceArray_get_by_name;\n    self.free = DtwResourceArray_free;\n    return self;\n}\n"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/resource_module/resource_array_module/resource_array_module.h",
		"is_binary":	false,
		"content":	"\ntypedef struct DtwResourceArrayModule{\n\n    void (*append)(DtwResourceArray *self, DtwResource *element);\n    DtwResource * (*get_by_name)(DtwResourceArray *self, const char *name);\n    void (*represent)(DtwResourceArray *self);\n    void (*free)(DtwResourceArray *self);\n\n}DtwResourceArrayModule;\n\nDtwResourceArrayModule newDtwResourceArrayModule();\n"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/resource_module/resource_module/"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/resource_module/resource_module/resource_module.c",
		"is_binary":	false,
		"content":	"\nDtwResourceModule newDtwResourceModule(){\n    DtwResourceModule self = {0};\n    self.newResource = new_DtwResource;\n    self.get_error_code = DtwResource_get_error_code;\n    self.get_error_message = DtwResource_get_error_message;\n    self.error = DtwResource_error;\n    self.load = DtwResource_load;\n    self.clear_errors = DtwResource_clear_errors;\n    self.unload = DtwResource_unload;\n    self.sub_resource = DtwResource_sub_resource;\n    self.get_any_from_sub_resource = DtwResource_get_any_from_sub_resource;\n    self.get_binary_from_sub_resource = DtwResource_get_binary_from_sub_resource;\n    self.get_string_from_sub_resource = DtwResource_get_string_from_sub_resource;\n    self.get_long_from_sub_resource = DtwResource_get_long_from_sub_resource;\n    self.get_double_from_sub_resource = DtwResource_get_double_from_sub_resource;\n    self.get_bool_from_sub_resource = DtwResource_get_bool_from_sub_resource;\n    self.get_error_path = DtwResource_get_error_path;\n    self.get_schema_values = DtwResource_get_schema_values;\n    self.set_binary_in_sub_resource = DtwResource_set_binary_in_sub_resource;\n    self.set_string_in_sub_resource = DtwResource_set_string_in_sub_resource;\n    self.set_long_in_sub_resource = DtwResource_set_long_in_sub_resource;\n    self.set_double_in_sub_resource = DtwResource_set_double_in_sub_resource;\n    self.set_bool_in_sub_resource = DtwResource_set_bool_in_sub_resource;\n    self.is_file = DtwResource_is_file;\n    self.sub_resource_ensuring_not_exist = DtwResource_sub_resource_ensuring_not_exist;\n    self.sub_resource_next = DtwResource_sub_resource_next;\n    self.destroy_sub_resource = DtwResource_destroy_sub_resource;\n    self.rename_sub_resource = DtwResource_rename_sub_resource;\n    self.sub_resource_now  = DtwResource_sub_resource_now;\n    self.sub_resource_now_in_unix = DtwResource_sub_resource_now_in_unix;\n    self.sub_resource_random = DtwResource_sub_resource_random;\n    self.set_binary_sha =DtwResource_set_binary_sha;\n    self.set_string_sha = DtwResource_set_string_sha;\n    self.set_any_in_sub_resource = DtwResource_set_any_in_sub_resource;\n    self.set_binary_sha_in_sub_resource = DtwResource_set_binary_sha_in_sub_resource;\n    self.set_string_sha_in_sub_resource = DtwResource_set_string_sha_in_sub_resource;\n\n    self.new_schema_insertion = DtwResource_new_schema_insertion;\n    self.find_by_name_id = DtwResource_find_by_name_id;\n    self.find_by_primary_key_with_string = DtwResource_find_by_primary_key_with_string;\n    self.find_by_primary_key_with_binary = DtwResource_find_by_primary_key_with_binary;\n    self.dangerous_remove_schema_prop = DtwResource_dangerous_remove_schema_prop;\n    self.dangerous_rename_schema_prop = DtwResource_dangerous_rename_schema_prop;\n    self.newDatabaseSchema = DtwResource_newDatabaseSchema;\n\n    self.lock =DtwResource_lock;\n    self.unlock = DtwResource_unlock;\n    self.destroy = DtwResource_destroy;\n\n    self.get_any = DtwResource_get_any;\n    self.get_string = DtwResource_get_string;\n    self.get_binary = DtwResource_get_binary;\n    self.get_double = DtwResource_get_double;\n    self.get_long = DtwResource_get_long;\n    self.get_bool = DtwResource_get_bool;\n\n    self.set_any = DtwResource_set_any;\n    self.set_binary = DtwResource_set_binary;\n    self.set_string = DtwResource_set_string;\n    self.set_long = DtwResource_set_long;\n    self.set_double = DtwResource_set_double;\n    self.set_bool = DtwResource_set_bool;\n\n\n    self.list_names = DtwResource_list_names;\n    self.size = DtwResource_size;\n    self.type = DtwResource_type;\n    self.type_in_str = DtwResource_type_in_str;\n    self.commit =DtwResource_commit;\n    self.represent = DtwResource_represent;\n    self.rename = DtwResource_rename;\n    self.free  = DtwResource_free;\n    self.sub_resources = DtwResource_sub_resources;\n    self.array = newDtwResourceArrayModule();\n\n    return self;\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/resource_module/resource_module/resource_module.h",
		"is_binary":	false,
		"content":	"\ntypedef struct DtwResourceModule{\n\n    DtwResource *(*newResource)(const char *path);\n    int (*get_error_code)(DtwResource *self);\n    bool (*error)(DtwResource *self);\n\n    char * (*get_error_message)(DtwResource *self);\n    bool (*is_file)(DtwResource *self);\n    void (*destroy_sub_resource)(DtwResource *self, const char *key);\n    void (*rename_sub_resource)(DtwResource *self,const char *old_name,const  char *new_name);\n    DtwResource * (*sub_resource)(struct DtwResource *self,const  char *format,...);\n    unsigned char *(*get_any_from_sub_resource)(DtwResource *self, long *size, bool *is_binary,const char *format,...);\n    unsigned char *(*get_binary_from_sub_resource)(DtwResource *self, long *size,const char *format,...);\n    char *(*get_string_from_sub_resource)(DtwResource *self,const char *format,...);\n    long (*get_long_from_sub_resource)(DtwResource *self,const char *format,...);\n    double (*get_double_from_sub_resource)(DtwResource *self,const char *format,...);\n    bool (*get_bool_from_sub_resource)(DtwResource *self,const char *format,...);\n    void (*set_any_in_sub_resource)(DtwResource *self,const char *key, unsigned char *element, long size,bool is_binary);\n    void (*set_binary_in_sub_resource)(DtwResource *self,const char *key, unsigned char *element, long size);\n    void (*set_string_in_sub_resource)(DtwResource *self,const char *key,const  char *element);\n    void (*set_long_in_sub_resource)(DtwResource *self,const char *key,long element);\n    void (*set_double_in_sub_resource)(DtwResource *self,const char *key,double element);\n    void (*set_bool_in_sub_resource)( DtwResource *self,const char *key,bool element);\n    void (*set_binary_sha)(DtwResource *self, unsigned  char *value, long size);\n    void (*set_string_sha)(DtwResource *self,const char *value);\n    void (*set_binary_sha_in_sub_resource)(DtwResource *self,const char *key, unsigned  char *value, long size);\n    void (*set_string_sha_in_sub_resource)(DtwResource *self,const char *key,const char *value);\n\n\n\n    DtwResource * (*new_schema_insertion)(DtwResource *self);\n    DtwResource  *(*find_by_name_id)(DtwResource *self, const char *name);\n    DtwResource * (*find_by_primary_key_with_binary)(DtwResource *self, const char *primary_key, unsigned  char *value, long size);\n    DtwResource * (*find_by_primary_key_with_string)(DtwResource *self, const char *key, const char *value);\n    void (*dangerous_remove_schema_prop)(DtwResource*self,const char *prop);\n    void (*dangerous_rename_schema_prop)(DtwResource*self,const char *prop,const char *new_name);\n    DtwDatabaseSchema * (*newDatabaseSchema)(DtwResource *self);\n\n    char * (*get_error_path)(DtwResource *self);\n    DtwResourceArray * (*get_schema_values)(DtwResource *self);\n\n\n    DtwResource * (*sub_resource_ensuring_not_exist)(DtwResource *self,const  char *format, ...);\n    DtwResource * (*sub_resource_next)(DtwResource *self, const char *end_path);\n    DtwResource * (*sub_resource_now)(DtwResource *self, const char *end_path);\n\n    DtwResource * (*sub_resource_now_in_unix)(DtwResource *self,const char *end_path);\n    DtwResource * (*sub_resource_random)(DtwResource *self,const char *end_path);\n\n\n    void (*load)(DtwResource *self);\n\n    void (*unload)(DtwResource *self);\n\n    int (*lock)(DtwResource *self);\n    void (*unlock)(DtwResource *self);\n\n    void (*destroy)(DtwResource *self);\n    void  (*clear_errors)(DtwResource *self);\n    unsigned char *(*get_any)(struct DtwResource *self, long *size, bool *is_binary);\n\n    unsigned char *(*get_binary)(struct DtwResource *self, long *size);\n\n    char *(*get_string)(struct DtwResource *self);\n\n    long (*get_long)(struct DtwResource *self);\n\n    double (*get_double)(struct DtwResource *self);\n\n    bool (*get_bool)(struct DtwResource *self);\n    void (*set_any)(DtwResource *self, unsigned char *element, long size,bool is_binary);\n    void (*set_binary)(DtwResource *self, unsigned char *element, long size);\n\n    void (*set_string)(DtwResource *self,const  char *element);\n\n    void (*set_long)(DtwResource *self,long element);\n\n    void (*set_double)(DtwResource *self,double element);\n\n    void (*set_bool)(DtwResource *self,bool element);\n\n\n\n    DtwStringArray *(*list_names)(DtwResource *self);\n\n    long (*size)(DtwResource *self);\n    int (*type)(DtwResource *self);\n\n    const char *(*type_in_str)(DtwResource *self);\n    void (*commit)(DtwResource *self);\n\n    void (*represent)(DtwResource *self);\n\n    void (*rename)(DtwResource *self,const char *new_name);\n\n    void (*free)(DtwResource *self);\n    DtwResourceArray * (*sub_resources)(DtwResource *self);\n    DtwResourceArrayModule array;\n\n\n}DtwResourceModule;\n\nDtwResourceModule newDtwResourceModule();"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/schema_module/"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/schema_module/schema_module.c",
		"is_binary":	false,
		"content":	"\n\nDtwSchemaModule newDtwSchemaModule(){\n    DtwSchemaModule  self = {0};\n    self.sub_schema = DtwSchema_new_subSchema;\n    self.add_primary_key = DtwSchema_add_primary_key;\n\n    return  self;\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/schema_module/schema_module.h",
		"is_binary":	false,
		"content":	"\ntypedef struct {\n    void (*add_primary_key)(DtwSchema *self, const char *primary_key);\n    DtwSchema * (*sub_schema)(DtwSchema *self,const char *name);\n}DtwSchemaModule;\n\nDtwSchemaModule newDtwSchemaModule();"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/string_array_module/"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/string_array_module/string_array_module.c",
		"is_binary":	false,
		"content":	"\nDtwStringArrayModule newDtwStringArrayModule(){\n    DtwStringArrayModule self = {0};\n    self.newStringArray = newDtwStringArray;\n    self.set_value = DtwStringArray_set_value;\n    self.append = DtwStringArray_append;\n    self.pop = DtwStringArray_pop;\n    self.merge = DtwStringArray_merge;\n    self.represent = DtwStringArray_represent;\n    self.find_position = DtwStringArray_find_position;\n    self.sort = DtwStringArray_sort;\n    self.free =DtwStringArray_free;\n    return self;\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/string_array_module/string_array_module.h",
		"is_binary":	false,
		"content":	"\ntypedef struct DtwStringArrayModule{\n    DtwStringArray *(*newStringArray)();\n\n    void (*set_value)(struct DtwStringArray *self,int index,const char *value);\n\n    void (*append)(struct DtwStringArray *self,const char *string);\n\n    void (*pop)(struct DtwStringArray *self, int position);\n\n    void (*merge)(struct DtwStringArray *self, struct DtwStringArray *other);\n\n    void (*represent)(struct DtwStringArray *self);\n\n    int (*find_position)(struct DtwStringArray *self,const char *string);\n\n    void (*sort)(struct DtwStringArray *self);\n\n    void (*free)(struct DtwStringArray *self);\n\n\n}DtwStringArrayModule;\n\nDtwStringArrayModule newDtwStringArrayModule();"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/transaction_module/"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/transaction_module/action/"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/transaction_module/action/action.c",
		"is_binary":	false,
		"content":	"\nDtwActionTransactionModule newDtwActionTransactionModule(){\n    DtwActionTransactionModule self = {0};\n    self.newAction = newDtwActionTransaction;\n    self.write_any = DtwActionTransaction_write_any;\n    self.move_any = DtwActionTransaction_move_any;\n    self.copy_any = DtwActionTransaction_copy_any;\n    self.move_any_merging = DtwActionTransaction_move_any_merging;\n    self.copy_any_merging = DtwActionTransaction_move_any_merging;\n    self.delete_any = DtwActionTransaction_delete_any;\n    self.convert_action_to_integer =DtwActionTransaction_convert_action_to_integer;\n    self.convert_action_to_string = DtwActionTransaction_convert_action_to_string;\n    self.commit = DtwActionTransaction_commit;\n    self.represent = DtwActionTransaction_represent;\n    self.free = DtwActionTransaction_free;\n    return self;\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/transaction_module/action/action.h",
		"is_binary":	false,
		"content":	"\n\ntypedef struct DtwActionTransactionModule{\n\n    DtwActionTransaction *(*newAction)();\n\n    DtwActionTransaction * (*write_any)(const char *source,unsigned  char *content,long size,bool is_binary);\n\n    DtwActionTransaction * (*move_any)(const char *source, const char *dest);\n    DtwActionTransaction * (*move_any_merging)(const char *source, const char *dest);\n    DtwActionTransaction * (*copy_any_merging)(const char *source, const char *dest);\n\n    DtwActionTransaction * (*copy_any)(const char *source, const char *dest);\n\n    DtwActionTransaction * (*delete_any)(const char *source);\n\n    short (*convert_action_to_integer)(char *action);\n\n    const char * (*convert_action_to_string)(int action);\n\n    void (*commit)(DtwActionTransaction* self,const char *path);\n\n    void (*represent)(DtwActionTransaction* self);\n\n    void (*free)(DtwActionTransaction* self);\n\n}DtwActionTransactionModule;\n\nDtwActionTransactionModule newDtwActionTransactionModule();"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/transaction_module/declaration.h",
		"is_binary":	false,
		"content":	"#include \"action/action.h\"\n#include \"json_error_module/json_error_module.h\"\n#include \"transaction_module/transaction_module.h\""
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/transaction_module/definition.c",
		"is_binary":	false,
		"content":	"#include \"action/action.c\"\n#include \"json_error_module/json_error_module.c\"\n#include \"transaction_module/transaction_module.c\""
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/transaction_module/json_error_module/"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/transaction_module/json_error_module/json_error_module.c",
		"is_binary":	false,
		"content":	"\nDtwJsonTransactionErrorModule newDtwJsonTransactionErrorModule(){\n    DtwJsonTransactionErrorModule self = {0};\n    self.represent = DtwJsonTransactionError_represent;\n    self.free = DtwJsonTransactionError_free;\n    return self;\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/transaction_module/json_error_module/json_error_module.h",
		"is_binary":	false,
		"content":	"\n\ntypedef struct DtwJsonTransactionErrorModule{\n    void (*represent)(struct DtwJsonTransactionError *self);\n    void (*free)(struct DtwJsonTransactionError *self);\n\n}DtwJsonTransactionErrorModule;\n\nDtwJsonTransactionErrorModule newDtwJsonTransactionErrorModule();"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/transaction_module/transaction_module/"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/transaction_module/transaction_module/transaction_module.c",
		"is_binary":	false,
		"content":	"\n\nDtwTransactionModule newDtwTransactionModule(){\n    DtwTransactionModule self = {0};\n    self.newTransaction = newDtwTransaction;\n    self.newTransaction_from_json = newDtwTransaction_from_json;\n    self.newTransaction_from_json_file = newDtwTransaction_from_json_file;\n    self.validate_json_transaction_file = dtw_validate_json_transaction_file;\n    self.remove_from_index = DtwTransaction_remove_from_index;\n    self.remove_from_source = DtwTransaction_remove_from_source;\n    self.filter = DtwTransaction_filter;\n    self.append_action = DtwTransaction_append_action;\n    self.write_any = DtwTransaction_write_any;\n    self.write_string = DtwTransaction_write_string;\n    self.write_long = DtwTransaction_write_long;\n    self.write_bool = DtwTransaction_write_bool;\n    self.write_double = DtwTransaction_write_double;\n\n    self.move_any_merging = DtwTransaction_move_any_merging;\n    self.copy_any_merging = DtwTransaction_copy_any_merging;\n    self.move_any = DtwTransaction_move_any;\n    self.copy_any = DtwTransaction_copy_any;\n    self.delete_any = DtwTransaction_delete_any;\n\n    self.dumps_transaction_to_json = DtwTransaction_dumps_to_json;\n    self.dumps_transaction_to_json_file = DtwTransaction_dumps_to_json_file;\n\n    self.commit = DtwTransaction_commit;\n    self.represent = DtwTransaction_represent;\n    self.free =DtwTransaction_free;\n\n    self.action = newDtwActionTransactionModule();\n    self.json_error = newDtwJsonTransactionErrorModule();\n\n\n    return self;\n}\n"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/transaction_module/transaction_module/transaction_module.h",
		"is_binary":	false,
		"content":	"\ntypedef struct DtwTransactionModule{\n    DtwTransaction *(*newTransaction)();\n    DtwTransaction * (*newTransaction_from_json)(cJSON *json_entry);\n    DtwTransaction * (*newTransaction_from_json_file)(const char *filename);\n    DtwJsonTransactionError * (*validate_json_transaction_file)(const char *filename);\n\n    void (*remove_from_index)(DtwTransaction *self,long index);\n    void (*remove_from_source)(DtwTransaction *self,const char *source);\n    void (*filter)(DtwTransaction *self,bool (*callback)(DtwActionTransaction *action));\n\n    void (*append_action)(struct DtwTransaction *self,struct DtwActionTransaction  *action);\n    void (*write_any)(struct DtwTransaction *self,const char *path,unsigned char *content, long size,bool is_binary);\n    void (*write_string)(struct DtwTransaction *self,const char *path,const char *content);\n\n    void (*write_long)(struct DtwTransaction *self,const char *path,long value);\n    void (*write_bool)(struct DtwTransaction *self,const char *path,bool value);\n    void (*write_double)(struct DtwTransaction *self,const char *path,double value);\n\n    void (*move_any_merging)(struct DtwTransaction *self,const char *source,const char *dest);\n    void (*copy_any_merging)(struct DtwTransaction *self,const char *source,const char *dest);\n\n\n    void (*move_any)(struct DtwTransaction *self,const char *source,const char *dest);\n    void (*copy_any)(struct DtwTransaction *self,const char *source,const char *dest);\n    void (*delete_any)(struct DtwTransaction *self,const char *source);\n\n    cJSON *(*dumps_transaction_to_json)(struct DtwTransaction *self);\n    void (*dumps_transaction_to_json_file)(struct DtwTransaction *self,const char *filename);\n\n    void (*commit)(struct DtwTransaction *self,const char *source);\n    void (*represent)(struct DtwTransaction *self);\n    void (*free)(struct DtwTransaction *self);\n\n    DtwActionTransactionModule action;\n    DtwJsonTransactionErrorModule json_error;\n\n\n}DtwTransactionModule;\n\nDtwTransactionModule newDtwTransactionModule();\n"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/tree_module/"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/tree_module/declaration.h",
		"is_binary":	false,
		"content":	"#include \"tree_part_module/tree_part_module.h\"\n#include \"json_error/json_error.h\"\n#include \"transaction_report/transaction_report_module.h\"\n#include \"tree/tree.h\"\n"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/tree_module/definition.c",
		"is_binary":	false,
		"content":	"#include \"tree_part_module/tree_part_module.c\"\n#include \"json_error/json_error.c\"\n#include \"transaction_report/transaction_report_module.c\"\n#include \"tree/tree.c\"\n"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/tree_module/json_error/"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/tree_module/json_error/json_error.c",
		"is_binary":	false,
		"content":	"\nDtwJsonTreeErrorModule newDtwJsonTreeErrorModule(){\n    DtwJsonTreeErrorModule self = {0};\n    self.validate_json_tree_by_cJSON= DtwJsonTreeError_validate_json_tree_by_cJSON;\n    self.validate_json_tree_by_content = DtwJsonTreeError_validate_json_tree_by_content;\n    self.represent =DtwJsonTreeError_represent;\n    self.free = DtwJsonTreeError_free;\n    return self;\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/tree_module/json_error/json_error.h",
		"is_binary":	false,
		"content":	"\n\ntypedef struct DtwJsonTreeErrorModule{\n\n    DtwJsonTreeError * (*validate_json_tree_by_cJSON)(cJSON *json_tree);\n    DtwJsonTreeError * (*validate_json_tree_by_content)(const char *content);\n    void (*free)(struct DtwJsonTreeError *self);\n    void (*represent)(struct DtwJsonTreeError *self);\n\n}DtwJsonTreeErrorModule;\n\nDtwJsonTreeErrorModule newDtwJsonTreeErrorModule();"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/tree_module/transaction_report/"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/tree_module/transaction_report/transaction_report_module.c",
		"is_binary":	false,
		"content":	"\nDtwTreeTransactionReportModule newDtwTreeTransactionReportModule(){\n    DtwTreeTransactionReportModule self = {0};\n    self.represent = DtwTreeTransactionReport_represent;\n    self.free = DtwTreeTransactionReport_free;\n    return self;\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/tree_module/transaction_report/transaction_report_module.h",
		"is_binary":	false,
		"content":	"\ntypedef struct  DtwTreeTransactionReportModule{\n\n    void (*represent)(struct DtwTreeTransactionReport *report);\n    void (*free)(struct DtwTreeTransactionReport *report);\n\n}DtwTreeTransactionReportModule;\n\nDtwTreeTransactionReportModule newDtwTreeTransactionReportModule();"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/tree_module/tree/"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/tree_module/tree/tree.c",
		"is_binary":	false,
		"content":	"\nDtwTreeModule newDtwTreeModule(){\n    DtwTreeModule self = {0};\n    self.newTree = newDtwTree;\n    self.add_tree_part_by_copy = DtwTree_add_tree_part_copy;\n    self.remove_tree_part  = DtwTree_remove_tree_part;\n    self.add_tree_part_getting_owenership = DtwTree_add_tree_part_getting_onwership;\n    self.add_tree_part_referencing = DtwTree_add_tree_part_referencing;\n    self.add_tree_parts_from_string_array = DtwTree_add_tree_parts_from_string_array;\n    self.get_sub_tree = DtwTree_get_sub_tree;\n    self.add_tree_from_hardware = DtwTree_add_tree_from_hardware;\n    self.find_tree_part_by_function = DtwTree_find_tree_part_by_function;\n    self.filter = DtwTree_filter;\n    self.map = DtwTree_map;\n\n    self.list_files = DtwTree_list_files;\n    self.list_dirs = DtwTree_list_dirs;\n    self.list_all = DtwTree_list_all;\n\n    self.list_files_recursively = DtwTree_list_files_recursively;\n    self.list_dirs_recursively = DtwTree_list_dirs_recursively;\n    self.list_all_recursively = DtwTree_list_all_recursively;\n\n    self.find_tree_part_by_name = DtwTree_find_tree_part_by_name;\n    self.find_tree_part_by_path = DtwTree_find_tree_part_by_path;\n\n    self.create_report = DtwTree_create_report;\n    self.loads_json_tree = DtwTree_loads_json_tree;\n    self.loads_json_tree_from_file = DtwTree_loads_json_tree_from_file;\n    self.dumps_json_tree = DtwTree_dumps_tree_json;\n    self.dumps_json_tree_to_file = DtwTree_dumps_tree_json_to_file;\n\n    self.represent = DtwTree_represent;\n    self.insecure_hardware_remove_tree = DtwTree_insecure_hardware_remove_tree;\n    self.insecure_hardware_write_tree = DtwTree_insecure_hardware_write_tree;\n    self.hardware_commit_tree = DtwTree_hardware_commit_tree;\n    self.free = DtwTree_free;\n    self.transaction_report = newDtwTreeTransactionReportModule();\n    self.part = newDtwTreePartModule();\n    self.json_error = newDtwJsonTreeErrorModule();\n    return self;\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/tree_module/tree/tree.h",
		"is_binary":	false,
		"content":	"\ntypedef struct DtwTreeModule{\n\n    DtwTree  *(*newTree)();\n    void (*add_tree_part_by_copy)(\n             DtwTree *self,\n             DtwTreePart *tree_part\n    );\n\n    void (*remove_tree_part)(\n             DtwTree *self,\n            int position\n    );\n\n    void (*add_tree_part_getting_owenership)(\n             DtwTree *self,\n             DtwTreePart *tree_part\n    );\n    void (*add_tree_part_referencing)(\n            DtwTree *self,\n            DtwTreePart *tree_part\n    );\n        void (*add_tree_parts_from_string_array)(\n            struct DtwTree *self,\n            struct DtwStringArray *paths,\n            DtwTreeProps props\n    );\n\n    struct DtwTree *(*get_sub_tree)(\n            struct DtwTree *self,\n            const char *path,\n            bool copy_content\n    );\n\n    void (*add_tree_from_hardware)(\n            struct DtwTree *self,\n            const char *path,\n            DtwTreeProps props\n    );\n    //Listage Functions\n\n    DtwTreePart *(*find_tree_part_by_function)(\n            struct DtwTree *self,\n            bool (*caller)(struct  DtwTreePart *part)\n    );\n\n    DtwTree *(*filter)(\n            struct DtwTree *self,\n            bool (*caller)(struct  DtwTreePart *part)\n    );\n\n    DtwTree *(*map)(\n            struct DtwTree *self,\n            struct  DtwTreePart*(*caller)(struct  DtwTreePart *part)\n    );\n\n\n    DtwStringArray * (*list_files)(struct DtwTree *self, const char *path,bool concat_path);\n    DtwStringArray * (*list_dirs)(struct DtwTree *self, const char *path,bool concat_path);\n    DtwStringArray * (*list_all)(struct DtwTree *self, const char *path,bool concat_path);\n\n    DtwStringArray * (*list_files_recursively)(struct DtwTree *self, const char *path,bool concat_path);\n    DtwStringArray * (*list_dirs_recursively)(struct DtwTree *self, const char *path,bool concat_path);\n    DtwStringArray * (*list_all_recursively)(struct DtwTree *self, const char *path,bool concat_path);\n\n\n    struct DtwTreePart *(*find_tree_part_by_name)( struct DtwTree *self,const char *name);\n    struct DtwTreePart *(*find_tree_part_by_path)(   struct DtwTree *self,const char *path);\n\n\n    struct DtwTreeTransactionReport * (*create_report)(struct DtwTree *self);\n\n    bool (*loads_json_tree)(\n            struct DtwTree *self,\n            const char *content\n    );\n\n\n    bool (*loads_json_tree_from_file)(\n            struct DtwTree *self,\n            const char *path\n    );\n\n    char *(*dumps_json_tree)(\n            struct DtwTree *self,\n            DtwTreeProps props\n    );\n\n    void (*dumps_json_tree_to_file)(\n            struct DtwTree *self,\n            const char *path,\n            DtwTreeProps  props\n    );\n\n    void (*represent)(struct DtwTree *self);\n    void (*insecure_hardware_remove_tree)(struct DtwTree *self);\n    void (*insecure_hardware_write_tree)(struct DtwTree *self);\n    void (*hardware_commit_tree)(struct DtwTree *self);\n    void (*free)(struct DtwTree *self);\n\n    DtwTreeTransactionReportModule transaction_report;\n\n    DtwTreePartModule part;\n    DtwJsonTreeErrorModule json_error;\n\n}DtwTreeModule;\n\nDtwTreeModule newDtwTreeModule();"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/tree_module/tree_part_module/"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/tree_module/tree_part_module/tree_part_module.c",
		"is_binary":	false,
		"content":	"\n\nDtwTreePartModule newDtwTreePartModule(){\n    DtwTreePartModule self ={0};\n    self.newPart = newDtwTreePart;\n    self.newPartEmpty = newDtwTreePartEmpty;\n    self.newPartLoading = newDtwTreePartLoading;\n    self.get_content_string_by_reference = DtwTreePart_get_content_string_by_reference;\n    self.get_content_binary_by_reference = DtwTreePart_get_content_binary_by_reference;\n    self.get_content_sha = DtwTreePart_get_content_sha;\n    self.set_any_content = DtwTreePart_set_any_content;\n    self.set_string_content = DtwTreePart_set_string_content;\n    self.set_binary_content = DtwTreePart_set_binary_content;\n    self.load_content_from_hardware =DtwTreePart_load_content_from_hardware;\n    self.free_content = DtwTreePart_free_content;\n    self.represent =DtwTreePart_represent;\n    self.hardware_remove = DtwTreePart_hardware_remove;\n    self.hardware_write = DtwTreePart_hardware_write;\n    self.hardware_modify = DtwTreePart_hardware_modify;\n    self.hardware_commit =DtwTreePart_hardware_commit;\n\n    self.free = DtwTreePart_free;\n    self.self_copy = DtwTreePart_self_copy;\n\n\n    return self;\n}\n"
	}, {
		"path":	"src/dependencies/doTheWorld/namespace/tree_module/tree_part_module/tree_part_module.h",
		"is_binary":	false,
		"content":	"\n\ntypedef struct DtwTreePartModule{\n\n    DtwTreePart  *(*newPart)(const char *path, DtwTreeProps props);\n    DtwTreePart  *(*newPartEmpty)(const char *path);\n    DtwTreePart * (*newPartLoading)(const char *path);\n\n    char *(*get_content_string_by_reference)(struct DtwTreePart *self);\n    unsigned char *(*get_content_binary_by_reference)(struct DtwTreePart *self);\n\n    char *(*get_content_sha)(struct DtwTreePart *self);\n    void (*set_any_content)(struct DtwTreePart *self,unsigned char *content,long content_size,bool is_binary);\n    void (*set_string_content)(struct DtwTreePart *self,const char *content);\n    void (*set_binary_content)(struct DtwTreePart *self,unsigned char *content,long content_size);\n    void (*load_content_from_hardware)(struct DtwTreePart *self);\n    void (*free_content)(struct DtwTreePart *self);\n    void(*represent)(struct DtwTreePart *self);\n\n    bool(*hardware_remove)(struct DtwTreePart *self, int transaction);\n    bool(*hardware_write)(struct DtwTreePart *self, int transaction);\n    bool(*hardware_modify)(struct DtwTreePart *self, int transaction);\n    bool(*hardware_commit)(struct DtwTreePart *self);\n\n    void (*free)(struct DtwTreePart *self);\n    struct DtwTreePart *(*self_copy)(struct DtwTreePart *self);\n}DtwTreePartModule;\n\n\nDtwTreePartModule newDtwTreePartModule();"
	}, {
		"path":	"src/dependencies/doTheWorld/numeral_io/"
	}, {
		"path":	"src/dependencies/doTheWorld/numeral_io/numeral_io.c",
		"is_binary":	false,
		"content":	"\nlong dtw_load_long_file_content_setting_error(const char *path,int *error){\n    char *data = dtw_load_string_file_content(path);\n    if(!data){\n        *error = DTW_NOT_FOUND;\n        return DTW_NOT_FOUND;\n    }\n    long value = -1;\n    int result = sscanf(data,\"%ld\",&value);\n    free(data);\n    if(result){\n        return value;\n    }\n    *error = DTW_NOT_NUMERICAL;\n    return DTW_NOT_NUMERICAL;\n}\n\n\nlong dtw_load_long_file_content(const char * path){\n   int error;\n   return dtw_load_long_file_content_setting_error(path,&error);\n}\n\n\ndouble dtw_load_double_file_content_setting_error(const char * path, int *error){\n    char *data = dtw_load_string_file_content(path);\n    if(!data){\n        *error = DTW_NOT_FOUND;\n        return DTW_NOT_FOUND;\n    }\n    double value = -1;\n    int result = sscanf(data,\"%lf\",&value);\n    free(data);\n    if(result){\n    \n        return value;\n    }\n    *error = DTW_NOT_NUMERICAL;\n    return DTW_NOT_NUMERICAL;\n}\n\n\ndouble dtw_load_double_file_content(const char * path){\n    int error;\n    return dtw_load_double_file_content_setting_error(path,&error);\n}\n\n\nbool dtw_load_bool_file_content_setting_error(const char * path, int *error){\n    char *data = dtw_load_string_file_content(path);\n    if(!data){\n        *error = DTW_NOT_FOUND;\n        return false;\n    }\n\n    if(strcmp(data,\"true\") == 0 || strcmp(data,\"t\") == 0){\n        free(data);\n        return true;\n    }\n\n    if(strcmp(data,\"false\") == 0 || strcmp(data,\"f\") == 0){\n        free(data);\n        return false;\n    }\n    free(data);\n    *error = DTW_NOT_BOOL;\n    return false;\n\n}\n\n\nbool dtw_load_bool_file_content(const char * path){\n    int error;\n    return dtw_load_bool_file_content_setting_error(path,&error);\n    \n}\n\n\n\nvoid dtw_write_long_file_content(const char *path, long value){\n    char result[30] ={0};\n    sprintf(result,\"%ld\",value);\n    dtw_write_string_file_content(path,result);\n}\n\n\nvoid dtw_write_double_file_content(const char *path,double value){\n    char result[30] ={0};\n    sprintf(result,\"%lf\",value);\n    dtw_write_string_file_content(path,result);\n}\n\n\nvoid dtw_write_bool_file_content(const char *path, bool value){\n    if(value){\n        dtw_write_string_file_content(path,\"t\");\n    }\n    else{\n        dtw_write_string_file_content(path,\"f\");\n    }\n}\n\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/numeral_io/numeral_io.h",
		"is_binary":	false,
		"content":	"\n\n#define DTW_NOT_NUMERICAL -2\n#define DTW_NOT_BOOL -3\n\nlong dtw_load_long_file_content_setting_error(const char *path,int *error);\n\nlong dtw_load_long_file_content(const char * path);\n\ndouble dtw_load_double_file_content_setting_error(const char * path, int *error);\n\ndouble dtw_load_double_file_content(const char * path);\n\nbool dtw_load_bool_file_content_setting_error(const char * path, int *error);\n\n\nbool dtw_load_bool_file_content(const char * path);\n\n\nvoid dtw_write_long_file_content(const char *path, long value);\n\nvoid dtw_write_bool_file_content(const char *path, bool value);\n\nvoid dtw_write_double_file_content(const char *path,double value);\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/one.c",
		"is_binary":	false,
		"content":	"\n// USE  THIS FILE ONLY FOR PRODUCTION\n// This file is part of the DoTheWorld project.\n// Do not edit this file, it is automatically generated.\n// See the README.md file for more information.\n/*\nMIT License\n\nCopyright (c) 2023 Mateus Moutinho Queiroz\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n#ifndef DO_THE_WORLD_H\n#include \"definition.c\"\n#include \"dependencies/definition.c\"\n\n#endif //DO_THE_WORLD_H\n\n\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/path/"
	}, {
		"path":	"src/dependencies/doTheWorld/path/basic/"
	}, {
		"path":	"src/dependencies/doTheWorld/path/basic/basic.c",
		"is_binary":	false,
		"content":	"\n\nstruct DtwPath * newDtwPath(const char *path) {\n    struct DtwPath *self = (struct DtwPath *)malloc(sizeof(struct DtwPath));\n    self->garbage = newDtwStringArray();\n    self->path = private_dtw_format_path(path);\n    self->original_path_string = strdup(self->path);\n\n\n    return self;\n}\nbool DtwPath_changed(struct DtwPath *self){\n    return strcmp(self->path,self->original_path_string) != 0;\n}\n\n\n\n\nvoid DtwPath_represent(struct DtwPath *self){\n    char  *path = DtwPath_get_path(self);\n    char *full_name = DtwPath_get_full_name(self);\n    char *dir = DtwPath_get_dir(self);\n    char *name = DtwPath_get_name(self);\n    char *extension = DtwPath_get_extension(self);\n    bool changed = DtwPath_changed(self);\n\n    printf(\"First Path: %s\\n\", self->original_path_string ? self->original_path_string : \"NULL\");\n    printf(\"Path: %s\\n\", path  ? path : \"NULL\");\n    printf(\"Path Changed: %s\\n\", changed ? \"true\" : \"false\");\n    printf(\"Dir: %s\\n\", dir ? dir : \"NULL\");\n    printf(\"Full Name: %s\\n\", full_name ? full_name : \"NULL\");\n    printf(\"Name: %s\\n\", name ? name : \"NULL\");\n    printf(\"Extension: %s\\n\", extension ? extension : \"NULL\");\n\n    \n}\n\n\n\nvoid DtwPath_free(struct DtwPath *self) {\n    DtwStringArray_free(self->garbage);\n    free(self->original_path_string);\n    free(self->path);\n    free(self);\n}\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/path/basic/basic.h",
		"is_binary":	false,
		"content":	"\n\nstruct DtwPath * newDtwPath(const char *path);\n\nbool DtwPath_changed(struct DtwPath *self);\n\n\n\n\nvoid DtwPath_represent(struct DtwPath *self);\n\n\n\nvoid DtwPath_free(struct DtwPath *self);"
	}, {
		"path":	"src/dependencies/doTheWorld/path/declaration.h",
		"is_binary":	false,
		"content":	"#include \"path.h\"\n#include \"basic/basic.h\"\n#include \"getters/getters.h\"\n#include \"setters/setters.h\"\n#include \"index/index.h\"\n#include \"meta/meta.h\"\n"
	}, {
		"path":	"src/dependencies/doTheWorld/path/definition.c",
		"is_binary":	false,
		"content":	"\n#include \"basic/basic.c\"\n#include \"getters/getters.c\"\n#include \"setters/setters.c\"\n#include \"index/index.c\"\n#include \"meta/meta.c\"\n"
	}, {
		"path":	"src/dependencies/doTheWorld/path/getters/"
	}, {
		"path":	"src/dependencies/doTheWorld/path/getters/getters.c",
		"is_binary":	false,
		"content":	"\n\nchar * DtwPath_get_name(struct DtwPath *self){\n\n    long path_size = (long)strlen(self->path);\n    long start = 0;\n    long end = path_size;\n    for(long i = path_size-1; i >=0; i--){\n        char current_char = self->path[i];\n        if(current_char == '/' || current_char == '\\\\'){\n            start = i+1;\n            break;\n        }\n        if(current_char == '.'){\n            end = i;\n        }\n    }\n    if(end - start == 0){\n        return NULL;\n    }\n\n    char *buffer = private_dtw_sub_str(self->path,start,end);\n    return privateDtwStringArray_append_if_not_included(self->garbage,buffer);\n\n}\nchar * DtwPath_get_extension(struct DtwPath *self){\n    long path_size = (long)strlen(self->path);\n    long start = -1;\n    long end = path_size;\n    for(long i = path_size-1; i >=0; i--){\n        char current_char = self->path[i];\n        if(current_char == '.'){\n            start = i+1;\n            break;\n        }\n    }\n    if(start == -1){\n        return  NULL;\n    }\n    char *buffer = private_dtw_sub_str(self->path,start,end);\n    return privateDtwStringArray_append_if_not_included(self->garbage,buffer);\n}\n\nchar * DtwPath_get_full_name(struct DtwPath *self){\n    long path_size = (long)strlen(self->path);\n    long start = 0;\n    long end = path_size;\n    for(long i = path_size-1; i >=0; i--){\n        char current_char = self->path[i];\n        if(current_char == '/' || current_char == '\\\\'){\n            start = i+1;\n            break;\n        }\n    }\n    if(end - start == 0){\n        return NULL;\n    }\n    char *buffer = private_dtw_sub_str(self->path,start,end);\n    return privateDtwStringArray_append_if_not_included(self->garbage,buffer);\n}\n\nchar * DtwPath_get_dir(struct DtwPath *self){\n    long path_size = (long)strlen(self->path);\n    long start = 0;\n    long end = -1;\n    for(long i = path_size-1; i >=0; i--){\n        char current_char = self->path[i];\n        if(current_char == '/' || current_char == '\\\\'){\n            end = i+1;\n            break;\n        }\n    }\n    if(end == -1){\n        return NULL;\n    }\n\n    char *buffer = private_dtw_sub_str(self->path,start,end);\n    return privateDtwStringArray_append_if_not_included(self->garbage,buffer);\n}\n\nchar * DtwPath_get_path(struct DtwPath *self){\n    return self->path;\n}\n\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/path/getters/getters.h",
		"is_binary":	false,
		"content":	"\n\nchar * DtwPath_get_name(DtwPath *self);\n\nchar * DtwPath_get_extension(struct DtwPath *self);\n\n\nchar * DtwPath_get_full_name(struct DtwPath *self);\n\n\nchar * DtwPath_get_dir(struct DtwPath *self);\n\n\nchar * DtwPath_get_path(struct DtwPath *self);\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/path/index/"
	}, {
		"path":	"src/dependencies/doTheWorld/path/index/index.c",
		"is_binary":	false,
		"content":	"\nint DtwPath_get_total_dirs(DtwPath *self){\n    int size = 0;\n    int path_size = (int)strlen(self->path);\n    for(int i = 0; i < path_size;i++){\n        char current = self->path[i];\n        if(current == '/' || current =='\\\\'){\n            size+=1;\n        }\n    }\n    return size;\n}\n\nchar *DtwPath_get_sub_dirs_from_index(DtwPath *self, int start, int end){\n\n    int size = DtwPath_get_total_dirs(self);\n    if(size == 0){\n        return NULL;\n    }\n    int converted_start_index = (int)private_dtw_convert_index(start, size);\n    int converted_end_index = (int)private_dtw_convert_index(end, size);\n\n    if(converted_start_index == -1  || converted_end_index == -1){\n        return  NULL;\n    }\n\n    char *dir = DtwPath_get_dir(self);\n    int  dirs_string_size = (int)strlen(dir);\n    int total_dirs = 0;\n    bool start_defined = false;\n    bool end_defined  = false;\n    int start_point = 0;\n    int end_point = dirs_string_size;\n\n    for(int i= 0 ;i < dirs_string_size;i++ ){\n        char current = dir[i];\n        if(current == '/' || current =='\\\\'){\n            total_dirs+=1;\n            continue;\n        }\n        if(total_dirs == converted_start_index  &&!start_defined){\n            start_point = i;\n            start_defined = true;\n        }\n\n        if(total_dirs == (converted_end_index + 1)&&!end_defined){\n            end_point = i;\n            end_defined = true;\n        }\n    }\n    char *buffer = private_dtw_sub_str(dir,start_point,end_point);\n    return privateDtwStringArray_append_if_not_included(self->garbage,buffer);\n}\n\n\n\nint private_dtw_count_dirs_before(const char *dirs,int index){\n    int total = 0;\n    for(int i =index; i >=0; i--){\n        char current_char = dirs[i];\n        if(current_char == '\\\\' || current_char == '/' ){\n            total+=1;\n        }\n    }\n    return  total;\n}\n\nvoid DtwPath_insert_dir_at_index(DtwPath *self, int index, const char *dir){\n\n    int size = DtwPath_get_total_dirs(self);\n    int converted_index = (int)private_dtw_convert_index(index,size+1);\n\n    if(converted_index == -1){\n        return  ;\n    }\n    char * starter = NULL;\n    if(converted_index > 0){\n        starter = DtwPath_get_sub_dirs_from_index(self, 0, converted_index - 1);\n    }\n\n    const char *rest =NULL;\n    if(converted_index < size){\n        rest = DtwPath_get_sub_dirs_from_index(self, converted_index, -1);\n    }\n\n\n     char *buffer =NULL;\n    if(starter && rest){\n        buffer = private_dtw_formatt(\"%s/%s/%s\",starter,dir,rest);\n    }\n    if(starter && rest==NULL){\n        buffer = private_dtw_formatt(\"%s/%s\",starter,dir);\n    }\n    if(starter == NULL && rest){\n        buffer = private_dtw_formatt(\"%s/%s\",dir,rest);\n    }\n\n    if(!starter && !rest){\n        buffer = (char*)dir;\n    }\n\n    DtwPath_set_dir(self,buffer);\n\n    if(starter || rest){\n        free(buffer);\n    }\n}\n\n\n\nvoid DtwPath_remove_sub_dirs_at_index(DtwPath *self, int start, int end){\n\n    int size = DtwPath_get_total_dirs(self);\n    if(size == 0){\n        return ;\n    }\n    int converted_start_index = (int)private_dtw_convert_index(start, size);\n    int converted_end_index = (int)private_dtw_convert_index(end, size);\n\n    if(converted_start_index == -1  || converted_end_index == -1){\n        return  ;\n    }\n    char *start_dir = NULL;\n    if(converted_start_index != 0){\n        start_dir = DtwPath_get_sub_dirs_from_index(self,0,converted_start_index-1);\n    }\n\n    char *end_dir = DtwPath_get_sub_dirs_from_index(self,converted_end_index+1,-1);\n\n    if(start_dir != NULL  && end_dir != NULL){\n        char *full_dir = dtw_concat_path(start_dir,end_dir);\n        DtwPath_set_dir(self,full_dir);\n        free(full_dir);\n        return ;\n    }\n    if(start_dir != NULL){\n        DtwPath_set_dir(self,start_dir);\n    }\n\n    if(end_dir != NULL){\n        DtwPath_set_dir(self,end_dir);\n    }\n\n\n}\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/path/index/index.h",
		"is_binary":	false,
		"content":	"\nint DtwPath_get_total_dirs(DtwPath *self);\n\nchar *DtwPath_get_sub_dirs_from_index(DtwPath *self, int start, int end);\n\n\nint private_dtw_count_dirs_before(const char *dirs,int index);\n\nvoid DtwPath_insert_dir_at_index(DtwPath *self, int index, const char *dir);\n\nvoid DtwPath_remove_sub_dirs_at_index(DtwPath *self, int start, int end);\n"
	}, {
		"path":	"src/dependencies/doTheWorld/path/meta/"
	}, {
		"path":	"src/dependencies/doTheWorld/path/meta/meta.c",
		"is_binary":	false,
		"content":	"\nvoid DtwPath_insert_dir_after(DtwPath *self,const char *str,const char *dir){\n    char *current_dir = DtwPath_get_dir(self);\n    int index = (int)dtw_index_of_string(current_dir,str);\n    if(index == -1){\n        return;\n    }\n\n    int start = private_dtw_count_dirs_before(current_dir,index)+1;\n    DtwPath_insert_dir_at_index(self, start, dir);\n}\n\nvoid DtwPath_insert_dir_before(DtwPath *self,const char *str,const char *dir){\n    char *current_dir = DtwPath_get_dir(self);\n    int index = (int)dtw_index_of_string(current_dir,str);\n    if(index == -1){\n        return;\n    }\n    int start = private_dtw_count_dirs_before(current_dir,index);\n    DtwPath_insert_dir_at_index(self, start, dir);\n}\n\nvoid DtwPath_remove_sub_dirs_at(DtwPath *self,const char *str){\n    char *current_dir = DtwPath_get_dir(self);\n    int index = (int)dtw_index_of_string(current_dir,str);\n    if(index == -1){\n        return;\n    }\n\n    int start = private_dtw_count_dirs_before(current_dir,index);\n    int end = private_dtw_count_dirs_before(current_dir,index+ (int)strlen(str));\n    DtwPath_remove_sub_dirs_at_index(self, start, end - 1);\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/path/meta/meta.h",
		"is_binary":	false,
		"content":	"\nvoid DtwPath_insert_dir_after(DtwPath *self,const char *str,const char *dir);\n\n\nvoid DtwPath_insert_dir_before(DtwPath *self,const char *str,const char *dir);\n\n\nvoid DtwPath_remove_sub_dirs_at(DtwPath *self,const char *str);\n"
	}, {
		"path":	"src/dependencies/doTheWorld/path/path.h",
		"is_binary":	false,
		"content":	"\ntypedef struct DtwPath {\n    char *original_path_string;\n    char *path;\n    DtwStringArray *garbage;\n\n\n}DtwPath;\n"
	}, {
		"path":	"src/dependencies/doTheWorld/path/setters/"
	}, {
		"path":	"src/dependencies/doTheWorld/path/setters/setters.c",
		"is_binary":	false,
		"content":	"\n\nvoid DtwPath_set_extension(struct DtwPath *self, const char *extension){\n\n    const char *dir = DtwPath_get_dir(self);\n    if(!dir){\n        dir = \"\";\n    }\n    const char *name = DtwPath_get_name(self);\n    if(!name){\n        name = \"\";\n    }\n    free(self->path);\n    char *formated_extension = dtw_replace_string(extension,\".\",\"\");\n    self->path= private_dtw_formatt(\"%s%s.%s\",dir,name,formated_extension);\n    free(formated_extension);\n}\n\n\nvoid DtwPath_set_name(struct DtwPath * self, const char * name){\n    const char *dir = DtwPath_get_dir(self);\n    if(!dir){\n        dir = \"\";\n    }\n    char *extension = DtwPath_get_extension(self);\n    free(self->path);\n\n    if(extension){\n        self->path = private_dtw_formatt(\"%s%s.%s\",dir,name,extension);\n    }\n    if(!extension){\n        self->path = private_dtw_formatt(\"%s%s\",dir,name);\n    }\n}\n\n\n\nvoid DtwPath_set_full_name(struct DtwPath * self, const char * full_name){\n    const char *dir = DtwPath_get_dir(self);\n    if(!dir){\n        dir = \"\";\n    }\n    free(self->path);\n    self->path = private_dtw_formatt(\"%s%s\",dir,full_name);\n\n}\n\n\nvoid DtwPath_set_dir(struct DtwPath *self, const char *dir){\n    const char * full_name = DtwPath_get_full_name(self);\n    if(!full_name){\n        full_name = \"\";\n    }\n    free(self->path);\n    char *buffer = private_dtw_formatt(\"%s/%s\",dir,full_name);\n    self->path = private_dtw_format_path(buffer);\n    free(buffer);\n\n}\n\n\nvoid DtwPath_set_path(struct DtwPath *self, const char *target_path) {\n    free(self->path);\n    self->path = private_dtw_format_path(target_path);\n}\n\n\nvoid DtwPath_add_start_dir(struct DtwPath *self, const char *start_dir){\n    char *element = dtw_concat_path(start_dir,self->path);\n    free(self->path);\n    self->path = private_dtw_format_path(element);\n    free(element);\n}\n\nvoid DtwPath_add_end_dir(struct DtwPath *self, const char *end_dir){\n    const char *dir = DtwPath_get_dir(self);\n    if(!dir){\n        dir = \"\";\n    }\n    const char * full_name = DtwPath_get_full_name(self);\n    if(!full_name){\n        full_name = \"\";\n    }\n    free(self->path);\n\n    char *buffer = private_dtw_formatt(\"%s/%s/%s\",dir,end_dir,full_name);\n    self->path = private_dtw_format_path(buffer);\n    free(buffer);\n}\n\nvoid DtwPath_replace_dirs(DtwPath *self,const char *str,const char *dir){\n    char *self_dir = DtwPath_get_dir(self);\n\n    char *formatted_entry = NULL;\n    if(dtw_starts_with(self_dir,str)){\n       formatted_entry = private_dtw_formatt(\"%s/\",dir);\n    }\n    else{\n        formatted_entry = private_dtw_formatt(\"/%s/\",dir);\n\n    }\n    char * formated_dir = dtw_replace_string(self_dir,str,formatted_entry);\n    DtwPath_set_dir(self,formated_dir);\n    free(formated_dir);\n    free(formatted_entry);\n\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/path/setters/setters.h",
		"is_binary":	false,
		"content":	"\n\nvoid DtwPath_set_extension(struct DtwPath *self, const char *extension);\n\n\nvoid DtwPath_set_name(struct DtwPath * self, const char * name);\n\n\nvoid DtwPath_set_full_name(struct DtwPath * self, const char * full_name);\n\n\nvoid DtwPath_set_dir(struct DtwPath *self, const char *dir);\n\n\n\nvoid DtwPath_set_path(struct DtwPath *self, const char *target_path);\n\n\nvoid DtwPath_add_start_dir(struct DtwPath *self, const char *start_dir);\n\n\nvoid DtwPath_add_end_dir(struct DtwPath *self, const char *end_dir);\n\n\nvoid DtwPath_replace_dirs(DtwPath *self,const char *str,const char *dir);\n"
	}, {
		"path":	"src/dependencies/doTheWorld/randonizer/"
	}, {
		"path":	"src/dependencies/doTheWorld/randonizer/randonizer.c",
		"is_binary":	false,
		"content":	"\n\n\n\nDtwRandonizer * newDtwRandonizer(){\n    DtwRandonizer *self = (DtwRandonizer*) malloc(sizeof (DtwRandonizer));\n    *self =(DtwRandonizer){0};\n\n    #ifndef DTW_DEBUG_TIME\n\n            #ifdef _WIN32\n                FILETIME ft;\n                LARGE_INTEGER li;\n\n                GetSystemTimeAsFileTime(&ft);\n                li.LowPart = ft.dwLowDateTime;\n                li.HighPart = ft.dwHighDateTime;\n\n                self->internal_seed = li.QuadPart;\n                self->internal_seed ^= GetCurrentProcessId();\n            #else\n                struct timespec ts;\n                clock_gettime(CLOCK_REALTIME, &ts);\n\n                self->internal_seed = (uint64_t)ts.tv_sec + (uint64_t)ts.tv_nsec;\n                self->internal_seed += getpid();\n            #endif\n    #endif\n    return self;\n}\n\nint DtwRandonizer_generate_num(DtwRandonizer *self,int max) {\n    self->actual_generation+=1;\n    srand(  self->internal_seed + self->actual_generation + self->seed);\n    int value = rand() % max;\n    return value;\n}\nchar * DtwRandonizer_generate_token(struct DtwRandonizer*self, int size){\n    static const char chars[] =\n            \"abcdefghijklmnopqrstuvwxyz\"\n            \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n            \"0123456789\";\n\n    int total_size = sizeof(chars) - 1;\n    char *token = (char*)malloc(size +1);\n\n    for (int i = 0; i < size; ++i) {\n        int index = DtwRandonizer_generate_num(self,total_size);\n        token[i] = chars[index];\n    }\n\n    token[size] = '\\0';\n    return token;\n}\n\nvoid DtwRandonizer_free(struct DtwRandonizer *self){\n    free(self);\n}\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/randonizer/randonizer.h",
		"is_binary":	false,
		"content":	"\n\n\ntypedef struct DtwRandonizer{\n    long internal_seed;\n    long seed;\n    long actual_generation;\n\n}DtwRandonizer;\n\n\nDtwRandonizer * newDtwRandonizer();\n\nint DtwRandonizer_generate_num(DtwRandonizer *self,int max);\n\nchar * DtwRandonizer_generate_token(struct DtwRandonizer*self, int size);\nvoid DtwRandonizer_free(struct DtwRandonizer *self);\n\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/database_schema/"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/database_schema/database_schema.c",
		"is_binary":	false,
		"content":	"\nDtwDatabaseSchema *private_newDtwDtatabaseSchema(){\n    DtwDatabaseSchema *self = (DtwDatabaseSchema*) malloc(sizeof (DtwDatabaseSchema));\n    *self = (DtwDatabaseSchema){0};\n    self->value_name = DTW_SCHEMA_DEFAULT_VALUES_NAME;\n    self->index_name = DTW_SCHEMA_DEFAULT_INDEX_NAME;\n    self->sub_schemas = (struct DtwSchema **)malloc(0);\n    return  self;\n}\n\n\nDtwSchema * privateDtwDtatabaseSchema_get_sub_schema(DtwDatabaseSchema *self,const char *name){\n\n    for(int i = 0; i < self->size; i++){\n        DtwSchema  *current = self->sub_schemas[i];\n\n        if(strcmp(current->name,name) == 0){\n            return  current;\n        }\n\n    }\n    return NULL;\n}\n\nDtwSchema * DtwDtatabaseSchema_new_subSchema(DtwDatabaseSchema *self,const char *name){\n    DtwSchema *subSchema = private_newDtwSchema(name);\n    self->sub_schemas = ( DtwSchema **) realloc(self->sub_schemas, (self->size + 1) * sizeof( DtwSchema *));\n    self->sub_schemas[self->size] = subSchema;\n    self->size+=1;\n    return subSchema;\n}\n\n\n\nvoid private_new_DtwDtatabaseSchema_free(DtwDatabaseSchema *self){\n    for (int i = 0; i < self->size; i++) {\n        private_newDtwSchema_free((DtwSchema *) self->sub_schemas[i]);\n    }\n    free(self->sub_schemas);\n    free(self);\n}\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/database_schema/database_schema.h",
		"is_binary":	false,
		"content":	"\n\n#define DTW_SCHEMA_DEFAULT_VALUES_NAME \"value\"\n#define DTW_SCHEMA_DEFAULT_INDEX_NAME \"index\"\n\n\n\ntypedef struct DtwDatabaseSchema{\n\n    const char *value_name;\n    const char *index_name;\n    struct DtwSchema **sub_schemas;\n    int size;\n}DtwDatabaseSchema;\n\nDtwDatabaseSchema *private_newDtwDtatabaseSchema();\n\nDtwSchema * privateDtwDtatabaseSchema_get_sub_schema(DtwDatabaseSchema *self,const char *name);\n\nDtwSchema * DtwDtatabaseSchema_new_subSchema(DtwDatabaseSchema *self,const char *name);\n\nvoid private_new_DtwDtatabaseSchema_free(DtwDatabaseSchema *self);\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/declaration.h",
		"is_binary":	false,
		"content":	"#include \"root_props/root_props.h\"\n#include \"schema/schema.h\"\n#include \"database_schema/database_schema.h\"\n#include \"resource/declaration.h\"\n#include \"resource_array/resource_array.h\"\n"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/definition.c",
		"is_binary":	false,
		"content":	"#include \"schema/schema.c\"\n#include \"database_schema/database_schema.c\"\n#include \"root_props/root_props.c\"\n#include \"resource/definition.c\"\n#include \"resource_array/resource_array.c\""
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/constructors_and_desctructors/"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/constructors_and_desctructors/constructors_and_destructors.c",
		"is_binary":	false,
		"content":	"\n\nDtwResource *new_DtwResource(const char *path){\n    DtwResource *self = (DtwResource*) malloc(sizeof (DtwResource));\n    *self =(DtwResource){0};\n\n    self->path = strdup(path);\n    self->name = strdup(path);\n    self->sub_resources = newDtwResourceArray();\n    self->allow_transaction = true;\n    self->use_locker_on_unique_values = true;\n    self->cache_sub_resources = true;\n    self->root_props = private_newDtwResourceRootProps();\n\n    return self;\n}   \n\nDtwResource * DtwResource_sub_resource(DtwResource *self,const  char *format, ...){\n    if(DtwResource_error(self)){\n        return NULL;\n    }\n\n\n    privateDtwResource_ensure_its_possible_to_sub_resource(self);\n\n    if(DtwResource_error(self)){\n        return NULL;\n    }\n\n\n    if(self->were_renamed){\n        private_DtwResource_raise_error(\n                self,\n                DTW_RESOURCE_RENAMED_RESOURCE_CANNOT_HAVE_SONS,\n                \"you cannot create a sub resurce from a renamed resource\",\n                self->name\n        );\n        return NULL;\n    }\n\n\n    va_list args;\n    va_start(args, format);\n    char *name = private_dtw_format_vaarg(format,args);\n    va_end(args);\n\n\n    DtwResource * Already_Exist = DtwResourceArray_get_by_name((DtwResourceArray*)self->sub_resources,name);\n    if(Already_Exist){\n        free(name);\n        return Already_Exist;\n    }\n\n    DtwResource *new_element = (DtwResource*) malloc(sizeof (DtwResource));\n    *new_element =(DtwResource){0};\n\n    if(self->schema_type == PRIVATE_DTW_SCHEMA_VALUE){\n        new_element->schema_type = PRIVATE_DTW_SCHEMA_ELEMENT;\n    }\n    if(self->schema_type ==PRIVATE_DTW_SCHEMA_ELEMENT){\n        new_element->schema_type = PRIVATE_DTW_SCHEMA_ELEMENT_PROP;\n    }\n\n    if(self->schema_type == PRIVATE_DTW_SCHEMA_INDEX){\n        new_element->schema_type = PRIVATE_DTW_SCHEMA_PK_FOLDER;\n    }\n    if(self->schema_type == PRIVATE_DTW_SCHEMA_PK_FOLDER){\n        new_element->schema_type = PRIVATE_DTW_SCHEMA_PK_VALUE;\n    }\n\n\n\n    new_element->allow_transaction = self->allow_transaction;\n    new_element->use_locker_on_unique_values = self->use_locker_on_unique_values;\n    new_element->root_props = self->root_props;\n    //copied elements\n\n    new_element->mother = self;\n    new_element->path = dtw_concat_path(self->path, name);\n    new_element->name = strdup(name);\n\n\n    new_element->cache_sub_resources = self->cache_sub_resources;\n    new_element->sub_resources = newDtwResourceArray();\n\n    if(self->datatabase_schema && self->root_props->is_writing_schema == false){\n        new_element->attached_schema = privateDtwDtatabaseSchema_get_sub_schema(self->datatabase_schema, name);\n    }\n\n    if(self->schema_type == PRIVATE_DTW_SCHEMA_ELEMENT){\n        DtwResource * ancestor = self->mother->mother;\n        new_element->attached_schema = privateDtwSchema_get_sub_schema(ancestor->attached_schema, name);\n    }\n\n\n\n    if(new_element->attached_schema){\n        self->root_props->is_writing_schema = true;\n        new_element->schema_type = PRIVATE_DTW_SCHEMA_ROOT;\n        new_element->values_resource = DtwResource_sub_resource(new_element,DTW_SCHEMA_DEFAULT_VALUES_NAME);\n        new_element->values_resource->schema_type = PRIVATE_DTW_SCHEMA_VALUE;\n        new_element->index_resource = DtwResource_sub_resource(new_element,DTW_SCHEMA_DEFAULT_INDEX_NAME);\n        new_element->index_resource->schema_type = PRIVATE_DTW_SCHEMA_INDEX;\n    }\n\n\n\n    if(self->cache_sub_resources){\n        DtwResourceArray_append((DtwResourceArray*)self->sub_resources,new_element);\n    }\n\n\n    free(name);\n    return new_element;\n\n}\nDtwResource * DtwResource_sub_resource_ensuring_not_exist(DtwResource *self,const  char *format, ...){\n    if(DtwResource_error(self)){\n        return NULL;\n    }\n    va_list args;\n    va_start(args, format);\n    char *name = private_dtw_format_vaarg(format,args);\n    va_end(args);\n;\n\n    DtwResource *possible_emptiy  = DtwResourceArray_get_by_name(\n            (DtwResourceArray*)self->sub_resources,\n            name\n    );\n    if(possible_emptiy){\n        return NULL;\n    }\n\n    bool old_cache_value = self->cache_sub_resources;\n    self->cache_sub_resources = false;\n    possible_emptiy = DtwResource_sub_resource(self,\"%s\",name);\n    possible_emptiy->cache_sub_resources = old_cache_value;\n    self->cache_sub_resources = old_cache_value;\n    if(self->use_locker_on_unique_values){\n        DtwResource_lock(possible_emptiy);\n    }\n\n    int type = DtwResource_type(possible_emptiy);\n\n    if(type == DTW_NOT_FOUND){\n\n\n            if(self->cache_sub_resources){\n                DtwResourceArray_append((DtwResourceArray*)self->sub_resources,possible_emptiy);\n            }\n            free(name);\n            return possible_emptiy;\n    }\n    DtwResource_unlock(possible_emptiy);\n    DtwResource_free(possible_emptiy);\n    free(name);\n    return  NULL;\n\n}\n\nvoid DtwResource_free(DtwResource *self){\n    if(!self){\n        return;\n    }\n\n    bool is_root = self->mother == NULL;\n    if(is_root){\n        privateDtwResourceRootProps_free(self->root_props);\n    }\n\n    if(self->datatabase_schema){\n        private_new_DtwDtatabaseSchema_free(self->datatabase_schema);\n    }\n\n    DtwResourceArray_free((DtwResourceArray*)self->sub_resources);\n\n\n\n    if(self->value_any){\n        free(self->value_any);\n    }\n\n\n    free(self->path);\n    free(self->name);\n    free(self);\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/constructors_and_desctructors/constructors_and_destructors.h",
		"is_binary":	false,
		"content":	"\n\nDtwResource *new_DtwResource(const char *path);\n\nDtwResource * DtwResource_sub_resource(DtwResource *self,const  char *format, ...);\n\nDtwResource * DtwResource_sub_resource_ensuring_not_exist(DtwResource *self,const  char *format, ...);\n\nvoid DtwResource_free(DtwResource *self);"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/custom_constructors/"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/custom_constructors/custom_constructors.c",
		"is_binary":	false,
		"content":	"\n\nDtwResource * DtwResource_sub_resource_next(DtwResource *self, const char *end_path){\n    if(DtwResource_error(self)){\n        return NULL;\n    }\n    long  size = dtw_get_total_itens_of_dir(self->path);\n    if(size < 0){\n        size = 0;\n    }\n    while(true){\n\n        char *path = NULL;\n        if(end_path){\n            path = private_dtw_realoc_formatting(path,\"%ld%s\",size,end_path);\n        }\n\n        else{\n            path = private_dtw_realoc_formatting(path,\"%ld\",size);\n        }\n\n        DtwResource *new_element = DtwResource_sub_resource_ensuring_not_exist(self,\"%s\",path);\n        free(path);\n        if(DtwResource_error(self)){\n            return NULL;\n        }\n\n        if(new_element){\n            return new_element;\n        }\n        size = size+1;\n    }\n}\n\n\nDtwResource * DtwResource_sub_resource_now(DtwResource *self, const char *end_path){\n    if(DtwResource_error(self)){\n        return NULL;\n    }\n    bool empty_already_exist = false;\n\n\n    while(true){\n\n        long now = dtw_get_time();\n        char *time = dtw_convert_unix_time_to_string(now);\n        char *path = NULL;\n\n        if(empty_already_exist){\n            char *token = DtwRandonizer_generate_token(self->root_props->randonizer,10);\n            path = private_dtw_realoc_formatting(path,\"%s--%s\",time,token);\n            free(token);\n        }\n        else{\n            path = private_dtw_realoc_formatting(path,\"%s\",time);\n        }\n\n        free(time);\n\n        if(end_path){\n            path = private_dtw_realoc_formatting(path,\"%s%s\",path,end_path);\n        }\n\n        DtwResource *new_element = DtwResource_sub_resource_ensuring_not_exist(self,\"%s\",path);\n\n        free(path);\n\n\n        if(DtwResource_error(self)){\n            return NULL;\n        }\n        if(new_element){\n            return new_element;\n        }\n        empty_already_exist = true;\n    }\n}\n\n\nDtwResource * DtwResource_sub_resource_now_in_unix(DtwResource *self, const char *end_path){\n    if(DtwResource_error(self)){\n        return NULL;\n    }\n    bool empty_already_exist = false;\n\n    while(true){\n\n        long now = dtw_get_time();\n        char *path = NULL;\n\n        if(empty_already_exist){\n            char *token = DtwRandonizer_generate_token(self->root_props->randonizer,10);\n            path = private_dtw_realoc_formatting(path,\"%ld--%s\",now,token);\n            free(token);\n        }\n        else{\n            path = private_dtw_realoc_formatting(path,\"%ld\",now);\n        }\n\n        if(end_path){\n            path = private_dtw_realoc_formatting(path,\"%s%s\",path,end_path);\n        }\n\n        DtwResource *new_element = DtwResource_sub_resource_ensuring_not_exist(self,\"%s\",path);\n\n        free(path);\n\n\n        if(DtwResource_error(self)){\n            return NULL;\n        }\n        if(new_element){\n            return new_element;\n        }\n        empty_already_exist = true;\n    }\n}\n\nDtwResource * DtwResource_sub_resource_random(DtwResource *self, const char *end_path){\n    if(DtwResource_error(self)){\n        return NULL;\n    }\n    while(true){\n\n        char *path = NULL;\n        char *token = DtwRandonizer_generate_token(self->root_props->randonizer,15);\n        path = private_dtw_realoc_formatting(path,\"%s\",token);\n        free(token);\n\n        if(end_path){\n            path = private_dtw_realoc_formatting(path,\"%s%s\",path,end_path);\n        }\n\n        DtwResource *new_element = DtwResource_sub_resource_ensuring_not_exist(self,\"%s\",path);\n        free(path);\n        if(DtwResource_error(self)){\n            return NULL;\n        }\n\n        if(new_element){\n            return new_element;\n        }\n\n    }\n}\n\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/custom_constructors/custom_constructors.h",
		"is_binary":	false,
		"content":	"\n\nDtwResource * DtwResource_sub_resource_next(DtwResource *self, const char *end_path);\n\n\nDtwResource * DtwResource_sub_resource_now(DtwResource *self, const char *end_path);\n\nDtwResource * DtwResource_sub_resource_now_in_unix(DtwResource *self, const char *end_path);\n\nDtwResource * DtwResource_sub_resource_random(DtwResource *self, const char *end_path);\n\n\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/declaration.h",
		"is_binary":	false,
		"content":	"#include \"resource.h\"\n#include \"constructors_and_desctructors/constructors_and_destructors.h\"\n#include \"custom_constructors/custom_constructors.h\"\n#include \"destroy/destroy.h\"\n#include \"extras/extras.h\"\n#include \"getters/getters.h\"\n#include \"loaders_and_unloaders/loaders_and_unloaders.h\"\n#include \"schema/schema.h\"\n#include \"setters/setters.h\"\n#include \"sub_resource_setters/sub_resource_setters.h\"\n"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/definition.c",
		"is_binary":	false,
		"content":	"#include \"constructors_and_desctructors/constructors_and_destructors.c\"\n#include \"custom_constructors/custom_constructors.c\"\n#include \"destroy/destroy.c\"\n#include \"extras/extras.c\"\n#include \"getters/getters.c\"\n#include \"loaders_and_unloaders/loaders_and_unloaders.c\"\n#include \"schema/schema.c\"\n#include \"setters/setters.c\"\n#include \"sub_resource_setters/sub_resource_setters.c\"\n"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/destroy/"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/destroy/destroy.c",
		"is_binary":	false,
		"content":	"\nvoid private_DtwResurce_destroy_primary_key(DtwResource *self) {\n\n\n    if (!DtwResource_is_file(self)) {\n        return;\n    }\n\n    DtwResource *root = self->mother->mother->mother;\n    DtwResource *pk_index_folder = DtwResource_sub_resource(root->index_resource, \"%s\", self->name);\n    long size;\n    bool is_binary;\n    unsigned char *possible_pk_value = DtwResource_get_any(self, &size, &is_binary);\n    char *pk_sha = dtw_generate_sha_from_any(possible_pk_value, size);\n\n    DtwResource *pk_index_value = DtwResource_sub_resource(pk_index_folder, \"%s\", pk_sha);\n\n    if(DtwResource_error(self)){\n        return;\n    }\n\n    free(pk_sha);\n    if (self->allow_transaction) {\n        DtwTransaction_delete_any(self->root_props->transaction, pk_index_value->path);\n    } else {\n        dtw_remove_any(pk_index_value->path);\n    }\n\n\n}\nvoid private_DtwResource_destroy_all_primary_keys(DtwResource *self){\n    DtwSchema * schema = (DtwSchema*)self->mother->mother->attached_schema;\n    for(int i = 0; i < schema->primary_keys->size; i++){\n        char *current_pk = schema->primary_keys->strings[i];\n        DtwResource *son = DtwResource_sub_resource(self,\"%s\",current_pk);\n        private_DtwResurce_destroy_primary_key(son);\n\n        if(DtwResource_error(self)){\n            return;\n        }\n\n    }\n}\nvoid DtwResource_destroy(DtwResource *self){\n    if(DtwResource_error(self)){\n        return;\n    }\n\n\n    if(self->schema_type == PRIVATE_DTW_SCHEMA_ELEMENT){\n        self->root_props->is_writing_schema = true;\n        private_DtwResource_destroy_all_primary_keys(self);\n        self->root_props->is_writing_schema =false;\n    }\n\n    if(private_DtwResource_its_a_pk(self)){\n        self->root_props->is_writing_schema = true;\n        private_DtwResurce_destroy_primary_key(self);\n        self->root_props->is_writing_schema =false;\n\n    }\n\n    if(DtwResource_error(self)){\n        return;\n    }\n\n    if(self->root_props->is_writing_schema == false){\n        if(\n                self->schema_type == PRIVATE_DTW_SCHEMA_VALUE\n                || self->schema_type == PRIVATE_DTW_SCHEMA_INDEX\n                || self->schema_type == PRIVATE_DTW_SCHEMA_PK_FOLDER\n                || self->schema_type == PRIVATE_DTW_SCHEMA_PK_VALUE\n        ){\n            private_DtwResource_raise_error(\n                    self,\n                    DTW_RESOURCE_ONLY_ROOT_SCHEMA_CANN_MODIFY_SCHEMA_PROPS,\n                    \"you cannot delete a internal schema part\"\n            );\n        }\n    }\n\n    if(DtwResource_error(self)){\n        return;\n    }\n\n\n    if(self->allow_transaction){\n        DtwTransaction_delete_any(self->root_props->transaction,self->path);\n    }\n    else{\n        dtw_remove_any(self->path);\n    }\n\n}\n\nvoid DtwResource_destroy_sub_resource(DtwResource *self, const char *key){\n    if(DtwResource_error(self)){\n        return;\n    }\n    DtwResource *son = DtwResource_sub_resource(self, \"%s\",key);\n    DtwResource_destroy(son);\n}\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/destroy/destroy.h",
		"is_binary":	false,
		"content":	"\nvoid private_DtwResurce_destroy_primary_key(DtwResource *self);\n\n\nvoid private_DtwResource_destroy_all_primary_keys(DtwResource *self);\n\nvoid DtwResource_destroy(DtwResource *self);\n\n\nvoid DtwResource_destroy_sub_resource(DtwResource *self, const char *key);\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/extras/"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/extras/extras.c",
		"is_binary":	false,
		"content":	"\n\n\nbool DtwResource_error(DtwResource *self){\n    if(self==NULL){\n        return true;\n    }\n    if(DtwResource_get_error_code(self) == DTW_RESOURCE_OK){\n        return false;\n    }\n    return true;\n}\n\n\n\nint DtwResource_get_error_code(DtwResource *self){\n    if(self == NULL){\n        return DTW_RESOURCE_ELEMENT_IS_NULL;\n    }\n    return self->root_props->error_code;\n}\nchar * DtwResource_get_error_path(DtwResource *self){\n    if(self == NULL){\n        return NULL;\n    }\n\n    if(self->root_props == NULL){\n        return NULL;\n    }\n    return self->root_props->error_path;\n}\n\n\nchar * DtwResource_get_error_message(DtwResource *self){\n\n    if(self== NULL){\n        return (char*)\"element its null\";\n    }\n\n    return self->root_props->error_message;\n}\nvoid  DtwResource_clear_errors(DtwResource *self){\n    if(!DtwResource_error(self)){\n        return;\n    }\n    free(self->root_props->error_message);\n    self->root_props->error_message = NULL;\n    free(self->root_props->error_path);\n    self->root_props->error_path = NULL;\n    self->root_props->error_code = DTW_RESOURCE_OK;\n\n}\n\n\nvoid  private_DtwResource_raise_error(DtwResource *self, int error_code, const char *format,...){\n\n    va_list args;\n    va_start(args, format);\n    char *error_message = private_dtw_format_vaarg(format,args);\n    va_end(args);\n\n    self->root_props->error_code = error_code;\n    self->root_props->error_path = strdup(self->path);\n    self->root_props->error_message = dtw_replace_string(error_message,\"#path#\",self->path);\n    free(error_message);\n}\n\nvoid DtwResource_rename(DtwResource *self,const char *new_name){\n    if(DtwResource_error(self)){\n        return;\n    }\n    if(private_DtwResource_its_a_pk(self)){\n        private_DtwResource_raise_error(\n                self,\n                DTW_IMPOSSIBLE_TO_RENAME_A_PRIMARY_KEY,\n                \"primary key %s cannot be renamed\",\n                self->name\n        );\n        return;\n    }\n    DtwResourceArray *sons =(DtwResourceArray*)self->sub_resources;\n    if(sons->size > 0){\n        private_DtwResource_raise_error(\n                self,\n                DTW_RESOURCE_RENAMED_RESOURCE_CANNOT_HAVE_SONS,\n                \"you cannot rename a resource with active sons\",\n                self->name\n        );\n        return;\n    }\n\n    self->were_renamed = true;\n    char *old_path = strdup(self->path);\n    free(self->path);\n    free(self->name);\n\n    if(self->mother){\n        self->path  = dtw_concat_path(self->mother->path, new_name);\n    }\n    if(self->mother==NULL){\n        self->path = strdup(new_name);\n    }\n\n    self->name = strdup(new_name);\n\n    if(self->allow_transaction){\n        DtwTransaction_move_any(self->root_props->transaction,old_path,self->path);\n    }\n    else{\n        dtw_move_any(old_path,self->path,DTW_NOT_MERGE);\n    }\n\n    free(old_path);\n\n}\n\nvoid DtwResource_rename_sub_resource(DtwResource *self,const char *old_name,const  char *new_name){\n    if(DtwResource_error(self)){\n        return;\n    }\n    DtwResource *created = DtwResource_sub_resource(self,\"name\");\n    DtwResource_rename(created,new_name);\n}\n\nint DtwResource_lock(DtwResource *self){\n    if(DtwResource_error(self)){\n        return -1;\n    }\n    return DtwLocker_lock(self->root_props->locker, self->path);\n}\n\nvoid DtwResource_unlock(DtwResource *self){\n    if(DtwResource_error(self)){\n        return ;\n    }\n    DtwLocker_unlock(self->root_props->locker, self->path);\n    \n}\n\n\n\nvoid DtwResource_commit(DtwResource *self){\n    if(DtwResource_error(self)){\n        return ;\n    }\n    DtwTransaction_commit(self->root_props->transaction,NULL);\n}\n\nlong DtwResource_size(DtwResource *self){\n    if(DtwResource_error(self)){\n        return -1;\n    }\n    return dtw_get_total_itens_of_dir(self->path);\n}\n\n\n\nDtwStringArray *DtwResource_list_names(DtwResource *self){\n    if(DtwResource_error(self)){\n        return NULL;\n    }\n    return dtw_list_all(self->path,DTW_NOT_CONCAT_PATH);\n}\n\nint DtwResource_type(DtwResource *self){\n    if(DtwResource_error(self)){\n        return -1;\n    }\n    DtwResource_load_if_not_loaded(self);\n\n    if(self->value_any == NULL){\n        return dtw_entity_type(self->path);\n    }\n\n    if(self->value_size == 0){\n        return DTW_COMPLEX_STRING_TYPE;\n    }\n    if(self->is_binary){\n        return DTW_COMPLEX_BINARY;\n    }\n\n    char *data_in_string = DtwResource_get_string(self);\n\n    if(\n            strcmp(data_in_string,\"t\") == 0 || strcmp(data_in_string,\"true\") == 0  ||\n                    strcmp(data_in_string,\"f\") == 0 || strcmp(data_in_string,\"false\") == 0\n\n    ){\n        return DTW_COMPLEX_BOOL_TYPE;\n    }\n\n\n    double data_double;\n    int result = sscanf(data_in_string,\"%lf\",&data_double);\n    if(result == 0){\n        return DTW_COMPLEX_STRING_TYPE;\n\n    }\n\n\n    for(int i = 0; i < self->value_size; i++){\n        char current = data_in_string[i];\n        if(current == '.'){\n            return  DTW_COMPLEX_DOUBLE_TYPE;\n        }\n    }\n    return  DTW_COMPLEX_LONG_TYPE;\n\n}\nbool DtwResource_is_file(DtwResource *self){\n    if(DtwResource_error(self)){\n        return -1;\n    }\n    DtwResource_load_if_not_loaded(self);\n\n    if(self->value_any){\n        return true;\n    }\n    return  false;\n\n}\n\nconst char * DtwResource_type_in_str(DtwResource *self){\n    if(DtwResource_error(self)){\n        return NULL;\n    }\n     return dtw_convert_entity(DtwResource_type(self));\n}\n\nvoid DtwResource_represent(DtwResource *self){\n    if(DtwResource_error(self)){\n        return;\n    }\n\n    if(DtwResource_error(self)){\n        printf(\"error code: %d\\n\", DtwResource_get_error_code(self));\n        printf(\"error message: %s\\n\", DtwResource_get_error_message(self));\n        return ;\n    }\n\n    printf(\"path: %s\\n\", self->path);\n    printf(\"name: %s\\n\",self->name);\n    if(self->loaded){\n        printf(\"type: %s\\n\",DtwResource_type_in_str(self));\n        int type = DtwResource_type(self);\n        if(type == DTW_COMPLEX_STRING_TYPE){\n            printf(\"value: %s\\n\", DtwResource_get_string(self));\n        }\n        if(type == DTW_COMPLEX_LONG_TYPE){\n            printf(\"value: %ld\\n\", DtwResource_get_long(self));\n        }\n\n        if(type == DTW_COMPLEX_DOUBLE_TYPE){\n            printf(\"value: %lf\\n\", DtwResource_get_double(self));\n        }\n\n        if(type == DTW_COMPLEX_BOOL_TYPE){\n            printf(\"value: %s\\n\",DtwResource_get_bool(self) ?\"true\": \"false\");\n        }\n\n    }\n\n\n}\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/extras/extras.h",
		"is_binary":	false,
		"content":	"\n\n\nbool DtwResource_error(DtwResource *self);\n\nint DtwResource_get_error_code(DtwResource *self);\n\n\nchar * DtwResource_get_error_message(DtwResource *self);\n\nchar * DtwResource_get_error_path(DtwResource *self);\n\nvoid  DtwResource_clear_errors(DtwResource *self);\n\n\nvoid  private_DtwResource_raise_error(DtwResource *self, int error_code, const char *format,...);\n\nvoid DtwResource_rename(DtwResource *self,const char *new_name);\n\nvoid DtwResource_rename_sub_resource(DtwResource *self,const char *old_name,const  char *new_name);\n\nint DtwResource_lock(DtwResource *self);\n\nvoid DtwResource_unlock(DtwResource *self);\n\n\nvoid DtwResource_commit(DtwResource *self);\n\nlong DtwResource_size(DtwResource *self);\n\n\n\nDtwStringArray *DtwResource_list_names(DtwResource *self);\n\nint DtwResource_type(DtwResource *self);\n\nbool DtwResource_is_file(DtwResource *self);\n\n\nconst char * DtwResource_type_in_str(DtwResource *self);\n\nvoid DtwResource_represent(DtwResource *self);\n"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/getters/"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/getters/getters.c",
		"is_binary":	false,
		"content":	"\nunsigned char *DtwResource_get_any(DtwResource *self, long *size, bool *is_binary){\n    if(DtwResource_error(self)){\n        return NULL;\n    }\n    DtwResource_load_if_not_loaded(self);\n    *size = self->value_size;\n    *is_binary = self->is_binary;\n\n    if(!self->value_any){\n        private_DtwResource_raise_error(\n                self,\n                DTW_RESOURCE_ELEMENT_NOT_EXIST,\n                \"element at #path# not exist\"\n                );\n        return NULL;\n    }\n\n    return self->value_any;\n\n\n}\n\nunsigned char *DtwResource_get_any_from_sub_resource(DtwResource *self, long *size, bool *is_binary,const char *format,...){\n    if(DtwResource_error(self)){\n        return NULL;\n    }\n    va_list args;\n    va_start(args, format);\n    char *name = private_dtw_format_vaarg(format,args);\n    va_end(args);\n\n    DtwResource *element = DtwResource_sub_resource(self,\"%s\",name);\n    free(name);\n    return DtwResource_get_any(element,size,is_binary);\n\n}\n\nunsigned char *DtwResource_get_binary(DtwResource *self, long *size){\n    if(DtwResource_error(self)){\n        return NULL;\n    }\n    bool is_binary;\n\n    return DtwResource_get_any(self,size,&is_binary);\n}\n\nunsigned char *DtwResource_get_binary_from_sub_resource(DtwResource *self, long *size,const char *format,...){\n    if(DtwResource_error(self)){\n        return NULL;\n    }\n\n    va_list args;\n    va_start(args, format);\n    char *name = private_dtw_format_vaarg(format,args);\n    va_end(args);\n\n    DtwResource *element = DtwResource_sub_resource(self,\"%s\",name);\n    free(name);\n    return DtwResource_get_binary(element,size);\n}\n\n\nchar *DtwResource_get_string(DtwResource *self){\n    if(DtwResource_error(self)){\n        return NULL;\n    }\n\n    long size;\n    bool is_binary;\n    char *result =  (char *)DtwResource_get_any(self,&size,&is_binary);\n\n    if(is_binary){\n        private_DtwResource_raise_error(\n                self,\n                DTW_RESOURCE_ELEMENT_NOT_STRING,\n                \"element at #path# its an binary\"\n        );\n        return NULL;\n    }\n\n    return result;\n}\n\n\nchar *DtwResource_get_string_from_sub_resource(DtwResource *self,const char *format,...){\n    if(DtwResource_error(self)){\n        return NULL;\n    }\n\n    va_list args;\n    va_start(args, format);\n    char *name = private_dtw_format_vaarg(format,args);\n    va_end(args);\n\n\n    DtwResource *element = DtwResource_sub_resource(self,\"%s\",name);\n    free(name);\n    return DtwResource_get_string(element);\n}\n\n\nlong DtwResource_get_long(DtwResource *self){\n\n    if(DtwResource_error(self)){\n        return -1;\n    }\n\n    char *element = DtwResource_get_string(self);\n\n    if(DtwResource_error(self)){\n        return -1;\n    }\n\n    long value;\n    int result = sscanf(element,\"%ld\",&value);\n    if(result == 0){\n        private_DtwResource_raise_error(\n                self,\n                DTW_RESOURCE_ELEMENT_NOT_LONG,\n                \"element at #path# its not long\"\n        );\n        return -1;\n    }\n    return value;\n}\n\n\nlong DtwResource_get_long_from_sub_resource(DtwResource *self,const char *format,...){\n    if(DtwResource_error(self)){\n        return -1;\n    }\n    va_list args;\n    va_start(args, format);\n    char *name = private_dtw_format_vaarg(format,args);\n    va_end(args);\n\n\n    DtwResource *element = DtwResource_sub_resource(self,\"%s\",name);\n    free(name);\n    return DtwResource_get_long(element);\n}\n\n\ndouble DtwResource_get_double(DtwResource *self){\n    if(DtwResource_error(self)){\n        return -1;\n    }\n\n    char *element = DtwResource_get_string(self);\n    if(DtwResource_error(self)){\n        return -1;\n    }\n\n    double value;\n    int result = sscanf(element,\"%lf\",&value);\n    if(result == 0){\n        private_DtwResource_raise_error(\n                self,\n                DTW_RESOURCE_ELEMENT_NOT_DOUBLE,\n                \"element at #path# its not long\"\n        );\n        return-1;\n    }\n    return value;\n}\n\ndouble DtwResource_get_double_from_sub_resource(DtwResource *self,const char *format,...){\n\n    if(DtwResource_error(self)){\n        return -1;\n    }\n\n    va_list args;\n    va_start(args, format);\n    char *name = private_dtw_format_vaarg(format,args);\n    va_end(args);\n\n\n    DtwResource *element = DtwResource_sub_resource(self,\"%s\",name);\n    free(name);\n    return DtwResource_get_double(element);\n}\n\n\nbool DtwResource_get_bool(DtwResource *self){\n    if(DtwResource_error(self)){\n        return false;\n    }\n    char *element = DtwResource_get_string(self);\n    if(DtwResource_error(self)){\n        return false;\n    }\n\n    if(strcmp(element,\"true\") == 0 || strcmp(element,\"t\") == 0){\n        return true;\n    }\n    if(strcmp(element,\"false\") == 0 || strcmp(element,\"f\") == 0){\n        return false;\n    }\n\n    private_DtwResource_raise_error(\n            self,\n            DTW_RESOURCE_ELEMENT_NOT_BOOL,\n            \"element at #path# its not bool\"\n    );\n    return false;\n}\n\nbool DtwResource_get_bool_from_sub_resource(DtwResource *self,const char *format,...){\n    if(DtwResource_error(self)){\n        return false;\n    }\n\n    va_list args;\n    va_start(args, format);\n    char *name = private_dtw_format_vaarg(format,args);\n    va_end(args);\n\n    DtwResource *element = DtwResource_sub_resource(self,\"%s\",name);\n    free(name);\n    return DtwResource_get_bool(element);\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/getters/getters.h",
		"is_binary":	false,
		"content":	"\nunsigned char *DtwResource_get_any(DtwResource *self, long *size, bool *is_binary);\n\n\nunsigned char *DtwResource_get_any_from_sub_resource(DtwResource *self, long *size, bool *is_binary,const char *format,...);\n\nunsigned char *DtwResource_get_binary(DtwResource *self, long *size);\n\nunsigned char *DtwResource_get_binary_from_sub_resource(DtwResource *self, long *size,const char *format,...);\n\nchar *DtwResource_get_string(DtwResource *self);\n\nchar *DtwResource_get_string_from_sub_resource(DtwResource *self,const char *format,...);\n\n\nlong DtwResource_get_long(DtwResource *self);\n\n\n\nlong DtwResource_get_long_from_sub_resource(DtwResource *self,const char *format,...);\n\n\ndouble DtwResource_get_double(DtwResource *self);\n\ndouble DtwResource_get_double_from_sub_resource(DtwResource *self,const char *format,...);\n\nbool DtwResource_get_bool(DtwResource *self);\n\nbool DtwResource_get_bool_from_sub_resource(DtwResource *self,const char *format,...);\n"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/loaders_and_unloaders/"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/loaders_and_unloaders/loaders_and_unloaders.c",
		"is_binary":	false,
		"content":	"\n\nvoid DtwResource_unload(DtwResource *self){\n    if(DtwResource_error(self)){\n        return ;\n    }\n    if(self->loaded == false){\n        return;\n    }\n    if(self->value_any){\n        free(self->value_any);\n    }\n\n    self->value_any = NULL;\n    self->is_binary = false;\n    self->value_size = 0;\n}\n\nvoid DtwResource_load(DtwResource *self){\n    if(DtwResource_error(self)){\n        return ;\n    }\n    DtwResource_unload(self);\n    self->value_any = dtw_load_any_content(self->path,&self->value_size,&self->is_binary);\n\n    self->loaded = true;\n\n}\nvoid DtwResource_load_if_not_loaded(DtwResource *self){\n    if(DtwResource_error(self)){\n        return ;\n    }\n    if(self->loaded == false){\n        DtwResource_load(self);\n    }\n}\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/loaders_and_unloaders/loaders_and_unloaders.h",
		"is_binary":	false,
		"content":	"\n\nvoid DtwResource_unload(DtwResource *self);\n\n\nvoid DtwResource_load(DtwResource *self);\n\nvoid DtwResource_load_if_not_loaded(DtwResource *self);\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/resource.h",
		"is_binary":	false,
		"content":	"\n\ntypedef struct DtwResource{\n\n    bool allow_transaction;\n    bool use_locker_on_unique_values;\n\n\n    privateDtwResourceRootProps *root_props;\n    struct DtwResource *mother;\n    char *name;\n    char *path;\n\n\n\n\n    //in the schema struct there is:\n    //|/root\n    //|/root/values\n    //|root/values/element  <-----------------------------|\n    //|root/values/element/pk_name ->any(write_point)     |\n    //|root/values/element/element_prop ->any(write_point)|\n    //|root/index                                         |\n    //|root/index/pk_name/pk_sha ->txt  -------------------\n    DtwSchema *attached_schema;\n    DtwDatabaseSchema *datatabase_schema;\n    struct DtwResource *values_resource;\n    struct DtwResource *index_resource;\n    int schema_type;\n\n    bool loaded;\n    bool is_binary;\n    bool were_renamed;\n    unsigned char *value_any;\n    long value_size;\n   \n    //cache implementation\n    bool cache_sub_resources;\n    void *sub_resources;\n\n}DtwResource;\n\n\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/schema/"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/schema/schema.c",
		"is_binary":	false,
		"content":	"\nbool private_DtwResource_its_a_pk(DtwResource *self){\n    if(self->schema_type != PRIVATE_DTW_SCHEMA_ELEMENT_PROP){\n        return false;\n    }\n    DtwResource *ancestor = self->mother->mother->mother;\n    DtwSchema * schema = ancestor->attached_schema;\n    return DtwStringArray_find_position(schema->primary_keys,self->name) !=-1;\n}\n\nvoid privateDtwResource_ensure_its_possible_to_sub_resource(DtwResource *self){\n\n    if(self->root_props->is_writing_schema){\n        return;\n    }\n\n    if(self->schema_type == 0){\n\n        return;\n    }\n\n\n    if(self->schema_type != PRIVATE_DTW_SCHEMA_ELEMENT && self->schema_type != PRIVATE_DTW_SCHEMA_ELEMENT_PROP){\n\n        private_DtwResource_raise_error(\n                self,\n                DTW_RESOURCE_IMPOSSIBLE_TO_ADD_SUB_RESOURCE_INSIDE_SCHEMA_STRUCT,\n                \"impossible to add sub resource inside schema struct \"\n        );\n        return ;\n    }\n\n    if(private_DtwResource_its_a_pk(self)){\n        private_DtwResource_raise_error(\n                self,\n                DTW_RESOURCE_PRIMARY_KEY_CANNOT_HAVE_SUB_RESOURCE,\n                \"primary key %s cannot have a sub resource\",\n                self->name\n        );\n        return;\n    }\n\n}\n\n\nDtwResource * DtwResource_new_schema_insertion(DtwResource *self){\n\n    if(DtwResource_error(self)){\n        return NULL;\n    }\n    if(self->schema_type != PRIVATE_DTW_SCHEMA_ROOT || self->datatabase_schema){\n        private_DtwResource_raise_error(\n                self,\n                DTW_RESOURCE_IMPSSIBLE_TO_ADD_INSERTION_OUTSIDE_ROOT_SCHEMA,\n                \"only root schema can generate insertions\");\n        return NULL;\n    }\n    self->root_props->is_writing_schema = true;\n\n    DtwResource  *created = DtwResource_sub_resource_random(self->values_resource,NULL);\n    self->root_props->is_writing_schema = false;\n    return created;\n}\n\nDtwResource  *DtwResource_find_by_name_id(DtwResource *self, const char *name){\n\n    if(DtwResource_error(self)){\n        return NULL;\n    }\n    if(self->schema_type != PRIVATE_DTW_SCHEMA_ROOT){\n        private_DtwResource_raise_error(\n                self,\n                DTW_RESOURCE_ONLY_ROOT_SCHEMA_CAN_FIND_BY_ID_OR_PK,\n                \"only root schema can find by id or pk\"\n                );\n        return NULL;\n    }\n    self->root_props->is_writing_schema = true;\n\n    DtwResource *element = DtwResource_sub_resource(self->values_resource,name);\n\n    if(DtwResource_type(element) == DTW_NOT_FOUND){\n        return NULL;\n    }\n    self->root_props->is_writing_schema = false;\n\n    return element;\n}\nDtwResource * DtwResource_find_by_primary_key_with_binary(DtwResource *self, const char *primary_key, unsigned  char *value, long size){\n    if(DtwResource_error(self)){\n        return NULL;\n    }\n    if(self->schema_type != PRIVATE_DTW_SCHEMA_ROOT){\n        private_DtwResource_raise_error(\n                self,\n                DTW_RESOURCE_ONLY_ROOT_SCHEMA_CAN_FIND_BY_ID_OR_PK,\n                \"only root schema can find by id or pk\"\n                );\n        return NULL;\n    }\n    self->root_props->is_writing_schema = true;\n\n    DtwResource *primary_key_folder = DtwResource_sub_resource(self->index_resource, \"%s\", primary_key);\n    char *sha = dtw_generate_sha_from_any(value,size);\n    DtwResource *index_value = DtwResource_sub_resource(primary_key_folder,\"%s\",sha);\n    free(sha);\n    if(DtwResource_type(index_value) == DTW_NOT_FOUND){\n        return NULL;\n    }\n    char *element_folder = DtwResource_get_string(index_value);\n    if(DtwResource_error(self)){\n        return NULL;\n    }\n    if(element_folder == NULL){\n        return NULL;\n    }\n\n    DtwResource *founded_resource = DtwResource_sub_resource(self->values_resource, \"%s\", element_folder);\n    self->root_props->is_writing_schema = false;\n    return founded_resource;\n}\n\n\n\nDtwResource * DtwResource_find_by_primary_key_with_string(DtwResource *self, const char *key, const char *value){\n    if(DtwResource_error(self)){\n        return NULL;\n    }\n    return DtwResource_find_by_primary_key_with_binary(self,key,(unsigned char*)value, (long)strlen(value));\n}\n\n\nvoid DtwResource_dangerous_remove_schema_prop(DtwResource*self,const char *prop){\n    if(DtwResource_error(self)){\n        return ;\n    }\n    if(self->schema_type != PRIVATE_DTW_SCHEMA_ROOT){\n        private_DtwResource_raise_error(\n                self,\n                DTW_RESOURCE_ONLY_ROOT_SCHEMA_CANN_MODIFY_SCHEMA_PROPS,\n                \"only root schema can modify schema props\"\n        );\n        return;\n    }\n    self->root_props->is_writing_schema = true;\n\n    bool allow_transaction = self->allow_transaction;\n\n    DtwResourceArray * all_values = DtwResource_sub_resources(self->values_resource);\n    DtwTransaction * transaction = self->root_props->transaction;\n    for(int i = 0; i < all_values->size; i++){\n        DtwResource *current = all_values->resources[i];\n        DtwResource *prop_to_remove = DtwResource_sub_resource(current,\"%s\",prop);\n        if(allow_transaction){\n            DtwTransaction_delete_any(transaction,prop_to_remove->path);\n        }else{\n            dtw_remove_any(prop_to_remove->path);\n        }\n\n    }\n    DtwResource *index_element = DtwResource_sub_resource(self->index_resource,\"%s\",prop);\n    if(allow_transaction){\n        DtwTransaction_delete_any(transaction,index_element->path);\n    }else{\n        dtw_remove_any(index_element->path);\n    }\n    self->root_props->is_writing_schema = false;\n\n}\n\n\nvoid DtwResource_dangerous_rename_schema_prop(DtwResource*self,const char *prop,const char *new_name){\n    if(DtwResource_error(self)){\n        return ;\n    }\n    if(self->schema_type != PRIVATE_DTW_SCHEMA_ROOT){\n        private_DtwResource_raise_error(\n                self,\n                DTW_RESOURCE_ONLY_ROOT_SCHEMA_CANN_MODIFY_SCHEMA_PROPS,\n                \"only root schema can modify schema props\"\n        );\n        return;\n    }\n    self->root_props->is_writing_schema = true;\n    bool allow_transaction = self->allow_transaction;\n\n    DtwResourceArray * all_values = DtwResource_sub_resources(self->values_resource);\n    DtwTransaction * transaction = self->root_props->transaction;\n    for(int i = 0; i < all_values->size; i++){\n        DtwResource *current = all_values->resources[i];\n        DtwResource *prop_to_remove = DtwResource_sub_resource(current,\"%s\",prop);\n        DtwResource *new_prop = DtwResource_sub_resource(current,\"%s\",new_name);\n        if(allow_transaction){\n            DtwTransaction_move_any_merging(transaction,prop_to_remove->path,new_prop->path);\n        }else{\n            dtw_move_any(prop_to_remove->path,new_prop->path,DTW_MERGE);\n        }\n\n    }\n\n\n    DtwResource *index_element = DtwResource_sub_resource(self->index_resource,\"%s\",prop);\n    DtwResource *new_index = DtwResource_sub_resource(self->index_resource,\"%s\",new_name);\n    if(allow_transaction){\n        DtwTransaction_move_any_merging(transaction,index_element->path,new_index->path);\n    }else{\n        dtw_move_any(index_element->path,new_index->path,DTW_MERGE);\n    }\n    self->root_props->is_writing_schema = false;\n\n}\n\n\n\nDtwDatabaseSchema * DtwResource_newDatabaseSchema(DtwResource *self){\n    if(DtwResource_error(self)){\n        return  NULL;\n    }\n    privateDtwResource_ensure_its_possible_to_sub_resource(self);\n\n    if(DtwResource_error(self)){\n        return  NULL;\n    }\n\n    if(self->datatabase_schema){\n        return self->datatabase_schema;\n    }\n\n    self->datatabase_schema = private_newDtwDtatabaseSchema();\n    return self->datatabase_schema;\n}\n"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/schema/schema.h",
		"is_binary":	false,
		"content":	"\n#define PRIVATE_DTW_SCHEMA_ROOT  1\n#define PRIVATE_DTW_SCHEMA_VALUE 2\n#define PRIVATE_DTW_SCHEMA_ELEMENT 3\n#define PRIVATE_DTW_SCHEMA_ELEMENT_PROP 4\n#define PRIVATE_DTW_SCHEMA_INDEX 5\n#define PRIVATE_DTW_SCHEMA_PK_FOLDER 6\n#define PRIVATE_DTW_SCHEMA_PK_VALUE 7\n\nbool private_DtwResource_its_a_pk(DtwResource *self);\n\nvoid privateDtwResource_ensure_its_possible_to_sub_resource(DtwResource *self);\n\nDtwResource * DtwResource_new_schema_insertion(DtwResource *self);\n\nDtwResource  *DtwResource_find_by_name_id(DtwResource *self, const char *name);\n\nDtwResource * DtwResource_find_by_primary_key_with_binary(DtwResource *self, const char *primary_key, unsigned  char *value, long size);\n\nDtwResource * DtwResource_find_by_primary_key_with_string(DtwResource *self, const char *key, const char *value);\n\nvoid DtwResource_dangerous_remove_schema_prop(DtwResource*self,const char *prop);\n\nvoid DtwResource_dangerous_rename_schema_prop(DtwResource*self,const char *prop,const char *new_name);\n\n\n\nDtwDatabaseSchema * DtwResource_newDatabaseSchema(DtwResource *self);\n"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/setters/"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/setters/setters.c",
		"is_binary":	false,
		"content":	"//\n// Created by mateusmoutinho on 05/08/23.\n//\nvoid private_dtw_resource_set_primary_key(DtwResource *self, unsigned  char *element, long size){\n\n    self->root_props->is_writing_schema = true;\n    DtwResource * ancestor = self->mother->mother->mother;\n    DtwResource *index_resource =ancestor->index_resource;\n    DtwResource *pk_folder = DtwResource_sub_resource(index_resource,\"%s\",self->name);\n\n    char *sha = dtw_generate_sha_from_any(element,size);\n    DtwResource  *pk_value = DtwResource_sub_resource(pk_folder,sha);\n    free(sha);\n    char *mothers_name =self->mother->name;\n\n    if(DtwResource_is_file(pk_value)) {\n        char *content = DtwResource_get_string(pk_value);\n        if (DtwResource_error(self)) {\n            self->root_props->is_writing_schema = false;\n            return;\n        }\n\n        //means its the same\n        if (strcmp(content, mothers_name) == 0) {\n            self->root_props->is_writing_schema = false;\n            return;\n        }\n\n        private_DtwResource_raise_error(\n                self,\n                DTW_RESOURCE_PRIMARY_KEY_ALREADY_EXIST,\n                \"primary key: %s already exist\",\n                self->name\n        );\n        self->root_props->is_writing_schema = false;\n        return;\n\n    }\n    DtwResource_set_string(pk_value,mothers_name);\n    self->root_props->is_writing_schema = false;\n\n}\nvoid DtwResource_set_any(DtwResource *self, unsigned char *element, long size,bool is_binary){\n    if(DtwResource_error(self)){\n        return ;\n    }\n    DtwResource_unload(self);\n\n    if(private_DtwResource_its_a_pk(self)){\n        private_dtw_resource_set_primary_key(self, element, size);\n    }\n\n    if(DtwResource_error(self)){\n        return;\n    }\n\n    if(self->allow_transaction){\n        DtwTransaction_write_any(self->root_props->transaction,self->path,element,size,is_binary);\n    }\n    else{\n        dtw_write_any_content(self->path,element,size);\n    }\n\n    self->loaded = true;\n    self->value_size = size;\n    self->is_binary = is_binary;\n    self->value_any = (unsigned  char *) malloc(size+1);\n\n    self->value_any[size]= '\\0';\n    memcpy(self->value_any,element,size);\n}\nvoid DtwResource_set_binary(DtwResource *self, unsigned char *element, long size){\n    DtwResource_set_any(self,element,size,true);\n}\n\nvoid DtwResource_set_string(DtwResource *self,const  char *element){\n    DtwResource_set_any(self,(unsigned char *)element,strlen(element),false);\n}\n\nvoid DtwResource_set_binary_sha(DtwResource *self, unsigned  char *value, long size){\n    if(DtwResource_error(self)){\n        return ;\n    }\n    char *generated_sha = dtw_generate_sha_from_any(value,size);\n    DtwResource_set_string(self,generated_sha);\n    free(generated_sha);\n}\n\nvoid DtwResource_set_string_sha(DtwResource *self,const char *value){\n    if(DtwResource_error(self)){\n        return ;\n    }\n    DtwResource_set_binary_sha(self,(unsigned char*)value, (long)strlen(value));\n}\n\n\n\n\n\n\n\n\nvoid DtwResource_set_long(DtwResource *self,long element){\n    if(DtwResource_error(self)){\n        return ;\n    }\n    if(self->allow_transaction){\n        DtwTransaction_write_long(self->root_props->transaction,self->path,element);\n    }\n    else{\n        dtw_write_long_file_content(self->path,element);\n    }\n    DtwResource_unload(self);\n    self->loaded = true;\n    char result[20] ={0};\n    sprintf(result,\"%ld\",element);\n    self->value_any = (unsigned char *)strdup(result);\n\n}\n\nvoid DtwResource_set_double(DtwResource *self,double element){\n    if(DtwResource_error(self)){\n        return ;\n    }\n    if(self->allow_transaction){\n        DtwTransaction_write_double(self->root_props->transaction,self->path,element);\n    }\n    else{\n        dtw_write_double_file_content(self->path,element);\n    }\n    DtwResource_unload(self);\n    self->loaded = true;\n    char result[20] ={0};\n    sprintf(result,\"%lf\",element);\n    self->value_any = (unsigned char *)strdup(result);\n\n\n}\n\nvoid DtwResource_set_bool( DtwResource *self,bool element){\n    if(DtwResource_error(self)){\n        return ;\n    }\n    if(self->allow_transaction){\n        DtwTransaction_write_bool(self->root_props->transaction,self->path,element);\n    }\n    else{\n        dtw_write_bool_file_content(self->path,element);\n    }\n\n    DtwResource_unload(self);\n    self->loaded = true;\n    if(element){\n        self->value_any = (unsigned char*)strdup(\"true\");\n    }\n    else{\n        self->value_any = (unsigned char*)strdup(\"false\");\n\n    }\n\n}\n"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/setters/setters.h",
		"is_binary":	false,
		"content":	"//\n// Created by mateusmoutinho on 05/08/23.\n//\nvoid private_dtw_resource_set_primary_key(DtwResource *self, unsigned  char *element, long size);\n\nvoid DtwResource_set_any(DtwResource *self, unsigned char *element, long size,bool is_binary);\n\nvoid DtwResource_set_binary(DtwResource *self, unsigned char *element, long size);\n\n\nvoid DtwResource_set_string(DtwResource *self,const  char *element);\n\nvoid DtwResource_set_binary_sha(DtwResource *self, unsigned  char *value, long size);\n\n\nvoid DtwResource_set_string_sha(DtwResource *self,const char *value);\n\n\nvoid DtwResource_set_long(DtwResource *self,long element);\n\n\nvoid DtwResource_set_double(DtwResource *self,double element);\n\nvoid DtwResource_set_bool( DtwResource *self,bool element);\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/sub_resource_setters/"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/sub_resource_setters/sub_resource_setters.c",
		"is_binary":	false,
		"content":	"\nvoid DtwResource_set_any_in_sub_resource(DtwResource *self,const char *key, unsigned char *element, long size,bool is_binary) {\n    if(DtwResource_error(self)){\n        return ;\n    }\n\n    DtwResource *created = DtwResource_sub_resource(self,\"%s\",key);\n    DtwResource_set_any(created, element, size,is_binary);\n}\n\nvoid DtwResource_set_binary_in_sub_resource(DtwResource *self,const char *key, unsigned char *element, long size){\n    if(DtwResource_error(self)){\n        return ;\n    }\n\n    DtwResource *created = DtwResource_sub_resource(self,\"%s\",key);\n    DtwResource_set_binary(created, element, size);\n}\n\nvoid DtwResource_set_binary_sha_in_sub_resource(DtwResource *self, const char *key, unsigned  char *value, long size){\n    if(DtwResource_error(self)){\n        return ;\n    }\n    DtwResource *created = DtwResource_sub_resource(self,\"%s\",key);\n    DtwResource_set_binary_sha(created,value,size);\n}\n\n\nvoid DtwResource_set_string_sha_in_sub_resource(DtwResource *self, const char *key, const char *value){\n    if(DtwResource_error(self)){\n        return ;\n    }\n    DtwResource *created = DtwResource_sub_resource(self,\"%s\",key);\n    DtwResource_set_string_sha(created,value);\n}\n\nvoid DtwResource_set_string_in_sub_resource(DtwResource *self, const char *key, const  char *element){\n    if(DtwResource_error(self)){\n        return ;\n    }\n\n    DtwResource *created = DtwResource_sub_resource(self,\"%s\",key);\n    DtwResource_set_string(created,element);\n}\n\nvoid DtwResource_set_long_in_sub_resource(DtwResource *self, const char *key, long element){\n    if(DtwResource_error(self)){\n        return ;\n    }\n    DtwResource *created = DtwResource_sub_resource(self,\"%s\",key);\n    DtwResource_set_long(created,element);\n}\n\nvoid DtwResource_set_double_in_sub_resource(DtwResource *self, const char *key, double element){\n    if(DtwResource_error(self)){\n        return ;\n    }\n\n    DtwResource *created = DtwResource_sub_resource(self,\"%s\",key);\n    DtwResource_set_double(created,element);\n}\n\nvoid DtwResource_set_bool_in_sub_resource(DtwResource *self,const char *key, bool element){\n    if(DtwResource_error(self)){\n        return ;\n    }\n\n    DtwResource *created = DtwResource_sub_resource(self,\"%s\",key);\n    DtwResource_set_bool(created,element);\n}\n"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource/sub_resource_setters/sub_resource_setters.h",
		"is_binary":	false,
		"content":	"\nvoid DtwResource_set_any_in_sub_resource(DtwResource *self,const char *key, unsigned char *element, long size,bool is_binary);\n\n\nvoid DtwResource_set_binary_in_sub_resource(DtwResource *self,const char *key, unsigned char *element, long size);\n\n\nvoid DtwResource_set_binary_sha_in_sub_resource(DtwResource *self, const char *key, unsigned  char *value, long size);\n\n\nvoid DtwResource_set_string_sha_in_sub_resource(DtwResource *self, const char *key, const char *value);\n\nvoid DtwResource_set_string_in_sub_resource(DtwResource *self, const char *key, const  char *element);\n\nvoid DtwResource_set_long_in_sub_resource(DtwResource *self, const char *key, long element);\n\nvoid DtwResource_set_double_in_sub_resource(DtwResource *self, const char *key, double element);\n\nvoid DtwResource_set_bool_in_sub_resource(DtwResource *self,const char *key, bool element);\n"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource_array/"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource_array/resource_array.c",
		"is_binary":	false,
		"content":	"\n\n\nDtwResourceArray * newDtwResourceArray(){\n    DtwResourceArray *self = (DtwResourceArray*) malloc(sizeof (DtwResourceArray));\n    self->resources = (DtwResource**) malloc(0);\n    self->size = 0;\n    return self;\n}\n\n\nvoid DtwResourceArray_append(DtwResourceArray *self, DtwResource *element){\n    self->resources = (DtwResource**)realloc(self->resources,(self->size +1) * sizeof (DtwResource**));\n    self->resources[self->size] = element;\n    self->size+=1;\n}\n\n\nDtwResource* DtwResourceArray_get_by_name(DtwResourceArray *self, const char *name){\n    for(int i = 0; i < self->size; i++){\n        DtwResource *current = self->resources[i];\n        if(strcmp(current->name,name) ==0){\n            return current;\n        }\n    }\n    return NULL;\n}\n\nDtwResourceArray * DtwResource_get_schema_values(DtwResource *self){\n    if(DtwResource_error(self)){\n        return NULL;\n    }\n    self->root_props->is_writing_schema = true;\n\n    if(self->schema_type != PRIVATE_DTW_SCHEMA_ROOT){\n        private_DtwResource_raise_error(\n                self,\n                DTW_RESOURCE_ONLY_ROOT_SCHEMA_HAVE_SCHEMA_VALUES,\n                \"only root schema have schema values\"\n        );\n        return NULL;\n    }\n\n    DtwResourceArray *elements =  DtwResource_sub_resources(self->values_resource);\n    self->root_props->is_writing_schema = false;\n    return elements;\n}\n\n\nDtwResourceArray * DtwResource_sub_resources(DtwResource *self){\n\n\n\n    DtwStringArray  *names  = DtwResource_list_names(self);\n    DtwStringArray_sort(names);\n    DtwResourceArray *target_array = (DtwResourceArray*)self->sub_resources;\n\n    if(self->cache_sub_resources == false){\n        target_array = newDtwResourceArray();\n    }\n\n    for(int i = 0; i < names->size; i++){\n        char *current_name = names->strings[i];\n\n        if(self->cache_sub_resources){\n            DtwResource_sub_resource(self,\"%s\", current_name);\n        }\n        \n        else{\n            DtwResource *current_resource = DtwResource_sub_resource(self,\"%s\",current_name);\n            DtwResourceArray_append(target_array,current_resource);\n        }\n    }\n\n    DtwStringArray_free(names);\n    return target_array;\n\n\n}\n\n\nvoid DtwResourceArray_represent(DtwResourceArray *self){\n    for(int i = 0; i< self->size; i++){\n        printf(\"----------------------------------------\\n\");\n        DtwResource_represent(self->resources[i]);\n    }\n}\n\nvoid DtwResourceArray_free(DtwResourceArray *self){\n    for(int i = 0; i < self->size; i++){\n        DtwResource_free(self->resources[i]);\n\n    }\n    free(self->resources);\n    free(self);\n}\n"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/resource_array/resource_array.h",
		"is_binary":	false,
		"content":	"\n\n\ntypedef struct DtwResourceArray{\n    DtwResource **resources;\n    long size;\n\n}DtwResourceArray;\n\nDtwResourceArray * newDtwResourceArray();\n\nvoid DtwResourceArray_append(DtwResourceArray *self, DtwResource *element);\n\n\nDtwResource * DtwResourceArray_get_by_name(DtwResourceArray *self, const char *name);\n\nDtwResourceArray * DtwResource_get_schema_values(DtwResource *self);\n\nDtwResourceArray * DtwResource_sub_resources(DtwResource *self);\n\n\nvoid DtwResourceArray_represent(DtwResourceArray *self);\n\nvoid DtwResourceArray_free(DtwResourceArray *self);\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/root_props/"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/root_props/root_props.c",
		"is_binary":	false,
		"content":	"\n\nprivateDtwResourceRootProps *private_newDtwResourceRootProps(){\n    privateDtwResourceRootProps *self  = (privateDtwResourceRootProps*) malloc(sizeof (privateDtwResourceRootProps));\n    *self = (privateDtwResourceRootProps){0};\n    self->transaction = newDtwTransaction();\n    self->randonizer = newDtwRandonizer();\n    self->locker = newDtwLocker();\n    self->error_code = DTW_RESOURCE_OK;\n\n    return self;\n}\n\n\nvoid privateDtwResourceRootProps_free(privateDtwResourceRootProps *self){\n    DtwTransaction_free(self->transaction);\n    DtwRandonizer_free(self->randonizer);\n    DtwLocker_free(self->locker);\n    if(self->error_path){\n        free(self->error_path);\n    }\n\n    if(self->error_message){\n        free(self->error_message);\n    }\n\n\n\n    free(self);\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/root_props/root_props.h",
		"is_binary":	false,
		"content":	"#define DTW_RESOURCE_ELEMENT_IS_NULL -1\n#define DTW_RESOURCE_OK 0\n#define DTW_RESOURCE_ELEMENT_NOT_EXIST 1\n#define DTW_RESOURCE_ELEMENT_NOT_BOOL 2\n#define DTW_RESOURCE_ELEMENT_NOT_LONG 3\n#define DTW_RESOURCE_ELEMENT_NOT_DOUBLE 4\n#define DTW_RESOURCE_ELEMENT_NOT_STRING 5\n#define DTW_RESOURCE_PRIMARY_KEY_ALREADY_EXIST 6\n#define DTW_RESOURCE_PRIMARY_KEY_CANNOT_HAVE_SUB_RESOURCE 7\n#define DTW_IMPOSSIBLE_TO_RENAME_A_PRIMARY_KEY 8\n#define DTW_RESOURCE_RENAMED_RESOURCE_CANNOT_HAVE_SONS 9\n#define DTW_RESOURCE_IMPSSIBLE_TO_ADD_INSERTION_OUTSIDE_ROOT_SCHEMA 10\n#define DTW_RESOURCE_IMPOSSIBLE_TO_ADD_SUB_RESOURCE_INSIDE_SCHEMA_STRUCT 11\n#define DTW_RESOURCE_ONLY_ROOT_SCHEMA_CAN_FIND_BY_ID_OR_PK 12\n#define DTW_RESOURCE_ONLY_ROOT_SCHEMA_HAVE_SCHEMA_VALUES 13\n#define DTW_RESOURCE_ONLY_ROOT_SCHEMA_CANN_MODIFY_SCHEMA_PROPS 14\n\ntypedef struct {\n    DtwTransaction  *transaction;\n    DtwRandonizer  *randonizer;\n    DtwLocker *locker;\n    bool is_writing_schema;\n    int error_code;\n    char *error_path;\n    char *error_message;\n    \n}privateDtwResourceRootProps;\n\nprivateDtwResourceRootProps *private_newDtwResourceRootProps();\n\n\nvoid privateDtwResourceRootProps_free(privateDtwResourceRootProps *self);\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/schema/"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/schema/schema.c",
		"is_binary":	false,
		"content":	"\nDtwSchema *private_newDtwSchema(const char *name){\n    DtwSchema *self = (DtwSchema*) malloc(sizeof (DtwSchema));\n    *self = (DtwSchema){0};\n    self->value_name = DTW_SCHEMA_DEFAULT_VALUES_NAME;\n    self->index_name = DTW_SCHEMA_DEFAULT_INDEX_NAME;\n    self->sub_schemas = ( DtwSchema **)malloc(0);\n    if(name){\n        self->primary_keys = newDtwStringArray();\n        self->name = strdup(name);\n    }\n\n    return  self;\n}\n\n\nDtwSchema * privateDtwSchema_get_sub_schema(DtwSchema *self,const char *name){\n\n    for(int i = 0; i < self->size; i++){\n        DtwSchema  *current = self->sub_schemas[i];\n\n        if(strcmp(current->name,name) == 0){\n            return  current;\n        }\n    }\n    return NULL;\n}\n\nDtwSchema * DtwSchema_new_subSchema(DtwSchema *self,const char *name){\n    DtwSchema *subSchema = private_newDtwSchema(name);\n    self->sub_schemas = ( DtwSchema **) realloc(self->sub_schemas, (self->size + 1) * sizeof( DtwSchema *));\n    self->sub_schemas[self->size] = subSchema;\n    self->size+=1;\n    return subSchema;\n}\n\n\nvoid DtwSchema_add_primary_key(DtwSchema *self,const char *name){\n    DtwStringArray_append(self->primary_keys,name);\n}\n\nvoid private_newDtwSchema_free(DtwSchema *self){\n\n    for (int i = 0; i < self->size; i++) {\n        private_newDtwSchema_free((DtwSchema *) self->sub_schemas[i]);\n    }\n\n    free(self->sub_schemas);\n    if(self->name){\n        free(self->name);\n    }\n    if(self->primary_keys){\n        DtwStringArray_free(self->primary_keys);\n    }\n    free(self);\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/resource/schema/schema.h",
		"is_binary":	false,
		"content":	"\n\ntypedef struct DtwSchema{\n\n\n    const char *value_name;\n    const char *index_name;\n\n    char *name;\n    struct DtwSchema **sub_schemas;\n    int size;\n    DtwStringArray  *primary_keys;\n}DtwSchema;\n\nDtwSchema *private_newDtwSchema(const char *name);\n\nDtwSchema * privateDtwSchema_get_sub_schema(DtwSchema *self,const char *name);\n\n\nDtwSchema * (DtwSchema_new_subSchema)(DtwSchema *self,const char *name);\n\nvoid DtwSchema_add_primary_key(DtwSchema *self,const char *name);\n\nvoid private_newDtwSchema_free(DtwSchema *self);\n"
	}, {
		"path":	"src/dependencies/doTheWorld/sha256/"
	}, {
		"path":	"src/dependencies/doTheWorld/sha256/sha256.c",
		"is_binary":	false,
		"content":	"char * calc_sha_256_returning_string(const void *input, size_t len)\n{\n\n\n    uint8_t hash[SIZE_OF_SHA_256_HASH];\n    calc_sha_256(hash, input, len);\n    char *hash_string = (char*)malloc(SIZE_OF_SHA_256_HASH * 2 + 1);\n    for (unsigned int i = 0; i < SIZE_OF_SHA_256_HASH; i++) {\n        sprintf(hash_string + i * 2, \"%02x\", hash[i]);\n    }\n    return hash_string;\n}\n\nvoid  calc_sha_256_from_string(uint8_t hash[SIZE_OF_SHA_256_HASH], const char *input)\n{\n    calc_sha_256(hash, input, strlen(input));\n\n}\n\nchar * calc_sha_256_from_string_returning_string(const char *input)\n{\n    return calc_sha_256_returning_string(input, strlen(input));\n}\n\nint calc_sha_256_from_file(uint8_t hash[SIZE_OF_SHA_256_HASH], const char *filename)\n{\n    int size;\n    char *content = sha256_open_file(filename, &size);\n    if(content == NULL){\n        return -1;\n    }\n    calc_sha_256(hash, content, size);\n    free(content);\n    return 0;\n}\n\nchar * calc_sha_256_from_file_returning_string(const char *filename)\n{\n    int size;\n    char *content = sha256_open_file(filename, &size);\n    if(content == NULL){\n        return NULL;\n    }\n    char *hash_string = calc_sha_256_returning_string(content, size);\n    free(content);\n    return hash_string;\n\n}\nchar * sha256_open_file(const char *filename, int *size){\n    FILE *file = fopen(filename, \"rb\");\n    if (file == NULL) {\n        return NULL;\n    }\n    fseek(file,0,SEEK_END);\n    *size = ftell(file);\n    fseek(file,0,SEEK_SET);\n    char *content = (char*)malloc(*size +1);\n    fread(content,1,*size,file);\n    fclose(file);\n    return content;\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/sha256/sha256.h",
		"is_binary":	false,
		"content":	"\nchar * calc_sha_256_returning_string(const void *input, size_t len);\n/*\n    @param input: the string to be hashed\n    @param len: the length of the string\n    @return: the hash of the string\n    @note: if the input string is NULL, the results are unpredictable\n*/\n\nvoid calc_sha_256_from_string(uint8_t hash[SIZE_OF_SHA_256_HASH], const char *input);\n/*\n    @param hash: the hash array, where the result is delivered\n    @param input: the string to be hashed\n    @note: if the input string is NULL, the results are unpredictable\n*/\n\nint calc_sha_256_from_file(uint8_t hash[SIZE_OF_SHA_256_HASH], const char *filename);\n/*\n    @param hash: the hash array, where the result is delivered\n    @param filename: the name of the file to be hashed\n    @return: 0 if the file was hashed successfully, -1 otherwise\n*/\n\nchar * calc_sha_256_from_file_returning_string(const char *filename);\n/*\n    @param filename: the name of the file to be hashed\n    @return: the hash of the file\n    @note: if the filename is NULL, the return value is NULL\n*/\nchar * sha256_open_file(const char *filename, int *size);\n"
	}, {
		"path":	"src/dependencies/doTheWorld/string_array/"
	}, {
		"path":	"src/dependencies/doTheWorld/string_array/string_array.c",
		"is_binary":	false,
		"content":	"\nstruct DtwStringArray * newDtwStringArray(){\n    struct DtwStringArray *self = (struct DtwStringArray*)malloc(sizeof(struct DtwStringArray));\n    self->size = 0;\n\n    self->strings = (char**)malloc(1);\n\n    return self;\n}\n\nint DtwStringArray_find_position(struct DtwStringArray *self, const char *string){\n    for(int i = 0; i < self->size; i++){\n        if(strcmp(self->strings[i], string) == 0){\n            return i;\n        }\n    }\n    return -1;\n}\n\n\nvoid DtwStringArray_set_value(struct DtwStringArray *self, int index, const char *value){\n    if(index < self->size && index >= 0){\n        int size = strlen(value);\n        self->strings[index] = (char*)realloc(self->strings[index], size + 1);\n        self->strings[index][size] = '\\0';\n        strcpy(self->strings[index], value);\n    }\n}\nvoid DtwStringArray_append_getting_ownership(struct DtwStringArray *self, char *string){\n    self->strings =  (char**)realloc(self->strings, (self->size+ 1) * sizeof(char*));\n    self->strings[self->size] = string;\n    self->size+=1;\n}\n\n// Function prototypes\nvoid DtwStringArray_append(struct DtwStringArray *self, const  char *string){\n\n    self->strings =  (char**)realloc(self->strings, (self->size+ 1) * sizeof(char*));\n    self->strings[self->size] = strdup(string);\n    self->size+=1;\n}\n\nvoid DtwStringArray_pop(struct DtwStringArray *self, int position){\n    free(self->strings[position]);\n    for(int i = position; i < self->size -1; i++){\n        self->strings[i] = self->strings[i+1];\n    }\n    self->size-=1;\n}\n\nvoid DtwStringArray_merge(struct DtwStringArray *self, struct DtwStringArray *other){\n    for(int i = 0; i < other->size; i++){\n        DtwStringArray_append(self, other->strings[i]);\n    }\n}\n\n\nvoid DtwStringArray_represent(struct DtwStringArray *self){\n    for(int i = 0; i < self->size; i++){\n        printf(\"%s\\n\", self->strings[i]);\n    }\n}\n\n\n\nvoid DtwStringArray_sort(struct DtwStringArray *self) {\n\n    qsort(self->strings, self->size, sizeof(char*), private_dtw_string_cmp);\n\n\n}\n\nstruct DtwStringArray * DtwStringArray_clone(DtwStringArray *self){\n    DtwStringArray  *clone = newDtwStringArray();\n    for(int i = 0; i< self->size; i++){\n        DtwStringArray_append(clone,self->strings[i]);\n    }\n    return clone;\n}\n\nchar * privateDtwStringArray_append_if_not_included(DtwStringArray *self,char *value){\n    long position=DtwStringArray_find_position(self,value);\n    if(position != -1){\n        free(value);\n        return self->strings[position];\n    }\n    DtwStringArray_append_getting_ownership(self,value);\n    return value;\n}\nvoid DtwStringArray_free(struct DtwStringArray *self){\n    for(int i = 0; i < self->size; i++){\n            free(self->strings[i]);\n    }\n\n    free(self->strings);\n    free(self);\n}\n"
	}, {
		"path":	"src/dependencies/doTheWorld/string_array/string_array.h",
		"is_binary":	false,
		"content":	"\ntypedef struct DtwStringArray {\n  int size;\n\n  char **strings;\n\n\n\n}DtwStringArray;\n\n// End the structure with a semicolon\nint  DtwStringArray_find_position(struct DtwStringArray *self, const char *string);\n\n\nvoid DtwStringArray_append_getting_ownership(struct DtwStringArray *self, char *string);\n\nvoid DtwStringArray_append(struct DtwStringArray *self, const char *string);\n\nvoid DtwStringArray_pop(struct DtwStringArray *self, int position);\n\nvoid DtwStringArray_merge(struct DtwStringArray *self, struct DtwStringArray *other);\nvoid DtwStringArray_represent(struct DtwStringArray *self);\nvoid DtwStringArray_free(struct DtwStringArray *self);\nvoid DtwStringArray_sort(struct DtwStringArray *self);\n\nvoid DtwStringArray_set_value(struct DtwStringArray *self, int index, const char *value);\n\nstruct DtwStringArray * newDtwStringArray();\n\nchar * privateDtwStringArray_append_if_not_included(DtwStringArray *self,char *value);\n\nstruct DtwStringArray * DtwStringArray_clone(DtwStringArray *self);\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/string_functions/"
	}, {
		"path":	"src/dependencies/doTheWorld/string_functions/string_functions.c",
		"is_binary":	false,
		"content":	"\n\nvoid private_dtw_remove_double_bars_from_string_array(struct DtwStringArray*path){\n    for(int i =0;i< path->size;i++){\n        char *buffer = private_dtw_format_path(path->strings[i]);\n        free(path->strings[i]);\n        path->strings[i] = buffer;\n    }\n}\n\nchar *dtw_concat_path(const char *path1, const char *path2){\n\n    if(!path1){\n        return strdup(path2);\n    }\n\n    if(!path2){\n        return strdup(path1);\n    }\n\n    char *path = (char *)malloc(strlen(path1) + strlen(path2) + 3);\n\n    if(dtw_ends_with(path1, \"/\") || dtw_ends_with(path1, \"\\\\\")){\n        sprintf(path,\"%s%s\",path1,path2);\n\n    }\n    else{\n        sprintf(path,\"%s/%s\",path1,path2);\n\n    }\n    return path;\n}\n\nchar * private_dtw_format_vaarg(const char *expresion, va_list args){\n\n    va_list args_copy;\n    va_copy(args_copy, args);\n    long required_size = vsnprintf(NULL, 0,expresion,args_copy);\n    va_end(args_copy);\n    char *buffer = (char*)malloc(sizeof(char) * required_size + 2);\n    vsnprintf(buffer,sizeof (char) * required_size+1,expresion,args);\n    return buffer;\n}\n\nchar *private_dtw_format_path(const char *path){\n    int path_size = (int)strlen(path);\n    char *buffer = (char*)malloc((path_size+2) * sizeof(char));\n    int buffer_size = 0;\n    bool already_concatened = false;\n    for(long i = 0; i < path_size;i++){\n        char current_char = path[i];\n\n        bool is_a_divisor =current_char == '\\\\' || current_char == '/';\n\n        if(is_a_divisor && already_concatened){\n            continue;\n        }\n        if(is_a_divisor){\n#ifdef __linux\n            buffer[buffer_size] = '/';\n#else\n            buffer[buffer_size] = '\\\\';\n#endif\n            buffer_size+=1;\n            already_concatened = true;\n            continue;\n        }\n\n        already_concatened = false;\n        buffer[buffer_size] = current_char;\n        buffer_size+=1;\n\n    }\n    buffer[buffer_size] = '\\0';\n    return buffer;\n}\n\n\nchar * private_dtw_sub_str(const char *str, long start,long end){\n    long size = end - start;\n    char *value = (char*)malloc(size+ 2);\n\n    for(long i = 0; i <size; i++){\n        value[i] = str[i+start];\n    }\n    value[size] = '\\0';\n    return value;\n}\n\nint private_dtw_string_cmp(const void *a, const void *b){\n    const char *str_a = *(const char **)a;\n    const char *str_b = *(const char **)b;\n    return strcmp(str_a, str_b);\n}\n\n\nbool dtw_starts_with(const char *string, const char *prefix){\n    if(!string || !prefix){\n        return false;\n    }\n    if(strncmp(string, prefix, strlen(prefix)) == 0){\n        return true;\n    }\n    return false;\n}\n\nbool dtw_ends_with(const char *string, const char *suffix){\n    if(strlen(string) < strlen(suffix)){\n        return false;\n    }\n    if(strcmp(string + strlen(string) - strlen(suffix), suffix) == 0){\n        return true;\n    }\n    return false;\n}\n\nchar *private_dtw_replace_string_once(const char *target, const char *old_element, const char *new_element) {\n\n    const char *pos = strstr(target, old_element);\n\n    int size_of_old_element = (int)strlen(old_element);\n    int size_of_new_element = (int)strlen(new_element);\n    // Allocate memory for the new string\n    char *result = (char *)malloc(strlen(target) + size_of_new_element - size_of_old_element + 1);\n\n    // Copy the part of the original string before the old substring\n    strncpy(result, target, pos - target);\n\n    // Copy the new substring to the result string\n    strcpy(result + (pos - target), new_element);\n\n    // Copy the rest of the original string after the old substring\n    strcpy(result + (pos - target) + size_of_new_element, pos + size_of_old_element);\n\n    return result;\n\n    \n\n}\n\nchar* dtw_replace_string(const char *target, const char *old_element, const char *new_element) {\n    char *result = (char *)malloc(strlen(target) + 1);\n    strcpy(result, target);\n    char *temp = NULL;\n    while (strstr(result, old_element) != NULL) {\n        temp = private_dtw_replace_string_once(result, old_element, new_element);\n        free(result);\n        result = temp;\n    }\n    return result;\n}\n\n\n\nchar *private_dtw_change_beginning_of_string(const char *target,int start_element_to_remove_size, const char *new_element) {\n    int target_size = (int)strlen(target);\n    int new_element_size = (int)strlen(new_element);\n    char *result = (char *)malloc(target_size- start_element_to_remove_size + new_element_size   +2);\n    strcpy(result, new_element);\n    char *new_target = (char *)malloc(target_size - start_element_to_remove_size + 2);\n    strcpy(new_target, target + start_element_to_remove_size);\n    strcat(result, new_target);\n    free(new_target);\n    return result;\n}\n\n\n\nchar *private_dtw_realoc_formatting(char *ptr,const char *format,...){\n\n    va_list args;\n    va_start(args, format);\n    char *value = private_dtw_format_vaarg(format,args);\n    va_end(args);\n    if(ptr){\n        free(ptr);\n    }\n\n    return value;\n}\nchar *private_dtw_formatt(const char *format,...){\n\n    va_list args;\n    va_start(args, format);\n    char *value = private_dtw_format_vaarg(format,args);\n    va_end(args);\n    return value;\n}\nbool dtw_is_string_at_point(\n        const char *str,\n        long str_size,\n        const char *target,\n        long target_size,\n        long target_point\n        ){\n\n    if(target_size + target_point > str_size){\n        return false;\n    }\n    for(long i = 0; i < target_size; i++ ){\n        char current_char = target[i];\n        char char_to_compare = str[i+target_point];\n        if(current_char != char_to_compare){\n            return  false;\n        }\n    }\n    return true;\n}\n\nlong  dtw_index_of_string(const char *str,const char *element){\n    long str_size = (long)strlen(str);\n    long element_size = (long)strlen(element);\n\n    for(int i = 0; i <str_size; i++){\n        if(dtw_is_string_at_point(str,str_size,element,element_size,i)){\n            return i;\n        }\n    }\n    return -1;\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/string_functions/string_functions.h",
		"is_binary":	false,
		"content":	"\n\nchar *dtw_concat_path(const char *path1, const char *path2);\n\nDtwStringArray* private_dtw_remove_start_path(struct DtwStringArray *paths,const char *path_to_remove);\n\nchar *private_dtw_format_path(const char *path);\n\nvoid private_dtw_remove_double_bars_from_string_array(struct DtwStringArray*path);\n\nchar * private_dtw_format_vaarg(const char *expresion, va_list args);\n\nchar *private_dtw_realoc_formatting(char *ptr,const char *format,...);\n\nchar *private_dtw_formatt(const char *format,...);\n\nchar * private_dtw_sub_str(const char *str, long start,long end);\n\nint private_dtw_string_cmp(const void *a, const void *b);\n\nbool dtw_is_string_at_point(\n        const char *str,\n        long str_size,\n        const char *target,\n        long target_size,\n        long target_point\n);\n\nlong  dtw_index_of_string(const char *str,const char *element);\n\nbool dtw_starts_with(const char *string, const char *prefix);\nbool dtw_ends_with(const char *string, const char *suffix);\nchar *private_dtw_replace_string_once(const char *target, const char *old_element, const char *new_element);\nchar* dtw_replace_string(const char *target, const char *old_element, const char *new_element);\n\nchar *private_dtw_change_beginning_of_string(const char *target,int start_element_to_remove_size, const char *new_element);\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/transaction/"
	}, {
		"path":	"src/dependencies/doTheWorld/transaction/action/"
	}, {
		"path":	"src/dependencies/doTheWorld/transaction/action/action.c",
		"is_binary":	false,
		"content":	"\n\nDtwActionTransaction * newDtwActionTransaction(){\n    DtwActionTransaction *self = (DtwActionTransaction*) malloc(sizeof (DtwActionTransaction));\n    *self= (DtwActionTransaction){0};\n    return self;\n}\n\n\nDtwActionTransaction * DtwActionTransaction_write_any(const char *source, unsigned  char *content,long size,bool is_binary){\n    DtwActionTransaction *self = newDtwActionTransaction();\n    self->action_type = DTW_ACTION_WRITE;\n    self->content = (unsigned char*)malloc(size +2);\n    memcpy(self->content,content,size);\n    self->content[size] = '\\0';\n    self->size = size;\n    self->source = strdup(source);\n    self->is_binary = is_binary;\n    return self;\n}\n\n\nDtwActionTransaction * DtwActionTransaction_move_any(const char *source, const char *dest){\n    DtwActionTransaction *self = newDtwActionTransaction();\n    self->action_type = DTW_ACTION_MOVE;\n    self->source = strdup(source);\n    self->dest = strdup(dest);\n    return self;\n\n}\n\n\nDtwActionTransaction * DtwActionTransaction_copy_any(const char *source, const char *dest){\n    DtwActionTransaction *self = newDtwActionTransaction();\n    self->action_type = DTW_ACTION_COPY;\n    self->source = strdup(source);\n    self->dest = strdup(dest);\n    return self;\n}\nDtwActionTransaction * DtwActionTransaction_move_any_merging(const char *source, const char *dest){\n    DtwActionTransaction *self = newDtwActionTransaction();\n    self->action_type = DTW_ACTION_MOVE_MERGING;\n    self->source = strdup(source);\n    self->dest = strdup(dest);\n    return self;\n}\n\nDtwActionTransaction * DtwActionTransaction_copy_any_merging(const char *source, const char *dest){\n    DtwActionTransaction *self = newDtwActionTransaction();\n    self->action_type = DTW_ACTION_COPY_MERGING;\n    self->source = strdup(source);\n    self->dest = strdup(dest);\n    return self;\n}\n\nDtwActionTransaction * DtwActionTransaction_delete_any(const char *source){\n    DtwActionTransaction *self = newDtwActionTransaction();\n    self->action_type = DTW_ACTION_DELETE;\n    self->source = strdup(source);\n    return self;\n}\n\n\n\nvoid DtwActionTransaction_commit(DtwActionTransaction* self,const char *path){\n\n    char *formated_source = dtw_concat_path(path,self->source);\n\n\n    if(self->action_type == DTW_ACTION_WRITE){\n        dtw_write_any_content(formated_source,self->content,self->size);\n        free(formated_source);\n        return;\n    }\n    if(self->action_type == DTW_ACTION_DELETE){\n        dtw_remove_any(formated_source);\n        free(formated_source);\n        return;\n    }\n    char *formated_dest = dtw_concat_path(path,self->dest);\n\n    if(self->action_type == DTW_ACTION_MOVE){\n        dtw_move_any(formated_source,formated_dest,DTW_NOT_MERGE);\n    }\n\n    if(self->action_type == DTW_ACTION_MOVE_MERGING){\n        dtw_move_any(formated_source,formated_dest,DTW_MERGE);\n    }\n\n    if(self->action_type == DTW_ACTION_COPY){\n        dtw_copy_any(formated_source,formated_dest,DTW_NOT_MERGE);\n    }\n\n    if(self->action_type == DTW_ACTION_COPY_MERGING){\n        dtw_copy_any(formated_source,formated_dest,DTW_MERGE);\n    }\n\n    free(formated_dest);\n    free(formated_source);\n\n}\n\n\nvoid DtwActionTransaction_free(DtwActionTransaction* self){\n\n    if(self->content){\n        free(self->content);\n    }\n    if(self->source){\n        free(self->source);\n    }\n    if(self->dest){\n        free(self->dest);\n    }\n    free(self);\n}\n"
	}, {
		"path":	"src/dependencies/doTheWorld/transaction/action/action.h",
		"is_binary":	false,
		"content":	"\n\nenum {\n    DTW_ACTION_FILE_NOT_FOUND,\n    DTW_ACTION_ITS_NOT_JSON,\n    DTW_ACTION_WRITE,\n    DTW_ACTION_MOVE,\n    DTW_ACTION_MOVE_MERGING,\n    DTW_ACTION_COPY,\n    DTW_ACTION_COPY_MERGING,\n    DTW_ACTION_DELETE\n};\n\n\ntypedef struct DtwActionTransaction{\n    short action_type;\n    unsigned  char *content;\n    long size;\n    bool is_binary;\n\n    char *dest;\n    char *source;\n\n}DtwActionTransaction;\n\nDtwActionTransaction *newDtwActionTransaction();\n\nDtwJsonTransactionError * private_dtw_validate_json_action_transaction(cJSON *json_obj);\n\n\nDtwActionTransaction * private_DtwActionTransaction_parse_json_object(cJSON *json_obj);\n\n\nDtwActionTransaction * DtwActionTransaction_write_any(const char *source,unsigned  char *content,long size,bool is_binary);\n\nDtwActionTransaction * DtwActionTransaction_move_any(const char *source, const char *dest);\n\nDtwActionTransaction * DtwActionTransaction_copy_any(const char *source, const char *dest);\n\nDtwActionTransaction * DtwActionTransaction_move_any_merging(const char *source, const char *dest);\n\nDtwActionTransaction * DtwActionTransaction_copy_any_merging(const char *source, const char *dest);\n\nDtwActionTransaction * DtwActionTransaction_delete_any(const char *source);\n\nshort DtwActionTransaction_convert_action_to_integer(char *action);\n\n\nconst char * DtwActionTransaction_convert_action_to_string(int action);\n\n\ncJSON *  private_DtwActionTransaction_create_json_object(DtwActionTransaction* self);\n\n\nvoid DtwActionTransaction_commit(DtwActionTransaction* self,const char *path);\n\nvoid DtwActionTransaction_represent(DtwActionTransaction* self);\n\nvoid DtwActionTransaction_free(DtwActionTransaction* self);\n"
	}, {
		"path":	"src/dependencies/doTheWorld/transaction/action/action_parsment.c",
		"is_binary":	false,
		"content":	"\nshort DtwActionTransaction_convert_action_to_integer(char *action){\n    if(strcmp(action,\"write\") == 0){\n        return DTW_ACTION_WRITE;\n    }\n\n    if(strcmp(action,\"move\") == 0){\n        return DTW_ACTION_MOVE;\n    }\n\n    if(strcmp(action,\"copy\") == 0){\n        return DTW_ACTION_COPY;\n    }\n\n    if(strcmp(action,\"delete\") == 0){\n        return DTW_ACTION_DELETE;\n    }\n    return -1;\n\n}\n\nconst char * DtwActionTransaction_convert_action_to_string(int action){\n    if(action == DTW_ACTION_WRITE){\n        return \"write\";\n    }\n    if(action == DTW_ACTION_MOVE){\n        return \"move\";\n    }\n\n    if(action == DTW_ACTION_COPY){\n        return \"copy\";\n    }\n    if(action == DTW_ACTION_DELETE){\n        return \"delete\";\n    }\n    return NULL;\n}\n\nDtwJsonTransactionError * private_dtw_validate_json_action_transaction(cJSON *json_obj){\n\n    if(json_obj->type != cJSON_Object ){\n        return private_new_DtwJsonTransactionError(\n                JSON_TRANSACTION_WRONG_TYPE,\n                \"the action object its not an object\",\n                NULL\n        );\n    }\n\n    cJSON *action = cJSON_GetObjectItem(json_obj,\"action\");\n\n    if(!action){\n        return private_new_DtwJsonTransactionError(\n                JSON_TRANSACTION_NOT_PRESENT_VALUE,\n                \"the action is not present\",\n                \"[\\\"action\\\"]\"\n        );\n    }\n\n    if(action->type != cJSON_String){\n        return private_new_DtwJsonTransactionError(\n                JSON_TRANSACTION_WRONG_TYPE,\n                \"the action is not an string\",\n                \"[\\\"action\\\"]\"\n        );\n    }\n\n\n    int converted_action = DtwActionTransaction_convert_action_to_integer(action->valuestring);\n\n    if(converted_action == -1){\n\n        char *formated_mensage = (char*)calloc(sizeof (char),strlen(action->valuestring) + 30);\n        sprintf(formated_mensage,\"the action: %s its not valid\",action->valuestring);\n        DtwJsonTransactionError  *error = private_new_DtwJsonTransactionError(\n                JSON_TRANSACTION_INVALID_ACTION,\n                formated_mensage,\n                \"[\\\"action\\\"]\"\n        );\n        free(formated_mensage);\n        return error;\n    }\n\n    if(converted_action == DTW_ACTION_WRITE){\n        cJSON  *content = cJSON_GetObjectItem(json_obj,\"content\");\n        if(!content){\n            return private_new_DtwJsonTransactionError(\n                    JSON_TRANSACTION_NOT_PRESENT_VALUE,\n                    \"the content is not present\",\n                    \"[\\\"content\\\"]\"\n            );\n        }\n        if(content->type != cJSON_String){\n            return private_new_DtwJsonTransactionError(\n                    JSON_TRANSACTION_WRONG_TYPE,\n                    \"the content is not an string\",\n                    \"[\\\"content\\\"]\"\n            );\n        }\n        cJSON *is_binary = cJSON_GetObjectItem(json_obj,\"is binary\");\n        if(is_binary){\n            if(!cJSON_IsBool(is_binary)){\n                return private_new_DtwJsonTransactionError(\n                        JSON_TRANSACTION_WRONG_TYPE,\n                        \"the is binary is not an bool\",\n                        \"[\\\"is binary\\\"]\"\n                );\n            }\n        }\n\n    }\n\n\n\n\n    cJSON *source = cJSON_GetObjectItem(json_obj,\"source\");\n    if(!source){\n        return private_new_DtwJsonTransactionError(\n                JSON_TRANSACTION_NOT_PRESENT_VALUE,\n                \"the source is not present\",\n                \"[\\\"source\\\"]\"\n        );\n    }\n\n    if(source->type != cJSON_String){\n        return private_new_DtwJsonTransactionError(\n                JSON_TRANSACTION_WRONG_TYPE,\n                \"the source is not an string\",\n                \"[\\\"source\\\"]\"\n        );\n    }\n\n    if(converted_action == DTW_ACTION_MOVE || converted_action == DTW_ACTION_COPY){\n        cJSON *dest = cJSON_GetObjectItem(json_obj,\"dest\");\n\n        if(!dest){\n            return private_new_DtwJsonTransactionError(\n                    JSON_TRANSACTION_NOT_PRESENT_VALUE,\n                    \"the dest is not present\",\n                    \"[\\\"dest\\\"]\"\n            );\n        }\n        if(dest->type != cJSON_String){\n            return private_new_DtwJsonTransactionError(\n                    JSON_TRANSACTION_WRONG_TYPE,\n                    \"the dest is not an string\",\n                    \"[\\\"dest\\\"]\"\n            );\n        }\n    }\n    return NULL;\n\n}\n\n\nDtwActionTransaction * private_DtwActionTransaction_parse_json_object(cJSON *json_obj){\n    DtwActionTransaction  *self = newDtwActionTransaction();\n\n    char *action = cJSON_GetObjectItem(json_obj,\"action\")->valuestring;\n    self->action_type  = DtwActionTransaction_convert_action_to_integer(action);\n\n    char *source = cJSON_GetObjectItem(json_obj,\"source\")->valuestring;\n    self->source = strdup(source);\n\n    if(self->action_type == DTW_ACTION_DELETE){\n        return self;\n    }\n\n    if(self->action_type == DTW_ACTION_WRITE){\n        cJSON *is_binary = cJSON_GetObjectItem(json_obj,\"is binary\");\n\n        if(is_binary){\n            if(is_binary->valueint){\n                self->is_binary= true;\n            }\n        }\n\n        char *content = cJSON_GetObjectItem(json_obj,\"content\")->valuestring;\n        if(self->is_binary){\n            self->content = dtw_base64_decode(content,&self->size);\n        }\n        else{\n            self->content =(unsigned char*)strdup(content);\n            self->size =(long)strlen(content);\n        }\n\n        return self;\n    }\n    char *dest  = cJSON_GetObjectItem(json_obj,\"dest\")->valuestring;\n    self->dest = strdup(dest);\n    return self;\n}\n\ncJSON *  private_DtwActionTransaction_create_json_object(DtwActionTransaction* self){\n    cJSON * json_object = cJSON_CreateObject();\n    cJSON_AddStringToObject(json_object,\"action\",DtwActionTransaction_convert_action_to_string(self->action_type));\n\n    cJSON_AddStringToObject(json_object,\"source\",self->source);\n    if(self->action_type ==DTW_ACTION_WRITE){\n        if(self->is_binary){\n            char *converted = dtw_base64_encode(self->content,self->size);\n            cJSON_AddStringToObject(json_object,\"content\",converted);\n            free(converted);\n            cJSON_AddBoolToObject(json_object,\"is binary\",true);\n        }\n        else{\n            cJSON_AddStringToObject(json_object,\"content\",(char*)self->content);\n        }\n    }\n    if(self->action_type != DTW_ACTION_DELETE){\n        cJSON_AddStringToObject(json_object,\"dest\",self->dest);\n    }\n\n    return json_object;\n}\n\n\n\nvoid DtwActionTransaction_represent(DtwActionTransaction* self){\n\n    printf(\"\\taction: %s\\n\", DtwActionTransaction_convert_action_to_string(self->action_type));\n    printf(\"\\tsource:%s\\n\",self->source);\n    if(self->action_type == DTW_ACTION_WRITE){\n\n        if(!self->is_binary && self->size <  30){\n\n            printf(\"\\tcontent : %s\\n\",(char*)self->content);\n        }\n        else{\n            printf(\"\\tcontent: impossible to show\\n\");\n        }\n\n        printf(\"\\tsize:%ld\\n\",self->size);\n        printf(\"\\tis binary: %s\\n\",self->is_binary? \"true\":\"false\");\n        return;\n    }\n\n    if(self->action_type != DTW_ACTION_DELETE){\n        printf(\"\\tdest: %s\\n\",self->dest);\n    }\n\n}\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/transaction/declaration.h",
		"is_binary":	false,
		"content":	"#include \"json_error/json_transaction_error.h\"\n#include \"action/action.h\"\n#include \"transaction/transaction.h\"\n"
	}, {
		"path":	"src/dependencies/doTheWorld/transaction/definition.c",
		"is_binary":	false,
		"content":	"#include \"json_error/json_transaction_error.c\"\n\n#include \"action/action.c\"\n#include \"action/action_parsment.c\"\n\n#include \"transaction/transaction.c\"\n#include \"transaction/transaction_parsment.c\""
	}, {
		"path":	"src/dependencies/doTheWorld/transaction/json_error/"
	}, {
		"path":	"src/dependencies/doTheWorld/transaction/json_error/json_transaction_error.c",
		"is_binary":	false,
		"content":	"\n\n\n\n\nDtwJsonTransactionError * private_new_DtwJsonTransactionError( int code,const char *mensage,const  char *path){\n    DtwJsonTransactionError *self = (DtwJsonTransactionError*) malloc(sizeof(DtwJsonTransactionError));\n    self->code  = code;\n    self->mensage = strdup(mensage);\n    self->path = NULL;\n    if(path){\n        self->path = strdup(path);\n    }\n\n    return self;\n}\n\nvoid DtwJsonTransactionError_represent(struct DtwJsonTransactionError *self){\n    printf(\"code: %d\\n\",self->code);\n    printf(\"mensage:%s\\n\",self->mensage);\n    if(self->path){\n        printf(\"path: %s\",self->path);\n    }\n}\n\nvoid DtwJsonTransactionError_prepend_path(struct DtwJsonTransactionError *self,char *path){\n    if(self->path){\n\n        char *new_path = (char*)calloc(sizeof (char), strlen(self->path) + strlen(path) + 2);\n\n        sprintf(new_path,\"%s%s\",path,self->path);\n\n        free(self->path);\n        self->path = new_path;\n        return;\n    }\n    self->path = strdup(path);\n}\n\n\nvoid DtwJsonTransactionError_free(struct DtwJsonTransactionError *self){\n    free(self->mensage);\n    if(self->path){\n        free(self->path);\n    }\n    free(self);\n\n}\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/transaction/json_error/json_transaction_error.h",
		"is_binary":	false,
		"content":	"enum {\n\n    JSON_TRANSACTION_WRONG_TYPE,\n    JSON_TRANSACTION_NOT_PRESENT_VALUE,\n    JSON_TRANSACTION_INVALID_ACTION\n};\ntypedef struct DtwJsonTransactionError{\n    int code;\n    char *mensage;\n    char *path;\n\n\n}DtwJsonTransactionError;\n\nDtwJsonTransactionError * private_new_DtwJsonTransactionError( int code,const char *mensage,const  char *path);\n\nvoid DtwJsonTransactionError_represent(struct DtwJsonTransactionError *self);\n\nvoid DtwJsonTransactionError_prepend_path(struct DtwJsonTransactionError *self,char *path);\n\nvoid DtwJsonTransactionError_free(struct DtwJsonTransactionError *self);\n"
	}, {
		"path":	"src/dependencies/doTheWorld/transaction/transaction/"
	}, {
		"path":	"src/dependencies/doTheWorld/transaction/transaction/transaction.c",
		"is_binary":	false,
		"content":	"\n\nDtwTransaction * newDtwTransaction(){\n    DtwTransaction *self = (DtwTransaction*) malloc(sizeof(DtwTransaction));\n    self->actions = (DtwActionTransaction **) malloc(sizeof (DtwActionTransaction**));\n    self->size = 0;\n\n    return self;\n}\n\nvoid DtwTransaction_append_action(struct DtwTransaction *self,struct DtwActionTransaction  *action){\n    self->actions =  (DtwActionTransaction**)realloc(\n            self->actions,\n            (sizeof(DtwActionTransaction*) * (self->size+1))\n    );\n    self->actions[self->size] = action;\n    self->size++;\n}\n\n\nvoid DtwTransaction_remove_from_index(DtwTransaction *self,long index){\n\n\n    DtwActionTransaction_free(self->actions[index]);\n    self->size -=1;\n    if(self->size == 0){\n        return;\n    }\n    for(long i = index; i < self->size; i++){\n        self->actions[i] = self->actions[i+1];\n    }\n\n}\nvoid DtwTransaction_filter(DtwTransaction *self,bool (*callback)(DtwActionTransaction *action)){\n    for(long i = 0; i < self->size; i++){\n        DtwActionTransaction *current = self->actions[i];\n        if(!callback(current)){\n            DtwTransaction_remove_from_index(self,i);\n            i-=1;\n        }\n    }\n}\n\nvoid DtwTransaction_remove_from_source(DtwTransaction *self,const char *source){\n    for(long i = 0; i < self->size; i++){\n        DtwActionTransaction *current = self->actions[i];\n        if(strcmp(current->source,source) ==0){\n            DtwTransaction_remove_from_index(self,i);\n            i-=1;\n        }\n    }\n}\n\n\nvoid DtwTransaction_write_any(struct DtwTransaction *self,const char *path,unsigned char *content, long size,bool is_binary){\n    DtwActionTransaction * action = DtwActionTransaction_write_any(path,content,size,is_binary);\n    DtwTransaction_append_action(self,action);\n}\n\nvoid DtwTransaction_write_string(struct DtwTransaction *self,const char *path,const char *content){\n    DtwActionTransaction * action = DtwActionTransaction_write_any(path,(unsigned char*)content, strlen(content),false);\n    DtwTransaction_append_action(self,action);\n}\n\n\nvoid DtwTransaction_write_long(struct DtwTransaction *self,const char *path,long value){\n    char converted[20] ={0};\n    sprintf(converted,\"%ld\",value);\n    DtwTransaction_write_string(self,path,converted);\n}\n\nvoid DtwTransaction_write_bool(struct DtwTransaction *self,const char *path,bool value){\n    if(value){\n        DtwTransaction_write_string(self,path,\"t\");\n    }\n    else{\n        DtwTransaction_write_string(self,path,\"f\");\n    }\n}\n\nvoid DtwTransaction_write_double(struct DtwTransaction *self,const char *path,double value){\n    char converted[20] ={0};\n    sprintf(converted,\"%lf\",value);\n    DtwTransaction_write_string(self,path,converted);\n}\n\n\nvoid DtwTransaction_move_any(struct DtwTransaction *self,const char *source,const char *dest){\n    DtwActionTransaction * action = DtwActionTransaction_move_any(source,dest);\n    DtwTransaction_append_action(self,action);\n}\n\nvoid DtwTransaction_copy_any(struct DtwTransaction *self,const char *source,const char *dest){\n    DtwActionTransaction * action = DtwActionTransaction_copy_any(source,dest);\n    DtwTransaction_append_action(self,action);\n}\n\nvoid DtwTransaction_move_any_merging(struct DtwTransaction *self,const char *source,const char *dest){\n    DtwActionTransaction * action = DtwActionTransaction_move_any_merging(source,dest);\n    DtwTransaction_append_action(self,action);\n}\n\n\nvoid DtwTransaction_copy_any_merging(struct DtwTransaction *self,const char *source,const char *dest){\n    DtwActionTransaction * action = DtwActionTransaction_copy_any_merging(source,dest);\n    DtwTransaction_append_action(self,action);\n}\n\n\nvoid DtwTransaction_delete_any(struct DtwTransaction *self,const char *source){\n     DtwActionTransaction  *action = DtwActionTransaction_delete_any(source);\n     DtwTransaction_append_action(self,action);\n}\n\n\n\nvoid DtwTransaction_commit(struct DtwTransaction *self,const char *path){\n    for(int i = 0; i < self->size; i++){\n        DtwActionTransaction_commit(self->actions[i],path);\n    }\n}\n\n\n\nvoid DtwTransaction_free(struct DtwTransaction *self){\n    for(int i =0; i < self->size; i++){\n        DtwActionTransaction_free(self->actions[i]);\n    }\n    free(self->actions);\n    free(self);\n}\n"
	}, {
		"path":	"src/dependencies/doTheWorld/transaction/transaction/transaction.h",
		"is_binary":	false,
		"content":	"\ntypedef struct DtwTransaction{\n\n    DtwActionTransaction  **actions;\n    long size;\n\n\n\n}DtwTransaction;\n\nDtwTransaction * newDtwTransaction();\n\nDtwTransaction * newDtwTransaction_from_json(cJSON *json_entry);\n\nDtwJsonTransactionError * dtw_validate_json_transaction(cJSON *json_entry);\n\nDtwJsonTransactionError * dtw_validate_json_transaction_file(const char *filename);\n\n\nDtwTransaction * newDtwTransaction_from_json_file(const char *filename);\n\nvoid DtwTransaction_remove_from_index(DtwTransaction *self,long index);\n\nvoid DtwTransaction_remove_from_source(DtwTransaction *self,const char *source);\n\nvoid DtwTransaction_filter(DtwTransaction *self,bool (*callback)(DtwActionTransaction *action));\n\nvoid DtwTransaction_append_action(struct DtwTransaction *self,struct DtwActionTransaction  *action);\n\nvoid DtwTransaction_write_any(struct DtwTransaction *self,const char *path,unsigned char *content, long size,bool is_binary);\n\nvoid DtwTransaction_write_string(struct DtwTransaction *self,const char *path,const char *content);\n\nvoid DtwTransaction_write_long(struct DtwTransaction *self,const char *path,long value);\n\nvoid DtwTransaction_write_bool(struct DtwTransaction *self,const char *path,bool value);\n\nvoid DtwTransaction_write_double(struct DtwTransaction *self,const char *path,double value);\n\nvoid DtwTransaction_move_any(struct DtwTransaction *self,const char *source,const char *dest);\n\nvoid DtwTransaction_move_any_merging(struct DtwTransaction *self,const char *source,const char *dest);\n\nvoid DtwTransaction_copy_any_merging(struct DtwTransaction *self,const char *source,const char *dest);\n\nvoid DtwTransaction_copy_any(struct DtwTransaction *self,const char *source,const char *dest);\n\nvoid DtwTransaction_delete_any(struct DtwTransaction *self,const char *source);\n\ncJSON * DtwTransaction_dumps_to_json(struct DtwTransaction *self);\n\nvoid DtwTransaction_dumps_to_json_file(struct DtwTransaction *self,const char *filename);\n\nvoid DtwTransaction_commit(struct DtwTransaction *self,const char *path);\n\nvoid DtwTransaction_represent(struct DtwTransaction *self);\n\n\nvoid DtwTransaction_free(struct DtwTransaction *self);\n"
	}, {
		"path":	"src/dependencies/doTheWorld/transaction/transaction/transaction_parsment.c",
		"is_binary":	false,
		"content":	"\n\nDtwJsonTransactionError * dtw_validate_json_transaction(cJSON *json_entry){\n    if(json_entry->type != cJSON_Array){\n        return private_new_DtwJsonTransactionError(\n                JSON_TRANSACTION_WRONG_TYPE,\n                \"the initial value its not an array\",\n                NULL\n                );\n    }\n    long  element_size = cJSON_GetArraySize(json_entry);\n    for(long  i = 0; i <element_size; i++){\n\n        cJSON *current_obj = cJSON_GetArrayItem(json_entry,i);\n\n        DtwJsonTransactionError  *current_error = private_dtw_validate_json_action_transaction(current_obj);\n        if(current_error){\n            char formated_path[20] = {0};\n            sprintf(formated_path,\"[%ld]\",i);\n            DtwJsonTransactionError_prepend_path(current_error,formated_path);\n\n            return current_error;\n        }\n\n    }\n\n    return NULL;\n}\n\nDtwJsonTransactionError * dtw_validate_json_transaction_file(const char *filename){\n    char *content = dtw_load_string_file_content(filename);\n    if(!content){\n        char *formated_mensage = (char*)calloc(sizeof (char), strlen(filename) + 50);\n        sprintf(formated_mensage, \"file: %s not found\",filename);\n        DtwJsonTransactionError  *error = private_new_DtwJsonTransactionError(\n                DTW_ACTION_FILE_NOT_FOUND,\n                formated_mensage,\n                NULL\n                );\n        free(formated_mensage);\n        return error;\n    }\n    cJSON *parsed = cJSON_Parse(content);\n    if(!parsed){\n        char *formated_mensage = (char*)calloc(sizeof (char), strlen(filename) + 50);\n        sprintf(formated_mensage, \"file: %s its not an valid json\",filename);\n        DtwJsonTransactionError  *error = private_new_DtwJsonTransactionError(\n                DTW_ACTION_ITS_NOT_JSON,\n                formated_mensage,\n                NULL\n        );\n        free(formated_mensage);\n        free(content);\n        return error;\n    }\n    DtwJsonTransactionError *generated_error = dtw_validate_json_transaction(parsed);\n\n    free(content);\n    cJSON_Delete(parsed);\n    return generated_error;\n}\n\n\nDtwTransaction * newDtwTransaction_from_json(cJSON *json_entry){\n    DtwJsonTransactionError *generated_error = dtw_validate_json_transaction(json_entry);\n    if(generated_error) {\n        DtwJsonTransactionError_free(generated_error);\n        return NULL;\n    }\n    DtwTransaction *self = newDtwTransaction();\n    long size = cJSON_GetArraySize(json_entry);\n    for(int i  = 0; i < size; i ++){\n        cJSON  *object_action = cJSON_GetArrayItem(json_entry,i);\n        DtwActionTransaction  *current_action = private_DtwActionTransaction_parse_json_object(object_action);\n        DtwTransaction_append_action(self,current_action);\n    }\n    return self;\n}\n\n\n\nDtwTransaction * newDtwTransaction_from_json_file(const char *filename){\n    char *content = dtw_load_string_file_content(filename);\n    if(!content){\n        return NULL;\n    }\n\n    cJSON  *element = cJSON_Parse(content);\n    free(content);\n    if(!element){\n        return NULL;\n    }\n\n    DtwJsonTransactionError *error = dtw_validate_json_transaction(element);\n    if(error){\n        DtwJsonTransactionError_free(error);\n        cJSON_Delete(element);\n        return NULL;\n    }\n\n\n    DtwTransaction  *self = newDtwTransaction_from_json(element);\n    cJSON_Delete(element);\n\n    return self;\n}\n\ncJSON * DtwTransaction_dumps_to_json(struct DtwTransaction *self){\n    cJSON * json_array = cJSON_CreateArray();\n    for(int i =0; i < self->size; i ++){\n\n        cJSON_AddItemToArray(\n                json_array,\n                private_DtwActionTransaction_create_json_object(self->actions[i])\n        );\n\n    }\n    return json_array;\n}\n\n\nvoid DtwTransaction_dumps_to_json_file(struct DtwTransaction *self,const char *filename){\n    cJSON *json_array = DtwTransaction_dumps_to_json(self);\n    char *result = cJSON_Print(json_array);\n    dtw_write_string_file_content(filename,result);\n    free(result);\n    cJSON_Delete(json_array);\n}\n\nvoid DtwTransaction_represent(struct DtwTransaction *self){\n\n    for(int i = 0; i < self->size; i++){\n\n        DtwActionTransaction_represent(self->actions[i]);\n        printf(\"------------------------------------\\n\");\n\n    }\n\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/tree/"
	}, {
		"path":	"src/dependencies/doTheWorld/tree/declarations.h",
		"is_binary":	false,
		"content":	"\n#include \"tree_props/tree_props.h\"\n#include \"json_error/json_error.h\"\n#include \"transaction_report/transaction_report.h\"\n#include \"tree_part/tree_part.h\"\n#include \"tree/tree.h\"\n"
	}, {
		"path":	"src/dependencies/doTheWorld/tree/definition.c",
		"is_binary":	false,
		"content":	"#include \"tree_props/tree_props.c\"\n#include \"json_error/json_error.c\"\n#include \"transaction_report/transaction_report.c\"\n#include \"tree_part/tree_part.c\"\n#include \"tree_part/hardware_tree_part.c\"\n\n#include \"tree/json_tree.c\"\n#include \"tree/tree_finding.c\"\n#include \"tree/listage.c\"\n#include \"tree/tree.c\"\n"
	}, {
		"path":	"src/dependencies/doTheWorld/tree/json_error/"
	}, {
		"path":	"src/dependencies/doTheWorld/tree/json_error/json_error.c",
		"is_binary":	false,
		"content":	" DtwJsonTreeError * newDtwJsonError(){\n     DtwJsonTreeError *self =(DtwJsonTreeError*)malloc(sizeof(struct DtwJsonTreeError));\n    return self;\n}\n\nDtwJsonTreeError * DtwJsonTreeError_validate_json_tree_by_cJSON(cJSON *json_tree){\n     struct DtwJsonTreeError *json_error = newDtwJsonError();\n    //verifiy if json_tre is not null\n    if(json_tree == NULL){\n        json_error->code = DTW_JSON_SYNTAX_ERROR;\n        json_error->menssage = \"json_tree is null\";\n        return json_error;\n    }\n\n    //verifiy if json_tre is an array\n    if(!cJSON_IsArray(json_tree)){\n        cJSON_Delete(json_tree);\n        json_error->code = DTW_JSON_TYPE_ERROR;\n        json_error->menssage = \"json_tree is not an array\";\n        return json_error;\n    }\n\n    int size = cJSON_GetArraySize(json_tree);\n    for(int i = 0; i < size; i++){\n        json_error->position = i;\n        cJSON *json_tree_part = cJSON_GetArrayItem(json_tree, i);\n        cJSON *path = cJSON_GetObjectItemCaseSensitive(json_tree_part, \"path\");\n        cJSON *original_path = cJSON_GetObjectItemCaseSensitive(json_tree_part, \"original_path\");\n        cJSON *hardware_sha = cJSON_GetObjectItemCaseSensitive(json_tree_part, \"hardware_sha256\");\n        cJSON *hardware_content_size = cJSON_GetObjectItemCaseSensitive(json_tree_part, \"hardware_content_size\");\n        cJSON *last_modification_in_unix_time = cJSON_GetObjectItemCaseSensitive(json_tree_part, \"last_modification_in_unix_time\");\n        cJSON *content_size = cJSON_GetObjectItemCaseSensitive(json_tree_part, \"content_size\");\n        cJSON *is_binary = cJSON_GetObjectItemCaseSensitive(json_tree_part, \"is_binary\");\n        cJSON *content = cJSON_GetObjectItemCaseSensitive(json_tree_part, \"content\");\n        cJSON *ignore = cJSON_GetObjectItemCaseSensitive(json_tree_part, \"ignore\");\n        cJSON *pending_action = cJSON_GetObjectItemCaseSensitive(json_tree_part, \"pending_action\");\n        //path is required\n        if(!cJSON_IsString(path)){\n            cJSON_Delete(json_tree);\n            json_error->code = DTW_JSON_REQUIRED_KEY_ERROR;\n            json_error->menssage = \"path is not a string\";\n            return json_error;\n        }\n\n        //Others are not required\n        if(original_path != NULL && !cJSON_IsString(original_path)){\n            cJSON_Delete(json_tree);\n            json_error->code = DTW_JSON_REQUIRED_VALUE_ERROR;\n            json_error->menssage = \"original_path is not a string\";\n            return json_error;\n        }\n        if(hardware_sha != NULL && !cJSON_IsString(hardware_sha)){\n            cJSON_Delete(json_tree);\n            json_error->code = DTW_JSON_REQUIRED_VALUE_ERROR;\n            json_error->menssage = \"hardware_sha is not a string\";\n            return json_error;\n        }\n        if(hardware_content_size != NULL && !cJSON_IsNumber(hardware_content_size)){\n            cJSON_Delete(json_tree);\n            json_error->code = DTW_JSON_REQUIRED_VALUE_ERROR;\n            json_error->menssage = \"hardware_content_size is not a number\";\n            return json_error;\n        }\n        if(last_modification_in_unix_time != NULL && !cJSON_IsNumber(last_modification_in_unix_time)){\n            cJSON_Delete(json_tree);\n            json_error->code = DTW_JSON_REQUIRED_VALUE_ERROR;\n            json_error->menssage = \"last_modification_in_unix_time is not a number\";\n            return json_error;\n        }\n        if(content_size != NULL && !cJSON_IsNumber(content_size)){\n            cJSON_Delete(json_tree);\n            json_error->code = DTW_JSON_REQUIRED_VALUE_ERROR;\n            json_error->menssage = \"content_size is not a number\";\n            return json_error;\n        }\n\n        if(is_binary != NULL && !cJSON_IsBool(is_binary)){\n            cJSON_Delete(json_tree);\n            json_error->code = DTW_JSON_REQUIRED_VALUE_ERROR;\n            json_error->menssage = \"is_binary is not a bool\";\n            return json_error;\n        }\n        if(content != NULL && !cJSON_IsString(content)){\n            cJSON_Delete(json_tree);\n            json_error->code = DTW_JSON_REQUIRED_VALUE_ERROR;\n            json_error->menssage = \"content is not a string\";\n            return json_error;\n        }\n        if(ignore != NULL && !cJSON_IsBool(ignore)){\n            cJSON_Delete(json_tree);\n            json_error->code = DTW_JSON_REQUIRED_VALUE_ERROR;\n            json_error->menssage = \"ignore is not a bool\";\n            return json_error;\n        }\n\n        if(pending_action != NULL && cJSON_IsNull(pending_action) == false){\n\n            if(cJSON_IsString(pending_action)){\n\n                int action = private_dtw_convert_string_to_action(\n                    cJSON_GetStringValue(pending_action)\n                );\n                if(action == DTW_ACTION_ERROR){\n                    cJSON_Delete(json_tree);\n                    json_error->code = DTW_JSON_REQUIRED_VALUE_ERROR;\n                    json_error->menssage = \"pending_action is not a valid action\";\n                    return json_error;\n                }\n            }\n            else{\n                cJSON_Delete(json_tree);\n                json_error->code = DTW_JSON_REQUIRED_VALUE_ERROR;\n                json_error->menssage = \"pending_action is not a valid action\";\n                return json_error;\n            }\n\n\n        }\n\n    }\n     DtwJsonTreeError_free(json_error);\n     return NULL;\n }\n\n DtwJsonTreeError * DtwJsonTreeError_validate_json_tree_by_content(const char *content){\n     cJSON *json_tree = cJSON_Parse(content);\n     DtwJsonTreeError *json_error = DtwJsonTreeError_validate_json_tree_by_cJSON(json_tree);\n     cJSON_Delete(json_tree);\n     return json_error;\n }\n\n\n\n\nvoid DtwJsonTreeError_represent( DtwJsonTreeError *self){\n\n    if(self == NULL){\n        return;\n    }\n    printf(\"code: %d\\n\", self->code);\n    printf(\"position: %d\\n\", self->position);\n    printf(\"menssage: %s\\n\", self->menssage);\n}\n\nvoid DtwJsonTreeError_free(struct DtwJsonTreeError *self){\n     if(self){\n         free(self);\n     }\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/tree/json_error/json_error.h",
		"is_binary":	false,
		"content":	"#define DTW_JSON_TYPE_ERROR 1\n#define DTW_JSON_SYNTAX_ERROR 2\n#define DTW_JSON_REQUIRED_KEY_ERROR 3\n#define DTW_JSON_REQUIRED_VALUE_ERROR 4\n#define DTW_JSON_NOT_FOUND_ERROR 5\n#define DTW_ACTION_ERROR (-1)\n\n\ntypedef struct DtwJsonTreeError {\n    int code;\n    int position;\n    const char *menssage;\n\n\n}DtwJsonTreeError;\n\nDtwJsonTreeError * newDtwJsonError();\n\nDtwJsonTreeError * DtwJsonTreeError_validate_json_tree_by_cJSON(cJSON *json_tree);\n\nDtwJsonTreeError * DtwJsonTreeError_validate_json_tree_by_content(const char *content);\n\nvoid DtwJsonTreeError_represent(struct DtwJsonTreeError *self);\n\nvoid DtwJsonTreeError_free(struct DtwJsonTreeError *self);\n"
	}, {
		"path":	"src/dependencies/doTheWorld/tree/transaction_report/"
	}, {
		"path":	"src/dependencies/doTheWorld/tree/transaction_report/transaction_report.c",
		"is_binary":	false,
		"content":	"\n\nstruct DtwTreeTransactionReport * newDtwTreeTransactionReport(){\n    struct DtwTreeTransactionReport *new_report = (struct DtwTreeTransactionReport *)malloc(sizeof(struct DtwTreeTransactionReport));\n    new_report->write = newDtwStringArray();\n    new_report->modify = newDtwStringArray();\n    new_report->remove = newDtwStringArray();\n    return new_report;\n}\n\nvoid  DtwTreeTransactionReport_represent(struct DtwTreeTransactionReport *report){\n    printf(\"Write:---------------------------------------\\n\");\n    DtwStringArray_represent(report->write);\n    printf(\"Modify:--------------------------------------\\n\");\n    DtwStringArray_represent(report->modify);\n    printf(\"Remove:--------------------------------------\\n\");\n    DtwStringArray_represent(report->remove);\n    puts(\"\");\n}\n\nvoid  DtwTreeTransactionReport_free(struct DtwTreeTransactionReport *report){\n    DtwStringArray_free(report->write);\n    DtwStringArray_free(report->modify);\n    DtwStringArray_free(report->remove);\n    free(report);\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/tree/transaction_report/transaction_report.h",
		"is_binary":	false,
		"content":	"\ntypedef struct DtwTreeTransactionReport{\n    DtwStringArray *write;\n    DtwStringArray *modify;\n    DtwStringArray *remove;\n\n}DtwTreeTransactionReport;\n\nstruct DtwTreeTransactionReport * newDtwTreeTransactionReport();\nvoid  DtwTreeTransactionReport_represent(struct DtwTreeTransactionReport *report);\nvoid  DtwTreeTransactionReport_free(struct DtwTreeTransactionReport *report);"
	}, {
		"path":	"src/dependencies/doTheWorld/tree/tree/"
	}, {
		"path":	"src/dependencies/doTheWorld/tree/tree/json_tree.c",
		"is_binary":	false,
		"content":	"\n\nbool DtwTree_loads_json_tree(struct DtwTree *self, const char *all_tree){\n    //load json\n    cJSON *json_tree = cJSON_Parse(all_tree);\n    if(json_tree == NULL){\n        return false;\n    }\n    DtwJsonTreeError *json_error = DtwJsonTreeError_validate_json_tree_by_cJSON(json_tree);\n    if(json_error){\n        DtwJsonTreeError_free(json_error);\n        return  false;\n    }\n\n    int size = cJSON_GetArraySize(json_tree);\n    for(int i = 0; i < size; i++){\n\n        cJSON *json_tree_part = cJSON_GetArrayItem(json_tree, i);\n        cJSON *path = cJSON_GetObjectItemCaseSensitive(json_tree_part, \"path\");\n        cJSON *original_path = cJSON_GetObjectItemCaseSensitive(json_tree_part, \"original_path\");\n        cJSON *hardware_sha = cJSON_GetObjectItemCaseSensitive(json_tree_part, \"hardware_sha256\");\n        cJSON *hardware_content_size = cJSON_GetObjectItemCaseSensitive(json_tree_part, \"hardware_content_size\");\n        cJSON *last_modification_in_unix_time = cJSON_GetObjectItemCaseSensitive(json_tree_part, \"last_modification_in_unix_time\");\n        cJSON *content_size = cJSON_GetObjectItemCaseSensitive(json_tree_part, \"content_size\");\n        cJSON *is_binary = cJSON_GetObjectItemCaseSensitive(json_tree_part, \"is_binary\");\n        cJSON *content = cJSON_GetObjectItemCaseSensitive(json_tree_part, \"content\");\n        cJSON *pending_action = cJSON_GetObjectItemCaseSensitive(json_tree_part, \"pending_action\");\n        cJSON *ignore = cJSON_GetObjectItemCaseSensitive(json_tree_part, \"ignore\");\n   \n        struct DtwTreePart *part = newDtwTreePartEmpty(\n                path->valuestring\n                );\n\n        if(original_path != NULL){\n            if(  part->path->original_path_string){\n                free(  part->path->original_path_string);\n            }\n            part->path->original_path_string = strdup(original_path->valuestring);\n\n        }\n\n        if(hardware_sha != NULL){\n            part->content_exist_in_hardware = true;\n            part->hawdware_content_sha = (char *)realloc(part->hawdware_content_sha,strlen(hardware_sha->valuestring)+1);\n            strcpy(part->hawdware_content_sha,hardware_sha->valuestring);\n            \n        }\n\n        if(hardware_content_size != NULL){\n            part->content_exist_in_hardware = true;\n            part->hardware_content_size = hardware_content_size->valueint;\n        }\n        \n        if(last_modification_in_unix_time != NULL){\n            part->last_modification_time = last_modification_in_unix_time->valueint;\n        }\n    \n        if(is_binary != NULL){\n            part->is_binary = is_binary->valueint;\n        }\n        \n        if(content_size != NULL){\n            part->content_size = content_size->valueint;\n        }\n\n        if(content != NULL){\n\n            if(part->is_binary){\n                long out_size;\n                unsigned char *decoded =dtw_base64_decode(\n                    content->valuestring,\n                    &out_size\n                );\n                DtwTreePart_set_binary_content(part,decoded,out_size);\n                free(decoded);\n            }\n           else{\n                DtwTreePart_set_string_content(part,content->valuestring);\n           } \n        }\n        if(pending_action != NULL &&  pending_action->valuestring){\n    \n            part->pending_action = private_dtw_convert_string_to_action(\n                pending_action->valuestring\n            );\n        }\n        if(ignore != NULL){\n            part->ignore = ignore->valueint;\n        }\n\n        DtwTree_add_tree_part_getting_onwership(self, part);\n        \n    }\n    cJSON_Delete(json_tree);\n    return  true;\n}\n\n\nbool DtwTree_loads_json_tree_from_file( DtwTree *self, const char *path){\n    char *content = dtw_load_string_file_content(path);\n    if(content == NULL){\n        return false;\n    }\n    bool result = DtwTree_loads_json_tree(self,content);\n    free(content);\n    return result;\n}\n\nchar * DtwTree_dumps_tree_json( DtwTree *self, DtwTreeProps  props){\n\n\n    DtwTreeProps formated_props = DtwTreeProps_format_props(props);\n\n    cJSON *json_array = cJSON_CreateArray();\n    for(int i = 0; i < self->size; i++){\n       \n        cJSON *json_tree_part = cJSON_CreateObject();\n        DtwTreePart *tree_part = self->tree_parts[i];\n        char *path_string = DtwPath_get_path(tree_part->path);\n        if(path_string ==NULL){\n            cJSON_Delete(json_tree_part);\n            continue;\n        }\n\n        if(formated_props.ignored_elements == DTW_INCLUDE && tree_part->ignore){\n            continue;\n        }\n        \n        if(tree_part->ignore){\n            cJSON_AddItemToObject(\n                json_tree_part, \n                \"ignore\", \n                cJSON_CreateBool(true)\n            );\n        }\n\n        cJSON_AddItemToObject(\n            json_tree_part, \n            \"path\", \n            cJSON_CreateString(path_string)\n        );\n        \n        \n        \n        if(formated_props.path_atributes == DTW_INCLUDE ){\n                char *dir_string = DtwPath_get_dir(tree_part->path);\n                char *full_name_string = DtwPath_get_full_name(tree_part->path);\n                char *name_string = DtwPath_get_name(tree_part->path);\n                char *extension_string = DtwPath_get_extension(tree_part->path);\n                if(tree_part->path->original_path_string != path_string){\n                    cJSON_AddItemToObject(\n                        json_tree_part, \n                        \"original_path\", \n                        cJSON_CreateString(tree_part->path->original_path_string)\n                    );\n                }\n                cJSON_AddItemToObject(\n                    json_tree_part, \n                    \"dir\", \n                    cJSON_CreateString(dir_string)\n                );\n                \n                cJSON_AddItemToObject(\n                    json_tree_part, \n                    \"full_name\", \n                    cJSON_CreateString(full_name_string)\n                );\n                \n                cJSON_AddItemToObject(\n                    json_tree_part, \n                    \"name\", \n                    cJSON_CreateString(name_string)\n                );\n                \n                cJSON_AddItemToObject(\n                    json_tree_part, \n                    \"extension\", \n                    cJSON_CreateString(extension_string)\n                );\n\n\n        }\n\n\n        if(formated_props.hadware_data == DTW_INCLUDE && tree_part->metadata_loaded){\n            cJSON_AddItemToObject(\n                json_tree_part, \n                \"hardware_sha256\", \n                cJSON_CreateString(tree_part->hawdware_content_sha)\n            );\n            cJSON_AddItemToObject(\n                json_tree_part, \n                \"last_modification_in_unix\", \n                cJSON_CreateNumber(tree_part->last_modification_time)\n            );\n\n            cJSON_AddItemToObject(\n                json_tree_part, \n                \"hardware_content_size\", \n                cJSON_CreateNumber(tree_part->hardware_content_size)\n            );\n\n            cJSON_AddItemToObject(\n                json_tree_part, \n                \"last_modification\", \n                cJSON_CreateString(tree_part->last_modification_in_str)\n            );\n        }\n\n        if(formated_props.content_data == DTW_INCLUDE && tree_part->content){\n            char *content_sha = DtwTreePart_get_content_sha(tree_part);\n            cJSON_AddItemToObject(\n                json_tree_part, \n                \"content_size\", \n                cJSON_CreateNumber(tree_part->content_size)\n            );\n\n            cJSON_AddItemToObject(\n                json_tree_part, \n                \"content_sha256\", \n                cJSON_CreateString(content_sha)\n            );\n\n        }\n\n        if(formated_props.content == DTW_INCLUDE && tree_part->content){\n\n            cJSON_AddItemToObject(\n                json_tree_part, \n                \"is_binary\", \n                cJSON_CreateBool(tree_part->is_binary)\n            );  \n            if(tree_part->is_binary == false){\n                cJSON_AddItemToObject(\n                    json_tree_part, \n                    \"content\", \n                    cJSON_CreateString(DtwTreePart_get_content_string_by_reference(tree_part))\n                );\n            }\n            else{\n                char *content_base64 = dtw_base64_encode(tree_part->content, tree_part->content_size);\n         \n     \n                cJSON_AddItemToObject(\n                    json_tree_part, \n                    \"content\", \n                    cJSON_CreateString(content_base64)\n                );  \n                free(content_base64);\n            }\n        }\n       \n        //adding action \n        const char *action_string = private_dtw_convert_action_to_string(tree_part->pending_action);\n        if(action_string != NULL){\n            cJSON_AddItemToObject(\n                json_tree_part, \n                \"pending_action\", \n                cJSON_CreateString(action_string)\n            );\n        } \n        //Add json_tree_part  \n        cJSON_AddItemToArray(json_array,json_tree_part);\n\n    }\n    \n    char *json_string = cJSON_Print(json_array);\n    //set ident to 4 spaces\n    if(formated_props.minification == DTW_MIMIFY){\n        cJSON_Minify(json_string);\n    }\n    cJSON_Delete(json_array);\n    return json_string;\n}\n\nvoid  DtwTree_dumps_tree_json_to_file(struct DtwTree *self, const char *path, DtwTreeProps  props){\n    char *json_string = DtwTree_dumps_tree_json(self,props);\n    dtw_write_string_file_content(path,json_string);\n    free(json_string);\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/tree/tree/listage.c",
		"is_binary":	false,
		"content":	"\n//listages\n DtwStringArray *DtwTree_list_files( DtwTree *self, const char *path,bool concat_path){\n    DtwStringArray *formated_elements = newDtwStringArray();\n    for(int i = 0; i < self->size; i++){\n        DtwTreePart *current = self->tree_parts[i];\n        DtwPath *current_path = current->path;\n        char *current_path_string = DtwPath_get_path(current_path);\n\n        long size = strlen(current_path_string);\n        char last_char = current_path_string[size-1];\n        if(last_char =='/'){\n            continue;\n        }\n\n        if(dtw_starts_with(current_path_string,path)){\n            //means its not an path from these dimension\n            int path_size = strlen(path);\n            bool insert = true;\n\n            for(int i =path_size +1; i < size;i++){\n                if(current_path_string[i] == '/'){\n                    insert = false;\n                    continue;\n                }\n            }\n\n            if(insert){\n                DtwStringArray_append(formated_elements,current_path_string);\n            }\n\n        }\n\n\n    }\n    if(!concat_path){\n\n        DtwStringArray  *not_concatened = private_dtw_remove_start_path(formated_elements,path);\n        DtwStringArray_free(formated_elements);\n        return not_concatened;\n    }\n\n\n    return formated_elements;\n}\n\n DtwStringArray *DtwTree_list_dirs( DtwTree *self, const char *path,bool concat_path){\n\n    DtwStringArray *formated_elements = newDtwStringArray();\n    for(int i = 0; i < self->size; i++){\n        DtwTreePart *current = self->tree_parts[i];\n        DtwPath *current_path = current->path;\n        char *current_path_string = DtwPath_get_path(current_path);\n\n        long size = strlen(current_path_string);\n        char last_char = current_path_string[size-1];\n        if(last_char !='/'){\n            continue;\n        }\n\n        if(dtw_starts_with(current_path_string,path)){\n            //means its not an path from these dimension\n            int path_size = strlen(path);\n\n            int total_found = 0;\n            for(int i =path_size +1; i < size;i++){\n                if(current_path_string[i] == '/'){\n                    total_found+=1;\n                    continue;\n                }\n            }\n\n            if(total_found ==1){\n                DtwStringArray_append(formated_elements,current_path_string);\n            }\n\n        }\n\n\n    }\n    if(!concat_path){\n\n        DtwStringArray  *not_concatened = private_dtw_remove_start_path(formated_elements,path);\n        DtwStringArray_free(formated_elements);\n        return not_concatened;\n    }\n\n\n    return formated_elements;\n}\n\nstruct DtwStringArray *DtwTree_list_all( DtwTree *self, const char *path,bool concat_path){\n\n    DtwStringArray *formated_elements = newDtwStringArray();\n    for(int i = 0; i < self->size; i++){\n        DtwTreePart *current = self->tree_parts[i];\n        DtwPath *current_path = current->path;\n        char *current_path_string = DtwPath_get_path(current_path);\n\n        if(dtw_starts_with(current_path_string,path)){\n            //means its not an path from these dimension\n            int path_size = strlen(path);\n            long size = strlen(current_path_string);\n            char last_char = current_path_string[size-1];\n\n            int total_found = 0;\n            for(int i =path_size+1; i < size;i++){\n                if(current_path_string[i] == '/'){\n                    total_found+=1;\n                    continue;\n                }\n            }\n\n            if(total_found ==1 && last_char == '/'){\n                DtwStringArray_append(formated_elements,current_path_string);\n            }\n            if(total_found ==0){\n                DtwStringArray_append(formated_elements,current_path_string);\n\n            }\n\n\n\n        }\n\n\n    }\n    if(!concat_path){\n\n        DtwStringArray  *not_concatened = private_dtw_remove_start_path(formated_elements,path);\n        DtwStringArray_free(formated_elements);\n        return not_concatened;\n    }\n\n\n    return formated_elements;\n\n}\n\n DtwStringArray *DtwTree_list_files_recursively( DtwTree *self, const char *path,bool concat_path){\n    DtwStringArray *formated_elements = newDtwStringArray();\n    for(int i = 0; i < self->size; i++){\n        DtwTreePart *current = self->tree_parts[i];\n        DtwPath *current_path = current->path;\n        char *current_path_string = DtwPath_get_path(current_path);\n\n\n        long size = strlen(current_path_string);\n        char last_char = current_path_string[size-1];\n        if(last_char =='/'){\n            continue;\n        }\n\n        if(dtw_starts_with(current_path_string,path)){\n            DtwStringArray_append(formated_elements,current_path_string);\n\n        }\n\n\n    }\n    if(!concat_path){\n\n        DtwStringArray  *not_concatened = private_dtw_remove_start_path(formated_elements,path);\n        DtwStringArray_free(formated_elements);\n        return not_concatened;\n    }\n\n\n    return formated_elements;\n}\n\n DtwStringArray *DtwTree_list_dirs_recursively( DtwTree *self, const char *path,bool concat_path){\n    DtwStringArray *formated_elements = newDtwStringArray();\n    for(int i = 0; i < self->size; i++){\n        DtwTreePart *current = self->tree_parts[i];\n        DtwPath *current_path = current->path;\n        char *current_path_string = DtwPath_get_path(current_path);\n\n        long size = strlen(current_path_string);\n        char last_char = current_path_string[size-1];\n        if(last_char !='/'){\n            continue;\n        }\n\n        if(dtw_starts_with(current_path_string,path)){\n            DtwStringArray_append(formated_elements,current_path_string);\n\n        }\n\n    }\n    if(!concat_path){\n\n        DtwStringArray  *not_concatened = private_dtw_remove_start_path(formated_elements,path);\n        DtwStringArray_free(formated_elements);\n        return not_concatened;\n    }\n\n\n    return formated_elements;\n}\n\n\n DtwStringArray *DtwTree_list_all_recursively( DtwTree *self, const char *path,bool concat_path){\n    DtwStringArray *formated_elements = newDtwStringArray();\n    for(int i = 0; i < self->size; i++){\n        DtwTreePart *current = self->tree_parts[i];\n        DtwPath *current_path = current->path;\n        char *current_path_string = DtwPath_get_path(current_path);\n\n\n\n        if(dtw_starts_with(current_path_string,path)){\n            DtwStringArray_append(formated_elements,current_path_string);\n\n        }\n\n    }\n    if(!concat_path){\n\n        DtwStringArray  *not_concatened = private_dtw_remove_start_path(formated_elements,path);\n        DtwStringArray_free(formated_elements);\n        return not_concatened;\n    }\n\n\n    return formated_elements;\n}\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/tree/tree/tree.c",
		"is_binary":	false,
		"content":	"\n\n\nstruct  DtwTree * newDtwTree(){\n\n    struct DtwTree *self = (struct DtwTree*)malloc(sizeof(struct DtwTree));\n    self->size = 0;\n    self->tree_parts = (struct DtwTreePart**)malloc(1);\n\n    return self;\n}\n\n\nstruct DtwTree *DtwTree_get_sub_tree(struct DtwTree *self, const char *path, bool copy_content){\n    struct DtwTree *sub_tree = newDtwTree();\n    for(int i = 0; i < self->size; i++){\n        struct DtwTreePart *tree_part = self->tree_parts[i];\n        char *current_path =  DtwPath_get_path(tree_part->path);\n        if(dtw_starts_with(current_path,path)){\n            if(copy_content){\n                DtwTree_add_tree_part_copy(sub_tree,tree_part);\n            }\n            if(!copy_content){\n                DtwTree_add_tree_part_referencing(sub_tree, tree_part);\n            }\n        }\n    }\n    return sub_tree;\n}\n\nvoid DtwTree_add_tree_part_referencing(struct DtwTree *self, struct DtwTreePart *tree_part) {\n    self->size++;\n    self->tree_parts =  (struct DtwTreePart**)realloc(self->tree_parts, self->size * sizeof(struct DtwTreePart *));\n    self->tree_parts[self->size - 1] = tree_part;\n}\n\nvoid DtwTree_add_tree_part_copy( DtwTree *self,  DtwTreePart *tree_part){\n    self->size++;\n    self->tree_parts =  (struct DtwTreePart**)realloc(self->tree_parts, self->size * sizeof(struct DtwTreePart *));\n    DtwTreePart *copy = DtwTreePart_self_copy(tree_part);\n    copy->owner = (void*)self;\n    self->tree_parts[self->size - 1] = copy;\n       \n}\n\nvoid DtwTree_remove_tree_part(struct DtwTree *self, int position){\n\n    self->size--;\n    DtwTreePart_free(self->tree_parts[position]);\n\n    for(int i = position; i<self->size; i++){\n        self->tree_parts[i] = self->tree_parts[i+1];\n    }\n\n\n}\n\nstruct DtwTreeTransactionReport * DtwTree_create_report(struct DtwTree *self){\n    struct DtwTreeTransactionReport *report = newDtwTreeTransactionReport();\n    for(int i = 0; i < self->size; i++){\n        struct DtwTreePart *tree_part = self->tree_parts[i];\n        int pending_action = tree_part->pending_action;\n        char *path = DtwPath_get_path(tree_part->path);\n\n        if (pending_action == DTW_WRITE){\n            DtwStringArray_append(report->write, path);\n        }\n\n        else if (pending_action == DTW_MODIFY){\n            DtwStringArray_append(report->modify, path);\n        }\n\n        else if (pending_action == DTW_REMOVE){\n            DtwStringArray_append(report->remove, path);\n        }\n\n\n    }\n    return report;\n}\n\n\nvoid DtwTree_add_tree_part_getting_onwership( DtwTree *self,  DtwTreePart *tree_part){\n    DtwTree_add_tree_part_referencing(self,tree_part);\n    tree_part->owner = (void*)self;\n}\n\n\n\nvoid DtwTree_represent( DtwTree *self){\n    for(int i = 0; i < self->size; i++){\n        DtwTreePart_represent(self->tree_parts[i]);\n    }\n}\n\nvoid DtwTree_add_tree_parts_from_string_array( DtwTree *self,  DtwStringArray *paths,DtwTreeProps props){\n    for(int i = 0; i < paths->size; i++){\n\n        const char *current_path = paths->strings[i];\n         DtwTreePart *tree_part = newDtwTreePart(\n                current_path,\n                props\n        );\n\n        DtwTree_add_tree_part_getting_onwership(self, tree_part);\n    }\n}\n\n\nvoid DtwTree_add_tree_from_hardware( DtwTree *self,const char *path, DtwTreeProps props){\n    DtwTreeProps formated_props = DtwTreeProps_format_props(props);\n    struct DtwStringArray *path_array = dtw_list_all_recursively(path,DTW_CONCAT_PATH);\n    DtwStringArray_sort(path_array);\n    DtwTree_add_tree_parts_from_string_array(self, path_array,props);\n    DtwStringArray_free(path_array);\n\n\n    if(formated_props.path_atributes == DTW_INCLUDE){\n        return;\n    }\n    if(self->size == 0){\n        return;\n    }\n    DtwTree_remove_tree_part(self,0);\n\n    int size_to_remove = strlen(path);\n    if(!dtw_ends_with(path,\"/\")){\n        size_to_remove+=1;\n    }\n\n    for(int i =0; i < self->size; i++){\n         DtwTreePart *current_part = self->tree_parts[i];\n         DtwPath *current_path = current_part->path;\n        char *current_path_string = DtwPath_get_path(current_path);\n        //remove the size toremove from string\n\n        memmove(\n                current_path_string,\n                current_path_string+size_to_remove,\n                strlen(current_path_string) - size_to_remove +1\n                );\n        DtwPath_set_path(current_path,current_path_string);\n\n        current_path->original_path_string = current_path_string;\n\n    }\n\n}\n\nvoid DtwTree_free( DtwTree *self){\n    for(int i = 0; i < self->size; i++){\n        DtwTreePart * part = self->tree_parts[i];\n        if(part->owner == (void*)self) {\n            DtwTreePart_free(part);\n\n        }\n\n    }\n    \n    free(self->tree_parts);\n    free(self);\n}\nvoid DtwTree_insecure_hardware_remove_tree(struct DtwTree *self){\n    for(int i = 0; i < self->size; i++){\n        DtwTreePart_hardware_remove(self->tree_parts[i],DTW_EXECUTE_NOW);\n    }\n}\n\nvoid DtwTree_insecure_hardware_write_tree(struct DtwTree *self){\n    \n    for(int i = 0; i < self->size; i++){\n        struct DtwTreePart *tree_part = self->tree_parts[i];\n        DtwTreePart_hardware_write(tree_part,DTW_EXECUTE_NOW);\n    }\n}\n\nvoid DtwTree_hardware_commit_tree(struct DtwTree *self){\n    for(int i = 0; i < self->size; i++){\n        DtwTreePart_hardware_commit(self->tree_parts[i]);\n    }\n}\n"
	}, {
		"path":	"src/dependencies/doTheWorld/tree/tree/tree.h",
		"is_binary":	false,
		"content":	"\n\n\ntypedef struct  DtwTree{\n    int size;\n     DtwTreePart **tree_parts;\n\n}DtwTree;\n\n\n DtwTree *DtwTree_get_sub_tree(\n     DtwTree *self,\n    const char *path,\n    bool copy_content\n);\n\n DtwTreePart *DtwTree_find_tree_part_by_function(DtwTree *self,bool (*caller)(  DtwTreePart *part));\n\n\n DtwTree *DtwTree_map(DtwTree *self, DtwTreePart* (*caller)( DtwTreePart *part));\n\n\n DtwTree *DtwTree_filter(DtwTree *self,bool (*caller)(struct  DtwTreePart *part));\n\n\n DtwTreePart *DtwTree_find_tree_part_by_name( DtwTree *self, const char *name);\n DtwTreePart *DtwTree_find_tree_part_by_path( DtwTree *self, const char *path);\n\n//listages\n DtwStringArray *DtwTree_list_files( DtwTree *self, const char *path,bool concat_path);\n\n DtwStringArray *DtwTree_list_dirs( DtwTree *self, const char *path,bool concat_path);\n\n DtwStringArray *DtwTree_list_all( DtwTree *self, const char *path,bool concat_path);\n\n DtwStringArray *DtwTree_list_files_recursively( DtwTree *self, const char *path,bool concat_path);\n\n DtwStringArray *DtwTree_list_dirs_recursively( DtwTree *self, const char *path,bool concat_path);\n\n DtwStringArray *DtwTree_list_all_recursively( DtwTree *self, const char *path,bool concat_path);\n\n\nvoid DtwTree_remove_tree_part( DtwTree *self, int position);\n\nvoid DtwTree_add_tree_part_copy( DtwTree *self,  DtwTreePart *tree_part);\n\nvoid DtwTree_add_tree_part_getting_onwership( DtwTree *self,  DtwTreePart *tree_part);\n\nvoid DtwTree_add_tree_part_referencing( DtwTree *self,  DtwTreePart *tree_part);\n\nvoid DtwTree_free( DtwTree *self);\nvoid DtwTree_represent( DtwTree *self);\n\nvoid DtwTree_add_tree_parts_from_string_array(DtwTree *self,DtwStringArray *paths,DtwTreeProps props);\n\nvoid DtwTree_add_tree_from_hardware(DtwTree *self,const char *path,DtwTreeProps props);\n\n DtwTreeTransactionReport * DtwTree_create_report( DtwTree *self);\n\n\n\nvoid DtwTree_insecure_hardware_remove_tree( DtwTree *self);\n\nvoid DtwTree_insecure_hardware_write_tree( DtwTree *self);\n\nvoid DtwTree_hardware_commit_tree( DtwTree *self);\n\nbool DtwTree_loads_json_tree( DtwTree *self, const char *content);\n\nbool DtwTree_loads_json_tree_from_file( DtwTree *self, const char *path);\n\nchar * DtwTree_dumps_tree_json(DtwTree *self,DtwTreeProps  props);\n\nvoid DtwTree_dumps_tree_json_to_file(DtwTree *self,const char *path,DtwTreeProps  props);\n\n  DtwTree * newDtwTree();\n\n"
	}, {
		"path":	"src/dependencies/doTheWorld/tree/tree/tree_finding.c",
		"is_binary":	false,
		"content":	"//\n// Created by jurandi on 11-04-2023.\n//\nstruct DtwTreePart *DtwTree_find_tree_part_by_function(\n        struct DtwTree *self,\n        bool (*caller)(struct  DtwTreePart *part)\n){\n    for(int i = 0;i < self->size; i++){\n        struct DtwTreePart *current = self->tree_parts[i];\n        bool result = caller(current);\n        if(result){\n            return current;\n        }\n    }\n    return NULL;\n}\n\nstruct DtwTree *DtwTree_filter(\n        struct DtwTree *self,\n        bool (*caller)(struct  DtwTreePart *part)\n){\n    DtwTree *filtered_tree = newDtwTree();\n\n    for(int i = 0;i < self->size; i++){\n\n        DtwTreePart *current = self->tree_parts[i];\n\n        bool result = caller(current);\n\n        if(result){\n            DtwTree_add_tree_part_copy(filtered_tree,current);\n        }\n\n    }\n    return filtered_tree;\n}\n\n\n DtwTree *DtwTree_map(DtwTree *self,DtwTreePart *(*caller)( DtwTreePart *part)){\n     DtwTree *mapped_tree = newDtwTree();\n\n    for(int i = 0;i < self->size; i++){\n         DtwTreePart *current = self->tree_parts[i];\n         DtwTreePart *copy = DtwTreePart_self_copy(current);\n         DtwTreePart *result = caller(copy);\n        DtwTree_add_tree_part_getting_onwership(mapped_tree, result);\n    }\n    return mapped_tree;\n}\n\n\n DtwTreePart *DtwTree_find_tree_part_by_name( DtwTree *self, const char *name){\n    for(int i = 0;i < self->size; i++){\n        DtwTreePart *current = self->tree_parts[i];\n        DtwPath *current_path = current->path;\n        char *current_name = DtwPath_get_full_name(current_path);\n        if(current_name){\n\n            if(strcmp(current_name, name) == 0){\n                return current;\n            }\n        }\n\n    }\n\n    return NULL;\n}\n\n DtwTreePart *DtwTree_find_tree_part_by_path( DtwTree *self, const char *path){\n    for(int i = 0;i < self->size; i++){\n         DtwTreePart *current = self->tree_parts[i];\n         DtwPath *current_path = current->path;\n        char *current_path_string = DtwPath_get_path(current_path);\n        if(current_path_string){\n            if(strcmp(current_path_string, path) == 0){\n                return current;\n            }\n        }\n\n    }\n\n    return NULL;\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/tree/tree_part/"
	}, {
		"path":	"src/dependencies/doTheWorld/tree/tree_part/hardware_tree_part.c",
		"is_binary":	false,
		"content":	"\n\n\n\n\n\nvoid DtwTreePart_load_content_from_hardware(struct DtwTreePart *self){\n\n    char *path = DtwPath_get_path(self->path);\n\n    if(path == NULL){\n        return;\n    }\n\n\n    if(dtw_entity_type(path) != DTW_FILE_TYPE){\n        return;\n    }\n\n    DtwTreePart_free_content(self);\n    self->content = dtw_load_any_content(path,&self->content_size,&self->is_binary);\n    self->hardware_content_size = self->content_size;\n    self->content_exist_in_hardware = true;\n\n\n}\n\n\n\nbool DtwTreePart_hardware_remove(struct DtwTreePart *self, int transaction){\n     if(self->ignore == true){\n        return false;\n     }\n     if(transaction == DTW_SET_AS_ACTION){\n        self->pending_action = DTW_REMOVE;\n        return false;\n     }\n\n    char *path =DtwPath_get_path(self->path);\n\n    remove(path);\n    \n    self->content_exist_in_hardware = false;\n    return true;\n}\n\nbool DtwTreePart_hardware_write(struct DtwTreePart *self, int transaction){\n    if(self->ignore == true){\n        return false;\n    }\n    if(transaction == DTW_SET_AS_ACTION){\n        self->pending_action = DTW_WRITE;\n        return false;\n    }   \n    //means that the content not exist in memory\n    if(self->content == NULL){\n        char *path = DtwPath_get_path(self->path);\n        char *dir = DtwPath_get_dir(self->path);\n        int entity_type = dtw_entity_type(path);\n       \n        if(entity_type== DTW_NOT_FOUND && dir!= NULL){\n            dtw_create_dir_recursively(dir);\n        \n        }\n \n\n        return true;\n    }\n    char *path = DtwPath_get_path(self->path);\n\n    dtw_write_any_content(path,self->content,(long)self->content_size);\n    free(self->hawdware_content_sha);\n    self->hawdware_content_sha = dtw_generate_sha_from_any(self->content,self->content_size);\n    self->content_exist_in_hardware = true;\n    private_DtwTreePart_set_last_modification(self,dtw_get_time());\n    return true;\n  \n}\n\nbool DtwTreePart_hardware_modify(struct DtwTreePart *self, int transaction){\n    if(self->ignore == true){\n        return false;\n    }\n    if(transaction == DTW_SET_AS_ACTION){\n        self->pending_action = DTW_MODIFY;\n        return false;\n    }\n    bool changed_path =DtwPath_changed(self->path);\n\n    \n    if(changed_path == true && self->content == NULL){\n        char *old_path = self->path->original_path_string;\n        char *new_path = DtwPath_get_path(self->path);\n        remove(old_path);\n        dtw_create_dir_recursively(new_path);\n        return true;\n    }\n\n    if(changed_path == false  && self->content == NULL){\n        return  false;\n    }\n\n    bool write = false;\n    if(changed_path == true){\n        char *old_path = self->path->original_path_string;\n        remove(old_path);\n        write = true;\n    }\n\n    if(changed_path== false){\n        if(self->metadata_loaded == true){\n            char *hardware_sha = self->hawdware_content_sha;\n            char *memory_sha = DtwTreePart_get_content_sha(self);\n            if(strcmp(hardware_sha,memory_sha) != 0){\n                write = true;\n            }\n        }\n        else{\n            write = true;\n        }\n    }\n\n    if(write){\n        char *path = DtwPath_get_path(self->path);\n        dtw_write_any_content(\n            path,\n            self->content,\n            (long)self->content_size\n        );\n        free(self->hawdware_content_sha);\n        self->hawdware_content_sha = dtw_generate_sha_from_string((const char *)self->content);\n        self->content_exist_in_hardware = true;\n        private_DtwTreePart_set_last_modification(self,dtw_get_time());\n\n\n        return true;\n    }\n    return false;\n}\n\nbool DtwTreePart_hardware_commit(struct DtwTreePart *self){\n    if(self->ignore == true){\n        return false;\n    }\n    if(self->pending_action == DTW_REMOVE){\n        return DtwTreePart_hardware_remove(self,DTW_EXECUTE_NOW);\n    }\n    if(self->pending_action == DTW_WRITE){\n        return DtwTreePart_hardware_write(self,DTW_EXECUTE_NOW);\n    }\n    if(self->pending_action == DTW_MODIFY){\n        return DtwTreePart_hardware_modify(self,DTW_EXECUTE_NOW);\n    }\n    return false;\n}\n"
	}, {
		"path":	"src/dependencies/doTheWorld/tree/tree_part/tree_part.c",
		"is_binary":	false,
		"content":	"\n\nvoid private_DtwTreePart_set_last_modification(DtwTreePart *self,long last_modification) {\n    self->last_modification_time = last_modification;\n    if(self->last_modification_in_str) {\n        free(self->last_modification_in_str);\n    }\n    self->last_modification_in_str = dtw_convert_unix_time_to_string(last_modification);\n}\n DtwTreePart * newDtwTreePart(const char *path, DtwTreeProps props){\n    DtwTreeProps formated_props = DtwTreeProps_format_props(props);\n\n    DtwTreePart *self = (DtwTreePart *)malloc(sizeof(struct DtwTreePart));\n    *self = (DtwTreePart){0};\n    self->path = newDtwPath(path);\n\n\n    if(formated_props.content == DTW_INCLUDE || formated_props.hadware_data == DTW_INCLUDE){\n        \n        DtwTreePart_load_content_from_hardware(self);\n        if(formated_props.hadware_data == DTW_INCLUDE && self->content){\n\n            self->metadata_loaded = true;\n            private_DtwTreePart_set_last_modification(self,dtw_get_entity_last_motification_in_unix(path));\n            free(self->hawdware_content_sha);\n            self->hawdware_content_sha = dtw_generate_sha_from_string((const char*)self->content);\n        }\n\n        if(formated_props.content == DTW_HIDE){\n            DtwTreePart_free_content(self);\n        }\n    }\n\n    return self;\n}\nchar *DtwTreePart_get_content_string_by_reference(struct DtwTreePart *self){\n    return (char *)self->content;\n}\n\nunsigned char *DtwTreePart_get_content_binary_by_reference(struct DtwTreePart *self){\n    return self->content;\n}\n\n\n  DtwTreePart * DtwTreePart_self_copy( DtwTreePart *self){\n    char *path = DtwPath_get_path(self->path);\n\n    DtwTreeProps props = {.content =DTW_NOT_LOAD,.hadware_data = DTW_NOT_LOAD};\n    DtwTreePart *new_tree_part = newDtwTreePart(\n            path,\n            props\n    );\n\n    new_tree_part->content_exist_in_hardware = self->content_exist_in_hardware;\n    new_tree_part->is_binary = self->is_binary;\n    new_tree_part->ignore = self->ignore;\n    new_tree_part->content_size = self->content_size;\n\n    char * current_sha = DtwTreePart_get_content_sha(self);\n\n    if(current_sha) {\n        new_tree_part->current_sha = strdup(current_sha);\n    }\n\n    if(self->hawdware_content_sha){\n        new_tree_part->hawdware_content_sha = strdup(self->hawdware_content_sha);\n    }\n\n    if(self->content) {\n        new_tree_part->content = (unsigned char *)malloc(self->content_size + 2);\n        memcpy(new_tree_part->content,self->content,self->content_size);\n\n        if(self->is_binary == false){\n            new_tree_part->content[self->content_size] = '\\0';\n        }\n\n    }\n\n\n    \n    return new_tree_part;\n}\n\nvoid DtwTreePart_set_any_content( DtwTreePart *self, unsigned char *content, long content_size, bool is_binary){\n\n    DtwTreePart_free_content(self);\n    self->is_binary = is_binary;\n    self->content = (unsigned char *)malloc(content_size+2);\n    memcpy(self->content,content,content_size);\n    self->content_size = content_size;\n\n\n}\n\nvoid DtwTreePart_set_string_content( DtwTreePart *self, const char *content){\n    DtwTreePart_set_any_content(\n        self,\n        (unsigned char*)content,\n        strlen(content),\n        false\n    );\n    \n    self->content[self->content_size] = '\\0';\n}\n\nvoid DtwTreePart_set_binary_content( DtwTreePart *self, unsigned char *content, long content_size){\n    DtwTreePart_set_any_content(self,content,content_size,true);\n}\n\n\nchar *DtwTreePart_get_content_sha( DtwTreePart *self){\n    if(self->content == NULL) {\n        return NULL;\n    }\n    if(self->current_sha) {\n        free(self->current_sha);\n    }\n    self->current_sha =dtw_generate_sha_from_any(self->content,self->content_size);;\n    return self->current_sha;\n}\n\n\n\n\n\n\n\nvoid DtwTreePart_represent(struct DtwTreePart *self){\n    printf(\"------------------------------------------------------------\\n\");\n    DtwPath_represent(self->path);\n    printf(\"Content Exist in Memory: %s\\n\",self->content ? \"true\" : \"false\");\n    printf(\"Ignore: %s\\n\",self->ignore ? \"true\" : \"false\");\n\n    printf(\"Content Exist In Hardware: %s\\n\",self->content_exist_in_hardware ? \"true\" : \"false\");\n    printf(\"Is Binary: %s\\n\",self->is_binary ? \"true\" : \"false\");\n\n    if(self->last_modification_in_str){\n        printf(\"Last Modification Time in Unix: %li\\n\",self->last_modification_time);\n        printf(\"Last Modification Time: %s\\n\",self->last_modification_in_str);\n    }\n\n    printf(\"Content Size: %ld\\n\",(long)self->content_size);\n\n    char *content_sha = DtwTreePart_get_content_sha(self);\n    if(content_sha){\n        printf(\"Content SHA:  %s\\n\",content_sha);\n    }\n    if(self->content && self->is_binary == false){\n        printf (\"Content: %s\\n\",(char*)self->content);\n    }\n\n    if(self->hawdware_content_sha) {\n        printf(\"Original Hardware SHA:%s\\n\",self->hawdware_content_sha);\n    }\n\n    if(self->is_binary == true){\n        printf(\"Content: Binary\\n\");\n    }\n    \n    const char *action = private_dtw_convert_action_to_string(self->pending_action);\n    if(action){\n        printf(\"Pending Action: %s\\n\",action);\n\n    }\n\n}\n\n\nvoid DtwTreePart_free_content(struct DtwTreePart *self){\n    if(self->content){\n        free(self->content);\n    }\n    self->content = NULL;\n\n}\nvoid DtwTreePart_free(struct DtwTreePart *self){\n    if(self->path) {\n        DtwPath_free(self->path);\n    }\n\n    if(self->hawdware_content_sha) {\n        free(self->hawdware_content_sha);\n    }\n    if(self->current_sha) {\n        free(self->current_sha);\n    }\n    if(self->last_modification_in_str) {\n        free(self->last_modification_in_str);\n    }\n    DtwTreePart_free_content(self);\n    free(self);\n}\n\n DtwTreePart * newDtwTreePartEmpty(const char *path){\n    DtwTreeProps  props = {.content =DTW_NOT_LOAD,.hadware_data = DTW_NOT_LOAD};\n    return newDtwTreePart(\n            path,\n         props\n    );\n\n}\n\n\n DtwTreePart * newDtwTreePartLoading(const char *path){\n    DtwTreeProps  props = {.content =DTW_LOAD,.hadware_data = DTW_LOAD};\n    return newDtwTreePart(\n            path,\n            props\n    );\n}\n"
	}, {
		"path":	"src/dependencies/doTheWorld/tree/tree_part/tree_part.h",
		"is_binary":	false,
		"content":	"\n\n#define DTW_IS_BINARY true\n#define DTW_IS_NOT_BINARY false\n#define DTW_IGNORE true\n#define DTW_NOT_IGNORE false\n\n#define DTW_SET_AS_ACTION 1\n#define DTW_EXECUTE_NOW 2\n\n#define DTW_MODIFY 1\n#define DTW_WRITE 2\n#define DTW_REMOVE 3\n\ntypedef struct DtwTreePart{\n    \n     DtwPath *path;\n    void *owner;\n    long content_size;\n    long  hardware_content_size;\n    bool content_exist_in_hardware;\n    bool ignore;\n    bool is_binary;\n    bool metadata_loaded;\n    char *current_sha;\n    char * last_modification_in_str;\n    long last_modification_time;\n    char *hawdware_content_sha;\n\n    unsigned char *content;\n    int pending_action;\n\n\n}DtwTreePart;\n\nvoid private_DtwTreePart_set_last_modification(DtwTreePart *self,long last_modification);\n\nchar *DtwTreePart_get_content_string_by_reference( DtwTreePart *self);\nunsigned char *DtwTreePart_get_content_binary_by_reference( DtwTreePart *self);\nchar *DtwTreePart_get_content_sha( DtwTreePart *self);\nvoid DtwTreePart_set_any_content( DtwTreePart *self, unsigned char *content, long content_size, bool is_binary);\nvoid DtwTreePart_set_string_content( DtwTreePart *self, const char *content);\nvoid DtwTreePart_set_binary_content( DtwTreePart *self, unsigned char *content, long content_size);\nvoid DtwTreePart_load_content_from_hardware( DtwTreePart *self);\nvoid DtwTreePart_free_content( DtwTreePart *self);\nvoid DtwTreePart_represent( DtwTreePart *self);\n\nbool DtwTreePart_hardware_remove( DtwTreePart *self,int transaction);\nbool DtwTreePart_hardware_write( DtwTreePart *self,int transaction);\nbool DtwTreePart_hardware_modify( DtwTreePart *self,int transaction);\n\n\nbool DtwTreePart_hardware_commit(struct DtwTreePart *self);\n\nvoid DtwTreePart_free(struct DtwTreePart *self);\nstruct DtwTreePart * DtwTreePart_self_copy(struct DtwTreePart *self);\n\nstruct DtwTreePart * newDtwTreePart(const char *path, DtwTreeProps props);\nstruct DtwTreePart * newDtwTreePartEmpty(const char *path);\nstruct DtwTreePart * newDtwTreePartLoading(const char *path);\n"
	}, {
		"path":	"src/dependencies/doTheWorld/tree/tree_props/"
	}, {
		"path":	"src/dependencies/doTheWorld/tree/tree_props/tree_props.c",
		"is_binary":	false,
		"content":	"//\n// Created by jurandi on 01-07-2023.\n//\n\nDtwTreeProps DtwTreeProps_format_props(DtwTreeProps props){\n    DtwTreeProps result = props;\n\n    if(!result.minification){\n        result.minification = DTW_NOT_MIMIFY;\n    }\n    if(!result.content){\n        result.content = DTW_INCLUDE;\n    }\n    if(!result.path_atributes){\n        result.path_atributes = DTW_INCLUDE;\n    }\n    if(!result.hadware_data){\n        result.hadware_data = DTW_INCLUDE;\n    }\n    if(!result.content_data){\n        result.content_data = DTW_INCLUDE;\n    }\n    if(!result.ignored_elements){\n        result.ignored_elements = DTW_HIDE;\n    }\n    return result;\n}"
	}, {
		"path":	"src/dependencies/doTheWorld/tree/tree_props/tree_props.h",
		"is_binary":	false,
		"content":	"\n\n#define DTW_NOT_MIMIFY 1\n#define DTW_MIMIFY 2\n\n#define DTW_NOT_LOAD 1\n#define DTW_LOAD 2\n\n#define DTW_HIDE 1\n#define DTW_INCLUDE 2\n\ntypedef struct DtwTreeProps{\n   int minification;\n   int content;\n   int path_atributes;\n   int hadware_data;\n   int content_data;\n   int ignored_elements;\n\n}DtwTreeProps;\n\n\n\nDtwTreeProps DtwTreeProps_format_props(DtwTreeProps props);\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/LuaCEmbed.h",
		"is_binary":	false,
		"content":	"\ntypedef struct LuaCEmbed{\n    lua_State *state;\n    const char *current_function;\n    bool is_lib;\n    int total_args;\n    char *error_msg;\n    void (*delete_function)(struct  LuaCEmbed *self);\n    void *global_tables;\n    void *func_tables;\n    int lib_identifier;\n    int stack_leve;\n    char *main_lib_table;\n    bool field_protection;\n}LuaCEmbed;\n\nint lua_cembed_timeout = -1;\nLuaCEmbed  *global_current_lua_embed_object;\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/args/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/args/args_error/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/args/args_error/args_error.c",
		"is_binary":	false,
		"content":	"\n\nint LuaCEmbed_ensure_arg_exist(LuaCEmbed *self, private_lua_cembed_incremented_arg index){\n    PRIVATE_LUA_CEMBED_PROTECT_NUM\n\n    if(index > self->total_args){\n\n        privateLuaCEmbed_raise_error_not_jumping(self, PRIVATE_LUA_CEMBED_ARG_NOT_PROVIDED,index,self->current_function);\n        return LUA_CEMBED_GENERIC_ERROR;\n    }\n    return LUA_CEMBED_OK;\n\n}\n\nint private_LuaCEmbed_ensure_top_stack_arg_type(LuaCEmbed *self, int index,int arg_type) {\n    PRIVATE_LUA_CEMBED_PROTECT_NUM\n    int type = lua_type(self->state, -1);\n    if (type != arg_type) {\n\n        privateLuaCEmbed_raise_error_not_jumping(self,\n             PRIVATE_LUA_CEMBED_ARG_WRONG_TYPE,\n             index + LUA_CEMBED_INDEX_DIF,\n             self->current_function,\n             LuaCembed_convert_arg_code(type),\n             LuaCembed_convert_arg_code(arg_type)\n        );\n        return LUA_CEMBED_GENERIC_ERROR;\n    }\n\n    return LUA_CEMBED_OK;\n\n}\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/args/args_error/args_error.h",
		"is_binary":	false,
		"content":	"\n\nint LuaCEmbed_ensure_arg_exist(LuaCEmbed *self, private_lua_cembed_incremented_arg index);\n\nint private_LuaCEmbed_ensure_top_stack_arg_type(LuaCEmbed *self, int index,int arg_type);\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/args/basic/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/args/basic/basic.c",
		"is_binary":	false,
		"content":	"\nint  privateLuaCEmbed_put_arg_on_top(LuaCEmbed *self, int index){\n    PRIVATE_LUA_CEMBED_PROTECT_NUM\n    long  formatted_index = index + LUA_CEMBED_INDEX_DIF;\n\n    if(formatted_index > self->total_args){\n        privateLuaCEmbed_raise_error_not_jumping(self,PRIVATE_LUA_CEMBED_ARG_NOT_PROVIDED,formatted_index,self->current_function);\n        return LUA_CEMBED_GENERIC_ERROR;\n     }\n\n    char *formated_arg = private_LuaCembed_format(PRIVATE_LUA_CEMBED_ARGS_,self->stack_leve,formatted_index-1);\n    lua_getglobal(self->state,formated_arg);\n    int type = lua_type(self->state,-1);\n    if(type == LUA_CEMBED_NOT_FOUND || type == LUA_CEMBED_NIL){\n        privateLuaCEmbed_raise_error_not_jumping(self,PRIVATE_LUA_CEMBED_ARG_NOT_PROVIDED,formatted_index,self->current_function);\n        free(formated_arg);\n        return LUA_CEMBED_GENERIC_ERROR;\n    }\n\n    free(formated_arg);\n    return LUA_OK;\n}\n\nint  LuaCEmbed_get_total_args(LuaCEmbed *self){\n    return self->total_args;\n}\n\n\n\nint  LuaCEmbed_get_arg_type(LuaCEmbed *self,int index){\n\n    long  formatted_index = index + LUA_CEMBED_INDEX_DIF;\n\n    if(formatted_index > self->total_args){\n        return LUA_CEMBED_NIL;\n    }\n\n    char *formated_arg = private_LuaCembed_format(PRIVATE_LUA_CEMBED_ARGS_,self->stack_leve,formatted_index-1);\n    lua_getglobal(self->state,formated_arg);\n    int type = lua_type(self->state, -1);\n    free(formated_arg);\n    PRIVATE_LUA_CEMBED_CLEAR_STACK\n    return type;\n}\n\n\nlong long LuaCEmbed_get_long_arg(LuaCEmbed *self, int index){\n    PRIVATE_LUA_CEMBED_PROTECT_NUM\n\n\n    if(privateLuaCEmbed_put_arg_on_top(self,index)){\n        PRIVATE_LUA_CEMBED_CLEAR_STACK\n       return (long )LUA_CEMBED_NOT_FOUND;\n    }\n\n    if(private_LuaCEmbed_ensure_top_stack_arg_type(self,index,LUA_CEMBED_NUMBER)){\n        PRIVATE_LUA_CEMBED_CLEAR_STACK\n        return (long )LUA_CEMBED_NOT_FOUND;\n    }\n\n    long long result =  (long long)lua_tonumber(self->state,-1);\n    PRIVATE_LUA_CEMBED_CLEAR_STACK\n    return result;\n}\n\n\ndouble LuaCEmbed_get_double_arg(LuaCEmbed *self, int index){\n    PRIVATE_LUA_CEMBED_PROTECT_NUM\n\n    if(privateLuaCEmbed_put_arg_on_top(self,index)){\n        PRIVATE_LUA_CEMBED_CLEAR_STACK\n       return (long )LUA_CEMBED_NOT_FOUND;\n    }\n    if(private_LuaCEmbed_ensure_top_stack_arg_type(self,index,LUA_CEMBED_NUMBER)){\n        PRIVATE_LUA_CEMBED_CLEAR_STACK\n        return (long )LUA_CEMBED_NOT_FOUND;\n    }\n    double result = lua_tonumber(self->state,-1);\n    PRIVATE_LUA_CEMBED_CLEAR_STACK\n    return result;\n}\n\nbool LuaCEmbed_get_bool_arg(LuaCEmbed *self, int index){\n    PRIVATE_LUA_CEMBED_PROTECT_BOOL\n\n    if(privateLuaCEmbed_put_arg_on_top(self,index)){\n        PRIVATE_LUA_CEMBED_CLEAR_STACK\n       return (long )LUA_CEMBED_NOT_FOUND;\n    }\n    if(private_LuaCEmbed_ensure_top_stack_arg_type(self,index,LUA_CEMBED_BOOL)){\n    PRIVATE_LUA_CEMBED_CLEAR_STACK\n        return (long )LUA_CEMBED_NOT_FOUND;\n    }\n    bool result = lua_toboolean(self->state,-1);\n    PRIVATE_LUA_CEMBED_CLEAR_STACK\n    return result;\n}\n\n\nchar * LuaCEmbed_get_str_arg(LuaCEmbed *self, int index){\n    PRIVATE_LUA_CEMBED_PROTECT_NULL\n    PRIVATE_LUA_CEMBED_CLEAR_STACK\n\n    if(privateLuaCEmbed_put_arg_on_top(self,index)){\n        PRIVATE_LUA_CEMBED_CLEAR_STACK\n        return NULL;\n    }\n\n    if(private_LuaCEmbed_ensure_top_stack_arg_type(self,index,LUA_CEMBED_STRING)){\n        return NULL;\n    }\n    char *result =  (char*)lua_tostring(self->state,-1);\n    PRIVATE_LUA_CEMBED_CLEAR_STACK\n    return result;\n}\nchar * LuaCEmbed_get_raw_str_arg(LuaCEmbed *self,long *size, int index){\n    PRIVATE_LUA_CEMBED_PROTECT_NULL\n    PRIVATE_LUA_CEMBED_CLEAR_STACK\n\n    if(privateLuaCEmbed_put_arg_on_top(self,index)){\n        PRIVATE_LUA_CEMBED_CLEAR_STACK\n       return NULL;\n    }\n\n    if(private_LuaCEmbed_ensure_top_stack_arg_type(self,index,LUA_CEMBED_STRING)){\n        return NULL;\n    }\n    char *result =  (char*)lua_tolstring(self->state,-1,(size_t*)size);\n    PRIVATE_LUA_CEMBED_CLEAR_STACK\n    return result;\n}\n\nLuaCEmbedTable  * LuaCEmbed_get_arg_table(LuaCEmbed *self,int index){\n    PRIVATE_LUA_CEMBED_PROTECT_NULL\n\n    if(privateLuaCEmbed_put_arg_on_top(self,index)){\n        PRIVATE_LUA_CEMBED_CLEAR_STACK\n       return NULL;\n    }\n\n    if(private_LuaCEmbed_ensure_top_stack_arg_type(self,index,LUA_CEMBED_TABLE)){\n        return NULL;\n    }\n\n    int formatted_index = index + LUA_CEMBED_INDEX_DIF;\n    char *formated_arg = private_LuaCembed_format(PRIVATE_LUA_CEMBED_ARGS_,self->stack_leve,formatted_index-1);\n    LuaCEmbedTable  *created = LuaCembed_get_global_table(self,formated_arg);\n    free(formated_arg);\n    PRIVATE_LUA_CEMBED_CLEAR_STACK\n    return created;\n\n}\n\nLuaCEmbedTable* LuaCEmbed_run_args_lambda(LuaCEmbed *self, int index, LuaCEmbedTable *args_to_call, int total_returns){\n\n    long  formatted_index = index + LUA_CEMBED_INDEX_DIF;\n    char *formatted_arg = private_LuaCembed_format(PRIVATE_LUA_CEMBED_ARGS_,self->stack_leve,formatted_index-1);\n\n    if(privateLuaCEmbed_put_arg_on_top(self,index)){\n        PRIVATE_LUA_CEMBED_CLEAR_STACK\n        free(formatted_arg);\n       return NULL;\n    }\n\n    if(private_LuaCEmbed_ensure_top_stack_arg_type(self,index,LUA_CEMBED_FUNCTION)){\n        free(formatted_arg);\n        PRIVATE_LUA_CEMBED_CLEAR_STACK\n        return  NULL;\n    }\n\n    int total_args = private_lua_cEmbed_unpack(args_to_call,formatted_arg);\n    if(lua_pcall(self->state,total_args,total_returns,0)){\n\n        privateLuaCEmbed_raise_error_not_jumping(self, lua_tostring(self->state,-1));\n        free(formatted_arg);\n\n        PRIVATE_LUA_CEMBED_CLEAR_STACK\n        return  NULL;\n    }\n\n\n    for(int i = 0; i < total_returns; i++){\n        char *formatted = private_LuaCembed_format(PRIVATE_LUA_CEMBED_MULTIRETURN_,self->stack_leve,i);\n        int position = (i +1) * -1;\n        lua_pushvalue(self->state,position);\n        lua_setglobal(self->state,formatted);\n        free(formatted);\n    }\n\n\n\n    LuaCEmbedTable  *result = LuaCembed_new_anonymous_table(self);\n    for(int i = 0; i < total_returns; i++){\n        lua_getglobal(self->state,result->global_name);\n        lua_pushinteger(self->state,i+1);\n        char *formatted = private_LuaCembed_format(PRIVATE_LUA_CEMBED_MULTIRETURN_,self->stack_leve,i);\n        lua_getglobal(self->state,formatted);\n        lua_settable(self->state,-3);\n        free(formatted);\n    }\n    free(formatted_arg);\n    PRIVATE_LUA_CEMBED_CLEAR_STACK\n    return result;\n\n}\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/args/basic/basic.h",
		"is_binary":	false,
		"content":	"\nint privateLuaCEmbed_put_arg_on_top(LuaCEmbed *self, int index);\n\nint  LuaCEmbed_get_total_args(LuaCEmbed *self);\n\nint  LuaCEmbed_get_arg_type(LuaCEmbed *self,int index);\n\n\n\nlong long LuaCEmbed_get_long_arg(LuaCEmbed *self, int index);\n\ndouble LuaCEmbed_get_double_arg(LuaCEmbed *self, int index);\n\nbool LuaCEmbed_get_bool_arg(LuaCEmbed *self, int index);\n\nchar * LuaCEmbed_get_str_arg(LuaCEmbed *self, int index);\n\nchar * LuaCEmbed_get_raw_str_arg(LuaCEmbed *self,long *size, int index);\n\nLuaCEmbedTable  * LuaCEmbed_get_arg_table(LuaCEmbed *self,int index);\n\nLuaCEmbedTable* LuaCEmbed_run_args_lambda(LuaCEmbed *self, int index, LuaCEmbedTable *args_to_call, int total_returns);\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/args/declaration.h",
		"is_binary":	false,
		"content":	"#include \"args_error/args_error.h\"\n#include \"basic/basic.h\"\n#include \"evaluation/evaluation.h\""
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/args/definition.h",
		"is_binary":	false,
		"content":	"#include \"args_error/args_error.c\"\n#include \"basic/basic.c\"\n#include \"evaluation/evaluation.c\""
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/args/evaluation/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/args/evaluation/evaluation.c",
		"is_binary":	false,
		"content":	"\n\nint private_LuaCembed_run_code_with_args(LuaCEmbed *self,int index,const char *code,va_list args){\n    PRIVATE_LUA_CEMBED_PROTECT_NUM\n\n    int formatted_index = index + LUA_CEMBED_INDEX_DIF;\n\n    if(LuaCEmbed_ensure_arg_exist(self,formatted_index)){\n        return LUA_CEMBED_GENERIC_ERROR;\n    }\n\n    char *formated_expresion = private_LuaCembed_format_vaarg(code,args);\n\n    char *buffer = private_LuaCembed_format(\n            PRIVATE_LUA_CEMBED_GLOBAL_EVALUATION_CODE,\n            PRIVATE_LUA_CEMBED_EVALUATION_NAME,\n            formated_expresion\n    );\n\n    if(LuaCEmbed_evaluate(self, buffer)){\n        free(formated_expresion);\n        free(buffer);\n        return  LUA_CEMBED_GENERIC_ERROR;\n    }\n    free(buffer);\n\n    lua_getglobal(self->state,PRIVATE_LUA_CEMBED_EVALUATION_NAME);\n\n    int type = lua_type(self->state,-1);\n\n    if(type != LUA_CEMBED_FUNCTION){\n        privateLuaCEmbed_raise_error_not_jumping(self,PRIVATE_LUA_CEMBED_CODE_ITS_NOT_A_FUNCTION,formated_expresion);\n        free(formated_expresion);\n        return LUA_CEMBED_GENERIC_ERROR;\n    }\n\n    free(formated_expresion);\n    lua_getglobal(self->state,PRIVATE_LUA_CEMBED_EVALUATION_NAME);\n    privateLuaCEmbed_put_arg_on_top(self,index);\n\n    if(lua_pcall(self->state,1,1,0)){\n        const char *generated_error = lua_tostring(self->state,-1);\n        privateLuaCEmbed_raise_error_not_jumping(self, generated_error);\n    }\n    return LUA_CEMBED_OK;\n}\n\nint privateLuaCembed_ensure_arg_evaluation_type(LuaCEmbed *self,int index,int expected_type){\n    PRIVATE_LUA_CEMBED_PROTECT_NUM\n\n    int actual_type = lua_type(self->state,-1);\n    if(actual_type== expected_type){\n        return LUA_CEMBED_OK;\n    }\n\n    privateLuaCEmbed_raise_error_not_jumping(self,\n             PRIVATE_LUA_CEMBED_RESULT_EVALUATION_ARG_WRONG_TYPE,\n             self->current_function,\n             index,\n             LuaCembed_convert_arg_code(actual_type),\n             LuaCembed_convert_arg_code(expected_type)\n     );\n    return LUA_CEMBED_GENERIC_ERROR;\n}\nint LuaCEmbed_get_type_clojure_evalation(LuaCEmbed *self,int index,const char *code,...){\n    PRIVATE_LUA_CEMBED_PROTECT_NUM\n\n    va_list args;\n    va_start(args,code);\n    int possible_error = private_LuaCembed_run_code_with_args(self,index,code,args);\n    va_end(args);\n    if(possible_error){\n        return possible_error;\n    }\n    return lua_type(self->state,-1);\n}\nint LuaCEmbed_generate_arg_clojure_evalation(LuaCEmbed *self,int index,const char *code,...){\n    PRIVATE_LUA_CEMBED_PROTECT_NUM\n\n    va_list args;\n    va_start(args,code);\n    int possible_error = private_LuaCembed_run_code_with_args(self,index,code,args);\n    va_end(args);\n    if(possible_error){\n        return possible_error;\n    }\n    return LUA_CEMBED_OK;\n}\nlong long LuaCEmbed_get_long_arg_clojure_evalation(LuaCEmbed *self,int index,const char *code,...){\n    PRIVATE_LUA_CEMBED_PROTECT_NUM\n\n    va_list args;\n    va_start(args,code);\n    int possible_error = private_LuaCembed_run_code_with_args(self,index,code,args);\n    va_end(args);\n    if(possible_error){\n        return possible_error;\n    }\n    if(privateLuaCembed_ensure_arg_evaluation_type(self,index,LUA_CEMBED_NUMBER)){\n        return  LUA_CEMBED_GENERIC_ERROR;\n    }\n    return (long long) lua_tonumber(self->state,-1);\n\n}\n\n\ndouble LuaCEmbed_get_double_arg_clojure_evalation(LuaCEmbed *self,int index,const char *code,...){\n    PRIVATE_LUA_CEMBED_PROTECT_NUM\n\n    va_list args;\n    va_start(args,code);\n    int possible_error = private_LuaCembed_run_code_with_args(self,index,code,args);\n    va_end(args);\n    if(possible_error){\n        return possible_error;\n    }\n    if(privateLuaCembed_ensure_arg_evaluation_type(self,index,LUA_CEMBED_NUMBER)){\n        return  LUA_CEMBED_GENERIC_ERROR;\n    }\n    return (double ) lua_tonumber(self->state,-1);\n\n}\n\nbool LuaCEmbed_get_bool_arg_clojure_evalation(LuaCEmbed *self,int index,const  char *code,...){\n    PRIVATE_LUA_CEMBED_PROTECT_BOOL\n    va_list args;\n    va_start(args,code);\n    int possible_error = private_LuaCembed_run_code_with_args(self,index,code,args);\n    va_end(args);\n    if(possible_error){\n        return possible_error;\n    }\n    if(privateLuaCembed_ensure_arg_evaluation_type(self,index,LUA_CEMBED_NUMBER)){\n        return  false;\n    }\n    return lua_toboolean(self->state,-1);\n\n}\n\nchar* LuaCEmbed_get_string_arg_clojure_evalation(LuaCEmbed *self,int index,const  char *code,...){\n    PRIVATE_LUA_CEMBED_PROTECT_NULL\n    va_list args;\n    va_start(args,code);\n    int possible_error = private_LuaCembed_run_code_with_args(self,index,code,args);\n    va_end(args);\n    if(possible_error){\n        return  NULL;\n    }\n    if(privateLuaCembed_ensure_arg_evaluation_type(self,index,LUA_CEMBED_NUMBER)){\n        return  NULL;\n    }\n    return (char*)lua_tostring(self->state,-1);\n\n}\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/args/evaluation/evaluation.h",
		"is_binary":	false,
		"content":	"\n\nint private_LuaCembed_run_code_with_args(LuaCEmbed *self,int index,const char *code,va_list args);\n\nint privateLuaCembed_ensure_arg_evaluation_type(LuaCEmbed *self,int index,int expected_type);\n\nint LuaCEmbed_get_type_clojure_evalation(LuaCEmbed *self,int index,const char *code,...);\n\nint LuaCEmbed_generate_arg_clojure_evalation(LuaCEmbed *self,int index,const char *code,...);\n\nlong long LuaCEmbed_get_long_arg_clojure_evalation(LuaCEmbed *self,int index,const char *code,...);\n\n\ndouble LuaCEmbed_get_double_arg_clojure_evalation(LuaCEmbed *self,int index,const char *code,...);\n\nbool LuaCEmbed_get_bool_arg_clojure_evalation(LuaCEmbed *self,int index,const char *code,...);\n\nchar* LuaCEmbed_get_string_arg_clojure_evalation(LuaCEmbed *self,int index,const char *code,...);\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/basic/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/basic/basic.c",
		"is_binary":	false,
		"content":	"\n\nLuaCEmbed * newLuaCEmbedEvaluation(){\n    LuaCEmbed  *self = (LuaCEmbed*) malloc(sizeof (LuaCEmbed));\n    *self = (LuaCEmbed){0};\n    self->state = luaL_newstate();\n\n    self->global_tables = (void*)newprivateLuaCEmbedTableArray();\n\n    return self;\n}\nvoid LuaCEmbed_load_lib_from_c(LuaCEmbed *self,int (*callback)(lua_State *l),const char *name){\n    int result = callback(self->state);\n    if(result > 0){\n        lua_setglobal(self->state,name);\n    }\n}\n\n\n\n\n\nvoid LuaCembed_set_delete_function(LuaCEmbed *self,void (*delelte_function)(struct  LuaCEmbed *self)){\n    self->delete_function = delelte_function;\n}\n\n\n\n\nvoid LuaCEmbed_set_timeout(int seconds){\n    lua_cembed_timeout = seconds;\n}\n\nchar * LuaCEmbed_get_error_message(LuaCEmbed *self){\n    if(!self){\n        return NULL;\n    }\n\n    return self->error_msg;\n}\nvoid LuaCEmbed_clear_errors(LuaCEmbed *self){\n    if(!self){\n        return;\n    }\n\n    if(self->error_msg){\n        free(self->error_msg);\n        self->error_msg = NULL;\n    }\n}\nvoid * privateLuaCEmbed_get_current_table_array(LuaCEmbed *self){\n    if(self->current_function){\n       return  self->func_tables;\n    }\n    return self->global_tables;\n}\nvoid privateLuaCEmbed_raise_error_not_jumping(LuaCEmbed *self, const char *error_msg, ...){\n\n    if(LuaCEmbed_has_errors(self)){\n        return;\n    }\n\n    va_list args;\n    va_start(args,error_msg);\n    self->error_msg = private_LuaCembed_format_vaarg(error_msg, args);\n    va_end(args);\n\n}\n\n\n\nbool LuaCEmbed_has_errors(LuaCEmbed *self){\n    if(!self){\n        return true;\n    }\n\n    if(self->error_msg){\n        return  true;\n    }\n\n    return false;\n}\n\n\n\n\n\n\nvoid privata_LuaCEmbed_increment_stack_(LuaCEmbed *self){\n    lua_getglobal(self->state,PRIVATE_LUA_CEMBED_STACK_LEVEL);\n    int value = 0;\n    if(lua_type(self->state,-1) == LUA_CEMBED_NUMBER){\n        value =  lua_tonumber(self->state,-1);\n    }\n    int new_value = value+1;\n    lua_pushinteger(self->state,new_value);\n    lua_setglobal(self->state,PRIVATE_LUA_CEMBED_STACK_LEVEL);\n    self->stack_leve =new_value;\n}\n\n\nvoid  privata_LuaCEmbed_decrement_stack(LuaCEmbed *self){\n    lua_getglobal(self->state,PRIVATE_LUA_CEMBED_STACK_LEVEL);\n    int value = 0;\n    if(lua_type(self->state,-1) == LUA_CEMBED_NUMBER){\n        value =  lua_tointeger(self->state,-1);\n    }\n    if(value> 0){\n        int new_value = value -1;\n        lua_pushinteger(self->state,new_value);\n        lua_setglobal(self->state,PRIVATE_LUA_CEMBED_STACK_LEVEL);\n        self->stack_leve = new_value;\n    }\n\n}\n\nvoid privateLuaCEmbd_get_field_protected(LuaCEmbed *self,const char *name){\n    bool old_field_proection = self->field_protection;\n    self->field_protection = true;\n    lua_getfield(self->state,-1,name);\n    self->field_protection = old_field_proection;\n}\n\nvoid LuaCEmbed_free(LuaCEmbed *self){\n    privateLuaCEmbedTableArray_free((privateLuaCEmbedTableArray*)self->global_tables);\n    if(!self->is_lib){ //se for do prprio lua, o lua cuidar de limpar\n        lua_close(self->state); // Fecha o estado Lua\n    }\n    if(self->error_msg){\n        free(self->error_msg);\n    }\n    if(self->main_lib_table){\n        free(self->main_lib_table);\n    }\n    free(self);\n}\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/basic/basic.h",
		"is_binary":	false,
		"content":	"\n\n\nLuaCEmbed * newLuaCEmbedEvaluation();\n\n\nint private_LuaCemb_internal_free(lua_State *L);\n\nvoid LuaCEmbed_load_lib_from_c(LuaCEmbed *self,int (*callback)(lua_State *l),const char *name);\n\nvoid LuaCembed_set_delete_function(LuaCEmbed *self,void (*delelte_function)(struct  LuaCEmbed *self));\n\nchar * LuaCEmbed_get_error_message(LuaCEmbed *self);\n\n\nbool LuaCEmbed_has_errors(LuaCEmbed *self);\n\nvoid LuaCEmbed_clear_errors(LuaCEmbed *self);\n\nvoid privateLuaCEmbd_get_field_protected(LuaCEmbed *self,const char *name);\n\nvoid privateLuaCEmbed_raise_error_not_jumping(LuaCEmbed *self, const char *error, ...);\n\nvoid * privateLuaCEmbed_get_current_table_array(LuaCEmbed *self);\n\n\nvoid LuaCEmbed_set_timeout(int seconds);\n\n\n\nvoid  privata_LuaCEmbed_increment_stack_(LuaCEmbed *self);\n\n\nvoid  privata_LuaCEmbed_decrement_stack(LuaCEmbed *self);\n\nvoid LuaCEmbed_free(LuaCEmbed *self);\n\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/callback_handle/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/callback_handle/callback_handle.c",
		"is_binary":	false,
		"content":	"\n\nint privateLuaCEmbed_main_callback_handler(lua_State  *L){\n\n    bool is_a_method = lua_toboolean(L, lua_upvalueindex(1));\n    bool is_a_function = !is_a_method;\n    LuaCEmbedResponse *possible_return = NULL;\n    LuaCEmbed  *self = (LuaCEmbed*)lua_touserdata(L,lua_upvalueindex(2));\n    int old_total_args = self->total_args;\n    self->total_args =  lua_gettop(self->state);\n    privata_LuaCEmbed_increment_stack_(self);\n\n    lua_getglobal(self->state,PRIVATE_LUA_CEMBED_STACK_LEVEL);\n    self->stack_leve = (int)lua_tonumber(self->state,-1);\n\n    for(int i  = 0; i < self->total_args; i++){\n        char *formated_arg = private_LuaCembed_format(PRIVATE_LUA_CEMBED_ARGS_,self->stack_leve,i);\n        lua_pushvalue(L,i+1);\n        lua_setglobal(L,formated_arg);\n        free(formated_arg);\n    }\n\n    const char *func_name =  lua_tostring(L,lua_upvalueindex(3));\n    self->current_function = func_name;\n    void *old_funct_tables = self->func_tables;\n    self->func_tables = (void*)newprivateLuaCEmbedTableArray();\n    if(is_a_method){\n        LuaCEmbedResponse *(*method_callback)(LuaCEmbedTable *tb, LuaCEmbed *self);\n\n        //equivalent of PRIVATE_LUA_CEMBED_SELFNAME = index[4]\n        lua_pushvalue(L, lua_upvalueindex(4));\n        lua_setglobal(L,PRIVATE_LUA_CEMBED_SELFNAME);\n\n        LuaCEmbedTable  *table = private_newLuaCembedTable(self, PRIVATE_LUA_CEMBED_SELFNAME);\n        method_callback = (LuaCEmbedResponse *(*)(LuaCEmbedTable *tb, LuaCEmbed *self))lua_touserdata(L, lua_upvalueindex(5));\n        possible_return = method_callback(table,self);\n        privateLuaCEmbedTable_free(table);\n    }\n\n    if(is_a_function){\n        LuaCEmbedResponse *(*function_callback)(LuaCEmbed *self);\n        function_callback = (LuaCEmbedResponse *(*)(LuaCEmbed *self))lua_touserdata(L, lua_upvalueindex(4));\n        possible_return = function_callback(self);\n    }\n\n    privateLuaCEmbedTableArray_free((privateLuaCEmbedTableArray*)self->func_tables);\n    self->func_tables = old_funct_tables;\n    self->total_args = old_total_args;\n    privata_LuaCEmbed_decrement_stack(self);\n    PRIVATE_LUA_CEMBED_CLEAR_STACK\n    self->current_function = NULL;\n\n    if(possible_return==NULL){\n        return PRIVATE_LUACEMBED_NO_RETURN;\n    }\n\n    if(possible_return->type == PRIVATE_LUA_CEMBED_ERROR_RESPONSE){\n\n        if(self->field_protection){\n            private_LuaCEmbedResponse_free(possible_return);\n            if(self->error_msg){\n                free(self->error_msg);\n                self->error_msg = NULL;\n            }\n\n            return PRIVATE_LUACEMBED_NO_RETURN;\n        }\n\n        lua_pushstring(L, possible_return->string_val);\n        privateLuaCEmbed_raise_error_not_jumping(self,possible_return->string_val);\n        private_LuaCEmbedResponse_free(possible_return);\n        lua_error(L);\n        return PRIVATE_LUACEMBED_NO_RETURN;\n    }\n\n    if(possible_return->type == PRIVATE_LUA_CEMBED_LONG_RESPONSE){\n        lua_pushinteger(L, (int)possible_return->num_val);\n        private_LuaCEmbedResponse_free(possible_return);\n        return PRIVATE_LUACEMBED_ONE_RETURN;\n    }\n\n    if(possible_return->type == PRIVATE_LUA_CEMBED_BOOL_RESPONSE){\n        lua_pushboolean(L, (bool)possible_return->num_val);\n        private_LuaCEmbedResponse_free(possible_return);\n        return PRIVATE_LUACEMBED_ONE_RETURN;\n    }\n\n    if(possible_return->type == PRIVATE_LUA_CEMBED_DOUBLE_RESPONSE){\n        lua_pushnumber(L, possible_return->num_val);\n        private_LuaCEmbedResponse_free(possible_return);\n        return PRIVATE_LUACEMBED_ONE_RETURN;\n    }\n\n    if(possible_return->type == PRIVATE_LUA_CEMBED_STRING_RESPONSE){\n        lua_pushlstring(self->state,possible_return->string_val,possible_return->string_size);\n        private_LuaCEmbedResponse_free(possible_return);\n        return PRIVATE_LUACEMBED_ONE_RETURN;\n    }\n\n    if(possible_return->type == PRIVATE_LUA_CEMBED_DOUBLE_RESPONSE){\n        lua_pushboolean(L, (bool)possible_return->num_val);\n        private_LuaCEmbedResponse_free(possible_return);\n        return PRIVATE_LUACEMBED_ONE_RETURN;\n    }\n\n    if(possible_return->type == PRIVATE_LUA_CEMBED_TABLE_RESPONSE){\n        lua_getglobal(self->state, PRIVATE_LUA_CEMBED_TABLE_RETURN);\n        lua_pushvalue(self->state,-1);\n        private_LuaCEmbedResponse_free(possible_return);\n        return PRIVATE_LUACEMBED_ONE_RETURN;\n    }\n\n    if(possible_return->type == PRIVATE_LUA_CEMBED_MULTI_RESPONSE){\n        LuaCEmbedTable  *table = private_newLuaCembedTable(self,  PRIVATE_LUA_CEMBED_TABLE_RETURN);\n        int size =private_lua_cEmbed_unpack(table,NULL);\n        private_LuaCEmbedResponse_free(possible_return);\n        privateLuaCEmbedTable_free(table);\n\n        return  size;\n    }\n\n\n    if(possible_return->type == PRIVATE_LUA_CEMBED_EVALUATION){\n        char *formated_function =private_LuaCembed_format(\n                PRIVATE_LUA_CEMBED_GLOBAL_EVALUATION_CODE,\n                PRIVATE_LUA_CEMBED_EVALUATION_NAME,\n                possible_return->string_val\n        );\n\n        int error_code = LuaCEmbed_evaluate(self, formated_function);\n        free(formated_function);\n\n        if(error_code){\n            private_LuaCEmbedResponse_free(possible_return);\n            return PRIVATE_LUACEMBED_NO_RETURN;\n        }\n\n        lua_getglobal(self->state, PRIVATE_LUA_CEMBED_EVALUATION_NAME);\n        int v_type = lua_type(self->state,-1);\n        if(v_type == LUA_CEMBED_FUNCTION){\n            const int TOTAL_ARGS =0;\n            const int TOTAL_RETURNS =1;\n            if(lua_pcall(self->state,TOTAL_ARGS,TOTAL_RETURNS,0)){\n                private_LuaCEmbedResponse_free(possible_return);\n                return PRIVATE_LUACEMBED_NO_RETURN;\n            }\n        }\n\n        lua_pushvalue(self->state,-1);\n        private_LuaCEmbedResponse_free(possible_return);\n        return PRIVATE_LUACEMBED_ONE_RETURN;\n\n    }\n\n    private_LuaCEmbedResponse_free(possible_return);\n    return PRIVATE_LUACEMBED_NO_RETURN;\n\n}\n\n\nvoid private_LuaCEmbed_add_lib_callback(LuaCEmbed *self, const char *callback_name, LuaCEmbedResponse* (*callback)(LuaCEmbed *args),bool global_functions ){\n\n    char *main_lib_table = private_LuaCembed_format(PRIVATE_LUA_CEMBED_MAIN_LIB_TABLE_NAME__,self->lib_identifier);\n\n    //get the table\n    lua_getglobal(self->state,main_lib_table);\n    lua_pushvalue(self->state,-1);\n    //set the function name\n    lua_pushstring(self->state,callback_name);\n\n    //creating the clojure\n\n    //creating the clojure\n    lua_pushboolean(self->state,false);//is a method\n    lua_pushlightuserdata(self->state,(void*)self); //self\n    lua_pushstring(self->state,callback_name);//calback name\n    lua_pushlightuserdata(self->state,(void*)callback);//calback\n\n    lua_pushcclosure(self->state,privateLuaCEmbed_main_callback_handler,4);\n\n\n    lua_settable(self->state,-3);\n    if(global_functions){\n        //it points the function to a global function\n        //like: callback = private_lua_c_embed_main_lib_table.callback\n        lua_getglobal(self->state, main_lib_table);\n        lua_getfield(self->state,-1,callback_name);\n        lua_setglobal(self->state, callback_name);\n    }\n\n    lua_settop(self->state, 0);\n    free(main_lib_table);\n\n}\n\nvoid private_LuaCEmbed_add_evaluation_callback(LuaCEmbed *self, const char *callback_name, LuaCEmbedResponse* (*callback)(LuaCEmbed *args) ){\n    PRIVATE_LUA_CEMBED_PROTECT_VOID\n\n    //creating the clojure\n    lua_pushboolean(self->state,false);//is a method\n    lua_pushlightuserdata(self->state,(void*)self); //self\n    lua_pushstring(self->state,callback_name);//calback name\n    lua_pushlightuserdata(self->state,(void*)callback);//calback\n\n    lua_pushcclosure(self->state,privateLuaCEmbed_main_callback_handler,4);\n    lua_setglobal(self->state, callback_name);\n    lua_settop(self->state, 0);\n\n}\n\n\nvoid LuaCEmbed_add_callback(LuaCEmbed *self, const char *callback_name, LuaCEmbedResponse* (*callback)(LuaCEmbed *args) ){\n    PRIVATE_LUA_CEMBED_PROTECT_VOID\n\n    if(self->is_lib){\n        private_LuaCEmbed_add_lib_callback(self,callback_name,callback,false);\n        return;\n    }\n    private_LuaCEmbed_add_evaluation_callback(self,callback_name,callback);\n\n}\n\nvoid LuaCEmbed_add_global_callback(LuaCEmbed *self, const char *callback_name, LuaCEmbedResponse* (*callback)(LuaCEmbed *args)){\n    PRIVATE_LUA_CEMBED_PROTECT_VOID\n\n    if(self->is_lib){\n        private_LuaCEmbed_add_lib_callback(self,callback_name,callback,true);\n        return;\n    }\n    private_LuaCEmbed_add_evaluation_callback(self,callback_name,callback);\n}"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/callback_handle/callback_handle.h",
		"is_binary":	false,
		"content":	"\n\nint privateLuaCEmbed_main_callback_handler(lua_State  *L);\n\nvoid private_LuaCEmbed_add_lib_callback(LuaCEmbed *self, const char *callback_name, LuaCEmbedResponse* (*callback)(LuaCEmbed *args),bool global_functions );\n\nvoid private_LuaCEmbed_add_evaluation_callback(LuaCEmbed *self, const char *callback_name, LuaCEmbedResponse* (*callback)(LuaCEmbed *args) );\n\nvoid LuaCEmbed_add_callback(LuaCEmbed *self, const char *callback_name, LuaCEmbedResponse* (*callback)(LuaCEmbed *args) );\n\n\nvoid LuaCEmbed_add_global_callback(LuaCEmbed *self, const char *callback_name, LuaCEmbedResponse* (*callback)(LuaCEmbed *args));\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/declaration.h",
		"is_binary":	false,
		"content":	"typedef long private_lua_cembed_incremented_arg ;\n#include \"LuaCEmbed.h\"\n#include \"memory/memory.h\"\n\n#include \"lib_start/lib_start.h\"\n#include \"basic/basic.h\"\n#include \"table/declaration.h\"\n#include \"args/declaration.h\"\n#include \"globals/declaration.h\"\n#include \"callback_handle/callback_handle.h\"\n#include \"evaluation/evaluation.h\"\n#include \"protection_macros.h\"\n#include \"lib_props/lib_props.h\"\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/definition.h",
		"is_binary":	false,
		"content":	"#include \"memory/memory.c\"\n#include \"lib_start/lib_start.c\"\n#include \"basic/basic.c\"\n#include \"args/definition.h\"\n#include \"table/definition.h\"\n#include \"globals/definition.h\"\n#include \"callback_handle/callback_handle.c\"\n#include \"evaluation/evaluation.c\"\n#include \"lib_props/lib_props.c\""
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/evaluation/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/evaluation/evaluation.c",
		"is_binary":	false,
		"content":	"\n\n#ifdef _WIN32\nVOID CALLBACK TimerHandler(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime) {\n\n    privateLuaCEmbed_raise_error_not_jumping(global_current_lua_embed_object, PRIVATE_LUA_CEMBED_TIMEOUT_ERROR);\n    lua_pushstring(global_current_lua_embed_object->state,PRIVVATE_LUA_CEMBED_TIMEOUT_ERROR);\n    lua_error(global_current_lua_embed_object->state);\n}\n\n#else \n\nvoid private_LuaCembed_handle_timeout(int signum) {\n\n    privateLuaCEmbed_raise_error_not_jumping(global_current_lua_embed_object, PRIVATE_LUA_CEMBED_TIMEOUT_ERROR);\n    lua_pushstring(global_current_lua_embed_object->state,PRIVVATE_LUA_CEMBED_TIMEOUT_ERROR);\n    lua_error(global_current_lua_embed_object->state);\n}\n\n#endif \n\n\n\nint privateLuaCEmbed_start_func_evaluation(lua_State *state){\n\n    int evaluation_type = lua_tointeger(state, lua_upvalueindex(1));\n    char *text_value = (char*)lua_touserdata(state,lua_upvalueindex(2));\n    LuaCEmbed  *self = (LuaCEmbed*)lua_touserdata(state,lua_upvalueindex(3));\n    global_current_lua_embed_object = self;\n        #ifdef _WIN32\n            if (lua_cembed_timeout > 0) {\n                SetTimer(NULL, 0,lua_cembed_timeout > 0 * 1000, TimerHandler);\n            }\n        #else\n            if (lua_cembed_timeout > 0) {\n                signal(SIGALRM, private_LuaCembed_handle_timeout);\n                alarm(lua_cembed_timeout);\n            }\n        #endif\n\n    int error  = 0;\n    if(evaluation_type == PRIVATE_LUA_EMBED_FILE_EVALUATION_TYPE){\n        error =luaL_dofile(self->state,text_value);\n    }\n    if(evaluation_type == PRIVATE_LUA_EMBED_STRING_EVALUATION_TYPE){\n        error = luaL_dostring(self->state,text_value);\n    }\n    if(error){\n        privateLuaCEmbed_raise_error_not_jumping(self,lua_tostring(self->state,-1));\n    }\n    lua_pushinteger(self->state,error);\n\n    return 1;\n\n}\nint LuaCEmbed_evaluate(LuaCEmbed *self, const char *code, ...){\n\n    PRIVATE_LUA_CEMBED_PROTECT_NUM\n\n    va_list args;\n    va_start(args,code);\n    char * formated_expresion = private_LuaCembed_format_vaarg(code,args);\n    va_end(args);\n    lua_pushinteger(self->state,PRIVATE_LUA_EMBED_STRING_EVALUATION_TYPE);\n    lua_pushlightuserdata(self->state,(void*)formated_expresion); //code\n    lua_pushlightuserdata(self->state,(void*)self); //code\n    lua_pushcclosure(self->state,privateLuaCEmbed_start_func_evaluation,3);\n    lua_pcall(self->state,0,1,0);\n    int error = lua_tointeger(self->state,-1);\n    free(formated_expresion);\n\n    return error;\n\n}\n\nint LuaCEmbed_evaluete_file(LuaCEmbed *self, const char *file){\n    PRIVATE_LUA_CEMBED_PROTECT_NUM\n\n\n    lua_pushinteger(self->state,PRIVATE_LUA_EMBED_FILE_EVALUATION_TYPE);\n    lua_pushlightuserdata(self->state,(void*)file); //code\n    lua_pushlightuserdata(self->state,(void*)self); //code\n    lua_pushcclosure(self->state,privateLuaCEmbed_start_func_evaluation,3);\n    lua_pcall(self->state,0,1,0);\n    int error = lua_tointeger(self->state,-1);\n    return error;\n\n}\n\nint private_LuaCEmbed_evaluate_puting_on_top_of_stack(LuaCEmbed *self,const char *code, va_list args){\n\n    char * formated_expresion =private_LuaCembed_format_vaarg(code,args);\n\n    char * buffer =private_LuaCembed_format(\n            PRIVATE_LUA_CEMBED_GLOBAL_EVALUATION_CODE,\n            PRIVATE_LUA_CEMBED_EVALUATION_NAME,\n            formated_expresion\n    );\n\n    if(LuaCEmbed_evaluate(self, buffer)){\n        free(formated_expresion);\n        free(buffer);\n        return  LUA_CEMBED_GENERIC_ERROR;\n    }\n\n    lua_getglobal(self->state,PRIVATE_LUA_CEMBED_EVALUATION_NAME);\n\n    int type = lua_type(self->state,-1);\n\n    if(type == LUA_CEMBED_FUNCTION){\n        if(lua_pcall(self->state,0,1,0)){\n            const char *generated_error = lua_tostring(self->state,-1);\n            privateLuaCEmbed_raise_error_not_jumping(self, generated_error);\n        }\n    }\n    free(formated_expresion);\n    free(buffer);\n    return LUA_CEMBED_OK;\n\n}\nint private_LuaCEmbed_ensure_evaluation_type(LuaCEmbed *self,int type){\n\n    int actual_type = lua_type(self->state,-1);\n    if(actual_type== type){\n        return LUA_CEMBED_OK;\n    }\n\n\n    privateLuaCEmbed_raise_error_not_jumping(self,\n         PRIVATE_LUA_CEMBED_RESULT_EVALUATION_WRONG_TYPE,\n         LuaCembed_convert_arg_code(actual_type),\n         LuaCembed_convert_arg_code(type)\n    );\n\n    return LUA_CEMBED_GENERIC_ERROR;\n}\n\nchar * LuaCEmbed_get_evaluation_string(LuaCEmbed *self,const char *code, ...){\n    PRIVATE_LUA_CEMBED_PROTECT_NULL\n\n    va_list args;\n    va_start(args,code);\n    int possible_error = private_LuaCEmbed_evaluate_puting_on_top_of_stack(self,code,args);\n    va_end(args);\n    if(possible_error){\n        return  NULL;\n    }\n\n    if(private_LuaCEmbed_ensure_evaluation_type(self,LUA_CEMBED_STRING)){\n        return NULL;\n    }\n    return (char*)lua_tostring(self->state,-1);\n\n}\n\n\nint  LuaCEmbed_get_evaluation_type(LuaCEmbed *self,const char *code, ...){\n    PRIVATE_LUA_CEMBED_PROTECT_NUM\n\n    va_list args;\n    va_start(args,code);\n    int possible_error = private_LuaCEmbed_evaluate_puting_on_top_of_stack(self,code,args);\n    va_end(args);\n    if(possible_error){\n        return  LUA_CEMBED_GENERIC_ERROR;\n    }\n\n    return lua_type(self->state,-1);\n}\n\n\nlong LuaCEmbed_get_evaluation_table_size(LuaCEmbed *self,const char *code, ...){\n    PRIVATE_LUA_CEMBED_PROTECT_NUM\n\n    va_list args;\n    va_start(args,code);\n    int possible_error = private_LuaCEmbed_evaluate_puting_on_top_of_stack(self,code,args);\n    va_end(args);\n    if(possible_error){\n        return  LUA_CEMBED_GENERIC_ERROR;\n    }\n    if(private_LuaCEmbed_ensure_evaluation_type(self,LUA_CEMBED_TABLE)){\n        return LUA_CEMBED_GENERIC_ERROR;\n    }\n    /*\n    long  size = 0;\n    lua_pushnil(self->state); // Coloca a chave nula na pilha\n    while (lua_next(self->state, -1) != 0) { // Enquanto houver elementos na tabela\n        size+=1;\n        lua_pop(self->state, 1);\n    }\n     */\n\n    return (long)lua_rawlen(self->state,-1);\n}\n\n\n\nlong long  LuaCEmbed_get_evaluation_long(LuaCEmbed *self,const char *code, ...){\n    PRIVATE_LUA_CEMBED_PROTECT_NUM\n\n    va_list args;\n    va_start(args,code);\n    int possible_error = private_LuaCEmbed_evaluate_puting_on_top_of_stack(self,code,args);\n    va_end(args);\n    if(possible_error){\n        return  LUA_CEMBED_GENERIC_ERROR;\n    }\n    if(private_LuaCEmbed_ensure_evaluation_type(self,LUA_CEMBED_NUMBER)){\n        return LUA_CEMBED_GENERIC_ERROR;\n    }\n    return (long)lua_tonumber(self->state,-1);\n\n}\n\ndouble LuaCEmbed_get_evaluation_double(LuaCEmbed *self,const char *code, ...){\n    PRIVATE_LUA_CEMBED_PROTECT_NUM\n\n    va_list args;\n    va_start(args,code);\n    int possible_error = private_LuaCEmbed_evaluate_puting_on_top_of_stack(self,code,args);\n    va_end(args);\n    if(possible_error){\n        return  LUA_CEMBED_GENERIC_ERROR;\n    }\n    if(private_LuaCEmbed_ensure_evaluation_type(self,LUA_CEMBED_NUMBER)){\n        return LUA_CEMBED_GENERIC_ERROR;\n    }\n    return (double)lua_tonumber(self->state,-1);\n}\n\nbool LuaCEmbed_get_evaluation_bool(LuaCEmbed *self,const char *code, ...){\n    PRIVATE_LUA_CEMBED_PROTECT_BOOL\n\n    va_list args;\n    va_start(args,code);\n    int possible_error = private_LuaCEmbed_evaluate_puting_on_top_of_stack(self,code,args);\n    va_end(args);\n    if(possible_error){\n        return  LUA_CEMBED_GENERIC_ERROR;\n    }\n    if(private_LuaCEmbed_ensure_evaluation_type(self,LUA_CEMBED_BOOL)){\n        return LUA_CEMBED_GENERIC_ERROR;\n    }\n    return (bool)lua_toboolean(self->state,-1);\n}\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/evaluation/evaluation.h",
		"is_binary":	false,
		"content":	"\n\n#ifdef _WIN32\nVOID CALLBACK TimerHandler(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);\n#else \n\nvoid private_LuaCembed_handle_timeout(int signum);\n\n#endif \n\nint privateLuaCEmbed_start_func_evaluation(lua_State *state);\n\nint LuaCEmbed_evaluate(LuaCEmbed *self, const char *code, ...);\n\nint LuaCEmbed_evaluete_file(LuaCEmbed *self, const char *file);\n\n\nint private_LuaCEmbed_ensure_evaluation_type(LuaCEmbed *self,int type);\n\nint private_LuaCEmbed_evaluate_puting_on_top_of_stack(LuaCEmbed *self,const char *code, va_list args);\n\nchar * LuaCEmbed_get_evaluation_string(LuaCEmbed *self,const char *code, ...);\n\n\nint  LuaCEmbed_get_evaluation_type(LuaCEmbed *self,const char *code, ...);\n\n\nlong LuaCEmbed_get_evaluation_table_size(LuaCEmbed *self,const char *code, ...);\n\nlong long  LuaCEmbed_get_evaluation_long(LuaCEmbed *self,const char *code, ...);\n\ndouble LuaCEmbed_get_evaluation_double(LuaCEmbed *self,const char *code, ...);\n\nbool LuaCEmbed_get_evaluation_bool(LuaCEmbed *self,const char *code, ...);\n\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/globals/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/globals/declaration.h",
		"is_binary":	false,
		"content":	"#include \"errors/errors.h\"\n#include \"getters/getters.h\"\n#include \"setters/setters.h\"\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/globals/definition.h",
		"is_binary":	false,
		"content":	"#include \"errors/errors.c\"\n#include \"getters/getters.c\"\n#include \"setters/setters.c\"\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/globals/errors/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/globals/errors/errors.c",
		"is_binary":	false,
		"content":	"\n\n\n\nint LuaCEmbed_ensure_global_type(LuaCEmbed *self, const char *name,int expected_type){\n    PRIVATE_LUA_CEMBED_PROTECT_NUM\n\n    lua_getglobal(self->state,name);\n    int type = lua_type(self->state,-1);\n\n    if(type != expected_type){\n        privateLuaCEmbed_raise_error_not_jumping(self,\n             PRIVATE_LUA_CEMBED_GLOBAL_WRONG_TYPE,\n             name,\n             LuaCembed_convert_arg_code(type),\n             LuaCembed_convert_arg_code(expected_type)\n        );\n        return  LUA_CEMBED_GENERIC_ERROR;\n    }\n\n    return LUA_CEMBED_OK;\n\n}"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/globals/errors/errors.h",
		"is_binary":	false,
		"content":	"\n\n\nint LuaCEmbed_ensure_global_type(LuaCEmbed *self, const char *name,int expected_type);\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/globals/getters/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/globals/getters/getters.c",
		"is_binary":	false,
		"content":	"\n\nint LuaCEmbed_get_global_type(LuaCEmbed *self,const char *name){\n    PRIVATE_LUA_CEMBED_PROTECT_NUM\n\n    lua_getglobal(self->state, name);\n    return lua_type(self->state,-1);\n}\n\nlong long  LuaCEmbed_get_global_long(LuaCEmbed *self,const char *name){\n    PRIVATE_LUA_CEMBED_PROTECT_NUM\n\n    if(LuaCEmbed_ensure_global_type(self,name,LUA_CEMBED_NUMBER)){\n        return  LUA_CEMBED_GENERIC_ERROR;\n    }\n    lua_getglobal(self->state, name);\n    return (long )lua_tonumber(self->state,-1);\n}\n\ndouble LuaCEmbed_get_global_double(LuaCEmbed *self,const char *name){\n    PRIVATE_LUA_CEMBED_PROTECT_NUM\n\n    if(LuaCEmbed_ensure_global_type(self,name,LUA_CEMBED_NUMBER)){\n        return  LUA_CEMBED_GENERIC_ERROR;\n    }\n    lua_getglobal(self->state, name);\n    return (double )lua_tonumber(self->state,-1);\n}\n\nbool LuaCEmbed_get_global_bool(LuaCEmbed *self,const char *name){\n    PRIVATE_LUA_CEMBED_PROTECT_BOOL\n\n    if(LuaCEmbed_ensure_global_type(self,name,LUA_CEMBED_BOOL)){\n        return  LUA_CEMBED_GENERIC_ERROR;\n    }\n    lua_getglobal(self->state, name);\n    return lua_toboolean(self->state,-1);\n}\n\nchar * LuaCEmbed_get_global_raw_string(LuaCEmbed *self,const char *name,long *size){\n    PRIVATE_LUA_CEMBED_PROTECT_NULL\n\n    if(LuaCEmbed_ensure_global_type(self,name,LUA_CEMBED_STRING)){\n        return  NULL;\n    }\n    lua_getglobal(self->state, name);\n    return (char*)lua_tolstring(self->state,-1,(size_t*)size);\n}\n\nchar * LuaCEmbed_get_global_string(LuaCEmbed *self,const char *name){\n    PRIVATE_LUA_CEMBED_PROTECT_NULL\n\n    if(LuaCEmbed_ensure_global_type(self,name,LUA_CEMBED_STRING)){\n        return  NULL;\n    }\n    lua_getglobal(self->state, name);\n    return (char*)lua_tostring(self->state,-1);\n}\n\nLuaCEmbedTable * LuaCembed_new_anonymous_table(LuaCEmbed *self){\n    PRIVATE_LUA_CEMBED_PROTECT_NULL\n\n\n    const char *format_raw = PRIVATE_LUA_CEMBED_ANONYMOUS_TABLE_;\n    if(self->current_function){\n       format_raw  =PRIVATE_LUA_CEMBED_ANONYMOUS_FUNC_TABLE_;\n    }\n    privateLuaCEmbedTableArray *target = (privateLuaCEmbedTableArray*)privateLuaCEmbed_get_current_table_array(self);\n    char *buffer= private_LuaCembed_format(format_raw, self->stack_leve, target->size);\n    LuaCEmbedTable  *created_table =LuaCembed_new_global_table(self,buffer);\n\n    free(buffer);\n    return created_table;\n}\n\n\n\nLuaCEmbedTable * LuaCembed_get_global_table(LuaCEmbed *self, const char *name){\n    PRIVATE_LUA_CEMBED_PROTECT_NULL\n\n    if(LuaCEmbed_ensure_global_type(self,name,LUA_CEMBED_TABLE)){\n        return  NULL;\n    }\n\n    privateLuaCEmbedTableArray *target = (privateLuaCEmbedTableArray*)privateLuaCEmbed_get_current_table_array(self);\n\n    LuaCEmbedTable  *possible = privateLuaCEmbedTableArray_find_by_global_name(target,name);\n    if(possible){\n        return possible;\n    }\n\n    LuaCEmbedTable  *creaeted = private_newLuaCembedTable(self, \"%s\", name);\n\n    privateLuaCEmbedTableArray_append(\n            target,\n            creaeted\n    );\n    return creaeted;\n}\n\nLuaCEmbedTable * LuaCembed_new_global_table(LuaCEmbed *self, const char *name){\n    PRIVATE_LUA_CEMBED_PROTECT_NULL\n\n    lua_newtable(self->state);\n    lua_setglobal(self->state,name);\n    privateLuaCEmbedTableArray *target = (privateLuaCEmbedTableArray*)privateLuaCEmbed_get_current_table_array(self);\n\n    LuaCEmbedTable  *possible = privateLuaCEmbedTableArray_find_by_global_name(target,name);\n    if(possible){\n        return possible;\n    }\n\n    LuaCEmbedTable  *creaeted = private_newLuaCembedTable(self, \"%s\", name);\n\n    privateLuaCEmbedTableArray_append(\n            target,\n            creaeted\n    );\n    return creaeted;\n}\n\nLuaCEmbedTable* LuaCEmbed_run_global_lambda(LuaCEmbed *self, const char *name, LuaCEmbedTable *args_to_call, int total_returns){\n\n    PRIVATE_LUA_CEMBED_PROTECT_NULL\n\n    if(LuaCEmbed_ensure_global_type(self,name,LUA_CEMBED_FUNCTION)){\n        return  NULL;\n    }\n\n    int total_args = private_lua_cEmbed_unpack(args_to_call,name);\n    if(lua_pcall(self->state,total_args,total_returns,0)){\n        privateLuaCEmbed_raise_error_not_jumping(self, lua_tostring(self->state,-1));\n        return  NULL;\n    }\n\n    for(int i = 0; i < total_returns; i++){\n        char *formatted = private_LuaCembed_format(PRIVATE_LUA_CEMBED_MULTIRETURN_, self->stack_leve, i);\n        int position = (i +1) * -1;\n        lua_pushvalue(self->state,position);\n        lua_setglobal(self->state,formatted);\n        free(formatted);\n    }\n\n    LuaCEmbedTable  *result = LuaCembed_new_anonymous_table(self);\n    for(int i = 0; i < total_returns; i++){\n        lua_getglobal(self->state,result->global_name);\n        lua_pushinteger(self->state,i+1);\n        char *formatted = private_LuaCembed_format(PRIVATE_LUA_CEMBED_MULTIRETURN_,self->stack_leve,i);\n        lua_getglobal(self->state,formatted);\n        lua_settable(self->state,-3);\n        free(formatted);\n    }\n\n    return result;\n}\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/globals/getters/getters.h",
		"is_binary":	false,
		"content":	"\n\nint LuaCEmbed_get_global_type(LuaCEmbed *self,const char *name);\n\nlong long  LuaCEmbed_get_global_long(LuaCEmbed *self,const char *name);\n\ndouble LuaCEmbed_get_global_double(LuaCEmbed *self,const char *name);\n\nbool LuaCEmbed_get_global_bool(LuaCEmbed *self,const char *name);\n\nchar * LuaCEmbed_get_global_string(LuaCEmbed *self,const char *name);\n\nchar * LuaCEmbed_get_global_raw_string(LuaCEmbed *self,const char *name,long *size);\n\n\nLuaCEmbedTable * LuaCembed_new_anonymous_table(LuaCEmbed *self);\n\nLuaCEmbedTable* LuaCEmbed_run_global_lambda(LuaCEmbed *self, const char *name, LuaCEmbedTable *args_to_call, int total_returns);\n\nLuaCEmbedTable * LuaCembed_get_global_table(LuaCEmbed *self, const char *name);\n\nLuaCEmbedTable * LuaCembed_new_global_table(LuaCEmbed *self, const char *name);\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/globals/setters/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/globals/setters/setters.c",
		"is_binary":	false,
		"content":	"\n\nvoid LuaCEmbed_set_global_string(LuaCEmbed *self, const char *name, const  char *value){\n    PRIVATE_LUA_CEMBED_PROTECT_VOID\n\n    lua_pushstring(self->state,value);\n    lua_setglobal(self->state,name);\n}\nvoid LuaCEmbed_set_global_raw_string(LuaCEmbed *self, const char *name, const  char *value,long size){\n    PRIVATE_LUA_CEMBED_PROTECT_VOID\n\n    lua_pushlstring(self->state,value,size);\n    lua_setglobal(self->state,name);\n}\n\n\nvoid LuaCEmbed_set_global_long(LuaCEmbed *self, const char *name, long long  value){\n    PRIVATE_LUA_CEMBED_PROTECT_VOID\n\n    lua_pushnumber(self->state,(double )value);\n    lua_setglobal(self->state,name);\n}\n\nvoid LuaCEmbed_set_global_double(LuaCEmbed *self, const char *name, double value){\n    PRIVATE_LUA_CEMBED_PROTECT_VOID\n\n    lua_pushnumber(self->state,(double )value);\n    lua_setglobal(self->state,name);\n}\n\nvoid LuaCEmbed_set_global_bool(LuaCEmbed *self, const char *name, bool value){\n    PRIVATE_LUA_CEMBED_PROTECT_VOID\n    lua_pushboolean(self->state,value);\n    lua_setglobal(self->state,name);\n}\n\n\nvoid LuaCEmbed_set_global_table(LuaCEmbed *self, const char *name, LuaCEmbedTable *table){\n    PRIVATE_LUA_CEMBED_PROTECT_VOID\n\n    lua_getglobal(self->state,table->global_name);\n    lua_setglobal(self->state,name);\n}"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/globals/setters/setters.h",
		"is_binary":	false,
		"content":	"\nvoid LuaCEmbed_set_global_string(LuaCEmbed *self, const char *name, const  char *value);\n\nvoid LuaCEmbed_set_global_raw_string(LuaCEmbed *self, const char *name, const  char *value,long size);\n\nvoid LuaCEmbed_set_global_long(LuaCEmbed *self, const char *name, long long  value);\n\nvoid LuaCEmbed_set_global_double(LuaCEmbed *self, const char *name, double value);\n\nvoid LuaCEmbed_set_global_bool(LuaCEmbed *self, const char *name, bool value);\n\nvoid LuaCEmbed_set_global_table(LuaCEmbed *self, const char *name, LuaCEmbedTable *table);\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/lib_props/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/lib_props/lib_props.c",
		"is_binary":	false,
		"content":	"\n\nvoid LuaCEmbed_set_long_lib_prop(LuaCEmbed *self,const char *name,long long value){\n    char *main_lib_table = private_LuaCembed_format(PRIVATE_LUA_CEMBED_MAIN_LIB_TABLE_NAME__,self->lib_identifier);\n\n    lua_getglobal(self->state,main_lib_table);\n    lua_pushvalue(self->state,-1);\n    //set the function name\n    lua_pushstring(self->state,name);\n    lua_pushinteger(self->state,value);\n    lua_settable(self->state,-3);\n    free(main_lib_table);\n}\n\nvoid LuaCEmbed_set_double_lib_prop(LuaCEmbed *self,const char *name,double value){\n\n    lua_getglobal(self->state,self->main_lib_table);\n    lua_pushvalue(self->state,-1);\n    //set the function name\n    lua_pushstring(self->state,name);\n    lua_pushnumber(self->state,value);\n    lua_settable(self->state,-3);\n\n}\n\nvoid LuaCEmbed_set_bool_lib_prop(LuaCEmbed *self,const char *name,bool value){\n\n    lua_getglobal(self->state,self->main_lib_table);\n    lua_pushvalue(self->state,-1);\n    //set the function name\n    lua_pushstring(self->state,name);\n    lua_pushboolean(self->state,value);\n    lua_settable(self->state,-3);\n\n}\n\nvoid LuaCEmbed_set_string_lib_prop(LuaCEmbed *self,const char *name,const char * value){\n\n    lua_getglobal(self->state,self->main_lib_table);\n    lua_pushvalue(self->state,-1);\n    //set the function name\n    lua_pushstring(self->state,name);\n    lua_pushstring(self->state,value);\n    lua_settable(self->state,-3);\n\n}\n\nvoid LuaCEmbed_set_table_lib_prop(LuaCEmbed *self,const char *name,LuaCEmbedTable *value){\n\n    lua_getglobal(self->state,self->main_lib_table);\n    lua_pushvalue(self->state,-1);\n    lua_pushstring(self->state,name);\n    lua_getglobal(self->state,value->global_name);\n    lua_settable(self->state,-3);\n\n}\n\nint private_LuaCEmbed_ensure_lib_prop_type(LuaCEmbed *self,const char *name,int expected_type){\n    int type = lua_type(self->state,-1);\n    if(type!= expected_type){\n        privateLuaCEmbed_raise_error_not_jumping(\n                self,\n                PRIVATE_LUA_CEMBED_LIB_PROP_WRONG_TYPE,\n                name,\n                LuaCembed_convert_arg_code(type),\n                LuaCembed_convert_arg_code(expected_type)\n        );\n        return LUA_CEMBED_GENERIC_ERROR;\n    }\n    return LUA_CEMBED_OK;\n}\n\nlong long  LuaCEmbed_get_long_lib_prop(LuaCEmbed *self,const char *name){\n    lua_getglobal(self->state,self->main_lib_table);\n    lua_getfield(self->state, -1,name);\n    if(private_LuaCEmbed_ensure_lib_prop_type(self,name,LUA_CEMBED_NUMBER)){\n        return LUA_CEMBED_GENERIC_ERROR;\n    }\n    return lua_tointeger(self->state,-1);\n\n}\n\ndouble LuaCEmbed_get_double_lib_prop(LuaCEmbed *self,const char *name){\n\n    lua_getglobal(self->state,self->main_lib_table);\n\n    lua_getfield(self->state, -1,name);\n    if(private_LuaCEmbed_ensure_lib_prop_type(self,name,LUA_CEMBED_NUMBER)){\n        return LUA_CEMBED_GENERIC_ERROR;\n    }\n    return lua_tonumber(self->state,-1);\n}\n\nbool LuaCEmbed_get_bool_lib_prop(LuaCEmbed *self,const char *name){\n\n    lua_getglobal(self->state,self->main_lib_table);\n\n    lua_getfield(self->state, -1,name);\n    if(private_LuaCEmbed_ensure_lib_prop_type(self,name,LUA_CEMBED_BOOL)){\n        return LUA_CEMBED_GENERIC_ERROR;\n    }\n    return lua_toboolean(self->state,-1);\n}\n\nchar * LuaCEmbed_get_string_lib_prop(LuaCEmbed *self,const char *name){\n    lua_getglobal(self->state,self->main_lib_table);\n\n    lua_getfield(self->state, -1,name);\n    if(private_LuaCEmbed_ensure_lib_prop_type(self,name,LUA_CEMBED_STRING)){\n        return NULL;\n    }\n    return (char*)lua_tostring(self->state,-1);\n}\n\nLuaCEmbedTable *LuaCEmbed_get_table_lib_prop(LuaCEmbed *self,const char *name){\n;\n    lua_getglobal(self->state,self->main_lib_table);\n\n    lua_getfield(self->state, -1,name);\n    if(private_LuaCEmbed_ensure_lib_prop_type(self,name,LUA_CEMBED_TABLE)){\n        return NULL;\n    }\n\n    char *global_sub_table_name  = private_LuaCembed_format(\n            PRIVATE_LUA_CEMBED_MAIN_LIB_SUB_TABLE,\n            self->lib_identifier,\n            name\n            );\n    lua_setglobal(self->state,global_sub_table_name);\n\n    privateLuaCEmbedTableArray *target = (privateLuaCEmbedTableArray*)privateLuaCEmbed_get_current_table_array(self);\n\n    LuaCEmbedTable  *possible = privateLuaCEmbedTableArray_find_by_global_name(target,global_sub_table_name);\n    if(possible){\n        free(global_sub_table_name);\n        return possible;\n    }\n\n    LuaCEmbedTable  *creaeted = private_newLuaCembedTable(self, \"%s\",global_sub_table_name);\n    free(global_sub_table_name);\n\n    privateLuaCEmbedTableArray_append(\n            target,\n            creaeted\n    );\n    return creaeted;\n}\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/lib_props/lib_props.h",
		"is_binary":	false,
		"content":	"\n\nvoid LuaCEmbed_set_long_lib_prop(LuaCEmbed *self,const char *name,long long value);\n\nvoid LuaCEmbed_set_double_lib_prop(LuaCEmbed *self,const char *name,double value);\n\nvoid LuaCEmbed_set_bool_lib_prop(LuaCEmbed *self,const char *name,bool value);\n\nvoid LuaCEmbed_set_string_lib_prop(LuaCEmbed *self,const char *name,const char * value);\n\nvoid LuaCEmbed_set_table_lib_prop(LuaCEmbed *self,const char *name,LuaCEmbedTable *value);\n\nint private_LuaCEmbed_ensure_lib_prop_type(LuaCEmbed *self,const char *name,int expected_type);;\n\n\nlong long  LuaCEmbed_get_long_lib_prop(LuaCEmbed *self,const char *name);\n\ndouble LuaCEmbed_get_double_lib_prop(LuaCEmbed *self,const char *name);\n\nbool LuaCEmbed_get_bool_lib_prop(LuaCEmbed *self,const char *name);\n\nchar * LuaCEmbed_get_string_lib_prop(LuaCEmbed *self,const char *name);\n\nLuaCEmbedTable *LuaCEmbed_get_table_lib_prop(LuaCEmbed *self,const char *name);\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/lib_start/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/lib_start/lib_start.c",
		"is_binary":	false,
		"content":	"\nint private_LuaCemb_internal_free(lua_State *L){\n    LuaCEmbed  *self = (LuaCEmbed*)lua_touserdata(L, lua_upvalueindex(1));\n    if(self->delete_function){\n        self->delete_function(self);\n    }\n    LuaCEmbed_free(self);\n    return 0;\n}\nLuaCEmbed * newLuaCEmbedLib(lua_State *state){\n    LuaCEmbed  *self = (LuaCEmbed*) malloc(sizeof (LuaCEmbed));\n    *self = (LuaCEmbed){0};\n\n    self->state = state;\n\n    self->lib_identifier = 0;\n\n    lua_getglobal(self->state,PRIVATE_LUA_CEMBED_TOTAL_LIBS);\n    if(lua_type(self->state,-1) == LUA_CEMBED_NIL){\n        self->lib_identifier  = lua_tointeger(self->state,-1);\n    }\n\n    self->lib_identifier +=1;\n\n    self->main_lib_table = private_LuaCembed_format(PRIVATE_LUA_CEMBED_MAIN_LIB_TABLE_NAME__,self->lib_identifier);\n\n    lua_pushinteger(self->state,self->lib_identifier);\n    lua_setglobal(self->state,PRIVATE_LUA_CEMBED_TOTAL_LIBS);\n\n\n    self->is_lib = true;\n    self->global_tables = (void*)newprivateLuaCEmbedTableArray();\n\n\n    UniversalGarbage  *garbage = newUniversalGarbage();\n    char *lib_meta_table = private_LuaCembed_format(PRIVATE_LUA_CEMBED_MAIN_META_TABLE__,self->lib_identifier);\n    UniversalGarbage_add_simple(garbage,lib_meta_table);\n    //creating the metatable\n    luaL_newmetatable(self->state, lib_meta_table);\n    //seting the clojure key\n    lua_pushstring(self->state,PRIVATE_LUA_CEMBED_DEL_PREFIX);\n    //set self as first clojure argument\n    lua_pushlightuserdata(self->state,(void*)self);\n    lua_pushcclosure(self->state,private_LuaCemb_internal_free,1);\n    lua_settable(self->state, -3);\n\n\n    char *lib_main_table = private_LuaCembed_format(PRIVATE_LUA_CEMBED_MAIN_LIB_TABLE_NAME__,self->lib_identifier);\n    UniversalGarbage_add_simple(garbage,lib_main_table);\n    //creating the global table to store the elements\n    lua_newtable(self->state);\n    lua_setglobal(self->state,lib_main_table);\n    luaL_setmetatable(self->state, lib_meta_table);\n\n    UniversalGarbage_free(garbage);\n    return  self;\n}\n\nint LuaCembed_perform(LuaCEmbed *self){\n    PRIVATE_LUA_CEMBED_PROTECT_NUM\n\n    char *lib_main_table = private_LuaCembed_format(PRIVATE_LUA_CEMBED_MAIN_LIB_TABLE_NAME__,self->lib_identifier);\n    lua_getglobal(self->state,lib_main_table);\n    free(lib_main_table);\n    return 1;\n}\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/lib_start/lib_start.h",
		"is_binary":	false,
		"content":	"\nint private_LuaCemb_internal_free(lua_State *L);\n\nLuaCEmbed * newLuaCEmbedLib(lua_State *state);\n\nint LuaCembed_perform(LuaCEmbed *self);\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/memory/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/memory/memory.c",
		"is_binary":	false,
		"content":	"\n\nvoid LuaCEmbed_set_memory_limit(LuaCEmbed *self, double limit){\n    lua_setallocf(self->state, private_LuaCembed_custom_allocator, &lua_cembed_used_memory);\n    lua_cembed_memory_limit = limit;\n}\nstatic void *private_LuaCembed_custom_allocator(void *ud, void *ptr, size_t osize, size_t nsize) {\n    int *used = (int *)ud;\n\n    if (ptr == NULL) {\n        osize = 0;\n    }\n\n    if (nsize == 0) {\n        free(ptr);\n        *used -= osize; /* subtract old size from used memory */\n        return NULL;\n    } else {\n        long  custom_limit = (long)(lua_cembed_memory_limit * PRIVATE_LUA_CEMBED_ONE_MB);\n        if (*used + (nsize - osize) > custom_limit) /* too much memory in use */\n            return NULL;\n        ptr = realloc(ptr, nsize);\n        if (ptr) /* reallocation successful? */\n            *used += (nsize - osize);\n        return ptr;\n    }\n}\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/memory/memory.h",
		"is_binary":	false,
		"content":	"\n\nlong lua_cembed_used_memory = 0;\nlong  lua_cembed_memory_limit = -1;\n\nvoid LuaCEmbed_set_memory_limit(LuaCEmbed *self, double limit);\n\n\nstatic void *private_LuaCembed_custom_allocator(void *ud, void *ptr, size_t osize, size_t nsize) ;\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/protection_macros.h",
		"is_binary":	false,
		"content":	"#define PRIVATE_LUA_CEMBED_PROTECT_VOID \\\n    if(!self){                          \\\n    return;                              \\\n    }\n\n\n#define PRIVATE_LUA_CEMBED_PROTECT_NUM \\\n    if(!self){                          \\\n    return LUA_CEMBED_GENERIC_ERROR;      \\\n    }\n\n#define PRIVATE_LUA_CEMBED_PROTECT_BOOL \\\n    if(!self){                          \\\n    return false;      \\\n    }\n\n#define PRIVATE_LUA_CEMBED_PROTECT_NULL \\\n    if(!self){                          \\\n    return NULL;      \\\n    }\n\n#define PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK     if(lua_gettop(self->main_object->state)){lua_settop(self->main_object->state,0);}\n\n#define PRIVATE_LUA_CEMBED_CLEAR_STACK     if(lua_gettop(self->state)){lua_settop(self->state,0);}\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/declaration.h",
		"is_binary":	false,
		"content":	"#include \"table/declaration.h\"\n#include \"table_array/table_array.h\"\n#include \"protection_macros.h\""
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/definition.h",
		"is_binary":	false,
		"content":	"#include \"table/definition.h\"\n#include \"table_array/table_array.c\""
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/protection_macros.h",
		"is_binary":	false,
		"content":	"#define PRIVATE_LUA_CEMBED_TABLE_PROTECT_VOID \\\n    if(!self){                          \\\n    return;                              \\\n    }\n\n#define PRIVATE_LUA_CEMBED_TABLE_PROTECT_NUM \\\n    if(!self){                          \\\n    return LUA_CEMBED_GENERIC_ERROR;      \\\n    }\n\n#define PRIVATE_LUA_CEMBED_TABLE_PROTECT_BOOL \\\n    if(!self){                          \\\n    return false;      \\\n    }\n\n#define PRIVATE_LUA_CEMBED_TABLE_PROTECT_NULL \\\n    if(!self){                          \\\n    return NULL;      \\\n    }\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/append/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/append/append.c",
		"is_binary":	false,
		"content":	"void  LuaCEmbedTable_append_table(LuaCEmbedTable *self, LuaCEmbedTable *table){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_VOID\n\n    long size = LuaCEmbedTable_get_listable_size(self);\n    lua_getglobal(self->main_object->state,self->global_name);\n    lua_pushinteger(self->main_object->state,size+1);\n    lua_getglobal(self->main_object->state,table->global_name);\n    lua_rawset(self->main_object->state,-3);\n    lua_settop(self->main_object->state, 0);\n\n}\n\nvoid  LuaCEmbedTable_append_string(LuaCEmbedTable *self,  const char *value){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_VOID\n\n    long size = LuaCEmbedTable_get_listable_size(self);\n    lua_getglobal(self->main_object->state,self->global_name);\n    lua_pushinteger(self->main_object->state,size+1);\n    lua_pushstring(self->main_object->state,value);\n    lua_rawset(self->main_object->state,-3);\n    lua_settop(self->main_object->state, 0);\n\n}\n\nvoid  LuaCEmbedTable_append_long(LuaCEmbedTable *self,  long long  value){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_VOID\n\n    long size = LuaCEmbedTable_get_listable_size(self);\n    lua_getglobal(self->main_object->state,self->global_name);\n    lua_pushinteger(self->main_object->state,size+1);\n    lua_pushnumber(self->main_object->state,(double)value);\n    lua_rawset(self->main_object->state,-3);\n    lua_settop(self->main_object->state, 0);\n\n}\n\nvoid  LuaCEmbedTable_append_double(LuaCEmbedTable *self, double  value){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_VOID\n\n    long size = LuaCEmbedTable_get_listable_size(self);\n    lua_getglobal(self->main_object->state,self->global_name);\n    lua_pushinteger(self->main_object->state,size+1);\n    lua_pushnumber(self->main_object->state,value);\n    lua_rawset(self->main_object->state,-3);\n    lua_settop(self->main_object->state, 0);\n\n}\n\nvoid  LuaCEmbedTable_append_bool(LuaCEmbedTable *self,  bool value){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_VOID\n\n    long size = LuaCEmbedTable_get_listable_size(self);\n    lua_getglobal(self->main_object->state,self->global_name);\n    lua_pushinteger(self->main_object->state,size+1);\n    lua_pushboolean(self->main_object->state,value);\n    lua_rawset(self->main_object->state,-3);\n    lua_settop(self->main_object->state, 0);\n\n}\n\nvoid  LuaCEmbedTable_append_evaluation(LuaCEmbedTable *self, const char *code, ...){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_VOID\n\n    va_list  args;\n    va_start(args,code);\n     char *buffer = private_LuaCembed_format_vaarg(code,args);\n    va_end(args);\n\n    LuaCEmbed_evaluate(\n            self->main_object,\n            PRIVATE_LUA_CEMBED_GLOBAL_EVALUATION_CODE,\n            PRIVATE_LUA_CEMBED_EVALUATION_NAME,\n            buffer\n    );\n    free(buffer);\n    if(LuaCEmbed_has_errors(self->main_object)){\n        return;\n    }\n    long size = LuaCEmbedTable_get_listable_size(self);\n    lua_getglobal(self->main_object->state,self->global_name);\n    lua_pushinteger(self->main_object->state,size+1);\n    lua_getglobal(self->main_object->state,PRIVATE_LUA_CEMBED_EVALUATION_NAME);\n    lua_rawset(self->main_object->state,-3);\n    lua_settop(self->main_object->state, 0);\n}"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/append/append.h",
		"is_binary":	false,
		"content":	"\n\nvoid  LuaCEmbedTable_append_table(LuaCEmbedTable *self, LuaCEmbedTable *table);\n\n\nvoid  LuaCEmbedTable_append_evaluation(LuaCEmbedTable *self, const char *code, ...);\n\nvoid  LuaCEmbedTable_append_string(LuaCEmbedTable *self,  const char *value);\n\nvoid  LuaCEmbedTable_append_long(LuaCEmbedTable *self,  long long  value);\n\nvoid  LuaCEmbedTable_append_double(LuaCEmbedTable *self, double  value);\n\nvoid  LuaCEmbedTable_append_bool(LuaCEmbedTable *self,  bool value);"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/basic/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/basic/basic.c",
		"is_binary":	false,
		"content":	"\n\n\n\nLuaCEmbedTable * private_newLuaCembedTable(LuaCEmbed *main_embed, const char *format, ...){\n\n    LuaCEmbedTable  *self = (LuaCEmbedTable*)malloc(sizeof (LuaCEmbedTable));\n    *self = (LuaCEmbedTable){0};\n    self->main_object =main_embed;\n\n    va_list  args;\n    va_start(args,format);\n    self->global_name = private_LuaCembed_format_vaarg(format,args);\n    va_end(args);\n\n    self->sub_tables = (void*)newprivateLuaCEmbedTableArray();\n\n    return self;\n}\n\n int  private_lua_cEmbed_unpack(LuaCEmbedTable *self,const char * previews_function){\n\n    long size = LuaCEmbedTable_get_listable_size(self);\n     lua_settop(self->main_object->state, 0);\n\n\n     lua_getglobal(self->main_object->state,self->global_name);\n     int table_index = lua_gettop(self->main_object->state);\n     int total = 0;\n\n\n     lua_pushnil(self->main_object->state);\n     while(lua_next(self->main_object->state,table_index)){\n\n         lua_pushvalue(self->main_object->state,-1);\n         char *formated = private_LuaCembed_format(PRIVATE_LUA_CEMBED_MULTIRETURN_,self->main_object->stack_leve,total);\n\n         lua_setglobal(self->main_object->state,formated);\n         free(formated);\n         lua_pop(self->main_object->state,1);\n         total+=1;\n     }\n    if(previews_function){\n        lua_getglobal(self->main_object->state,previews_function);\n    }\n    for(int i = 0; i < size; i++){\n        char *formated = private_LuaCembed_format(PRIVATE_LUA_CEMBED_MULTIRETURN_,self->main_object->stack_leve,i);\n        lua_getglobal(self->main_object->state,formated);\n        free(formated);\n    }\n\n    return (int)size;\n}\nvoid privateLuaCEmbedTable_free(LuaCEmbedTable *self){\n\n    free(self->global_name);\n\n    if(self->prop_name){\n        free(self->prop_name);\n    }\n\n    privateLuaCEmbedTableArray_free((privateLuaCEmbedTableArray*)self->sub_tables);\n    free(self);\n}\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/basic/basic.h",
		"is_binary":	false,
		"content":	"\n\nLuaCEmbedTable * private_newLuaCembedTable(LuaCEmbed *main_embed, const char *format, ...);\n\nint  private_lua_cEmbed_unpack(LuaCEmbedTable *self,const char * previews_function);\n\nvoid privateLuaCEmbedTable_free(LuaCEmbedTable *self);\n\nvoid privateLuaCEmbedTable_free_setting_nill(LuaCEmbedTable *self);"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/declaration.h",
		"is_binary":	false,
		"content":	"#include \"table.h\"\n#include \"basic/basic.h\"\n#include \"getters/declaration.h\"\n#include \"setters/declaration.h\"\n#include \"errors/errors.h\"\n#include \"sub_tables/declaration.h\"\n#include \"append/append.h\"\n#include \"destroy/destroy.h\"\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/definition.h",
		"is_binary":	false,
		"content":	"\n#include \"basic/basic.c\"\n#include \"getters/definition.h\"\n#include \"setters/definition.h\"\n#include \"errors/errors.c\"\n#include \"sub_tables/definition.h\"\n#include \"append/append.c\"\n#include \"destroy/destroy.c\""
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/destroy/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/destroy/destroy.c",
		"is_binary":	false,
		"content":	"\n\nvoid LuaCembedTable_destroy_prop(LuaCEmbedTable *self, const char *name){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_VOID\n\n\n    lua_getglobal(self->main_object->state,self->global_name);\n    lua_pushstring(self->main_object->state,name);\n    lua_pushnil(self->main_object->state);\n    lua_settable(self->main_object->state,-3);\n}\nvoid LuaCEmbedTable_destroy_by_index(LuaCEmbedTable *self, long index){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_VOID\n\n    long formatted_index = index + LUA_CEMBED_INDEX_DIF;\n\n    if(LuaCembedTable_has_key_at_index(self,index)){\n        char *key = LuaCembedTable_get_key_by_index(self,index);\n        LuaCembedTable_destroy_prop(self,key);\n        return;\n    }\n\n    lua_getglobal(self->main_object->state,self->global_name);\n\n    long converted_index = privateLuaCEmbedTable_convert_index(self,formatted_index);\n    int table_index = lua_gettop(self->main_object->state);\n    int total = 0;\n\n    lua_pushnil(self->main_object->state);\n    while(lua_next(self->main_object->state,table_index)){\n        if(total >= converted_index){\n\n            lua_getglobal(self->main_object->state,self->global_name);\n            lua_pushnumber(self->main_object->state,(double)(total));\n            lua_pushvalue(self->main_object->state,-3);\n            lua_settable(self->main_object->state,-3);\n            lua_pop(self->main_object->state,1);\n\n        }\n        lua_pop(self->main_object->state,1);\n        total+=1;\n\n    }\n\n    lua_getglobal(self->main_object->state,self->global_name);\n    lua_pushnumber(self->main_object->state,total);\n    lua_pushnil(self->main_object->state);\n    lua_settable(self->main_object->state,-3);\n\n\n\n}"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/destroy/destroy.h",
		"is_binary":	false,
		"content":	"\n\nvoid LuaCembedTable_destroy_prop(LuaCEmbedTable *self, const char *name);\n\nvoid LuaCEmbedTable_destroy_by_index(LuaCEmbedTable *self, long index);"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/errors/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/errors/errors.c",
		"is_binary":	false,
		"content":	"\n\n\nint privateLuaCEmbedTable_ensure_type_with_key(LuaCEmbedTable *self, const char *name, int expected_type){\n    if(!self){\n        return LUA_CEMBED_GENERIC_ERROR;\n    }\n\n    int type = lua_type(self->main_object->state,-1);\n    if(type == expected_type){\n        return  LUA_CEMBED_OK;\n    }\n    privateLuaCEmbed_raise_error_not_jumping(\n            self->main_object,\n            PRIVATE_LUA_CEMBED_WRONG_TYPE_PROPETY,\n            name,\n            self->global_name,\n            LuaCembed_convert_arg_code(type),\n            LuaCembed_convert_arg_code(expected_type)\n    );\n    return LUA_CEMBED_GENERIC_ERROR;\n}\n\nint privateLuaCEmbedTable_ensure_type_with_index(LuaCEmbedTable *self, long index, int expected_type){\n    if(!self){\n        return LUA_CEMBED_GENERIC_ERROR;\n    }\n\n    int type = lua_type(self->main_object->state,-1);\n    if(type == expected_type){\n        return  LUA_CEMBED_OK;\n    }\n    privateLuaCEmbed_raise_error_not_jumping(\n            self->main_object,\n            PRIVATE_LUA_CEMBED_WRONG_TYPE_INDEX,\n            index,\n            self->global_name,\n            LuaCembed_convert_arg_code(type),\n            LuaCembed_convert_arg_code(expected_type)\n    );\n    return LUA_CEMBED_GENERIC_ERROR;\n}"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/errors/errors.h",
		"is_binary":	false,
		"content":	"\nint privateLuaCEmbedTable_ensure_type_with_key(LuaCEmbedTable *self, const char *name, int expected_type);\n\nint privateLuaCEmbedTable_ensure_type_with_index(LuaCEmbedTable *self, long index, int expected_type);\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/getters/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/getters/declaration.h",
		"is_binary":	false,
		"content":	"#include \"index/index.h\"\n#include \"keys/keys.h\""
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/getters/definition.h",
		"is_binary":	false,
		"content":	"#include \"index/index.c\"\n#include \"keys/keys.c\""
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/getters/index/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/getters/index/index.c",
		"is_binary":	false,
		"content":	"\n\nlong  LuaCEmbedTable_get_full_size(LuaCEmbedTable *self){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_NUM\n\n\n\n    lua_getglobal(self->main_object->state,self->global_name);\n    int index = lua_gettop(self->main_object->state);\n    long total = 0;\n\n    lua_pushnil(self->main_object->state);\n    while(lua_next(self->main_object->state,index)){\n        total+=1;\n        lua_pop(self->main_object->state,1);\n    }\n\n    PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n    return total;\n}\n\nlong  LuaCEmbedTable_get_listable_size(LuaCEmbedTable *self){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_NUM\n\n    lua_getglobal(self->main_object->state,self->global_name);\n    return (long)lua_rawlen(self->main_object->state,-1);\n}\n\n\nlong  privateLuaCEmbedTable_convert_index(LuaCEmbedTable *self, private_lua_cembed_incremented_arg index){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_NUM\n\n    if(index >= 0){\n        return  index;\n    }\n\n    return LuaCEmbedTable_get_full_size(self) + index;\n}\n\nint LuaCEmbedTable_get_type_by_index(LuaCEmbedTable *self, int index){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_NUM\n\n    long formatted_index = index + LUA_CEMBED_INDEX_DIF;\n\n    lua_getglobal(self->main_object->state,self->global_name);\n    int table_index = lua_gettop(self->main_object->state);\n    long converted_index = privateLuaCEmbedTable_convert_index(self,formatted_index);\n    int total = 1;\n    lua_pushnil(self->main_object->state);\n    while(lua_next(self->main_object->state,table_index)){\n        if(total == converted_index){\n            int type = lua_type(self->main_object->state,-1);\n            lua_pop(self->main_object->state,1);\n            PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n            return type;\n        }\n        lua_pop(self->main_object->state,1);\n        total+=1;\n\n    }\n    PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n    return LUA_CEMBED_NOT_FOUND;\n}\nchar *LuaCembedTable_get_key_by_index(LuaCEmbedTable *self, long index){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_NULL\n\n    long formatted_index = index + LUA_CEMBED_INDEX_DIF;\n\n    lua_getglobal(self->main_object->state,self->global_name);\n    int table_index = lua_gettop(self->main_object->state);\n    long converted_index = privateLuaCEmbedTable_convert_index(self,formatted_index);\n    int total = 1;\n    lua_pushnil(self->main_object->state);\n    while(lua_next(self->main_object->state,table_index)){\n\n        if(total == converted_index){\n            if(lua_type(self->main_object->state,-2) != LUA_CEMBED_STRING ){\n                lua_pop(self->main_object->state,1);\n                PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n                return NULL;\n            }\n            char* result = (char*)lua_tostring(self->main_object->state,-2);\n            lua_pop(self->main_object->state,1);\n            PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n            return result;\n        }\n\n        lua_pop(self->main_object->state,1);\n        total+=1;\n\n    }\n    PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n    return NULL;\n}\nbool LuaCembedTable_has_key_at_index(LuaCEmbedTable *self, long index){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_BOOL\n    lua_settop(self->main_object->state,0);\n\n    long formatted_index = index + LUA_CEMBED_INDEX_DIF;\n\n    lua_getglobal(self->main_object->state,self->global_name);\n    int table_index = lua_gettop(self->main_object->state);\n    long converted_index = privateLuaCEmbedTable_convert_index(self,formatted_index);\n    int total = 1;\n    lua_pushnil(self->main_object->state);\n    while(lua_next(self->main_object->state,table_index)){\n        if(total == converted_index){\n            bool has_key =lua_type(self->main_object->state,-2) == LUA_CEMBED_STRING;\n            lua_pop(self->main_object->state,1);\n            PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n            return has_key;\n        }\n\n        lua_pop(self->main_object->state,1);\n        total+=1;\n    }\n    PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n    return false;\n}\n\nlong long  LuaCEmbedTable_get_long_by_index(LuaCEmbedTable *self, int index){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_NUM\n    lua_settop(self->main_object->state,0);\n\n    int formatted_index = index + LUA_CEMBED_INDEX_DIF;\n\n    lua_getglobal(self->main_object->state,self->global_name);\n    int table_index = lua_gettop(self->main_object->state);\n    long converted_index = privateLuaCEmbedTable_convert_index(self,formatted_index);\n    int total = 1;\n\n    lua_pushnil(self->main_object->state);\n    while(lua_next(self->main_object->state,table_index)){\n        if(total == converted_index){\n            if(privateLuaCEmbedTable_ensure_type_with_index(self,converted_index,LUA_CEMBED_NUMBER)){\n                lua_pop(self->main_object->state,1);\n                PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n                return LUA_CEMBED_GENERIC_ERROR;\n            }\n            long result = (long)lua_tonumber(self->main_object->state,-1);\n            lua_pop(self->main_object->state,1);\n            PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n            return result;\n        }\n\n        lua_pop(self->main_object->state,1);\n        total+=1;\n\n    }\n\n    privateLuaCEmbed_raise_error_not_jumping(\n            self->main_object,\n            PRIVATE_LUA_CEMBED_WRONG_TYPE_INDEX,\n            index,\n            self->global_name,\n            LuaCembed_convert_arg_code(LUA_CEMBED_NIL),\n            LuaCembed_convert_arg_code(LUA_CEMBED_NUMBER)\n    );\n    PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n    return LUA_CEMBED_GENERIC_ERROR;\n}\n\ndouble LuaCEmbedTable_get_double_by_index(LuaCEmbedTable *self, int index){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_NUM\n\n    int formatted_index = index + LUA_CEMBED_INDEX_DIF;\n\n    lua_getglobal(self->main_object->state,self->global_name);\n    int table_index = lua_gettop(self->main_object->state);\n    long converted_index = privateLuaCEmbedTable_convert_index(self,formatted_index);\n    int total = 1;\n    lua_pushnil(self->main_object->state);\n    while(lua_next(self->main_object->state,table_index)){\n        if(total == converted_index){\n            if(privateLuaCEmbedTable_ensure_type_with_index(self,converted_index,LUA_CEMBED_NUMBER)){\n                lua_pop(self->main_object->state,1);\n                PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n                return LUA_CEMBED_GENERIC_ERROR;\n            }\n            double result = (double )lua_tonumber(self->main_object->state,-1);\n            lua_pop(self->main_object->state,1);\n            PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n            return result;\n        }\n        lua_pop(self->main_object->state,1);\n        total+=1;\n\n    }\n\n    privateLuaCEmbed_raise_error_not_jumping(\n            self->main_object,\n            PRIVATE_LUA_CEMBED_WRONG_TYPE_INDEX,\n            index,\n            self->global_name,\n            LuaCembed_convert_arg_code(LUA_CEMBED_NIL),\n            LuaCembed_convert_arg_code(LUA_CEMBED_NUMBER)\n    );\n    PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n    return LUA_CEMBED_GENERIC_ERROR;\n}\n\nchar * LuaCEmbedTable_get_string_by_index(LuaCEmbedTable *self, int index){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_NULL\n\n    int formatted_index = index + LUA_CEMBED_INDEX_DIF;\n\n    lua_getglobal(self->main_object->state,self->global_name);\n    int table_index = lua_gettop(self->main_object->state);\n    long converted_index = privateLuaCEmbedTable_convert_index(self,formatted_index);\n    int total = 1;\n    lua_pushnil(self->main_object->state);\n    while(lua_next(self->main_object->state,table_index)){\n        if(total == converted_index){\n            if(privateLuaCEmbedTable_ensure_type_with_index(self,converted_index,LUA_CEMBED_STRING)){\n                lua_pop(self->main_object->state,1);\n                PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n                return NULL;\n            }\n            char * result = (char*)lua_tostring(self->main_object->state,-1);\n            lua_pop(self->main_object->state,1);\n            PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n            return result;\n        }\n        lua_pop(self->main_object->state,1);\n        total+=1;\n\n    }\n\n    privateLuaCEmbed_raise_error_not_jumping(\n            self->main_object,\n            PRIVATE_LUA_CEMBED_WRONG_TYPE_INDEX,\n            index,\n            self->global_name,\n            LuaCembed_convert_arg_code(LUA_CEMBED_NIL),\n            LuaCembed_convert_arg_code(LUA_CEMBED_STRING)\n    );\n    PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n    return NULL;\n}\n\nbool LuaCEmbedTable_get_bool_by_index(LuaCEmbedTable *self, int index){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_BOOL\n\n    int formatted_index = index + LUA_CEMBED_INDEX_DIF;\n    lua_getglobal(self->main_object->state,self->global_name);\n    int table_index = lua_gettop(self->main_object->state);\n    long converted_index = privateLuaCEmbedTable_convert_index(self,formatted_index);\n    int total = 1;\n    lua_pushnil(self->main_object->state);\n    while(lua_next(self->main_object->state,table_index)){\n        if(total == converted_index){\n            if(privateLuaCEmbedTable_ensure_type_with_index(self,converted_index,LUA_CEMBED_BOOL)){\n                lua_pop(self->main_object->state,1);\n                PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n                return LUA_CEMBED_GENERIC_ERROR;\n            }\n            bool result = lua_toboolean(self->main_object->state,-1);\n            lua_pop(self->main_object->state,1);\n            PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n            return result;\n        }\n        lua_pop(self->main_object->state,1);\n        total+=1;\n\n    }\n\n    privateLuaCEmbed_raise_error_not_jumping(\n            self->main_object,\n            PRIVATE_LUA_CEMBED_WRONG_TYPE_INDEX,\n            converted_index,\n            self->global_name,\n            LuaCembed_convert_arg_code(LUA_CEMBED_NIL),\n            LuaCembed_convert_arg_code(LUA_CEMBED_BOOL)\n    );\n    PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n    return LUA_CEMBED_GENERIC_ERROR;\n}"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/getters/index/index.h",
		"is_binary":	false,
		"content":	"\n\nchar *LuaCembedTable_get_key_by_index(LuaCEmbedTable *self, long index);\n\nbool LuaCembedTable_has_key_at_index(LuaCEmbedTable *self, long index);\n\nlong  LuaCEmbedTable_get_full_size(LuaCEmbedTable *self);\n\nlong  LuaCEmbedTable_get_listable_size(LuaCEmbedTable *self);\n\n\nlong  privateLuaCEmbedTable_convert_index(LuaCEmbedTable *self, private_lua_cembed_incremented_arg index);\n\nint LuaCEmbedTable_get_type_by_index(LuaCEmbedTable *self, int index);\n\nlong long LuaCEmbedTable_get_long_by_index(LuaCEmbedTable *self, int index);\n\ndouble LuaCEmbedTable_get_double_by_index(LuaCEmbedTable *self, int index);\n\nchar * LuaCEmbedTable_get_string_by_index(LuaCEmbedTable *self, int index);\n\nbool LuaCEmbedTable_get_bool_by_index(LuaCEmbedTable *self, int index);\n\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/getters/keys/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/getters/keys/keys.c",
		"is_binary":	false,
		"content":	"\nint  LuaCEmbedTable_get_type_prop(LuaCEmbedTable *self, const char *name){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_NUM\n    lua_getglobal(self->main_object->state,self->global_name);\n    privateLuaCEmbd_get_field_protected(self->main_object,name);\n    return lua_type(self->main_object->state,-1);\n\n}\n\nchar*  LuaCembedTable_get_string_prop(LuaCEmbedTable *self , const char *name){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_NULL\n\n\n\n    lua_getglobal(self->main_object->state,self->global_name);\n    privateLuaCEmbd_get_field_protected(self->main_object,name);\n    if(privateLuaCEmbedTable_ensure_type_with_key(self, name, LUA_CEMBED_STRING)){\n        return NULL;\n    }\n\n    char *value = (char*)lua_tostring(self->main_object->state,-1);\n    PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n    return value;\n}\n\n\nlong long   LuaCembedTable_get_long_prop(LuaCEmbedTable *self , const char *name){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_NUM\n\n    lua_getglobal(self->main_object->state,self->global_name);\n    privateLuaCEmbd_get_field_protected(self->main_object,name);\n    if(privateLuaCEmbedTable_ensure_type_with_key(self, name, LUA_CEMBED_NUMBER)){\n        return LUA_CEMBED_GENERIC_ERROR;\n    }\n    long long value = (long long)lua_tonumber(self->main_object->state,-1);\n    PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n    return value;\n}\n\ndouble  LuaCembedTable_get_double_prop(LuaCEmbedTable *self , const char *name){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_NUM\n\n\n\n    lua_getglobal(self->main_object->state,self->global_name);\n    privateLuaCEmbd_get_field_protected(self->main_object,name);\n\n    if(privateLuaCEmbedTable_ensure_type_with_key(self, name, LUA_CEMBED_NUMBER)){\n        return LUA_CEMBED_GENERIC_ERROR;\n    }\n    double value  = (double )lua_tonumber(self->main_object->state,-1);\n    PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n    return value;\n}\n\nbool  LuaCembedTable_get_bool_prop(LuaCEmbedTable *self , const char *name){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_BOOL\n\n\n\n    lua_getglobal(self->main_object->state,self->global_name);\n    privateLuaCEmbd_get_field_protected(self->main_object,name);\n    if(privateLuaCEmbedTable_ensure_type_with_key(self, name, LUA_CEMBED_BOOL)){\n        return LUA_CEMBED_GENERIC_ERROR;\n    }\n    bool value =  lua_toboolean(self->main_object->state,-1);\n    PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n    return value;\n}\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/getters/keys/keys.h",
		"is_binary":	false,
		"content":	"\n\n\nchar*  LuaCembedTable_get_string_prop(LuaCEmbedTable *self, const char *name);\n\nlong long   LuaCembedTable_get_long_prop(LuaCEmbedTable *self, const char *name);\n\ndouble  LuaCembedTable_get_double_prop(LuaCEmbedTable *self, const char *name);\n\nbool  LuaCembedTable_get_bool_prop(LuaCEmbedTable *self, const char *name);\n\nint  LuaCEmbedTable_get_type_prop(LuaCEmbedTable *self, const char *name);\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/setters/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/setters/declaration.h",
		"is_binary":	false,
		"content":	"#include \"index/index.h\"\n#include \"keys/keys.h\"\n#include \"insert/insert.h\""
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/setters/definition.h",
		"is_binary":	false,
		"content":	"#include \"index/index.c\"\n#include \"keys/keys.c\"\n#include \"insert/insert.c\"\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/setters/index/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/setters/index/index.c",
		"is_binary":	false,
		"content":	"\n\nvoid  LuaCEmbedTable_set_string_by_index(LuaCEmbedTable *self, long index, const char *value){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_VOID\n\n    char *possible_key = LuaCembedTable_get_key_by_index(self,index);\n    if(possible_key){\n        LuaCEmbedTable_set_string_prop(self,possible_key,value);\n        return;\n    }\n    long formatted_index = index + LUA_CEMBED_INDEX_DIF;\n    lua_getglobal(self->main_object->state,self->global_name);\n    lua_pushnumber(self->main_object->state,(double)formatted_index);\n    lua_pushstring(self->main_object->state,value);\n    lua_settable(self->main_object->state,-3);\n    lua_settop(self->main_object->state, 0);\n\n}\n\nvoid  LuaCEmbedTable_set_long_by_index(LuaCEmbedTable *self, long long  index, long  value){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_VOID\n\n    char *possible_key = LuaCembedTable_get_key_by_index(self,index);\n    if(possible_key){\n        LuaCEmbedTable_set_long_prop(self,possible_key,value);\n        return;\n    }\n    long formatted_index = index + LUA_CEMBED_INDEX_DIF;\n    lua_getglobal(self->main_object->state,self->global_name);\n    lua_pushnumber(self->main_object->state,(double)formatted_index);\n    lua_pushnumber(self->main_object->state,(double )value);\n    lua_settable(self->main_object->state,-3);\n    lua_settop(self->main_object->state, 0);\n\n}\n\nvoid  LuaCEmbedTable_set_double_by_index(LuaCEmbedTable *self, long index, double  value){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_VOID\n\n    char *possible_key = LuaCembedTable_get_key_by_index(self,index);\n    if(possible_key){\n        LuaCEmbedTable_set_double_prop(self,possible_key,value);\n        return;\n    }\n\n    long formatted_index = index + LUA_CEMBED_INDEX_DIF;\n    lua_getglobal(self->main_object->state,self->global_name);\n    lua_pushnumber(self->main_object->state,(double)formatted_index);\n    lua_pushnumber(self->main_object->state,(double )value);\n    lua_settable(self->main_object->state,-3);\n    lua_settop(self->main_object->state, 0);\n\n}\n\nvoid  LuaCEmbedTable_set_bool_by_index(LuaCEmbedTable *self, long index, bool value){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_VOID\n\n    char *possible_key = LuaCembedTable_get_key_by_index(self,index);\n    if(possible_key){\n        LuaCEmbedTable_set_bool_prop(self,possible_key,value);\n        return;\n    }\n\n    long formatted_index = index + LUA_CEMBED_INDEX_DIF;\n    lua_getglobal(self->main_object->state,self->global_name);\n    lua_pushnumber(self->main_object->state,(double)formatted_index);\n    lua_pushboolean(self->main_object->state,value);\n    lua_settable(self->main_object->state,-3);\n    lua_settop(self->main_object->state, 0);\n\n}\n\n\nvoid  LuaCEmbedTable_set_evaluation_by_index(LuaCEmbedTable *self, long index, const char *code, ...){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_VOID\n\n    long formatted_index = index + LUA_CEMBED_INDEX_DIF;\n    va_list  args;\n    va_start(args,code);\n    char *  buffer = private_LuaCembed_format_vaarg(code,args);\n    va_end(args);\n\n    LuaCEmbed_evaluate(self->main_object,\n                       PRIVATE_LUA_CEMBED_GLOBAL_EVALUATION_CODE,\n                       PRIVATE_LUA_CEMBED_EVALUATION_NAME,\n                       buffer\n    );\n    free(buffer);\n    if(LuaCEmbed_has_errors(self->main_object)){\n        return;\n    }\n    lua_getglobal(self->main_object->state,self->global_name);\n    lua_pushnumber(self->main_object->state,(double)formatted_index);\n    lua_getglobal(self->main_object->state,PRIVATE_LUA_CEMBED_EVALUATION_NAME);\n    lua_settable(self->main_object->state,-3);\n    lua_settop(self->main_object->state, 0);\n\n}\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/setters/index/index.h",
		"is_binary":	false,
		"content":	"\nvoid  LuaCEmbedTable_set_string_by_index(LuaCEmbedTable *self, long index, const char *value);\n\nvoid  LuaCEmbedTable_set_long_by_index(LuaCEmbedTable *self, long long  index, long  value);\n\nvoid  LuaCEmbedTable_set_double_by_index(LuaCEmbedTable *self, long index, double  value);\n\nvoid  LuaCEmbedTable_set_bool_by_index(LuaCEmbedTable *self, long index, bool value);\n\n\nvoid  LuaCEmbedTable_set_evaluation_by_index(LuaCEmbedTable *self, long index, const char *code, ...);\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/setters/insert/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/setters/insert/insert.c",
		"is_binary":	false,
		"content":	"\nvoid  private_LuaCEmbedTable_add_space(LuaCEmbedTable *self, long formatted_index){\n\n\n    lua_newtable(self->main_object->state);\n    lua_setglobal(self->main_object->state,PRIVATE_LUA_CEMBED_STAGE_AREA_TABLE);\n\n    lua_getglobal(self->main_object->state, self->global_name);\n    int table_index = lua_gettop(self->main_object->state);\n    int total = 1;\n    lua_pushnil(self->main_object->state); // Empilhando o primeiro par chave-valor\n    while (lua_next(self->main_object->state, table_index)) {\n\n        if (total >= formatted_index) {\n            lua_getglobal(self->main_object->state, PRIVATE_LUA_CEMBED_STAGE_AREA_TABLE);\n            lua_pushinteger(self->main_object->state, total + 1);\n            lua_pushvalue(self->main_object->state, -3);\n            lua_settable(self->main_object->state, -3);\n            lua_pop(self->main_object->state, 1);\n        }\n        lua_pop(self->main_object->state, 1); // Removendo o valor atual\n        total+=1;\n    }\n\n    lua_getglobal(self->main_object->state, PRIVATE_LUA_CEMBED_STAGE_AREA_TABLE);\n    table_index = lua_gettop(self->main_object->state);\n    lua_pushnil(self->main_object->state);\n\n    while (lua_next(self->main_object->state, table_index)) {\n        lua_getglobal(self->main_object->state,self->global_name);\n        lua_pushvalue(self->main_object->state,-3); //table[index] =  stage_area[index]\n        lua_pushvalue(self->main_object->state,-3);  //table[index] =  stage_area[index]\n        lua_settable(self->main_object->state,-3);\n        lua_pop(self->main_object->state, 2); // Removendo o valor atual\n    }\n\n    lua_getglobal(self->main_object->state, \"stage_arrea\");\n    lua_pushnil(self->main_object->state);\n}\n\nvoid LuaCEmbedTable_insert_string_at_index(LuaCEmbedTable *self, long index, const char *value) {\n    // Movendo os elementos existentes para frente\n    long formatted_index = index + LUA_CEMBED_INDEX_DIF;\n\n    private_LuaCEmbedTable_add_space(self,formatted_index);\n    // Inserindo o novo valor na posio especificada\n    lua_getglobal(self->main_object->state, self->global_name);\n    lua_pushnumber(self->main_object->state, (double)formatted_index);\n    lua_pushstring(self->main_object->state, value);\n    lua_settable(self->main_object->state, -3);\n\n    // Limpando a pilha\n    lua_settop(self->main_object->state, 0);\n}\n\n\nvoid  LuaCEmbedTable_insert_bool_at_index(LuaCEmbedTable *self, long index,bool value){\n\n    // Movendo os elementos existentes para frente\n    long formatted_index = index + LUA_CEMBED_INDEX_DIF;\n\n    private_LuaCEmbedTable_add_space(self,formatted_index);\n    // Inserindo o novo valor na posio especificada\n    lua_getglobal(self->main_object->state, self->global_name);\n    lua_pushnumber(self->main_object->state, (double)formatted_index);\n    lua_pushboolean(self->main_object->state, value);\n    lua_settable(self->main_object->state, -3);\n\n    // Limpando a pilha\n    lua_settop(self->main_object->state, 0);\n}\n\nvoid  LuaCEmbedTable_insert_long_at_index(LuaCEmbedTable *self, long long  index,long value){\n\n    // Movendo os elementos existentes para frente\n    long formatted_index = index + LUA_CEMBED_INDEX_DIF;\n\n    private_LuaCEmbedTable_add_space(self,formatted_index);\n    // Inserindo o novo valor na posio especificada\n    lua_getglobal(self->main_object->state, self->global_name);\n    lua_pushnumber(self->main_object->state, (double)formatted_index);\n    lua_pushinteger(self->main_object->state, value);\n    lua_settable(self->main_object->state, -3);\n\n    // Limpando a pilha\n    lua_settop(self->main_object->state, 0);\n}\n\nvoid  LuaCEmbedTable_insert_double_at_index(LuaCEmbedTable *self, long index,double value){\n\n    // Movendo os elementos existentes para frente\n    long formatted_index = index + LUA_CEMBED_INDEX_DIF;\n\n    private_LuaCEmbedTable_add_space(self,formatted_index);\n    // Inserindo o novo valor na posio especificada\n    lua_getglobal(self->main_object->state, self->global_name);\n    lua_pushnumber(self->main_object->state, (double)formatted_index);\n    lua_pushnumber(self->main_object->state, value);\n    lua_settable(self->main_object->state, -3);\n\n    // Limpando a pilha\n    lua_settop(self->main_object->state, 0);\n}\n\nvoid  LuaCEmbedTable_insert_table_at_index(LuaCEmbedTable *self, long index,LuaCEmbedTable *table){\n\n    // Movendo os elementos existentes para frente\n    long formatted_index = index + LUA_CEMBED_INDEX_DIF;\n\n    private_LuaCEmbedTable_add_space(self,formatted_index);\n    // Inserindo o novo valor na posio especificada\n    lua_getglobal(self->main_object->state, self->global_name);\n    lua_pushnumber(self->main_object->state, (double)formatted_index);\n    lua_getglobal(self->main_object->state,table->global_name);\n    lua_settable(self->main_object->state, -3);\n    // Limpando a pilha\n    lua_settop(self->main_object->state, 0);\n}"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/setters/insert/insert.h",
		"is_binary":	false,
		"content":	"\n\nvoid  private_LuaCEmbedTable_add_space(LuaCEmbedTable *self, long formatted_index);\n\nvoid  LuaCEmbedTable_insert_string_at_index(LuaCEmbedTable *self, long index, const char *value);\n\nvoid  LuaCEmbedTable_insert_bool_at_index(LuaCEmbedTable *self, long index,bool value);\n\nvoid  LuaCEmbedTable_insert_long_at_index(LuaCEmbedTable *self, long long  index,long value);\n\nvoid  LuaCEmbedTable_insert_double_at_index(LuaCEmbedTable *self, long index,double value);\n\nvoid  LuaCEmbedTable_insert_table_at_index(LuaCEmbedTable *self, long index,LuaCEmbedTable *table);\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/setters/keys/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/setters/keys/keys.c",
		"is_binary":	false,
		"content":	"\n\n\n\nvoid LuaCEmbedTable_set_method(LuaCEmbedTable *self , const char *name, LuaCEmbedResponse *(*callback)(LuaCEmbedTable  *self, LuaCEmbed *args)){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_VOID\n\n\n    bool is_meta = false;\n\n    if(strlen(name) > 3){\n        if(name[0] == '_' && name[1] == '_' ){\n            is_meta = true;\n        }\n    }\n    lua_getglobal(self->main_object->state,self->global_name);\n\n    if(is_meta){\n\n\n        int found =lua_getmetatable(self->main_object->state,-1);\n        if(!found){\n\n            //equivalent of meta ={} ;setmetatable(table,meta)\n            lua_getglobal(self->main_object->state,self->global_name);\n            lua_newtable(self->main_object->state);\n            lua_setmetatable(self->main_object->state,-2);\n\n            lua_getglobal(self->main_object->state,self->global_name);\n            lua_getmetatable(self->main_object->state,-1);\n        }\n    }\n\n\n    lua_pushstring(self->main_object->state,name);\n    //creating the clojure\n\n    lua_pushboolean(self->main_object->state,true);//is a method\n\n    lua_pushlightuserdata(self->main_object->state,(void*)self->main_object); //self\n    lua_pushstring(self->main_object->state,name);//calback name\n    lua_getglobal(self->main_object->state,self->global_name);//table\n    lua_pushlightuserdata(self->main_object->state,(void*)callback);\n\n    //add these clojure to be handled by the callbacks\n    lua_pushcclosure(self->main_object->state,privateLuaCEmbed_main_callback_handler,5);\n    lua_settable(self->main_object->state,-3);\n\n    if(is_meta){\n        //equivalent of meta ={} ;setmetatable(table,meta)\n        lua_getglobal(self->main_object->state,self->global_name);\n       lua_getmetatable(self->main_object->state,-1);\n        lua_setmetatable(self->main_object->state,-2);\n    }\n    lua_settop(self->main_object->state, 0);\n\n}\n\nvoid  LuaCEmbedTable_set_string_prop(LuaCEmbedTable *self , const char *name, const char *value){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_VOID\n\n    lua_getglobal(self->main_object->state,self->global_name);\n    lua_pushstring(self->main_object->state,name);\n    lua_pushstring(self->main_object->state,value);\n\n    lua_settable(self->main_object->state,-3);\n    lua_settop(self->main_object->state, 0);\n\n}\n\nvoid  LuaCEmbedTable_set_long_prop(LuaCEmbedTable *self , const char *name, long long   value){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_VOID\n\n    lua_getglobal(self->main_object->state,self->global_name);\n    lua_pushstring(self->main_object->state,name);\n    lua_pushnumber(self->main_object->state,(double)value);\n    lua_settable(self->main_object->state,-3);\n    lua_settop(self->main_object->state, 0);\n\n}\n\nvoid  LuaCEmbedTable_set_double_prop(LuaCEmbedTable *self , const char *name, double  value){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_VOID\n\n    lua_getglobal(self->main_object->state,self->global_name);\n    lua_pushstring(self->main_object->state,name);\n    lua_pushnumber(self->main_object->state,value);\n    lua_settable(self->main_object->state,-3);\n    lua_settop(self->main_object->state, 0);\n\n}\n\nvoid  LuaCEmbedTable_set_bool_prop(LuaCEmbedTable *self , const char *name, bool value){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_VOID\n\n    lua_getglobal(self->main_object->state,self->global_name);\n    lua_pushstring(self->main_object->state,name);\n    lua_pushboolean(self->main_object->state,value);\n    lua_settable(self->main_object->state,-3);\n    lua_settop(self->main_object->state, 0);\n\n}\n\nvoid  LuaCEmbedTable_set_evaluation_prop(LuaCEmbedTable *self, const char *name, const char *code, ...){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_VOID\n\n\n    va_list  args;\n    va_start(args,code);\n    char *buffer = private_LuaCembed_format_vaarg(code,args);\n    va_end(args);\n\n    LuaCEmbed_evaluate(self->main_object,\n                       PRIVATE_LUA_CEMBED_GLOBAL_EVALUATION_CODE,\n                       PRIVATE_LUA_CEMBED_EVALUATION_NAME,\n                       buffer\n    );\n    free(buffer);\n    if(LuaCEmbed_has_errors(self->main_object)){\n        return;\n    }\n    lua_getglobal(self->main_object->state,self->global_name);\n    lua_pushstring(self->main_object->state,name);\n    lua_getglobal(self->main_object->state,PRIVATE_LUA_CEMBED_EVALUATION_NAME);\n    lua_settable(self->main_object->state,-3);\n    lua_settop(self->main_object->state, 0);\n\n}"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/setters/keys/keys.h",
		"is_binary":	false,
		"content":	"\n\n\n\n\nvoid LuaCEmbedTable_set_method(LuaCEmbedTable *self, const char *name, LuaCEmbedResponse *(*callback)(LuaCEmbedTable  *self, LuaCEmbed *args));\n\nvoid  LuaCEmbedTable_set_string_prop(LuaCEmbedTable *self, const char *name, const char *value);\n\nvoid  LuaCEmbedTable_set_long_prop(LuaCEmbedTable *self, const char *name, long long   value);\n\nvoid  LuaCEmbedTable_set_double_prop(LuaCEmbedTable *self, const char *name, double  value);\n\nvoid  LuaCEmbedTable_set_bool_prop(LuaCEmbedTable *self, const char *name, bool value);\n\n\nvoid  LuaCEmbedTable_set_evaluation_prop(LuaCEmbedTable *self, const char *name, const char *code, ...);\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/sub_tables/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/sub_tables/declaration.h",
		"is_binary":	false,
		"content":	"#include \"key/key.h\"\n#include \"index/index.h\""
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/sub_tables/definition.h",
		"is_binary":	false,
		"content":	"#include \"key/key.c\"\n#include \"index/index.c\""
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/sub_tables/index/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/sub_tables/index/index.c",
		"is_binary":	false,
		"content":	"\nLuaCEmbedTable  *LuaCEmbedTable_new_sub_table_appending(LuaCEmbedTable *self){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_NULL\n\n\n\n    //equivalent of: full_sub_table_name = {}\n    long index= LuaCEmbedTable_get_listable_size(self) +1;\n    char *full_sub_table_name = private_LuaCembed_format(\"%s_%d\", self->global_name, index);\n    lua_newtable(self->main_object->state);\n    lua_setglobal(self->main_object->state,full_sub_table_name);\n\n\n    //equivalent of: table[index] = full_sub_table_name\n    lua_getglobal(self->main_object->state,self->global_name);\n    lua_pushinteger(self->main_object->state,index);\n    lua_getglobal(self->main_object->state,full_sub_table_name);\n    lua_settable(self->main_object->state,-3);\n    lua_settop(self->main_object->state, 0);\n\n    LuaCEmbedTable  *possible = privateLuaCEmbedTableArray_find_by_internal_index(\n            (privateLuaCEmbedTableArray *) self->sub_tables,\n            index\n    );\n\n    if(possible){\n        free(full_sub_table_name);\n        PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n        return possible;\n    }\n\n    LuaCEmbedTable  *created = private_newLuaCembedTable(self->main_object, full_sub_table_name);\n    created->index = index;\n\n    privateLuaCEmbedTableArray_append(\n            (privateLuaCEmbedTableArray*)self->sub_tables,\n            created\n    );\n\n    free(full_sub_table_name);\n    PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n    return created;\n}\n\nLuaCEmbedTable  *LuaCEmbedTable_get_sub_table_by_index(LuaCEmbedTable *self, long index){\n\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_NULL\n\n\n    long formatted_index = index + LUA_CEMBED_INDEX_DIF;\n\n    lua_getglobal(self->main_object->state,self->global_name);\n    int table_index = lua_gettop(self->main_object->state);\n    long converted_index = privateLuaCEmbedTable_convert_index(self,formatted_index);\n    int total = 1;\n\n    lua_pushnil(self->main_object->state);\n    while(lua_next(self->main_object->state,table_index)){\n        if(total == converted_index){\n\n            if(privateLuaCEmbedTable_ensure_type_with_index(self,converted_index,LUA_CEMBED_TABLE)){\n                lua_pop(self->main_object->state,1);\n                PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n                return NULL;\n            }\n\n            //equivalent of full_sub_table_name = table[index]\n            char *full_sub_table_name = private_LuaCembed_format(\"%s_%d\", self->global_name, index);\n            lua_setglobal(self->main_object->state,full_sub_table_name);\n\n            LuaCEmbedTable  *possible = privateLuaCEmbedTableArray_find_by_internal_index(\n                    (privateLuaCEmbedTableArray *) self->sub_tables,\n                    index\n            );\n\n            if(possible){\n                free(full_sub_table_name);\n                lua_pop(self->main_object->state,1);\n                PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n                return possible;\n            }\n\n            LuaCEmbedTable  *created = private_newLuaCembedTable(self->main_object, full_sub_table_name);\n            created->index = index;\n\n            privateLuaCEmbedTableArray_append(\n                    (privateLuaCEmbedTableArray*)self->sub_tables,\n                    created\n            );\n\n            free(full_sub_table_name);\n            lua_pop(self->main_object->state,1);\n            PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n            return created;\n        }\n        lua_pop(self->main_object->state,1);\n        total+=1;\n\n    }\n\n    privateLuaCEmbed_raise_error_not_jumping(\n            self->main_object,\n            PRIVATE_LUA_CEMBED_WRONG_TYPE_INDEX,\n            index,\n            self->global_name,\n            LuaCembed_convert_arg_code(LUA_CEMBED_NIL),\n            LuaCembed_convert_arg_code(LUA_CEMBED_TABLE)\n    );\n    PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n    return NULL;\n}\n\nvoid LuaCEmbedTable_set_sub_table_by_index(LuaCEmbedTable *self, long index,LuaCEmbedTable *sub_table){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_VOID\n\n\n    char *possible_key = LuaCembedTable_get_key_by_index(self,index);\n    if(possible_key){\n        LuaCEmbedTable_set_sub_table_prop(self,possible_key,sub_table);\n        PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n        return;\n    }\n\n    long formatted_index = index + LUA_CEMBED_INDEX_DIF;\n    lua_getglobal(self->main_object->state,self->global_name);\n    lua_pushinteger(self->main_object->state,formatted_index);\n    lua_getglobal(self->main_object->state,sub_table->global_name);\n    lua_settable(self->main_object->state,-3);\n    lua_settop(self->main_object->state, 0);\n    PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n}\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/sub_tables/index/index.h",
		"is_binary":	false,
		"content":	"\n\nLuaCEmbedTable  *LuaCEmbedTable_new_sub_table_appending(LuaCEmbedTable *self);\n\n\nLuaCEmbedTable  *LuaCEmbedTable_get_sub_table_by_index(LuaCEmbedTable *self, long index);\n\n\nvoid LuaCEmbedTable_set_sub_table_by_index(LuaCEmbedTable *self, long index,LuaCEmbedTable *sub_table);\n\n\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/sub_tables/key/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/sub_tables/key/key.c",
		"is_binary":	false,
		"content":	"\nLuaCEmbedTable  *LuaCEmbedTable_new_sub_table_by_key(LuaCEmbedTable *self, const char *name){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_NULL\n\n\n    //equivalent of: table.sub_table = {}\n    lua_getglobal(self->main_object->state,self->global_name);\n    lua_pushstring(self->main_object->state,name);\n    lua_newtable(self->main_object->state);\n    lua_settable(self->main_object->state,-3);\n\n\n    //equivalent of full_sub_table_name = table.sub_table\n    lua_getglobal(self->main_object->state,self->global_name);\n    lua_pushstring(self->main_object->state, name);\n    lua_gettable(self->main_object->state, -2);\n    char *full_sub_table_name = private_LuaCembed_format(\"%s_%s\", self->global_name, name);\n    lua_setglobal(self->main_object->state,full_sub_table_name);\n\n\n    LuaCEmbedTable  *possible = privateLuaCEmbedTableArray_find_by_prop_name(\n            (privateLuaCEmbedTableArray *) self->sub_tables,\n            name\n    );\n\n\n    if(possible){\n        free(full_sub_table_name);\n        PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n        return possible;\n    }\n\n    LuaCEmbedTable  *created = private_newLuaCembedTable(self->main_object, full_sub_table_name);\n    created->prop_name = strdup(name);\n\n    privateLuaCEmbedTableArray_append(\n            (privateLuaCEmbedTableArray*)self->sub_tables,\n            created\n    );\n\n    free(full_sub_table_name);\n    PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n    return created;\n}\n\n\nLuaCEmbedTable  *LuaCEmbedTable_get_sub_table_by_key(LuaCEmbedTable *self, const char *name){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_NULL\n\n\n    lua_getglobal(self->main_object->state,self->global_name);\n    privateLuaCEmbd_get_field_protected(self->main_object,name);\n    if(privateLuaCEmbedTable_ensure_type_with_key(self, name, LUA_CEMBED_TABLE)){\n        PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n        return NULL;\n    }\n    //equivalent of full_sub_table_name = table.sub_table\n    lua_getglobal(self->main_object->state,self->global_name);\n    privateLuaCEmbd_get_field_protected(self->main_object,name);\n    char *full_sub_table_name = private_LuaCembed_format(\"%s_%s\", self->global_name, name);\n    lua_setglobal(self->main_object->state,full_sub_table_name);\n\n\n    LuaCEmbedTable  *possible = privateLuaCEmbedTableArray_find_by_prop_name(\n            (privateLuaCEmbedTableArray *) self->sub_tables,\n            name\n    );\n\n\n    if(possible){\n        free(full_sub_table_name);\n        PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n        return possible;\n    }\n\n    LuaCEmbedTable  *created = private_newLuaCembedTable(self->main_object, full_sub_table_name);\n    created->prop_name = strdup(name);\n\n    privateLuaCEmbedTableArray_append(\n            (privateLuaCEmbedTableArray*)self->sub_tables,\n            created\n    );\n\n    free(full_sub_table_name);\n    PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n    return created;\n\n}\n\n\n\nvoid LuaCEmbedTable_set_sub_table_prop(LuaCEmbedTable *self, const char *name, LuaCEmbedTable *sub_table){\n    PRIVATE_LUA_CEMBED_TABLE_PROTECT_VOID\n\n    //equivalent of  table.name = sub_table;\n    lua_getglobal(self->main_object->state,self->global_name);\n    lua_pushstring(self->main_object->state,name);\n    lua_getglobal(self->main_object->state,sub_table->global_name);\n    lua_settable(self->main_object->state,-3);\n\n\n    //equivalent of full_sub_table_name = table.sub_table\n    lua_getglobal(self->main_object->state,self->global_name);\n    privateLuaCEmbd_get_field_protected(self->main_object,name);\n\n    char *full_sub_table_name = private_LuaCembed_format(\"%s_%s\", self->global_name, name);\n    lua_setglobal(self->main_object->state,full_sub_table_name);\n    free(full_sub_table_name);\n    PRIVATE_LUA_CEMBED_TABLE_CLEAR_STACK\n}"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/sub_tables/key/key.h",
		"is_binary":	false,
		"content":	"\nLuaCEmbedTable  *LuaCEmbedTable_new_sub_table_by_key(LuaCEmbedTable *self, const char *name);\n\nLuaCEmbedTable  *LuaCEmbedTable_get_sub_table_by_key(LuaCEmbedTable *self, const char *name);\n\nvoid LuaCEmbedTable_set_sub_table_prop(LuaCEmbedTable *self, const char *name, LuaCEmbedTable *sub_table);"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table/table.h",
		"is_binary":	false,
		"content":	"\n\ntypedef struct {\n    LuaCEmbed  *main_object;\n    char *prop_name;\n    char  *global_name;\n    void *sub_tables;\n    long index;\n\n}LuaCEmbedTable;\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table_array/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table_array/table_array.c",
		"is_binary":	false,
		"content":	"\n\nprivateLuaCEmbedTableArray *newprivateLuaCEmbedTableArray(){\n    privateLuaCEmbedTableArray *self = (privateLuaCEmbedTableArray*) malloc(sizeof (privateLuaCEmbedTableArray));\n    *self = (privateLuaCEmbedTableArray){0};\n    self->tables = (LuaCEmbedTable**)malloc(0);\n    return self;\n}\n\nvoid privateLuaCEmbedTableArray_append(privateLuaCEmbedTableArray *self,LuaCEmbedTable *element){\n\n    self->tables = (LuaCEmbedTable **)realloc(\n            self->tables,\n           (self->size+1)* sizeof (LuaCEmbedTable**)\n    );\n    self->tables[self->size] = element;\n    self->size+=1;\n}\n\n\nLuaCEmbedTable  *privateLuaCEmbedTableArray_find_by_prop_name(privateLuaCEmbedTableArray *self, const char *name){\n    for(int i = 0; i < self->size;i++){\n        LuaCEmbedTable  *current_table = self->tables[i];\n        if(current_table->prop_name){\n            if(strcmp(current_table->prop_name,name) ==0){\n                return  current_table;\n            }\n        }\n    }\n    return NULL;\n}\n\nLuaCEmbedTable  *privateLuaCEmbedTableArray_find_by_global_name(privateLuaCEmbedTableArray *self, const char *name){\n    for(int i = 0; i < self->size;i++){\n        LuaCEmbedTable  *current_table = self->tables[i];\n            if(strcmp(current_table->global_name,name) ==0){\n                return  current_table;\n            }\n    }\n    return NULL;\n}\n\nLuaCEmbedTable  *privateLuaCEmbedTableArray_find_by_internal_index(privateLuaCEmbedTableArray *self, long internal_index){\n    for(int i = 0; i < self->size;i++){\n        LuaCEmbedTable  *current_table = self->tables[i];\n        if(current_table->index == internal_index){\n            return current_table;\n        }\n    }\n    return NULL;\n}\n\nvoid  privateLuaCEmbedTableArray_free(privateLuaCEmbedTableArray *self){\n\n    for(int i = 0; i < self->size;i++){\n        LuaCEmbedTable  *current_table = self->tables[i];\n        privateLuaCEmbedTable_free(current_table);\n    }\n\n    free(self->tables);\n    free(self);\n}\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbed/table/table_array/table_array.h",
		"is_binary":	false,
		"content":	"\n\ntypedef struct {\n\n    LuaCEmbedTable **tables;\n    long size;\n\n}privateLuaCEmbedTableArray;\n\nprivateLuaCEmbedTableArray *newprivateLuaCEmbedTableArray();\n\nvoid privateLuaCEmbedTableArray_append(privateLuaCEmbedTableArray *self,LuaCEmbedTable *element);\n\nLuaCEmbedTable  *privateLuaCEmbedTableArray_find_by_global_name(privateLuaCEmbedTableArray *self, const char *name);\n\nLuaCEmbedTable  *privateLuaCEmbedTableArray_find_by_prop_name(privateLuaCEmbedTableArray *self, const char *name);\n\nLuaCEmbedTable  *privateLuaCEmbedTableArray_find_by_internal_index(privateLuaCEmbedTableArray *self, long internal_index);\n\nvoid  privateLuaCEmbedTableArray_free(privateLuaCEmbedTableArray *self);\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbedResponse/"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbedResponse/LuaCEmbedResponse.c",
		"is_binary":	false,
		"content":	"\n\n\nLuaCEmbedResponse *private_LuaCEmbedReturn_raw(){\n    LuaCEmbedResponse *self = (LuaCEmbedResponse*)malloc(sizeof(LuaCEmbedResponse));\n    *self = (LuaCEmbedResponse){0};\n    return self;\n}\n\nLuaCEmbedResponse  * LuaCEmbed_send_bool(bool value){\n    LuaCEmbedResponse * self= private_LuaCEmbedReturn_raw();\n    self->type = PRIVATE_LUA_CEMBED_BOOL_RESPONSE;\n    self->num_val = (double)value;\n    return self;\n}\n\n\nLuaCEmbedResponse * LuaCEmbed_send_str(const char *text){\n    LuaCEmbedResponse * self= private_LuaCEmbedReturn_raw();\n    self->type = PRIVATE_LUA_CEMBED_STRING_RESPONSE;\n    self->string_size = (long)strlen(text);\n    self->string_val  =  (char*)malloc(sizeof(char) * self->string_size +1);\n    memcpy(self->string_val,text,self->string_size);\n    self->string_val[self->string_size] = '\\0';\n    return self;\n}\n\nLuaCEmbedResponse * LuaCEmbed_send_raw_string(const char *text,long size){\n    LuaCEmbedResponse * self= private_LuaCEmbedReturn_raw();\n    self->type = PRIVATE_LUA_CEMBED_STRING_RESPONSE;\n    self->string_size = size;\n    self->string_val  =  (char*)malloc(sizeof(char) * self->string_size +1);\n    memcpy(self->string_val,text,self->string_size);\n    self->string_val[self->string_size] = '\\0';\n    return self;\n}\n\nLuaCEmbedResponse * LuaCEmbed_send_str_reference(const char *text){\n    LuaCEmbedResponse * self= private_LuaCEmbedReturn_raw();\n    self->type = PRIVATE_LUA_CEMBED_STRING_RESPONSE;\n    self->string_size = (long)strlen(text);\n    self->string_val  = (char*)text;\n    self->its_string_ref = true;\n    return self;\n}\n\nLuaCEmbedResponse * LuaCEmbed_send_raw_string_reference(const  char *text,long size){\n    LuaCEmbedResponse * self= private_LuaCEmbedReturn_raw();\n    self->type = PRIVATE_LUA_CEMBED_STRING_RESPONSE;\n    self->string_size = size;\n    self->string_val  = (char*)text;\n    self->its_string_ref = true;\n    return  self;\n}\n\n\n\nLuaCEmbedResponse * LuaCEmbed_send_error(const char *format,...){\n\n    va_list args;\n    va_start(args,format);\n    char *error = private_LuaCembed_format_vaarg(format,args);\n    va_end(args);\n\n    LuaCEmbedResponse * self= private_LuaCEmbedReturn_raw();\n    self->type = PRIVATE_LUA_CEMBED_ERROR_RESPONSE;\n    self->string_val  = error;\n    return self;\n}\n\n\nLuaCEmbedResponse * LuaCEmbed_send_multi_return(LuaCEmbedTable *table){\n    LuaCEmbedResponse * self= private_LuaCEmbedReturn_raw();\n    self->type = PRIVATE_LUA_CEMBED_MULTI_RESPONSE;\n    lua_getglobal(table->main_object->state,table->global_name);\n    lua_setglobal(table->main_object->state,PRIVATE_LUA_CEMBED_TABLE_RETURN);\n    return self;\n}\n\nLuaCEmbedResponse * LuaCEmbed_send_table(LuaCEmbedTable *table){\n    LuaCEmbedResponse * self= private_LuaCEmbedReturn_raw();\n    self->type = PRIVATE_LUA_CEMBED_TABLE_RESPONSE;\n    lua_getglobal(table->main_object->state,table->global_name);\n    lua_setglobal(table->main_object->state,PRIVATE_LUA_CEMBED_TABLE_RETURN);\n    return self;\n}\n\nLuaCEmbedResponse * LuaCEmbed_send_evaluation(const char *code){\n    LuaCEmbedResponse * self= private_LuaCEmbedReturn_raw();\n    self->type = PRIVATE_LUA_CEMBED_EVALUATION;\n    self->string_val  = strdup(code);\n    return self;\n}\n\nLuaCEmbedResponse  * LuaCEmbed_send_double(double value){\n    LuaCEmbedResponse * self= private_LuaCEmbedReturn_raw();\n    self->type = PRIVATE_LUA_CEMBED_DOUBLE_RESPONSE;\n    self->num_val = value;\n    return self;\n}\n\nLuaCEmbedResponse  * LuaCEmbed_send_long(long value){\n    LuaCEmbedResponse * self= private_LuaCEmbedReturn_raw();\n    self->type = PRIVATE_LUA_CEMBED_LONG_RESPONSE;\n    self->num_val = (double)value;\n    return self;\n}\n\n\n\nvoid private_LuaCEmbedResponse_free(LuaCEmbedResponse  *self){\n\n    if(self->string_val && self->its_string_ref == false){\n        free(self->string_val);\n    }\n    free(self);\n}\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbedResponse/LuaCEmbedResponse.h",
		"is_binary":	false,
		"content":	"\ntypedef struct {\n\n    int type;\n    double num_val;\n    bool its_string_ref;\n    long string_size;\n    char *string_val;\n\n}LuaCEmbedResponse;\n\nLuaCEmbedResponse *private_LuaCEmbedReturn_raw();\n\n\nLuaCEmbedResponse * LuaCEmbed_send_str(const char *text);\n\nLuaCEmbedResponse * LuaCEmbed_send_raw_string(const char *text,long size);\n\nLuaCEmbedResponse * LuaCEmbed_send_str_reference( const char *text);\n\nLuaCEmbedResponse * LuaCEmbed_send_raw_string_reference(const char *text,long size);\n\nLuaCEmbedResponse * LuaCEmbed_send_error(const char *format,...);\n\n\nLuaCEmbedResponse * LuaCEmbed_send_evaluation(const char *code);\n\n\n\n\n\nLuaCEmbedResponse  * LuaCEmbed_send_double(double value);\n\nLuaCEmbedResponse  * LuaCEmbed_send_bool(bool value);\n\n\nLuaCEmbedResponse  * LuaCEmbed_send_long(long value);\n\n\nvoid private_LuaCEmbedResponse_free(LuaCEmbedResponse  *self);\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/LuaCEmbedResponse/LuaCembedResponse_pt2.h",
		"is_binary":	false,
		"content":	"\n\nLuaCEmbedResponse * LuaCEmbed_send_table(LuaCEmbedTable *table);\n\n\nLuaCEmbedResponse * LuaCEmbed_send_multi_return(LuaCEmbedTable *table);\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/constants/"
	}, {
		"path":	"src/dependencies/luaCEmbed/constants/all.h",
		"is_binary":	false,
		"content":	"#include \"main_callback.h\"\n#include \"types.h\"\n#include \"responses.h\"\n#include \"lua_code.h\"\n#include \"errors.h\"\n#include \"aplication.h\"\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/constants/aplication.h",
		"is_binary":	false,
		"content":	"#ifndef LUA_CEMBED_INDEX_DIF\n#define LUA_CEMBED_INDEX_DIF 1\n#endif\n\n#define PRIVATE_LUA_EMBED_FILE_EVALUATION_TYPE 1\n#define PRIVATE_LUA_EMBED_STRING_EVALUATION_TYPE 2\n#define LUA_CEMBED_DEFAULT_TIMEOUT 10\n#define LUA_CEMBED_DEFAULT_MEMORY_LIMIT 100\n\n#define PRIVATE_LUA_CEMBED_ONE_MB (1024 * 1024)\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/constants/errors.h",
		"is_binary":	false,
		"content":	"\n\n#define  PRIVATE_LUA_CEMBED_TIMEOUT_ERROR \"timeout error\"\n#define PRIVATE_LUA_CEMBED_ARG_NOT_PROVIDED \"arg %ld at function:%s not provided\"\n#define PRIVATE_LUA_CEMBED_ARG_WRONG_TYPE \"arg %d at function:%s its %s instead of  %s\"\n#define PRIVATE_LUA_CEMBED_GLOBAL_WRONG_TYPE \"global variable:%s its %s instead of %s\"\n#define PRIVATE_LUA_CEMBED_RESULT_EVALUATION_WRONG_TYPE \"result evaluation its:%s instead of %s\"\n#define PRIVATE_LUA_CEMBED_RESULT_EVALUATION_ARG_WRONG_TYPE \"result evaluation of function %s at index %d its:%s instead of %s\"\n\n#define PRIVATE_LUA_CEMBED_CODE_ITS_NOT_A_FUNCTION \"value %s its not a function\"\n#define PRIVATE_LUA_CEMBED_WRONG_TYPE_PROPETY \"propety %s at object %s its %s instead of %s\"\n#define PRIVATE_LUA_CEMBED_WRONG_TYPE_INDEX \"index %d at object %s its %s instead of %s\"\n#define PRIVATE_LUA_CEMBED_ELEMENT_DOES_NOT_HAVE_KEY \"index %d at object %s not have a key\"\n#define PRIVVATE_LUA_CEMBED_TIMEOUT_ERROR \"timeout error\"\n#define PRIVATE_LUA_CEMBED_LIB_PROP_WRONG_TYPE \"lib prop %s its %s insteadd of %s\""
	}, {
		"path":	"src/dependencies/luaCEmbed/constants/lua_code.h",
		"is_binary":	false,
		"content":	"\n#define PRIVATE_LUA_CEMBED_TOTAL_LIBS \"private_lua_c_embed_total_running_libs\"\n#define PRIVATE_LUA_CEMBED_STACK_LEVEL \"private_lua_c_embed_stack_level\"\n\n#define PRIVATE_LUA_CEMBED_EVALUATION_NAME \"private_lua_c_embed_evaluation\"\n#define PRIVATE_LUA_CEMBED_DEL_PREFIX \"__gc\"\n#define  PRIVATE_LUA_CEMBED_GLOBAL_EVALUATION_CODE \"%s = %s\\n\"\n\n\n\n\n#define PRIVATE_LUA_CEMBED_SELFNAME \"private_lua_c_embed_self\"\n#define PRIVATE_LUA_CEMBED_STAGE_AREA_TABLE \"private_lua_c_embed_stage_area_table\"\n#define PRIVATE_LUA_CEMBED_TABLE_RETURN \"private_lua_embed_table_return\"\n\n#define PRIVATE_LUA_CEMBED_MAIN_LIB_TABLE_NAME__ \"private_lua_c_embed_main_lib_table_%d\"\n#define PRIVATE_LUA_CEMBED_MAIN_LIB_SUB_TABLE \"private_lua_c_embed_main_lib_table_%d_%s\"\n\n#define PRIVATE_LUA_CEMBED_MAIN_META_TABLE__ \"private_lua_c_embed_main_meta_table_%d\"\n#define PRIVATE_LUA_CEMBED_ANONYMOUS_TABLE_ \"private_lua_c_embed_anononymous_table_%d_%d\"\n#define PRIVATE_LUA_CEMBED_ANONYMOUS_FUNC_TABLE_ \"private_lua_c_embed_anononymous_func_table_%d_%d\"\n#define PRIVATE_LUA_CEMBED_ARGS_ \"private_lua_c_embed_args_%d_%d\"\n#define  PRIVATE_LUA_CEMBED_MULTIRETURN_ \"private_lua_c_embed_multi_return_%d_%d\""
	}, {
		"path":	"src/dependencies/luaCEmbed/constants/main_callback.h",
		"is_binary":	false,
		"content":	"\n#define PRIVATE_LUACEMBED_NO_RETURN 0\n#define PRIVATE_LUACEMBED_ONE_RETURN 1\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/constants/responses.h",
		"is_binary":	false,
		"content":	"#define PRIVATE_LUA_CEMBED_STRING_RESPONSE 1\n#define PRIVATE_LUA_CEMBED_LONG_RESPONSE 2\n#define PRIVATE_LUA_CEMBED_DOUBLE_RESPONSE 3\n#define PRIVATE_LUA_CEMBED_BOOL_RESPONSE 4\n#define PRIVATE_LUA_CEMBED_TABLE_RESPONSE 5\n\n#define PRIVATE_LUA_CEMBED_EVALUATION 6\n#define PRIVATE_LUA_CEMBED_ERROR_RESPONSE 7\n#define PRIVATE_LUA_CEMBED_MULTI_RESPONSE 8\n\n#define LUA_CEMBED_OK 0\n#define LUA_CEMBED_GENERIC_ERROR (-1)"
	}, {
		"path":	"src/dependencies/luaCEmbed/constants/types.h",
		"is_binary":	false,
		"content":	"#define LUA_CEMBED_NOT_FOUND LUA_TNONE\n#define LUA_CEMBED_STRING LUA_TSTRING\n#define LUA_CEMBED_NUMBER LUA_TNUMBER\n#define LUA_CEMBED_BOOL LUA_TBOOLEAN\n#define LUA_CEMBED_NIL LUA_TNIL\n#define LUA_CEMBED_FUNCTION LUA_TFUNCTION\n#define LUA_CEMBED_TABLE LUA_TTABLE\n\n#define PRIVATE_LUA_CEMBED_NOT_FOUND_STRING \"not Found\"\n#define PRIVATE_LUA_CEMBED_STRING_STRING \"string\"\n#define PRIVATE_LUA_CEMBED_NUMBER_STRING \"number\"\n#define PRIVATE_LUA_CEMBED_BOOL_STRING \"boolean\"\n#define PRIVATE_LUA_CEMBED_NIL_STRING \"nil\"\n#define PRIVATE_LUA_CEMBED_TABLE_STRING \"table\"\n#define PRIVATE_LUA_CEMBED_FUNCTION_STRING \"function\"\n\n#define PRIVATE_LUA_CEMBED_UNKNOW_STRING \"unknow\""
	}, {
		"path":	"src/dependencies/luaCEmbed/declaration.h",
		"is_binary":	false,
		"content":	"#ifdef _WIN32\n#include <windows.h>\n#else\n#include <signal.h>\n#include <unistd.h>\n#endif\n\n#include <setjmp.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdbool.h>\n#include \"dependencies/dependencies.h\"\n#include \"constants/all.h\"\n#include \"LuaCEmbedResponse/LuaCEmbedResponse.h\"\n#include \"LuaCEmbed/declaration.h\"\n#include \"LuaCEmbedResponse/LuaCembedResponse_pt2.h\"\n\n#include \"extra/extra.h\"\n#include \"namespace/declaration.h\""
	}, {
		"path":	"src/dependencies/luaCEmbed/definition.h",
		"is_binary":	false,
		"content":	"#include \"LuaCEmbedResponse/LuaCEmbedResponse.c\"\n#include \"LuaCEmbed/definition.h\"\n#include \"extra/extra.c\"\n#include \"namespace/definition.h\""
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/UniversalGarbage.h",
		"is_binary":	false,
		"content":	"\n\n\n#ifndef UNIVERSAL_GARBAGE_H\n\n\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n\n\n\n\n#define UniversalGarbage_create_empty_struct(name,element_type) \\\n(element_type*)malloc(sizeof(element_type));    \\\n*name = (element_type){0};\n\n\n#define UniversalGarbage_cast(value) ((void**)&value)\n\n\n#define UniversalGarbage_add(garbage,deallocator_callback,value) \\\n    rawUniversalGarbage_add(garbage,(void*)deallocator_callback,UniversalGarbage_cast(value))\n\n#define UniversalGarbage_add_simple(garbage,value) \\\n     UniversalGarbage_add(garbage,free,value)\n\n\n#define UniversalGarbage_add_return(garbage,deallocator_callback,value) \\\n        UniversalGarbage_add(garbage->return_values,deallocator_callback,value)\n\n\n#define UniversalGarbage_add_simple_return(garbage,value) \\\n    UniversalGarbage_add_simple(garbage->return_values,value)\n\n\n\n#define  UniversalGarbage_remove(garbage,value) \\\n    rawUniversalGarbage_remove(garbage,UniversalGarbage_cast(value));\n\n\n#define  UniversalGarbage_disconnect(garbage,value) \\\n    rawUniversalGarbage_disconnect(garbage,UniversalGarbage_cast(value));\n\n\n\n\n#define UniversalGarbage_reallocate(garbage,value) \\\n    rawUniversalGarbage_reallocate(garbage,UniversalGarbage_cast(value))\n\n\n#define UniversalGarbage_resset(garbage,value) \\\n    rawUniversalGarbage_resset(garbage,UniversalGarbage_cast(value))\n\n\n\n\n\n\ntypedef struct privateUniversalGarbageElement{\n    void **pointer;\n    void (*deallocator_callback)(void *element);\n    void *pointed_value;\n}privateUniversalGarbageElement;\n\nvoid private_UniversalGarbageSimpleElement_free_pointed_value(privateUniversalGarbageElement *self);\n\n\nvoid private_UniversalGarbageSimpleElement_free(privateUniversalGarbageElement *self);\n\nprivateUniversalGarbageElement * private_newUniversalGarbageSimpleElement(void (*dealocator_callback)(void *element), void **pointer);\n\n\n\ntypedef  struct UniversalGarbage{\n\n    struct UniversalGarbage *return_values;\n    privateUniversalGarbageElement **elements;\n    int  elements_size;\n    bool is_the_root;\n\n}UniversalGarbage;\n\nUniversalGarbage * newUniversalGarbage();\n\nUniversalGarbage * private_new_MainUniversalGarbage();\n\n\n\nbool  rawUniversalGarbage_resset(UniversalGarbage *self, void **pointer);\n\nbool  rawUniversalGarbage_remove(UniversalGarbage *self, void **pointer);\n\nbool  rawUniversalGarbage_disconnect(UniversalGarbage *self, void **pointer);\n\nbool rawUniversalGarbage_reallocate(UniversalGarbage *self, void **pointer);\n\nbool  rawUniversalGarbage_add(UniversalGarbage *self,  void *release_callback, void **pointer);\n\nvoid private_UniversalGarbage_free_all_sub_elements(UniversalGarbage *self);\n\nvoid UniversalGarbage_free_including_return(UniversalGarbage *self);\n\nvoid UniversalGarbage_free(UniversalGarbage *self);\n\n\n\n\n\n\n\nprivateUniversalGarbageElement * private_newUniversalGarbageSimpleElement(void (*dealocator_callback)(void *element), void **pointer){\n\n    privateUniversalGarbageElement * self = UniversalGarbage_create_empty_struct(\n            self,\n            privateUniversalGarbageElement\n    );\n    self->pointer = pointer;\n    self->deallocator_callback = dealocator_callback;\n    self->pointed_value = *pointer;\n    return  self;\n}\nvoid private_UniversalGarbageSimpleElement_free_pointed_value(privateUniversalGarbageElement *self){\n    if(self->pointed_value){\n        self->deallocator_callback(self->pointed_value);\n        self->pointed_value = NULL;\n    }\n}\n\nvoid private_UniversalGarbageSimpleElement_free(privateUniversalGarbageElement *self){\n    private_UniversalGarbageSimpleElement_free_pointed_value(self);\n    free(self);\n}\n\n\nUniversalGarbage * private_new_MainUniversalGarbage(){\n    UniversalGarbage *self = UniversalGarbage_create_empty_struct(self,UniversalGarbage)\n    self->elements = (privateUniversalGarbageElement**)malloc(0);\n    self->is_the_root = false;\n    return self;\n}\n\nUniversalGarbage * newUniversalGarbage(){\n    UniversalGarbage *self = UniversalGarbage_create_empty_struct(self,UniversalGarbage)\n    self->is_the_root = true;\n    self->elements = (privateUniversalGarbageElement**)malloc(0);\n    self->return_values =private_new_MainUniversalGarbage();\n\n    return self;\n}\n\n\n\n\nbool  rawUniversalGarbage_reallocate(UniversalGarbage *self, void **pointer){\n\n    if(self->is_the_root){\n\n        if(rawUniversalGarbage_reallocate(self->return_values,pointer)){\n            return true;\n        }\n    }\n\n\n    for(int i = 0; i < self->elements_size; i++){\n\n        privateUniversalGarbageElement *current = self->elements[i];\n        bool reallocate = current->pointer == pointer;\n\n        if(reallocate){\n            current->pointed_value = *pointer;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool rawUniversalGarbage_resset(UniversalGarbage *self, void **pointer){\n\n    if(self->is_the_root){\n        if(rawUniversalGarbage_resset(self->return_values,pointer)){\n            return true;\n        }\n    }\n\n\n    for(int i = 0; i < self->elements_size; i++){\n        privateUniversalGarbageElement *current = self->elements[i];\n        bool resset = current->pointer == pointer;\n        if(resset){\n            private_UniversalGarbageSimpleElement_free_pointed_value(current);\n            current->pointed_value = *pointer;\n            return true;\n        }\n    }\n    return  false;\n\n}\nbool  rawUniversalGarbage_remove(UniversalGarbage *self, void **pointer){\n    if(self->is_the_root){\n        if(rawUniversalGarbage_remove(self->return_values,pointer)){\n            *pointer = NULL;\n            return true;\n        }\n    }\n\n    for(int i = 0; i < self->elements_size; i++){\n        privateUniversalGarbageElement *current = self->elements[i];\n        if(current->pointer == pointer){\n            private_UniversalGarbageSimpleElement_free(current);\n            self->elements_size-=1;\n            bool its_not_the_last = i < self->elements_size;\n            if(its_not_the_last){\n                self->elements[i] = self->elements[self->elements_size];\n\n            }\n            *pointer = NULL;\n            return  true;\n        }\n    }\n    return  false;\n}\nbool  rawUniversalGarbage_disconnect(UniversalGarbage *self, void **pointer){\n    if(self->is_the_root){\n        if(rawUniversalGarbage_disconnect(self->return_values,pointer)){\n            return true;\n        }\n    }\n\n    for(int i = 0; i < self->elements_size; i++){\n        privateUniversalGarbageElement *current = self->elements[i];\n        if(current->pointer == pointer){\n            free(current);\n            self->elements_size-=1;\n            bool its_not_the_last = i < self->elements_size;\n            if(its_not_the_last){\n                self->elements[i] = self->elements[self->elements_size];\n            }\n            return true;\n        }\n    }\n    return  false;\n\n\n\n}\nbool  rawUniversalGarbage_add(UniversalGarbage *self, void *release_callback, void **pointer){\n\n    if(!pointer){\n        return false;\n    }\n\n\n    for(int i = 0; i < self->elements_size; i++){\n        privateUniversalGarbageElement *current = self->elements[i];\n        if(current->pointer == pointer){\n            return false;\n        }\n    }\n\n    self->elements = (privateUniversalGarbageElement**)realloc(\n            self->elements,\n            (self->elements_size + 1) * sizeof(privateUniversalGarbageElement*)\n    );\n    void (*dealocator_callback)(void *element);\n#ifdef __cplusplus\n    dealocator_callback =reinterpret_cast<void(*)(void*)>(release_callback);\n#else\n    dealocator_callback = (void*)(void*)release_callback;\n\n#endif\n\n\n\n    self->elements[self->elements_size] = private_newUniversalGarbageSimpleElement(dealocator_callback, pointer);\n    self->elements_size+=1;\n    return  true;\n}\n\n\n\nvoid  private_UniversalGarbage_free_all_sub_elements(UniversalGarbage *self){\n    for(int i = 0; i < self->elements_size; i++){\n        private_UniversalGarbageSimpleElement_free(self->elements[i]);\n    }\n    free(self->elements);\n}\n\nvoid UniversalGarbage_free_including_return(UniversalGarbage *self){\n    private_UniversalGarbage_free_all_sub_elements(self);\n    if(self->is_the_root){\n        UniversalGarbage_free(self->return_values);\n    }\n    free(self);\n}\n\nvoid UniversalGarbage_free(UniversalGarbage *self){\n    private_UniversalGarbage_free_all_sub_elements(self);\n\n    if(self->is_the_root){\n\n        UniversalGarbage *return_garbage = self->return_values;\n        for(int i = 0; i < return_garbage->elements_size; i++){\n            free(return_garbage->elements[i]);\n        }\n\n        free(return_garbage->elements);\n        free(return_garbage);\n    }\n\n\n    free(self);\n}\n\n\n\n\n#define UNIVERSAL_GARBAGE_H\n#endif"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/dependencies.h",
		"is_binary":	false,
		"content":	"#include \"UniversalGarbage.h\"\n#include \"lua/onelua.c\"\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/custom_math/"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/custom_math/custom_math.c",
		"is_binary":	false,
		"content":	"double private_lua_embed_fmod(double x, double y) {\n    while (y != 0.0) {\n        while (x >= y) {\n            x -= y;\n        }\n        if (x < y) {\n            return x;\n        }\n    }\n    return 0.0 / 0.0;\n}\n\ndouble private_lua_embed_pow(double b, double e) {\n    double resultado = 1.0;\n    int i;\n\n    if (e == 0.0) {\n        return 1.0;\n    }\n    if (e < 0.0) {\n        b = 1.0 / b;\n        e = -e;\n    }\n\n    for (i = 0; i < e; i++) {\n        resultado *= b;\n    }\n\n    return resultado;\n}\n\ndouble private_lua_embed_floor(double x) {\n    int i = (int)x;\n\n    if (x == (double)i) {\n        return x;\n    }\n\n    if (x < 0.0) {\n        return (double)(i - 1);\n    }\n\n    return (double)i;\n}"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/custom_math/custom_math.h",
		"is_binary":	false,
		"content":	"\ndouble private_lua_embed_fmod(double x, double y);\n\n// Implementao simples da funo pow\ndouble private_lua_embed_pow(double b, double e);\n\n// Implementao simples da funo floor\ndouble private_lua_embed_floor(double x);"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lapi.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: lapi.c $\n** Lua API\n** See Copyright Notice in lua.h\n*/\n\n#define lapi_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <limits.h>\n#include <stdarg.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lapi.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n#include \"lundump.h\"\n#include \"lvm.h\"\n\n\n\nconst char lua_ident[] =\n  \"$LuaVersion: \" LUA_COPYRIGHT \" $\"\n  \"$LuaAuthors: \" LUA_AUTHORS \" $\";\n\n\n\n/*\n** Test for a valid index (one that is not the 'nilvalue').\n** '!ttisnil(o)' implies 'o != &G(L)->nilvalue', so it is not needed.\n** However, it covers the most common cases in a faster way.\n*/\n#define isvalid(L, o)\t(!ttisnil(o) || o != &G(L)->nilvalue)\n\n\n/* test for pseudo index */\n#define ispseudo(i)\t\t((i) <= LUA_REGISTRYINDEX)\n\n/* test for upvalue */\n#define isupvalue(i)\t\t((i) < LUA_REGISTRYINDEX)\n\n\n/* Advance the garbage collector when creating large objects */\nstatic void advancegc (lua_State *L, size_t delta) {\n  delta >>= 5;  /* one object for each 32 bytes (empirical) */\n  if (delta > 0) {\n    global_State *g = G(L);\n    luaE_setdebt(g, g->GCdebt - delta);\n  }\n}\n\n\n/*\n** Convert an acceptable index to a pointer to its respective value.\n** Non-valid indices return the special nil value 'G(L)->nilvalue'.\n*/\nstatic TValue *index2value (lua_State *L, int idx) {\n  CallInfo *ci = L->ci;\n  if (idx > 0) {\n    StkId o = ci->func.p + idx;\n    api_check(L, idx <= ci->top.p - (ci->func.p + 1), \"unacceptable index\");\n    if (o >= L->top.p) return &G(L)->nilvalue;\n    else return s2v(o);\n  }\n  else if (!ispseudo(idx)) {  /* negative index */\n    api_check(L, idx != 0 && -idx <= L->top.p - (ci->func.p + 1),\n                 \"invalid index\");\n    return s2v(L->top.p + idx);\n  }\n  else if (idx == LUA_REGISTRYINDEX)\n    return &G(L)->l_registry;\n  else {  /* upvalues */\n    idx = LUA_REGISTRYINDEX - idx;\n    api_check(L, idx <= MAXUPVAL + 1, \"upvalue index too large\");\n    if (ttisCclosure(s2v(ci->func.p))) {  /* C closure? */\n      CClosure *func = clCvalue(s2v(ci->func.p));\n      return (idx <= func->nupvalues) ? &func->upvalue[idx-1]\n                                      : &G(L)->nilvalue;\n    }\n    else {  /* light C function or Lua function (through a hook)?) */\n      api_check(L, ttislcf(s2v(ci->func.p)), \"caller not a C function\");\n      return &G(L)->nilvalue;  /* no upvalues */\n    }\n  }\n}\n\n\n\n/*\n** Convert a valid actual index (not a pseudo-index) to its address.\n*/\nstatic StkId index2stack (lua_State *L, int idx) {\n  CallInfo *ci = L->ci;\n  if (idx > 0) {\n    StkId o = ci->func.p + idx;\n    api_check(L, o < L->top.p, \"invalid index\");\n    return o;\n  }\n  else {    /* non-positive index */\n    api_check(L, idx != 0 && -idx <= L->top.p - (ci->func.p + 1),\n                 \"invalid index\");\n    api_check(L, !ispseudo(idx), \"invalid index\");\n    return L->top.p + idx;\n  }\n}\n\n\nLUA_API int lua_checkstack (lua_State *L, int n) {\n  int res;\n  CallInfo *ci;\n  lua_lock(L);\n  ci = L->ci;\n  api_check(L, n >= 0, \"negative 'n'\");\n  if (L->stack_last.p - L->top.p > n)  /* stack large enough? */\n    res = 1;  /* yes; check is OK */\n  else  /* need to grow stack */\n    res = luaD_growstack(L, n, 0);\n  if (res && ci->top.p < L->top.p + n)\n    ci->top.p = L->top.p + n;  /* adjust frame top */\n  lua_unlock(L);\n  return res;\n}\n\n\nLUA_API void lua_xmove (lua_State *from, lua_State *to, int n) {\n  int i;\n  if (from == to) return;\n  lua_lock(to);\n  api_checkpop(from, n);\n  api_check(from, G(from) == G(to), \"moving among independent states\");\n  api_check(from, to->ci->top.p - to->top.p >= n, \"stack overflow\");\n  from->top.p -= n;\n  for (i = 0; i < n; i++) {\n    setobjs2s(to, to->top.p, from->top.p + i);\n    to->top.p++;  /* stack already checked by previous 'api_check' */\n  }\n  lua_unlock(to);\n}\n\n\nLUA_API lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf) {\n  lua_CFunction old;\n  lua_lock(L);\n  old = G(L)->panic;\n  G(L)->panic = panicf;\n  lua_unlock(L);\n  return old;\n}\n\n\nLUA_API lua_Number lua_version (lua_State *L) {\n  UNUSED(L);\n  return LUA_VERSION_NUM;\n}\n\n\n\n/*\n** basic stack manipulation\n*/\n\n\n/*\n** convert an acceptable stack index into an absolute index\n*/\nLUA_API int lua_absindex (lua_State *L, int idx) {\n  return (idx > 0 || ispseudo(idx))\n         ? idx\n         : cast_int(L->top.p - L->ci->func.p) + idx;\n}\n\n\nLUA_API int lua_gettop (lua_State *L) {\n  return cast_int(L->top.p - (L->ci->func.p + 1));\n}\n\n\nLUA_API void lua_settop (lua_State *L, int idx) {\n  CallInfo *ci;\n  StkId func, newtop;\n  ptrdiff_t diff;  /* difference for new top */\n  lua_lock(L);\n  ci = L->ci;\n  func = ci->func.p;\n  if (idx >= 0) {\n    api_check(L, idx <= ci->top.p - (func + 1), \"new top too large\");\n    diff = ((func + 1) + idx) - L->top.p;\n    for (; diff > 0; diff--)\n      setnilvalue(s2v(L->top.p++));  /* clear new slots */\n  }\n  else {\n    api_check(L, -(idx+1) <= (L->top.p - (func + 1)), \"invalid new top\");\n    diff = idx + 1;  /* will \"subtract\" index (as it is negative) */\n  }\n  newtop = L->top.p + diff;\n  if (diff < 0 && L->tbclist.p >= newtop) {\n    lua_assert(hastocloseCfunc(ci->nresults));\n    newtop = luaF_close(L, newtop, CLOSEKTOP, 0);\n  }\n  L->top.p = newtop;  /* correct top only after closing any upvalue */\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_closeslot (lua_State *L, int idx) {\n  StkId level;\n  lua_lock(L);\n  level = index2stack(L, idx);\n  api_check(L, hastocloseCfunc(L->ci->nresults) && L->tbclist.p == level,\n     \"no variable to close at given level\");\n  level = luaF_close(L, level, CLOSEKTOP, 0);\n  setnilvalue(s2v(level));\n  lua_unlock(L);\n}\n\n\n/*\n** Reverse the stack segment from 'from' to 'to'\n** (auxiliary to 'lua_rotate')\n** Note that we move(copy) only the value inside the stack.\n** (We do not move additional fields that may exist.)\n*/\nstatic void reverse (lua_State *L, StkId from, StkId to) {\n  for (; from < to; from++, to--) {\n    TValue temp;\n    setobj(L, &temp, s2v(from));\n    setobjs2s(L, from, to);\n    setobj2s(L, to, &temp);\n  }\n}\n\n\n/*\n** Let x = AB, where A is a prefix of length 'n'. Then,\n** rotate x n == BA. But BA == (A^r . B^r)^r.\n*/\nLUA_API void lua_rotate (lua_State *L, int idx, int n) {\n  StkId p, t, m;\n  lua_lock(L);\n  t = L->top.p - 1;  /* end of stack segment being rotated */\n  p = index2stack(L, idx);  /* start of segment */\n  api_check(L, L->tbclist.p < p, \"moving a to-be-closed slot\");\n  api_check(L, (n >= 0 ? n : -n) <= (t - p + 1), \"invalid 'n'\");\n  m = (n >= 0 ? t - n : p - n - 1);  /* end of prefix */\n  reverse(L, p, m);  /* reverse the prefix with length 'n' */\n  reverse(L, m + 1, t);  /* reverse the suffix */\n  reverse(L, p, t);  /* reverse the entire segment */\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_copy (lua_State *L, int fromidx, int toidx) {\n  TValue *fr, *to;\n  lua_lock(L);\n  fr = index2value(L, fromidx);\n  to = index2value(L, toidx);\n  api_check(L, isvalid(L, to), \"invalid index\");\n  setobj(L, to, fr);\n  if (isupvalue(toidx))  /* function upvalue? */\n    luaC_barrier(L, clCvalue(s2v(L->ci->func.p)), fr);\n  /* LUA_REGISTRYINDEX does not need gc barrier\n     (collector revisits it before finishing collection) */\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushvalue (lua_State *L, int idx) {\n  lua_lock(L);\n  setobj2s(L, L->top.p, index2value(L, idx));\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\n\n/*\n** access functions (stack -> C)\n*/\n\n\nLUA_API int lua_type (lua_State *L, int idx) {\n  const TValue *o = index2value(L, idx);\n  return (isvalid(L, o) ? ttype(o) : LUA_TNONE);\n}\n\n\nLUA_API const char *lua_typename (lua_State *L, int t) {\n  UNUSED(L);\n  api_check(L, LUA_TNONE <= t && t < LUA_NUMTYPES, \"invalid type\");\n  return ttypename(t);\n}\n\n\nLUA_API int lua_iscfunction (lua_State *L, int idx) {\n  const TValue *o = index2value(L, idx);\n  return (ttislcf(o) || (ttisCclosure(o)));\n}\n\n\nLUA_API int lua_isinteger (lua_State *L, int idx) {\n  const TValue *o = index2value(L, idx);\n  return ttisinteger(o);\n}\n\n\nLUA_API int lua_isnumber (lua_State *L, int idx) {\n  lua_Number n;\n  const TValue *o = index2value(L, idx);\n  return tonumber(o, &n);\n}\n\n\nLUA_API int lua_isstring (lua_State *L, int idx) {\n  const TValue *o = index2value(L, idx);\n  return (ttisstring(o) || cvt2str(o));\n}\n\n\nLUA_API int lua_isuserdata (lua_State *L, int idx) {\n  const TValue *o = index2value(L, idx);\n  return (ttisfulluserdata(o) || ttislightuserdata(o));\n}\n\n\nLUA_API int lua_rawequal (lua_State *L, int index1, int index2) {\n  const TValue *o1 = index2value(L, index1);\n  const TValue *o2 = index2value(L, index2);\n  return (isvalid(L, o1) && isvalid(L, o2)) ? luaV_rawequalobj(o1, o2) : 0;\n}\n\n\nLUA_API void lua_arith (lua_State *L, int op) {\n  lua_lock(L);\n  if (op != LUA_OPUNM && op != LUA_OPBNOT)\n    api_checkpop(L, 2);  /* all other operations expect two operands */\n  else {  /* for unary operations, add fake 2nd operand */\n    api_checkpop(L, 1);\n    setobjs2s(L, L->top.p, L->top.p - 1);\n    api_incr_top(L);\n  }\n  /* first operand at top - 2, second at top - 1; result go to top - 2 */\n  luaO_arith(L, op, s2v(L->top.p - 2), s2v(L->top.p - 1), L->top.p - 2);\n  L->top.p--;  /* pop second operand */\n  lua_unlock(L);\n}\n\n\nLUA_API int lua_compare (lua_State *L, int index1, int index2, int op) {\n  const TValue *o1;\n  const TValue *o2;\n  int i = 0;\n  lua_lock(L);  /* may call tag method */\n  o1 = index2value(L, index1);\n  o2 = index2value(L, index2);\n  if (isvalid(L, o1) && isvalid(L, o2)) {\n    switch (op) {\n      case LUA_OPEQ: i = luaV_equalobj(L, o1, o2); break;\n      case LUA_OPLT: i = luaV_lessthan(L, o1, o2); break;\n      case LUA_OPLE: i = luaV_lessequal(L, o1, o2); break;\n      default: api_check(L, 0, \"invalid option\");\n    }\n  }\n  lua_unlock(L);\n  return i;\n}\n\n\nLUA_API size_t lua_stringtonumber (lua_State *L, const char *s) {\n  size_t sz = luaO_str2num(s, s2v(L->top.p));\n  if (sz != 0)\n    api_incr_top(L);\n  return sz;\n}\n\n\nLUA_API lua_Number lua_tonumberx (lua_State *L, int idx, int *pisnum) {\n  lua_Number n = 0;\n  const TValue *o = index2value(L, idx);\n  int isnum = tonumber(o, &n);\n  if (pisnum)\n    *pisnum = isnum;\n  return n;\n}\n\n\nLUA_API lua_Integer lua_tointegerx (lua_State *L, int idx, int *pisnum) {\n  lua_Integer res = 0;\n  const TValue *o = index2value(L, idx);\n  int isnum = tointeger(o, &res);\n  if (pisnum)\n    *pisnum = isnum;\n  return res;\n}\n\n\nLUA_API int lua_toboolean (lua_State *L, int idx) {\n  const TValue *o = index2value(L, idx);\n  return !l_isfalse(o);\n}\n\n\nLUA_API const char *lua_tolstring (lua_State *L, int idx, size_t *len) {\n  TValue *o;\n  lua_lock(L);\n  o = index2value(L, idx);\n  if (!ttisstring(o)) {\n    if (!cvt2str(o)) {  /* not convertible? */\n      if (len != NULL) *len = 0;\n      lua_unlock(L);\n      return NULL;\n    }\n    luaO_tostring(L, o);\n    luaC_checkGC(L);\n    o = index2value(L, idx);  /* previous call may reallocate the stack */\n  }\n  lua_unlock(L);\n  if (len != NULL)\n    return getlstr(tsvalue(o), *len);\n  else\n    return getstr(tsvalue(o));\n}\n\n\nLUA_API lua_Unsigned lua_rawlen (lua_State *L, int idx) {\n  const TValue *o = index2value(L, idx);\n  switch (ttypetag(o)) {\n    case LUA_VSHRSTR: return tsvalue(o)->shrlen;\n    case LUA_VLNGSTR: return tsvalue(o)->u.lnglen;\n    case LUA_VUSERDATA: return uvalue(o)->len;\n    case LUA_VTABLE: return luaH_getn(hvalue(o));\n    default: return 0;\n  }\n}\n\n\nLUA_API lua_CFunction lua_tocfunction (lua_State *L, int idx) {\n  const TValue *o = index2value(L, idx);\n  if (ttislcf(o)) return fvalue(o);\n  else if (ttisCclosure(o))\n    return clCvalue(o)->f;\n  else return NULL;  /* not a C function */\n}\n\n\nl_sinline void *touserdata (const TValue *o) {\n  switch (ttype(o)) {\n    case LUA_TUSERDATA: return getudatamem(uvalue(o));\n    case LUA_TLIGHTUSERDATA: return pvalue(o);\n    default: return NULL;\n  }\n}\n\n\nLUA_API void *lua_touserdata (lua_State *L, int idx) {\n  const TValue *o = index2value(L, idx);\n  return touserdata(o);\n}\n\n\nLUA_API lua_State *lua_tothread (lua_State *L, int idx) {\n  const TValue *o = index2value(L, idx);\n  return (!ttisthread(o)) ? NULL : thvalue(o);\n}\n\n\n/*\n** Returns a pointer to the internal representation of an object.\n** Note that ANSI C does not allow the conversion of a pointer to\n** function to a 'void*', so the conversion here goes through\n** a 'size_t'. (As the returned pointer is only informative, this\n** conversion should not be a problem.)\n*/\nLUA_API const void *lua_topointer (lua_State *L, int idx) {\n  const TValue *o = index2value(L, idx);\n  switch (ttypetag(o)) {\n    case LUA_VLCF: return cast_voidp(cast_sizet(fvalue(o)));\n    case LUA_VUSERDATA: case LUA_VLIGHTUSERDATA:\n      return touserdata(o);\n    default: {\n      if (iscollectable(o))\n        return gcvalue(o);\n      else\n        return NULL;\n    }\n  }\n}\n\n\n\n/*\n** push functions (C -> stack)\n*/\n\n\nLUA_API void lua_pushnil (lua_State *L) {\n  lua_lock(L);\n  setnilvalue(s2v(L->top.p));\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushnumber (lua_State *L, lua_Number n) {\n  lua_lock(L);\n  setfltvalue(s2v(L->top.p), n);\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushinteger (lua_State *L, lua_Integer n) {\n  lua_lock(L);\n  setivalue(s2v(L->top.p), n);\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\n/*\n** Pushes on the stack a string with given length. Avoid using 's' when\n** 'len' == 0 (as 's' can be NULL in that case), due to later use of\n** 'memcmp' and 'memcpy'.\n*/\nLUA_API const char *lua_pushlstring (lua_State *L, const char *s, size_t len) {\n  TString *ts;\n  lua_lock(L);\n  ts = (len == 0) ? luaS_new(L, \"\") : luaS_newlstr(L, s, len);\n  setsvalue2s(L, L->top.p, ts);\n  api_incr_top(L);\n  advancegc(L, len);\n  luaC_checkGC(L);\n  lua_unlock(L);\n  return getstr(ts);\n}\n\n\nLUA_API const char *lua_pushextlstring (lua_State *L,\n\t        const char *s, size_t len, lua_Alloc falloc, void *ud) {\n  TString *ts;\n  lua_lock(L);\n  api_check(L, s[len] == '\\0', \"string not ending with zero\");\n  ts = luaS_newextlstr (L, s, len, falloc, ud);\n  setsvalue2s(L, L->top.p, ts);\n  api_incr_top(L);\n  if (falloc != NULL)  /* non-static string? */\n    advancegc(L, len);  /* count its memory */\n  luaC_checkGC(L);\n  lua_unlock(L);\n  return getstr(ts);\n}\n\n\nLUA_API const char *lua_pushstring (lua_State *L, const char *s) {\n  lua_lock(L);\n  if (s == NULL)\n    setnilvalue(s2v(L->top.p));\n  else {\n    TString *ts;\n    ts = luaS_new(L, s);\n    setsvalue2s(L, L->top.p, ts);\n    s = getstr(ts);  /* internal copy's address */\n  }\n  api_incr_top(L);\n  luaC_checkGC(L);\n  lua_unlock(L);\n  return s;\n}\n\n\nLUA_API const char *lua_pushvfstring (lua_State *L, const char *fmt,\n                                      va_list argp) {\n  const char *ret;\n  lua_lock(L);\n  ret = luaO_pushvfstring(L, fmt, argp);\n  luaC_checkGC(L);\n  lua_unlock(L);\n  return ret;\n}\n\n\nLUA_API const char *lua_pushfstring (lua_State *L, const char *fmt, ...) {\n  const char *ret;\n  va_list argp;\n  lua_lock(L);\n  va_start(argp, fmt);\n  ret = luaO_pushvfstring(L, fmt, argp);\n  va_end(argp);\n  luaC_checkGC(L);\n  lua_unlock(L);\n  return ret;\n}\n\n\nLUA_API void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n) {\n  lua_lock(L);\n  if (n == 0) {\n    setfvalue(s2v(L->top.p), fn);\n    api_incr_top(L);\n  }\n  else {\n    int i;\n    CClosure *cl;\n    api_checkpop(L, n);\n    api_check(L, n <= MAXUPVAL, \"upvalue index too large\");\n    cl = luaF_newCclosure(L, n);\n    cl->f = fn;\n    for (i = 0; i < n; i++) {\n      setobj2n(L, &cl->upvalue[i], s2v(L->top.p - n + i));\n      /* does not need barrier because closure is white */\n      lua_assert(iswhite(cl));\n    }\n    L->top.p -= n;\n    setclCvalue(L, s2v(L->top.p), cl);\n    api_incr_top(L);\n    luaC_checkGC(L);\n  }\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushboolean (lua_State *L, int b) {\n  lua_lock(L);\n  if (b)\n    setbtvalue(s2v(L->top.p));\n  else\n    setbfvalue(s2v(L->top.p));\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushlightuserdata (lua_State *L, void *p) {\n  lua_lock(L);\n  setpvalue(s2v(L->top.p), p);\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API int lua_pushthread (lua_State *L) {\n  lua_lock(L);\n  setthvalue(L, s2v(L->top.p), L);\n  api_incr_top(L);\n  lua_unlock(L);\n  return (G(L)->mainthread == L);\n}\n\n\n\n/*\n** get functions (Lua -> stack)\n*/\n\n\nstatic int auxgetstr (lua_State *L, const TValue *t, const char *k) {\n  int tag;\n  TString *str = luaS_new(L, k);\n  luaV_fastget(t, str, s2v(L->top.p), luaH_getstr, tag);\n  if (!tagisempty(tag)) {\n    api_incr_top(L);\n  }\n  else {\n    setsvalue2s(L, L->top.p, str);\n    api_incr_top(L);\n    tag = luaV_finishget(L, t, s2v(L->top.p - 1), L->top.p - 1, tag);\n  }\n  lua_unlock(L);\n  return novariant(tag);\n}\n\n\nstatic void getGlobalTable (lua_State *L, TValue *gt) {\n  Table *registry = hvalue(&G(L)->l_registry);\n  int tag = luaH_getint(registry, LUA_RIDX_GLOBALS, gt);\n  (void)tag;  /* avoid not-used warnings when checks are off */\n  api_check(L, novariant(tag) == LUA_TTABLE, \"global table must exist\");\n}\n\n\nLUA_API int lua_getglobal (lua_State *L, const char *name) {\n  TValue gt;\n  lua_lock(L);\n  getGlobalTable(L, &gt);\n  return auxgetstr(L, &gt, name);\n}\n\n\nLUA_API int lua_gettable (lua_State *L, int idx) {\n  int tag;\n  TValue *t;\n  lua_lock(L);\n  api_checkpop(L, 1);\n  t = index2value(L, idx);\n  luaV_fastget(t, s2v(L->top.p - 1), s2v(L->top.p - 1), luaH_get, tag);\n  if (tagisempty(tag))\n    tag = luaV_finishget(L, t, s2v(L->top.p - 1), L->top.p - 1, tag);\n  lua_unlock(L);\n  return novariant(tag);\n}\n\n\nLUA_API int lua_getfield (lua_State *L, int idx, const char *k) {\n  lua_lock(L);\n  return auxgetstr(L, index2value(L, idx), k);\n}\n\n\nLUA_API int lua_geti (lua_State *L, int idx, lua_Integer n) {\n  TValue *t;\n  int tag;\n  lua_lock(L);\n  t = index2value(L, idx);\n  luaV_fastgeti(t, n, s2v(L->top.p), tag);\n  if (tagisempty(tag)) {\n    TValue key;\n    setivalue(&key, n);\n    tag = luaV_finishget(L, t, &key, L->top.p, tag);\n  }\n  api_incr_top(L);\n  lua_unlock(L);\n  return novariant(tag);\n}\n\n\nstatic int finishrawget (lua_State *L, int tag) {\n  if (tagisempty(tag))  /* avoid copying empty items to the stack */\n    setnilvalue(s2v(L->top.p));\n  api_incr_top(L);\n  lua_unlock(L);\n  return novariant(tag);\n}\n\n\nl_sinline Table *gettable (lua_State *L, int idx) {\n  TValue *t = index2value(L, idx);\n  api_check(L, ttistable(t), \"table expected\");\n  return hvalue(t);\n}\n\n\nLUA_API int lua_rawget (lua_State *L, int idx) {\n  Table *t;\n  int tag;\n  lua_lock(L);\n  api_checkpop(L, 1);\n  t = gettable(L, idx);\n  tag = luaH_get(t, s2v(L->top.p - 1), s2v(L->top.p - 1));\n  L->top.p--;  /* pop key */\n  return finishrawget(L, tag);\n}\n\n\nLUA_API int lua_rawgeti (lua_State *L, int idx, lua_Integer n) {\n  Table *t;\n  int tag;\n  lua_lock(L);\n  t = gettable(L, idx);\n  luaH_fastgeti(t, n, s2v(L->top.p), tag);\n  return finishrawget(L, tag);\n}\n\n\nLUA_API int lua_rawgetp (lua_State *L, int idx, const void *p) {\n  Table *t;\n  TValue k;\n  lua_lock(L);\n  t = gettable(L, idx);\n  setpvalue(&k, cast_voidp(p));\n  return finishrawget(L, luaH_get(t, &k, s2v(L->top.p)));\n}\n\n\nLUA_API void lua_createtable (lua_State *L, unsigned narray, unsigned nrec) {\n  Table *t;\n  lua_lock(L);\n  t = luaH_new(L);\n  sethvalue2s(L, L->top.p, t);\n  api_incr_top(L);\n  if (narray > 0 || nrec > 0)\n    luaH_resize(L, t, narray, nrec);\n  luaC_checkGC(L);\n  lua_unlock(L);\n}\n\n\nLUA_API int lua_getmetatable (lua_State *L, int objindex) {\n  const TValue *obj;\n  Table *mt;\n  int res = 0;\n  lua_lock(L);\n  obj = index2value(L, objindex);\n  switch (ttype(obj)) {\n    case LUA_TTABLE:\n      mt = hvalue(obj)->metatable;\n      break;\n    case LUA_TUSERDATA:\n      mt = uvalue(obj)->metatable;\n      break;\n    default:\n      mt = G(L)->mt[ttype(obj)];\n      break;\n  }\n  if (mt != NULL) {\n    sethvalue2s(L, L->top.p, mt);\n    api_incr_top(L);\n    res = 1;\n  }\n  lua_unlock(L);\n  return res;\n}\n\n\nLUA_API int lua_getiuservalue (lua_State *L, int idx, int n) {\n  TValue *o;\n  int t;\n  lua_lock(L);\n  o = index2value(L, idx);\n  api_check(L, ttisfulluserdata(o), \"full userdata expected\");\n  if (n <= 0 || n > uvalue(o)->nuvalue) {\n    setnilvalue(s2v(L->top.p));\n    t = LUA_TNONE;\n  }\n  else {\n    setobj2s(L, L->top.p, &uvalue(o)->uv[n - 1].uv);\n    t = ttype(s2v(L->top.p));\n  }\n  api_incr_top(L);\n  lua_unlock(L);\n  return t;\n}\n\n\n/*\n** set functions (stack -> Lua)\n*/\n\n/*\n** t[k] = value at the top of the stack (where 'k' is a string)\n*/\nstatic void auxsetstr (lua_State *L, const TValue *t, const char *k) {\n  int hres;\n  TString *str = luaS_new(L, k);\n  api_checkpop(L, 1);\n  luaV_fastset(t, str, s2v(L->top.p - 1), hres, luaH_psetstr);\n  if (hres == HOK) {\n    luaV_finishfastset(L, t, s2v(L->top.p - 1));\n    L->top.p--;  /* pop value */\n  }\n  else {\n    setsvalue2s(L, L->top.p, str);  /* push 'str' (to make it a TValue) */\n    api_incr_top(L);\n    luaV_finishset(L, t, s2v(L->top.p - 1), s2v(L->top.p - 2), hres);\n    L->top.p -= 2;  /* pop value and key */\n  }\n  lua_unlock(L);  /* lock done by caller */\n}\n\n\nLUA_API void lua_setglobal (lua_State *L, const char *name) {\n  TValue gt;\n  lua_lock(L);  /* unlock done in 'auxsetstr' */\n  getGlobalTable(L, &gt);\n  auxsetstr(L, &gt, name);\n}\n\n\nLUA_API void lua_settable (lua_State *L, int idx) {\n  TValue *t;\n  int hres;\n  lua_lock(L);\n  api_checkpop(L, 2);\n  t = index2value(L, idx);\n  luaV_fastset(t, s2v(L->top.p - 2), s2v(L->top.p - 1), hres, luaH_pset);\n  if (hres == HOK) {\n    luaV_finishfastset(L, t, s2v(L->top.p - 1));\n  }\n  else\n    luaV_finishset(L, t, s2v(L->top.p - 2), s2v(L->top.p - 1), hres);\n  L->top.p -= 2;  /* pop index and value */\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_setfield (lua_State *L, int idx, const char *k) {\n  lua_lock(L);  /* unlock done in 'auxsetstr' */\n  auxsetstr(L, index2value(L, idx), k);\n}\n\n\nLUA_API void lua_seti (lua_State *L, int idx, lua_Integer n) {\n  TValue *t;\n  int hres;\n  lua_lock(L);\n  api_checkpop(L, 1);\n  t = index2value(L, idx);\n  luaV_fastseti(t, n, s2v(L->top.p - 1), hres);\n  if (hres == HOK)\n    luaV_finishfastset(L, t, s2v(L->top.p - 1));\n  else {\n    TValue temp;\n    setivalue(&temp, n);\n    luaV_finishset(L, t, &temp, s2v(L->top.p - 1), hres);\n  }\n  L->top.p--;  /* pop value */\n  lua_unlock(L);\n}\n\n\nstatic void aux_rawset (lua_State *L, int idx, TValue *key, int n) {\n  Table *t;\n  lua_lock(L);\n  api_checkpop(L, n);\n  t = gettable(L, idx);\n  luaH_set(L, t, key, s2v(L->top.p - 1));\n  invalidateTMcache(t);\n  luaC_barrierback(L, obj2gco(t), s2v(L->top.p - 1));\n  L->top.p -= n;\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_rawset (lua_State *L, int idx) {\n  aux_rawset(L, idx, s2v(L->top.p - 2), 2);\n}\n\n\nLUA_API void lua_rawsetp (lua_State *L, int idx, const void *p) {\n  TValue k;\n  setpvalue(&k, cast_voidp(p));\n  aux_rawset(L, idx, &k, 1);\n}\n\n\nLUA_API void lua_rawseti (lua_State *L, int idx, lua_Integer n) {\n  Table *t;\n  lua_lock(L);\n  api_checkpop(L, 1);\n  t = gettable(L, idx);\n  luaH_setint(L, t, n, s2v(L->top.p - 1));\n  luaC_barrierback(L, obj2gco(t), s2v(L->top.p - 1));\n  L->top.p--;\n  lua_unlock(L);\n}\n\n\nLUA_API int lua_setmetatable (lua_State *L, int objindex) {\n  TValue *obj;\n  Table *mt;\n  lua_lock(L);\n  api_checkpop(L, 1);\n  obj = index2value(L, objindex);\n  if (ttisnil(s2v(L->top.p - 1)))\n    mt = NULL;\n  else {\n    api_check(L, ttistable(s2v(L->top.p - 1)), \"table expected\");\n    mt = hvalue(s2v(L->top.p - 1));\n  }\n  switch (ttype(obj)) {\n    case LUA_TTABLE: {\n      hvalue(obj)->metatable = mt;\n      if (mt) {\n        luaC_objbarrier(L, gcvalue(obj), mt);\n        luaC_checkfinalizer(L, gcvalue(obj), mt);\n      }\n      break;\n    }\n    case LUA_TUSERDATA: {\n      uvalue(obj)->metatable = mt;\n      if (mt) {\n        luaC_objbarrier(L, uvalue(obj), mt);\n        luaC_checkfinalizer(L, gcvalue(obj), mt);\n      }\n      break;\n    }\n    default: {\n      G(L)->mt[ttype(obj)] = mt;\n      break;\n    }\n  }\n  L->top.p--;\n  lua_unlock(L);\n  return 1;\n}\n\n\nLUA_API int lua_setiuservalue (lua_State *L, int idx, int n) {\n  TValue *o;\n  int res;\n  lua_lock(L);\n  api_checkpop(L, 1);\n  o = index2value(L, idx);\n  api_check(L, ttisfulluserdata(o), \"full userdata expected\");\n  if (!(cast_uint(n) - 1u < cast_uint(uvalue(o)->nuvalue)))\n    res = 0;  /* 'n' not in [1, uvalue(o)->nuvalue] */\n  else {\n    setobj(L, &uvalue(o)->uv[n - 1].uv, s2v(L->top.p - 1));\n    luaC_barrierback(L, gcvalue(o), s2v(L->top.p - 1));\n    res = 1;\n  }\n  L->top.p--;\n  lua_unlock(L);\n  return res;\n}\n\n\n/*\n** 'load' and 'call' functions (run Lua code)\n*/\n\n\n#define checkresults(L,na,nr) \\\n     api_check(L, (nr) == LUA_MULTRET \\\n               || (L->ci->top.p - L->top.p >= (nr) - (na)), \\\n\t\"results from function overflow current stack size\")\n\n\nLUA_API void lua_callk (lua_State *L, int nargs, int nresults,\n                        lua_KContext ctx, lua_KFunction k) {\n  StkId func;\n  lua_lock(L);\n  api_check(L, k == NULL || !isLua(L->ci),\n    \"cannot use continuations inside hooks\");\n  api_checkpop(L, nargs + 1);\n  api_check(L, L->status == LUA_OK, \"cannot do calls on non-normal thread\");\n  checkresults(L, nargs, nresults);\n  func = L->top.p - (nargs+1);\n  if (k != NULL && yieldable(L)) {  /* need to prepare continuation? */\n    L->ci->u.c.k = k;  /* save continuation */\n    L->ci->u.c.ctx = ctx;  /* save context */\n    luaD_call(L, func, nresults);  /* do the call */\n  }\n  else  /* no continuation or no yieldable */\n    luaD_callnoyield(L, func, nresults);  /* just do the call */\n  adjustresults(L, nresults);\n  lua_unlock(L);\n}\n\n\n\n/*\n** Execute a protected call.\n*/\nstruct CallS {  /* data to 'f_call' */\n  StkId func;\n  int nresults;\n};\n\n\nstatic void f_call (lua_State *L, void *ud) {\n  struct CallS *c = cast(struct CallS *, ud);\n  luaD_callnoyield(L, c->func, c->nresults);\n}\n\n\n\nLUA_API int lua_pcallk (lua_State *L, int nargs, int nresults, int errfunc,\n                        lua_KContext ctx, lua_KFunction k) {\n  struct CallS c;\n  int status;\n  ptrdiff_t func;\n  lua_lock(L);\n  api_check(L, k == NULL || !isLua(L->ci),\n    \"cannot use continuations inside hooks\");\n  api_checkpop(L, nargs + 1);\n  api_check(L, L->status == LUA_OK, \"cannot do calls on non-normal thread\");\n  checkresults(L, nargs, nresults);\n  if (errfunc == 0)\n    func = 0;\n  else {\n    StkId o = index2stack(L, errfunc);\n    api_check(L, ttisfunction(s2v(o)), \"private_lua_error handler must be a function\");\n    func = savestack(L, o);\n  }\n  c.func = L->top.p - (nargs+1);  /* function to be called */\n  if (k == NULL || !yieldable(L)) {  /* no continuation or no yieldable? */\n    c.nresults = nresults;  /* do a 'conventional' protected call */\n    status = luaD_pcall(L, f_call, &c, savestack(L, c.func), func);\n  }\n  else {  /* prepare continuation (call is already protected by 'resume') */\n    CallInfo *ci = L->ci;\n    ci->u.c.k = k;  /* save continuation */\n    ci->u.c.ctx = ctx;  /* save context */\n    /* save information for error recovery */\n    ci->u2.funcidx = cast_int(savestack(L, c.func));\n    ci->u.c.old_errfunc = L->errfunc;\n    L->errfunc = func;\n    setoah(ci->callstatus, L->allowhook);  /* save value of 'allowhook' */\n    ci->callstatus |= CIST_YPCALL;  /* function can do error recovery */\n    luaD_call(L, c.func, nresults);  /* do the call */\n    ci->callstatus &= ~CIST_YPCALL;\n    L->errfunc = ci->u.c.old_errfunc;\n    status = LUA_OK;  /* if it is here, there were no errors */\n  }\n  adjustresults(L, nresults);\n  lua_unlock(L);\n  return status;\n}\n\n\nLUA_API int lua_load (lua_State *L, lua_Reader reader, void *data,\n                      const char *chunkname, const char *mode) {\n  ZIO z;\n  int status;\n  lua_lock(L);\n  if (!chunkname) chunkname = \"?\";\n  luaZ_init(L, &z, reader, data);\n  status = luaD_protectedparser(L, &z, chunkname, mode);\n  if (status == LUA_OK) {  /* no errors? */\n    LClosure *f = clLvalue(s2v(L->top.p - 1));  /* get new function */\n    if (f->nupvalues >= 1) {  /* does it have an upvalue? */\n      /* get global table from registry */\n      TValue gt;\n      getGlobalTable(L, &gt);\n      /* set global table as 1st upvalue of 'f' (may be LUA_ENV) */\n      setobj(L, f->upvals[0]->v.p, &gt);\n      luaC_barrier(L, f->upvals[0], &gt);\n    }\n  }\n  lua_unlock(L);\n  return status;\n}\n\n\n/*\n** Dump a Lua function, calling 'writer' to write its parts. Ensure\n** the stack returns with its original size.\n*/\nLUA_API int lua_dump (lua_State *L, lua_Writer writer, void *data, int strip) {\n  int status;\n  ptrdiff_t otop = savestack(L, L->top.p);  /* original top */\n  TValue *f = s2v(L->top.p - 1);  /* function to be dumped */\n  lua_lock(L);\n  api_checkpop(L, 1);\n  api_check(L, isLfunction(f), \"Lua function expected\");\n  status = luaU_dump(L, clLvalue(f)->p, writer, data, strip);\n  L->top.p = restorestack(L, otop);  /* restore top */\n  lua_unlock(L);\n  return status;\n}\n\n\nLUA_API int lua_status (lua_State *L) {\n  return L->status;\n}\n\n\n/*\n** Garbage-collection function\n*/\nLUA_API int lua_gc (lua_State *L, int what, ...) {\n  va_list argp;\n  int res = 0;\n  global_State *g = G(L);\n  if (g->gcstp & (GCSTPGC | GCSTPCLS))  /* internal stop? */\n    return -1;  /* all options are invalid when stopped */\n  lua_lock(L);\n  va_start(argp, what);\n  switch (what) {\n    case LUA_GCSTOP: {\n      g->gcstp = GCSTPUSR;  /* stopped by the user */\n      break;\n    }\n    case LUA_GCRESTART: {\n      luaE_setdebt(g, 0);\n      g->gcstp = 0;  /* (other bits must be zero here) */\n      break;\n    }\n    case LUA_GCCOLLECT: {\n      luaC_fullgc(L, 0);\n      break;\n    }\n    case LUA_GCCOUNT: {\n      /* GC values are expressed in Kbytes: #bytes/2^10 */\n      res = cast_int(g->totalbytes >> 10);\n      break;\n    }\n    case LUA_GCCOUNTB: {\n      res = cast_int(g->totalbytes & 0x3ff);\n      break;\n    }\n    case LUA_GCSTEP: {\n      lu_byte oldstp = g->gcstp;\n      l_obj n = va_arg(argp, int);\n      int work = 0;  /* true if GC did some work */\n      g->gcstp = 0;  /* allow GC to run (other bits must be zero here) */\n      if (n <= 0)\n        n = g->GCdebt;  /* force to run one basic step */\n      luaE_setdebt(g, g->GCdebt - n);\n      luaC_condGC(L, (void)0, work = 1);\n      if (work && g->gcstate == GCSpause)  /* end of cycle? */\n        res = 1;  /* signal it */\n      g->gcstp = oldstp;  /* restore previous state */\n      break;\n    }\n    case LUA_GCISRUNNING: {\n      res = gcrunning(g);\n      break;\n    }\n    case LUA_GCGEN: {\n      res = (g->gckind == KGC_INC) ? LUA_GCINC : LUA_GCGEN;\n      luaC_changemode(L, KGC_GENMINOR);\n      break;\n    }\n    case LUA_GCINC: {\n      res = (g->gckind == KGC_INC) ? LUA_GCINC : LUA_GCGEN;\n      luaC_changemode(L, KGC_INC);\n      break;\n    }\n    case LUA_GCPARAM: {\n      int param = va_arg(argp, int);\n      int value = va_arg(argp, int);\n      api_check(L, 0 <= param && param < LUA_GCPN, \"invalid parameter\");\n      res = cast_int(luaO_applyparam(g->gcparams[param], 100));\n      if (value >= 0)\n        g->gcparams[param] = luaO_codeparam(value);\n      break;\n    }\n    default: res = -1;  /* invalid option */\n  }\n  va_end(argp);\n  lua_unlock(L);\n  return res;\n}\n\n\n\n/*\n** miscellaneous functions\n*/\n\n\nLUA_API int lua_error (lua_State *L) {\n  TValue *errobj;\n  lua_lock(L);\n  errobj = s2v(L->top.p - 1);\n  api_checkpop(L, 1);\n  /* error object is the memory error message? */\n  if (ttisshrstring(errobj) && eqshrstr(tsvalue(errobj), G(L)->memerrmsg))\n    luaM_error(L);  /* raise a memory error */\n  else\n    luaG_errormsg(L);  /* raise a regular error */\n  /* code unreachable; will unlock when control actually leaves the kernel */\n  return 0;  /* to avoid warnings */\n}\n\n\nLUA_API int lua_next (lua_State *L, int idx) {\n  Table *t;\n  int more;\n  lua_lock(L);\n  api_checkpop(L, 1);\n  t = gettable(L, idx);\n  more = luaH_next(L, t, L->top.p - 1);\n  if (more)\n    api_incr_top(L);\n  else  /* no more elements */\n    L->top.p--;  /* pop key */\n  lua_unlock(L);\n  return more;\n}\n\n\nLUA_API void lua_toclose (lua_State *L, int idx) {\n  int nresults;\n  StkId o;\n  lua_lock(L);\n  o = index2stack(L, idx);\n  nresults = L->ci->nresults;\n  api_check(L, L->tbclist.p < o, \"given index below or equal a marked one\");\n  luaF_newtbcupval(L, o);  /* create new to-be-closed upvalue */\n  if (!hastocloseCfunc(nresults))  /* function not marked yet? */\n    L->ci->nresults = codeNresults(nresults);  /* mark it */\n  lua_assert(hastocloseCfunc(L->ci->nresults));\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_concat (lua_State *L, int n) {\n  lua_lock(L);\n  api_checknelems(L, n);\n  if (n > 0) {\n    luaV_concat(L, n);\n    luaC_checkGC(L);\n  }\n  else {  /* nothing to concatenate */\n    setsvalue2s(L, L->top.p, luaS_newlstr(L, \"\", 0));  /* push empty string */\n    api_incr_top(L);\n  }\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_len (lua_State *L, int idx) {\n  TValue *t;\n  lua_lock(L);\n  t = index2value(L, idx);\n  luaV_objlen(L, L->top.p, t);\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API lua_Alloc lua_getallocf (lua_State *L, void **ud) {\n  lua_Alloc f;\n  lua_lock(L);\n  if (ud) *ud = G(L)->ud;\n  f = G(L)->frealloc;\n  lua_unlock(L);\n  return f;\n}\n\n\nLUA_API void lua_setallocf (lua_State *L, lua_Alloc f, void *ud) {\n  lua_lock(L);\n  G(L)->ud = ud;\n  G(L)->frealloc = f;\n  lua_unlock(L);\n}\n\n\nvoid lua_setwarnf (lua_State *L, lua_WarnFunction f, void *ud) {\n  lua_lock(L);\n  G(L)->ud_warn = ud;\n  G(L)->warnf = f;\n  lua_unlock(L);\n}\n\n\nvoid lua_warning (lua_State *L, const char *msg, int tocont) {\n  lua_lock(L);\n  luaE_warning(L, msg, tocont);\n  lua_unlock(L);\n}\n\n\n\nLUA_API void *lua_newuserdatauv (lua_State *L, size_t size, int nuvalue) {\n  Udata *u;\n  lua_lock(L);\n  api_check(L, 0 <= nuvalue && nuvalue < USHRT_MAX, \"invalid value\");\n  u = luaS_newudata(L, size, nuvalue);\n  setuvalue(L, s2v(L->top.p), u);\n  api_incr_top(L);\n  advancegc(L, size);\n  luaC_checkGC(L);\n  lua_unlock(L);\n  return getudatamem(u);\n}\n\n\n\nstatic const char *aux_upvalue (TValue *fi, int n, TValue **val,\n                                GCObject **owner) {\n  switch (ttypetag(fi)) {\n    case LUA_VCCL: {  /* C closure */\n      CClosure *f = clCvalue(fi);\n      if (!(cast_uint(n) - 1u < cast_uint(f->nupvalues)))\n        return NULL;  /* 'n' not in [1, f->nupvalues] */\n      *val = &f->upvalue[n-1];\n      if (owner) *owner = obj2gco(f);\n      return \"\";\n    }\n    case LUA_VLCL: {  /* Lua closure */\n      LClosure *f = clLvalue(fi);\n      TString *name;\n      Proto *p = f->p;\n      if (!(cast_uint(n) - 1u  < cast_uint(p->sizeupvalues)))\n        return NULL;  /* 'n' not in [1, p->sizeupvalues] */\n      *val = f->upvals[n-1]->v.p;\n      if (owner) *owner = obj2gco(f->upvals[n - 1]);\n      name = p->upvalues[n-1].name;\n      return (name == NULL) ? \"(no name)\" : getstr(name);\n    }\n    default: return NULL;  /* not a closure */\n  }\n}\n\n\nLUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n) {\n  const char *name;\n  TValue *val = NULL;  /* to avoid warnings */\n  lua_lock(L);\n  name = aux_upvalue(index2value(L, funcindex), n, &val, NULL);\n  if (name) {\n    setobj2s(L, L->top.p, val);\n    api_incr_top(L);\n  }\n  lua_unlock(L);\n  return name;\n}\n\n\nLUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n) {\n  const char *name;\n  TValue *val = NULL;  /* to avoid warnings */\n  GCObject *owner = NULL;  /* to avoid warnings */\n  TValue *fi;\n  lua_lock(L);\n  fi = index2value(L, funcindex);\n  api_checknelems(L, 1);\n  name = aux_upvalue(fi, n, &val, &owner);\n  if (name) {\n    L->top.p--;\n    setobj(L, val, s2v(L->top.p));\n    luaC_barrier(L, owner, val);\n  }\n  lua_unlock(L);\n  return name;\n}\n\n\nstatic UpVal **getupvalref (lua_State *L, int fidx, int n, LClosure **pf) {\n  static const UpVal *const nullup = NULL;\n  LClosure *f;\n  TValue *fi = index2value(L, fidx);\n  api_check(L, ttisLclosure(fi), \"Lua function expected\");\n  f = clLvalue(fi);\n  if (pf) *pf = f;\n  if (1 <= n && n <= f->p->sizeupvalues)\n    return &f->upvals[n - 1];  /* get its upvalue pointer */\n  else\n    return (UpVal**)&nullup;\n}\n\n\nLUA_API void *lua_upvalueid (lua_State *L, int fidx, int n) {\n  TValue *fi = index2value(L, fidx);\n  switch (ttypetag(fi)) {\n    case LUA_VLCL: {  /* lua closure */\n      return *getupvalref(L, fidx, n, NULL);\n    }\n    case LUA_VCCL: {  /* C closure */\n      CClosure *f = clCvalue(fi);\n      if (1 <= n && n <= f->nupvalues)\n        return &f->upvalue[n - 1];\n      /* else */\n    }  /* FALLTHROUGH */\n    case LUA_VLCF:\n      return NULL;  /* light C functions have no upvalues */\n    default: {\n      api_check(L, 0, \"function expected\");\n      return NULL;\n    }\n  }\n}\n\n\nLUA_API void lua_upvaluejoin (lua_State *L, int fidx1, int n1,\n                                            int fidx2, int n2) {\n  LClosure *f1;\n  UpVal **up1 = getupvalref(L, fidx1, n1, &f1);\n  UpVal **up2 = getupvalref(L, fidx2, n2, NULL);\n  api_check(L, *up1 != NULL && *up2 != NULL, \"invalid upvalue index\");\n  *up1 = *up2;\n  luaC_objbarrier(L, f1, *up1);\n}\n\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lapi.h",
		"is_binary":	false,
		"content":	"/*\n** $Id: lapi.h $\n** Auxiliary functions from Lua API\n** See Copyright Notice in lua.h\n*/\n\n#ifndef lapi_h\n#define lapi_h\n\n\n#include \"llimits.h\"\n#include \"lstate.h\"\n\n\n/* Increments 'L->top.p', checking for stack overflows */\n#define api_incr_top(L)  \\\n    (L->top.p++, api_check(L, L->top.p <= L->ci->top.p, \"stack overflow\"))\n\n\n/*\n** If a call returns too many multiple returns, the callee may not have\n** stack space to accommodate all results. In this case, this macro\n** increases its stack space ('L->ci->top.p').\n*/\n#define adjustresults(L,nres) \\\n    { if ((nres) <= LUA_MULTRET && L->ci->top.p < L->top.p) \\\n\tL->ci->top.p = L->top.p; }\n\n\n/* Ensure the stack has at least 'n' elements */\n#define api_checknelems(L,n) \\\n       api_check(L, (n) < (L->top.p - L->ci->func.p), \\\n                         \"not enough elements in the stack\")\n\n\n/* Ensure the stack has at least 'n' elements to be popped. (Some\n** functions only update a slot after checking it for popping, but that\n** is only an optimization for a pop followed by a push.)\n*/\n#define api_checkpop(L,n) \\\n\tapi_check(L, (n) < L->top.p - L->ci->func.p &&  \\\n                     L->tbclist.p < L->top.p - (n), \\\n\t\t\t  \"not enough free elements in the stack\")\n\n\n/*\n** To reduce the overhead of returning from C functions, the presence of\n** to-be-closed variables in these functions is coded in the CallInfo's\n** field 'nresults', in a way that functions with no to-be-closed variables\n** with zero, one, or \"all\" wanted results have no overhead. Functions\n** with other number of wanted results, as well as functions with\n** variables to be closed, have an extra check.\n*/\n\n#define hastocloseCfunc(n)\t((n) < LUA_MULTRET)\n\n/* Map [-1, inf) (range of 'nresults') into (-inf, -2] */\n#define codeNresults(n)\t\t(-(n) - 3)\n#define decodeNresults(n)\t(-(n) - 3)\n\n#endif\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lauxlib.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: lauxlib.c $\n** Auxiliary functions for building Lua libraries\n** See Copyright Notice in lua.h\n*/\n\n#define lauxlib_c\n#define LUA_LIB\n\n#include \"lprefix.h\"\n\n\n#include <errno.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n\n/*\n** This file uses only the official API of Lua.\n** Any function declared here could be written as an application function.\n*/\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n\n\n#if !defined(MAX_SIZET)\n/* maximum value for size_t */\n#define MAX_SIZET\t((size_t)(~(size_t)0))\n#endif\n\n\n/*\n** {======================================================\n** Traceback\n** =======================================================\n*/\n\n\n#define LEVELS1\t10\t/* size of the first part of the stack */\n#define LEVELS2\t11\t/* size of the second part of the stack */\n\n\n\n/*\n** Search for 'objidx' in table at index -1. ('objidx' must be an\n** absolute index.) Return 1 + string at top if it found a good name.\n*/\nstatic int findfield (lua_State *L, int objidx, int level) {\n  if (level == 0 || !lua_istable(L, -1))\n    return 0;  /* not found */\n  lua_pushnil(L);  /* start 'next' loop */\n  while (lua_next(L, -2)) {  /* for each pair in table */\n    if (lua_type(L, -2) == LUA_TSTRING) {  /* ignore non-string keys */\n      if (lua_rawequal(L, objidx, -1)) {  /* found object? */\n        lua_pop(L, 1);  /* remove value (but keep name) */\n        return 1;\n      }\n      else if (findfield(L, objidx, level - 1)) {  /* try recursively */\n        /* stack: lib_name, lib_table, field_name (top) */\n        lua_pushliteral(L, \".\");  /* place '.' between the two names */\n        lua_replace(L, -3);  /* (in the slot occupied by table) */\n        lua_concat(L, 3);  /* lib_name.field_name */\n        return 1;\n      }\n    }\n    lua_pop(L, 1);  /* remove value */\n  }\n  return 0;  /* not found */\n}\n\n\n/*\n** Search for a name for a function in all loaded modules\n*/\nstatic int pushglobalfuncname (lua_State *L, lua_Debug *ar) {\n  int top = lua_gettop(L);\n  lua_getinfo(L, \"f\", ar);  /* push function */\n  lua_getfield(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);\n  if (findfield(L, top + 1, 2)) {\n    const char *name = lua_tostring(L, -1);\n    if (strncmp(name, LUA_GNAME \".\", 3) == 0) {  /* name start with '_G.'? */\n      lua_pushstring(L, name + 3);  /* push name without prefix */\n      lua_remove(L, -2);  /* remove original name */\n    }\n    lua_copy(L, -1, top + 1);  /* copy name to proper place */\n    lua_settop(L, top + 1);  /* remove table \"loaded\" and name copy */\n    return 1;\n  }\n  else {\n    lua_settop(L, top);  /* remove function and global table */\n    return 0;\n  }\n}\n\n\nstatic void pushfuncname (lua_State *L, lua_Debug *ar) {\n  if (pushglobalfuncname(L, ar)) {  /* try first a global name */\n    lua_pushfstring(L, \"function '%s'\", lua_tostring(L, -1));\n    lua_remove(L, -2);  /* remove name */\n  }\n  else if (*ar->namewhat != '\\0')  /* is there a name from code? */\n    lua_pushfstring(L, \"%s '%s'\", ar->namewhat, ar->name);  /* use it */\n  else if (*ar->what == 'm')  /* main? */\n      lua_pushliteral(L, \"main chunk\");\n  else if (*ar->what != 'C')  /* for Lua functions, use <file:line> */\n    lua_pushfstring(L, \"function <%s:%d>\", ar->short_src, ar->linedefined);\n  else  /* nothing left... */\n    lua_pushliteral(L, \"?\");\n}\n\n\nstatic int lastlevel (lua_State *L) {\n  lua_Debug ar;\n  int li = 1, le = 1;\n  /* find an upper bound */\n  while (lua_getstack(L, le, &ar)) { li = le; le *= 2; }\n  /* do a binary search */\n  while (li < le) {\n    int m = (li + le)/2;\n    if (lua_getstack(L, m, &ar)) li = m + 1;\n    else le = m;\n  }\n  return le - 1;\n}\n\n\nLUALIB_API void luaL_traceback (lua_State *L, lua_State *L1,\n                                const char *msg, int level) {\n  luaL_Buffer b;\n  lua_Debug ar;\n  int last = lastlevel(L1);\n  int limit2show = (last - level > LEVELS1 + LEVELS2) ? LEVELS1 : -1;\n  luaL_buffinit(L, &b);\n  if (msg) {\n    luaL_addstring(&b, msg);\n    luaL_addchar(&b, '\\n');\n  }\n  luaL_addstring(&b, \"stack traceback:\");\n  while (lua_getstack(L1, level++, &ar)) {\n    if (limit2show-- == 0) {  /* too many levels? */\n      int n = last - level - LEVELS2 + 1;  /* number of levels to skip */\n      lua_pushfstring(L, \"\\n\\t...\\t(skipping %d levels)\", n);\n      luaL_addvalue(&b);  /* add warning about skip */\n      level += n;  /* and skip to last levels */\n    }\n    else {\n      lua_getinfo(L1, \"Slnt\", &ar);\n      if (ar.currentline <= 0)\n        lua_pushfstring(L, \"\\n\\t%s: in \", ar.short_src);\n      else\n        lua_pushfstring(L, \"\\n\\t%s:%d: in \", ar.short_src, ar.currentline);\n      luaL_addvalue(&b);\n      pushfuncname(L, &ar);\n      luaL_addvalue(&b);\n      if (ar.istailcall)\n        luaL_addstring(&b, \"\\n\\t(...tail calls...)\");\n    }\n  }\n  luaL_pushresult(&b);\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Error-report functions\n** =======================================================\n*/\n\nLUALIB_API int luaL_argerror (lua_State *L, int arg, const char *extramsg) {\n  lua_Debug ar;\n  if (!lua_getstack(L, 0, &ar))  /* no stack frame? */\n    return luaL_error(L, \"bad argument #%d (%s)\", arg, extramsg);\n  lua_getinfo(L, \"n\", &ar);\n  if (strcmp(ar.namewhat, \"method\") == 0) {\n    arg--;  /* do not count 'self' */\n    if (arg == 0)  /* error is in the self argument itself? */\n      return luaL_error(L, \"calling '%s' on bad self (%s)\",\n                           ar.name, extramsg);\n  }\n  if (ar.name == NULL)\n    ar.name = (pushglobalfuncname(L, &ar)) ? lua_tostring(L, -1) : \"?\";\n  return luaL_error(L, \"bad argument #%d to '%s' (%s)\",\n                        arg, ar.name, extramsg);\n}\n\n\nLUALIB_API int luaL_typeerror (lua_State *L, int arg, const char *tname) {\n  const char *msg;\n  const char *typearg;  /* name for the type of the actual argument */\n  if (luaL_getmetafield(L, arg, \"__name\") == LUA_TSTRING)\n    typearg = lua_tostring(L, -1);  /* use the given type name */\n  else if (lua_type(L, arg) == LUA_TLIGHTUSERDATA)\n    typearg = \"light userdata\";  /* special name for messages */\n  else\n    typearg = luaL_typename(L, arg);  /* standard name */\n  msg = lua_pushfstring(L, \"%s expected, got %s\", tname, typearg);\n  return luaL_argerror(L, arg, msg);\n}\n\n\nstatic void tag_error (lua_State *L, int arg, int tag) {\n  luaL_typeerror(L, arg, lua_typename(L, tag));\n}\n\n\n/*\n** The use of 'lua_pushfstring' ensures this function does not\n** need reserved stack space when called.\n*/\nLUALIB_API void luaL_where (lua_State *L, int level) {\n  lua_Debug ar;\n  if (lua_getstack(L, level, &ar)) {  /* check function at level */\n    lua_getinfo(L, \"Sl\", &ar);  /* get info about it */\n    if (ar.currentline > 0) {  /* is there info? */\n      lua_pushfstring(L, \"%s:%d: \", ar.short_src, ar.currentline);\n      return;\n    }\n  }\n  lua_pushfstring(L, \"\");  /* else, no information available... */\n}\n\n\n/*\n** Again, the use of 'lua_pushvfstring' ensures this function does\n** not need reserved stack space when called. (At worst, it generates\n** an error with \"stack overflow\" instead of the given message.)\n*/\nLUALIB_API int luaL_error (lua_State *L, const char *fmt, ...) {\n  va_list argp;\n  va_start(argp, fmt);\n  luaL_where(L, 1);\n  lua_pushvfstring(L, fmt, argp);\n  va_end(argp);\n  lua_concat(L, 2);\n  return lua_error(L);\n}\n\n\nLUALIB_API int luaL_fileresult (lua_State *L, int stat, const char *fname) {\n  int en = errno;  /* calls to Lua API may change this value */\n  if (stat) {\n    lua_pushboolean(L, 1);\n    return 1;\n  }\n  else {\n    luaL_pushfail(L);\n    if (fname)\n      lua_pushfstring(L, \"%s: %s\", fname, strerror(en));\n    else\n      lua_pushstring(L, strerror(en));\n    lua_pushinteger(L, en);\n    return 3;\n  }\n}\n\n\n#if !defined(l_inspectstat)\t/* { */\n\n#if defined(LUA_USE_POSIX)\n\n#include <sys/wait.h>\n\n/*\n** use appropriate macros to interpret 'pclose' return status\n*/\n#define l_inspectstat(stat,what)  \\\n   if (WIFEXITED(stat)) { stat = WEXITSTATUS(stat); } \\\n   else if (WIFSIGNALED(stat)) { stat = WTERMSIG(stat); what = \"signal\"; }\n\n#else\n\n#define l_inspectstat(stat,what)  /* no op */\n\n#endif\n\n#endif\t\t\t\t/* } */\n\n\nLUALIB_API int luaL_execresult (lua_State *L, int stat) {\n  if (stat != 0 && errno != 0)  /* error with an 'errno'? */\n    return luaL_fileresult(L, 0, NULL);\n  else {\n    const char *what = \"exit\";  /* type of termination */\n    l_inspectstat(stat, what);  /* interpret result */\n    if (*what == 'e' && stat == 0)  /* successful termination? */\n      lua_pushboolean(L, 1);\n    else\n      luaL_pushfail(L);\n    lua_pushstring(L, what);\n    lua_pushinteger(L, stat);\n    return 3;  /* return true/fail,what,code */\n  }\n}\n\n/* }====================================================== */\n\n\n\n/*\n** {======================================================\n** Userdata's metatable manipulation\n** =======================================================\n*/\n\nLUALIB_API int luaL_newmetatable (lua_State *L, const char *tname) {\n  if (luaL_getmetatable(L, tname) != LUA_TNIL)  /* name already in use? */\n    return 0;  /* leave previous value on top, but return 0 */\n  lua_pop(L, 1);\n  lua_createtable(L, 0, 2);  /* create metatable */\n  lua_pushstring(L, tname);\n  lua_setfield(L, -2, \"__name\");  /* metatable.__name = tname */\n  lua_pushvalue(L, -1);\n  lua_setfield(L, LUA_REGISTRYINDEX, tname);  /* registry.name = metatable */\n  return 1;\n}\n\n\nLUALIB_API void luaL_setmetatable (lua_State *L, const char *tname) {\n  luaL_getmetatable(L, tname);\n  lua_setmetatable(L, -2);\n}\n\n\nLUALIB_API void *luaL_testudata (lua_State *L, int ud, const char *tname) {\n  void *p = lua_touserdata(L, ud);\n  if (p != NULL) {  /* value is a userdata? */\n    if (lua_getmetatable(L, ud)) {  /* does it have a metatable? */\n      luaL_getmetatable(L, tname);  /* get correct metatable */\n      if (!lua_rawequal(L, -1, -2))  /* not the same? */\n        p = NULL;  /* value is a userdata with wrong metatable */\n      lua_pop(L, 2);  /* remove both metatables */\n      return p;\n    }\n  }\n  return NULL;  /* value is not a userdata with a metatable */\n}\n\n\nLUALIB_API void *luaL_checkudata (lua_State *L, int ud, const char *tname) {\n  void *p = luaL_testudata(L, ud, tname);\n  luaL_argexpected(L, p != NULL, ud, tname);\n  return p;\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Argument check functions\n** =======================================================\n*/\n\nLUALIB_API int luaL_checkoption (lua_State *L, int arg, const char *def,\n                                 const char *const lst[]) {\n  const char *name = (def) ? luaL_optstring(L, arg, def) :\n                             luaL_checkstring(L, arg);\n  int i;\n  for (i=0; lst[i]; i++)\n    if (strcmp(lst[i], name) == 0)\n      return i;\n  return luaL_argerror(L, arg,\n                       lua_pushfstring(L, \"invalid option '%s'\", name));\n}\n\n\n/*\n** Ensures the stack has at least 'space' extra slots, raising an error\n** if it cannot fulfill the request. (The error handling needs a few\n** extra slots to format the error message. In case of an error without\n** this extra space, Lua will generate the same 'stack overflow' error,\n** but without 'msg'.)\n*/\nLUALIB_API void luaL_checkstack (lua_State *L, int space, const char *msg) {\n  if (l_unlikely(!lua_checkstack(L, space))) {\n    if (msg)\n      luaL_error(L, \"stack overflow (%s)\", msg);\n    else\n      luaL_error(L, \"stack overflow\");\n  }\n}\n\n\nLUALIB_API void luaL_checktype (lua_State *L, int arg, int t) {\n  if (l_unlikely(lua_type(L, arg) != t))\n    tag_error(L, arg, t);\n}\n\n\nLUALIB_API void luaL_checkany (lua_State *L, int arg) {\n  if (l_unlikely(lua_type(L, arg) == LUA_TNONE))\n    luaL_argerror(L, arg, \"value expected\");\n}\n\n\nLUALIB_API const char *luaL_checklstring (lua_State *L, int arg, size_t *len) {\n  const char *s = lua_tolstring(L, arg, len);\n  if (l_unlikely(!s)) tag_error(L, arg, LUA_TSTRING);\n  return s;\n}\n\n\nLUALIB_API const char *luaL_optlstring (lua_State *L, int arg,\n                                        const char *def, size_t *len) {\n  if (lua_isnoneornil(L, arg)) {\n    if (len)\n      *len = (def ? strlen(def) : 0);\n    return def;\n  }\n  else return luaL_checklstring(L, arg, len);\n}\n\n\nLUALIB_API lua_Number luaL_checknumber (lua_State *L, int arg) {\n  int isnum;\n  lua_Number d = lua_tonumberx(L, arg, &isnum);\n  if (l_unlikely(!isnum))\n    tag_error(L, arg, LUA_TNUMBER);\n  return d;\n}\n\n\nLUALIB_API lua_Number luaL_optnumber (lua_State *L, int arg, lua_Number def) {\n  return luaL_opt(L, luaL_checknumber, arg, def);\n}\n\n\nstatic void interror (lua_State *L, int arg) {\n  if (lua_isnumber(L, arg))\n    luaL_argerror(L, arg, \"number has no integer representation\");\n  else\n    tag_error(L, arg, LUA_TNUMBER);\n}\n\n\nLUALIB_API lua_Integer luaL_checkinteger (lua_State *L, int arg) {\n  int isnum;\n  lua_Integer d = lua_tointegerx(L, arg, &isnum);\n  if (l_unlikely(!isnum)) {\n    interror(L, arg);\n  }\n  return d;\n}\n\n\nLUALIB_API lua_Integer luaL_optinteger (lua_State *L, int arg,\n                                                      lua_Integer def) {\n  return luaL_opt(L, luaL_checkinteger, arg, def);\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Generic Buffer manipulation\n** =======================================================\n*/\n\n/* userdata to box arbitrary data */\ntypedef struct UBox {\n  void *box;\n  size_t bsize;\n} UBox;\n\n\n/* Resize the buffer used by a box. Optimize for the common case of\n** resizing to the old size. (For instance, __gc will resize the box\n** to 0 even after it was closed. 'pushresult' may also resize it to a\n** final size that is equal to the one set when the buffer was created.)\n*/\nstatic void *resizebox (lua_State *L, int idx, size_t newsize) {\n  UBox *box = (UBox *)lua_touserdata(L, idx);\n  if (box->bsize == newsize)  /* not changing size? */\n    return box->box;  /* keep the buffer */\n  else {\n    void *ud;\n    lua_Alloc allocf = lua_getallocf(L, &ud);\n    void *temp = allocf(ud, box->box, box->bsize, newsize);\n    if (l_unlikely(temp == NULL && newsize > 0)) {  /* allocation error? */\n      lua_pushliteral(L, \"not enough memory\");\n      lua_error(L);  /* raise a memory error */\n    }\n    box->box = temp;\n    box->bsize = newsize;\n    return temp;\n  }\n}\n\n\nstatic int boxgc (lua_State *L) {\n  resizebox(L, 1, 0);\n  return 0;\n}\n\n\nstatic const luaL_Reg boxmt[] = {  /* box metamethods */\n  {\"__gc\", boxgc},\n  {\"__close\", boxgc},\n  {NULL, NULL}\n};\n\n\nstatic void newbox (lua_State *L) {\n  UBox *box = (UBox *)lua_newuserdatauv(L, sizeof(UBox), 0);\n  box->box = NULL;\n  box->bsize = 0;\n  if (luaL_newmetatable(L, \"_UBOX*\"))  /* creating metatable? */\n    luaL_setfuncs(L, boxmt, 0);  /* set its metamethods */\n  lua_setmetatable(L, -2);\n}\n\n\n/*\n** check whether buffer is using a userdata on the stack as a temporary\n** buffer\n*/\n#define buffonstack(B)\t((B)->b != (B)->init.b)\n\n\n/*\n** Whenever buffer is accessed, slot 'idx' must either be a box (which\n** cannot be NULL) or it is a placeholder for the buffer.\n*/\n#define checkbufferlevel(B,idx)  \\\n  lua_assert(buffonstack(B) ? lua_touserdata(B->L, idx) != NULL  \\\n                            : lua_touserdata(B->L, idx) == (void*)B)\n\n\n/*\n** Compute new size for buffer 'B', enough to accommodate extra 'sz'\n** bytes plus one for a terminating zero. (The test for \"not big enough\"\n** also gets the case when the computation of 'newsize' overflows.)\n*/\nstatic size_t newbuffsize (luaL_Buffer *B, size_t sz) {\n  size_t newsize = (B->size / 2) * 3;  /* buffer size * 1.5 */\n  if (l_unlikely(MAX_SIZET - sz - 1 < B->n))  /* overflow in (B->n + sz + 1)? */\n    return luaL_error(B->L, \"buffer too large\");\n  if (newsize < B->n + sz + 1)  /* not big enough? */\n    newsize = B->n + sz + 1;\n  return newsize;\n}\n\n\n/*\n** Returns a pointer to a free area with at least 'sz' bytes in buffer\n** 'B'. 'boxidx' is the relative position in the stack where is the\n** buffer's box or its placeholder.\n*/\nstatic char *prepbuffsize (luaL_Buffer *B, size_t sz, int boxidx) {\n  checkbufferlevel(B, boxidx);\n  if (B->size - B->n >= sz)  /* enough space? */\n    return B->b + B->n;\n  else {\n    lua_State *L = B->L;\n    char *newbuff;\n    size_t newsize = newbuffsize(B, sz);\n    /* create larger buffer */\n    if (buffonstack(B))  /* buffer already has a box? */\n      newbuff = (char *)resizebox(L, boxidx, newsize);  /* resize it */\n    else {  /* no box yet */\n      lua_remove(L, boxidx);  /* remove placeholder */\n      newbox(L);  /* create a new box */\n      lua_insert(L, boxidx);  /* move box to its intended position */\n      lua_toclose(L, boxidx);\n      newbuff = (char *)resizebox(L, boxidx, newsize);\n      memcpy(newbuff, B->b, B->n * sizeof(char));  /* copy original content */\n    }\n    B->b = newbuff;\n    B->size = newsize;\n    return newbuff + B->n;\n  }\n}\n\n/*\n** returns a pointer to a free area with at least 'sz' bytes\n*/\nLUALIB_API char *luaL_prepbuffsize (luaL_Buffer *B, size_t sz) {\n  return prepbuffsize(B, sz, -1);\n}\n\n\nLUALIB_API void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l) {\n  if (l > 0) {  /* avoid 'memcpy' when 's' can be NULL */\n    char *b = prepbuffsize(B, l, -1);\n    memcpy(b, s, l * sizeof(char));\n    luaL_addsize(B, l);\n  }\n}\n\n\nLUALIB_API void luaL_addstring (luaL_Buffer *B, const char *s) {\n  luaL_addlstring(B, s, strlen(s));\n}\n\n\nLUALIB_API void luaL_pushresult (luaL_Buffer *B) {\n  lua_State *L = B->L;\n  checkbufferlevel(B, -1);\n  if (!buffonstack(B))  /* using static buffer? */\n    lua_pushlstring(L, B->b, B->n);  /* save result as regular string */\n  else {  /* reuse buffer already allocated */\n    UBox *box = (UBox *)lua_touserdata(L, -1);\n    void *ud;\n    lua_Alloc allocf = lua_getallocf(L, &ud);  /* function to free buffer */\n    size_t len = B->n;  /* final string length */\n    char *s;\n    resizebox(L, -1, len + 1);  /* adjust box size to content size */\n    s = (char*)box->box;  /* final buffer address */\n    s[len] = '\\0';  /* add ending zero */\n    /* clear box, as 'lua_pushextlstring' will take control over buffer */\n    box->bsize = 0;  box->box = NULL;\n    lua_pushextlstring(L, s, len, allocf, ud);\n    lua_closeslot(L, -2);  /* close the box */\n  }\n  lua_remove(L, -2);  /* remove box or placeholder from the stack */\n}\n\n\nLUALIB_API void luaL_pushresultsize (luaL_Buffer *B, size_t sz) {\n  luaL_addsize(B, sz);\n  luaL_pushresult(B);\n}\n\n\n/*\n** 'luaL_addvalue' is the only function in the Buffer system where the\n** box (if existent) is not on the top of the stack. So, instead of\n** calling 'luaL_addlstring', it replicates the code using -2 as the\n** last argument to 'prepbuffsize', signaling that the box is (or will\n** be) below the string being added to the buffer. (Box creation can\n** trigger an emergency GC, so we should not remove the string from the\n** stack before we have the space guaranteed.)\n*/\nLUALIB_API void luaL_addvalue (luaL_Buffer *B) {\n  lua_State *L = B->L;\n  size_t len;\n  const char *s = lua_tolstring(L, -1, &len);\n  char *b = prepbuffsize(B, len, -2);\n  memcpy(b, s, len * sizeof(char));\n  luaL_addsize(B, len);\n  lua_pop(L, 1);  /* pop string */\n}\n\n\nLUALIB_API void luaL_buffinit (lua_State *L, luaL_Buffer *B) {\n  B->L = L;\n  B->b = B->init.b;\n  B->n = 0;\n  B->size = LUAL_BUFFERSIZE;\n  lua_pushlightuserdata(L, (void*)B);  /* push placeholder */\n}\n\n\nLUALIB_API char *luaL_buffinitsize (lua_State *L, luaL_Buffer *B, size_t sz) {\n  luaL_buffinit(L, B);\n  return prepbuffsize(B, sz, -1);\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Reference system\n** =======================================================\n*/\n\n/*\n** The previously freed references form a linked list: t[1] is the index\n** of a first free index, t[t[1]] is the index of the second element,\n** etc. A zero signals the end of the list.\n*/\nLUALIB_API int luaL_ref (lua_State *L, int t) {\n  int ref;\n  if (lua_isnil(L, -1)) {\n    lua_pop(L, 1);  /* remove from stack */\n    return LUA_REFNIL;  /* 'nil' has a unique fixed reference */\n  }\n  t = lua_absindex(L, t);\n  if (lua_rawgeti(L, t, 1) == LUA_TNUMBER)  /* already initialized? */\n    ref = (int)lua_tointeger(L, -1);  /* ref = t[1] */\n  else {  /* first access */\n    lua_assert(!lua_toboolean(L, -1));  /* must be nil or false */\n    ref = 0;  /* list is empty */\n    lua_pushinteger(L, 0);  /* initialize as an empty list */\n    lua_rawseti(L, t, 1);  /* ref = t[1] = 0 */\n  }\n  lua_pop(L, 1);  /* remove element from stack */\n  if (ref != 0) {  /* any free element? */\n    lua_rawgeti(L, t, ref);  /* remove it from list */\n    lua_rawseti(L, t, 1);  /* (t[1] = t[ref]) */\n  }\n  else  /* no free elements */\n    ref = (int)lua_rawlen(L, t) + 1;  /* get a new reference */\n  lua_rawseti(L, t, ref);\n  return ref;\n}\n\n\nLUALIB_API void luaL_unref (lua_State *L, int t, int ref) {\n  if (ref >= 0) {\n    t = lua_absindex(L, t);\n    lua_rawgeti(L, t, 1);\n    lua_assert(lua_isinteger(L, -1));\n    lua_rawseti(L, t, ref);  /* t[ref] = t[1] */\n    lua_pushinteger(L, ref);\n    lua_rawseti(L, t, 1);  /* t[1] = ref */\n  }\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Load functions\n** =======================================================\n*/\n\ntypedef struct LoadF {\n  int n;  /* number of pre-read characters */\n  FILE *f;  /* file being read */\n  char buff[BUFSIZ];  /* area for reading file */\n} LoadF;\n\n\nstatic const char *getF (lua_State *L, void *ud, size_t *size) {\n  LoadF *lf = (LoadF *)ud;\n  (void)L;  /* not used */\n  if (lf->n > 0) {  /* are there pre-read characters to be read? */\n    *size = lf->n;  /* return them (chars already in buffer) */\n    lf->n = 0;  /* no more pre-read characters */\n  }\n  else {  /* read a block from file */\n    /* 'fread' can return > 0 *and* set the EOF flag. If next call to\n       'getF' called 'fread', it might still wait for user input.\n       The next check avoids this problem. */\n    if (feof(lf->f)) return NULL;\n    *size = fread(lf->buff, 1, sizeof(lf->buff), lf->f);  /* read block */\n  }\n  return lf->buff;\n}\n\n\nstatic int errfile (lua_State *L, const char *what, int fnameindex) {\n  const char *serr = strerror(errno);\n  const char *filename = lua_tostring(L, fnameindex) + 1;\n  lua_pushfstring(L, \"cannot %s %s: %s\", what, filename, serr);\n  lua_remove(L, fnameindex);\n  return LUA_ERRFILE;\n}\n\n\n/*\n** Skip an optional BOM at the start of a stream. If there is an\n** incomplete BOM (the first character is correct but the rest is\n** not), returns the first character anyway to force an error\n** (as no chunk can start with 0xEF).\n*/\nstatic int skipBOM (FILE *f) {\n  int c = getc(f);  /* read first character */\n  if (c == 0xEF && getc(f) == 0xBB && getc(f) == 0xBF)  /* correct BOM? */\n    return getc(f);  /* ignore BOM and return next char */\n  else  /* no (valid) BOM */\n    return c;  /* return first character */\n}\n\n\n/*\n** reads the first character of file 'f' and skips an optional BOM mark\n** in its beginning plus its first line if it starts with '#'. Returns\n** true if it skipped the first line.  In any case, '*cp' has the\n** first \"valid\" character of the file (after the optional BOM and\n** a first-line comment).\n*/\nstatic int skipcomment (FILE *f, int *cp) {\n  int c = *cp = skipBOM(f);\n  if (c == '#') {  /* first line is a comment (Unix exec. file)? */\n    do {  /* skip first line */\n      c = getc(f);\n    } while (c != EOF && c != '\\n');\n    *cp = getc(f);  /* next character after comment, if present */\n    return 1;  /* there was a comment */\n  }\n  else return 0;  /* no comment */\n}\n\n\nLUALIB_API int luaL_loadfilex (lua_State *L, const char *filename,\n                                             const char *mode) {\n  LoadF lf;\n  int status, readstatus;\n  int c;\n  int fnameindex = lua_gettop(L) + 1;  /* index of filename on the stack */\n  if (filename == NULL) {\n    lua_pushliteral(L, \"=stdin\");\n    lf.f = stdin;\n  }\n  else {\n    lua_pushfstring(L, \"@%s\", filename);\n    lf.f = fopen(filename, \"r\");\n    if (lf.f == NULL) return errfile(L, \"open\", fnameindex);\n  }\n  lf.n = 0;\n  if (skipcomment(lf.f, &c))  /* read initial portion */\n    lf.buff[lf.n++] = '\\n';  /* add newline to correct line numbers */\n  if (c == LUA_SIGNATURE[0]) {  /* binary file? */\n    lf.n = 0;  /* remove possible newline */\n    if (filename) {  /* \"real\" file? */\n      lf.f = freopen(filename, \"rb\", lf.f);  /* reopen in binary mode */\n      if (lf.f == NULL) return errfile(L, \"reopen\", fnameindex);\n      skipcomment(lf.f, &c);  /* re-read initial portion */\n    }\n  }\n  if (c != EOF)\n    lf.buff[lf.n++] = c;  /* 'c' is the first character of the stream */\n  status = lua_load(L, getF, &lf, lua_tostring(L, -1), mode);\n  readstatus = ferror(lf.f);\n  if (filename) fclose(lf.f);  /* close file (even in case of errors) */\n  if (readstatus) {\n    lua_settop(L, fnameindex);  /* ignore results from 'lua_load' */\n    return errfile(L, \"read\", fnameindex);\n  }\n  lua_remove(L, fnameindex);\n  return status;\n}\n\n\ntypedef struct LoadS {\n  const char *s;\n  size_t size;\n} LoadS;\n\n\nstatic const char *getS (lua_State *L, void *ud, size_t *size) {\n  LoadS *ls = (LoadS *)ud;\n  (void)L;  /* not used */\n  if (ls->size == 0) return NULL;\n  *size = ls->size;\n  ls->size = 0;\n  return ls->s;\n}\n\n\nLUALIB_API int luaL_loadbufferx (lua_State *L, const char *buff, size_t size,\n                                 const char *name, const char *mode) {\n  LoadS ls;\n  ls.s = buff;\n  ls.size = size;\n  return lua_load(L, getS, &ls, name, mode);\n}\n\n\nLUALIB_API int luaL_loadstring (lua_State *L, const char *s) {\n  return luaL_loadbuffer(L, s, strlen(s), s);\n}\n\n/* }====================================================== */\n\n\n\nLUALIB_API int luaL_getmetafield (lua_State *L, int obj, const char *event) {\n  if (!lua_getmetatable(L, obj))  /* no metatable? */\n    return LUA_TNIL;\n  else {\n    int tt;\n    lua_pushstring(L, event);\n    tt = lua_rawget(L, -2);\n    if (tt == LUA_TNIL)  /* is metafield nil? */\n      lua_pop(L, 2);  /* remove metatable and metafield */\n    else\n      lua_remove(L, -2);  /* remove only metatable */\n    return tt;  /* return metafield type */\n  }\n}\n\n\nLUALIB_API int luaL_callmeta (lua_State *L, int obj, const char *event) {\n  obj = lua_absindex(L, obj);\n  if (luaL_getmetafield(L, obj, event) == LUA_TNIL)  /* no metafield? */\n    return 0;\n  lua_pushvalue(L, obj);\n  lua_call(L, 1, 1);\n  return 1;\n}\n\n\nLUALIB_API lua_Integer luaL_len (lua_State *L, int idx) {\n  lua_Integer l;\n  int isnum;\n  lua_len(L, idx);\n  l = lua_tointegerx(L, -1, &isnum);\n  if (l_unlikely(!isnum))\n    luaL_error(L, \"object length is not an integer\");\n  lua_pop(L, 1);  /* remove object */\n  return l;\n}\n\n\nLUALIB_API const char *luaL_tolstring (lua_State *L, int idx, size_t *len) {\n  idx = lua_absindex(L,idx);\n  if (luaL_callmeta(L, idx, \"__tostring\")) {  /* metafield? */\n    if (!lua_isstring(L, -1))\n      luaL_error(L, \"'__tostring' must return a string\");\n  }\n  else {\n    switch (lua_type(L, idx)) {\n      case LUA_TNUMBER: {\n        if (lua_isinteger(L, idx))\n          lua_pushfstring(L, \"%I\", (LUAI_UACINT)lua_tointeger(L, idx));\n        else\n          lua_pushfstring(L, \"%f\", (LUAI_UACNUMBER)lua_tonumber(L, idx));\n        break;\n      }\n      case LUA_TSTRING:\n        lua_pushvalue(L, idx);\n        break;\n      case LUA_TBOOLEAN:\n        lua_pushstring(L, (lua_toboolean(L, idx) ? \"true\" : \"false\"));\n        break;\n      case LUA_TNIL:\n        lua_pushliteral(L, \"nil\");\n        break;\n      default: {\n        int tt = luaL_getmetafield(L, idx, \"__name\");  /* try name */\n        const char *kind = (tt == LUA_TSTRING) ? lua_tostring(L, -1) :\n                                                 luaL_typename(L, idx);\n        lua_pushfstring(L, \"%s: %p\", kind, lua_topointer(L, idx));\n        if (tt != LUA_TNIL)\n          lua_remove(L, -2);  /* remove '__name' */\n        break;\n      }\n    }\n  }\n  return lua_tolstring(L, -1, len);\n}\n\n\n/*\n** set functions from list 'l' into table at top - 'nup'; each\n** function gets the 'nup' elements at the top as upvalues.\n** Returns with only the table at the stack.\n*/\nLUALIB_API void luaL_setfuncs (lua_State *L, const luaL_Reg *l, int nup) {\n  luaL_checkstack(L, nup, \"too many upvalues\");\n  for (; l->name != NULL; l++) {  /* fill the table with given functions */\n    if (l->func == NULL)  /* place holder? */\n      lua_pushboolean(L, 0);\n    else {\n      int i;\n      for (i = 0; i < nup; i++)  /* copy upvalues to the top */\n        lua_pushvalue(L, -nup);\n      lua_pushcclosure(L, l->func, nup);  /* closure with those upvalues */\n    }\n    lua_setfield(L, -(nup + 2), l->name);\n  }\n  lua_pop(L, nup);  /* remove upvalues */\n}\n\n\n/*\n** ensure that stack[idx][fname] has a table and push that table\n** into the stack\n*/\nLUALIB_API int luaL_getsubtable (lua_State *L, int idx, const char *fname) {\n  if (lua_getfield(L, idx, fname) == LUA_TTABLE)\n    return 1;  /* table already there */\n  else {\n    lua_pop(L, 1);  /* remove previous result */\n    idx = lua_absindex(L, idx);\n    lua_newtable(L);\n    lua_pushvalue(L, -1);  /* copy to be left at top */\n    lua_setfield(L, idx, fname);  /* assign new table to field */\n    return 0;  /* false, because did not find table there */\n  }\n}\n\n\n/*\n** Stripped-down 'require': After checking \"loaded\" table, calls 'openf'\n** to open a module, registers the result in 'package.loaded' table and,\n** if 'glb' is true, also registers the result in the global table.\n** Leaves resulting module on the top.\n*/\nLUALIB_API void luaL_requiref (lua_State *L, const char *modname,\n                               lua_CFunction openf, int glb) {\n  luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);\n  lua_getfield(L, -1, modname);  /* LOADED[modname] */\n  if (!lua_toboolean(L, -1)) {  /* package not already loaded? */\n    lua_pop(L, 1);  /* remove field */\n    lua_pushcfunction(L, openf);\n    lua_pushstring(L, modname);  /* argument to open function */\n    lua_call(L, 1, 1);  /* call 'openf' to open module */\n    lua_pushvalue(L, -1);  /* make copy of module (call result) */\n    lua_setfield(L, -3, modname);  /* LOADED[modname] = module */\n  }\n  lua_remove(L, -2);  /* remove LOADED table */\n  if (glb) {\n    lua_pushvalue(L, -1);  /* copy of module */\n    lua_setglobal(L, modname);  /* _G[modname] = module */\n  }\n}\n\n\nLUALIB_API void luaL_addgsub (luaL_Buffer *b, const char *s,\n                                     const char *p, const char *r) {\n  const char *wild;\n  size_t l = strlen(p);\n  while ((wild = strstr(s, p)) != NULL) {\n    luaL_addlstring(b, s, wild - s);  /* push prefix */\n    luaL_addstring(b, r);  /* push replacement in place of pattern */\n    s = wild + l;  /* continue after 'p' */\n  }\n  luaL_addstring(b, s);  /* push last suffix */\n}\n\n\nLUALIB_API const char *luaL_gsub (lua_State *L, const char *s,\n                                  const char *p, const char *r) {\n  luaL_Buffer b;\n  luaL_buffinit(L, &b);\n  luaL_addgsub(&b, s, p, r);\n  luaL_pushresult(&b);\n  return lua_tostring(L, -1);\n}\n\n\nstatic void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) {\n  (void)ud; (void)osize;  /* not used */\n  if (nsize == 0) {\n    free(ptr);\n    return NULL;\n  }\n  else\n    return realloc(ptr, nsize);\n}\n\n\n/*\n** Standard panic funcion just prints an error message. The test\n** with 'lua_type' avoids possible memory errors in 'lua_tostring'.\n*/\nstatic int panic (lua_State *L) {\n  const char *msg = (lua_type(L, -1) == LUA_TSTRING)\n                  ? lua_tostring(L, -1)\n                  : \"private_lua_error object is not a string\";\n  lua_writestringerror(\"PANIC: unprotected private_lua_error in call to Lua API (%s)\\n\",\n                        msg);\n  return 0;  /* return to Lua to abort */\n}\n\n\n/*\n** Warning functions:\n** warnfoff: warning system is off\n** warnfon: ready to start a new message\n** warnfcont: previous message is to be continued\n*/\nstatic void warnfoff (void *ud, const char *message, int tocont);\nstatic void warnfon (void *ud, const char *message, int tocont);\nstatic void warnfcont (void *ud, const char *message, int tocont);\n\n\n/*\n** Check whether message is a control message. If so, execute the\n** control or ignore it if unknown.\n*/\nstatic int checkcontrol (lua_State *L, const char *message, int tocont) {\n  if (tocont || *(message++) != '@')  /* not a control message? */\n    return 0;\n  else {\n    if (strcmp(message, \"off\") == 0)\n      lua_setwarnf(L, warnfoff, L);  /* turn warnings off */\n    else if (strcmp(message, \"on\") == 0)\n      lua_setwarnf(L, warnfon, L);   /* turn warnings on */\n    return 1;  /* it was a control message */\n  }\n}\n\n\nstatic void warnfoff (void *ud, const char *message, int tocont) {\n  checkcontrol((lua_State *)ud, message, tocont);\n}\n\n\n/*\n** Writes the message and handle 'tocont', finishing the message\n** if needed and setting the next warn function.\n*/\nstatic void warnfcont (void *ud, const char *message, int tocont) {\n  lua_State *L = (lua_State *)ud;\n  lua_writestringerror(\"%s\", message);  /* write message */\n  if (tocont)  /* not the last part? */\n    lua_setwarnf(L, warnfcont, L);  /* to be continued */\n  else {  /* last part */\n    lua_writestringerror(\"%s\", \"\\n\");  /* finish message with end-of-line */\n    lua_setwarnf(L, warnfon, L);  /* next call is a new message */\n  }\n}\n\n\nstatic void warnfon (void *ud, const char *message, int tocont) {\n  if (checkcontrol((lua_State *)ud, message, tocont))  /* control message? */\n    return;  /* nothing else to be done */\n  lua_writestringerror(\"%s\", \"Lua warning: \");  /* start a new warning */\n  warnfcont(ud, message, tocont);  /* finish processing */\n}\n\n\n\n/*\n** A function to compute an unsigned int with some level of\n** randomness. Rely on Address Space Layout Randomization (if present)\n** and the current time.\n*/\n#if !defined(luai_makeseed)\n\n#include <time.h>\n\n\n/* Size for the buffer, in bytes */\n#define BUFSEEDB\t(sizeof(void*) + sizeof(time_t))\n\n/* Size for the buffer in int's, rounded up */\n#define BUFSEED\t\t((BUFSEEDB + sizeof(int) - 1) / sizeof(int))\n\n/*\n** Copy the contents of variable 'v' into the buffer pointed by 'b'.\n** (The '&b[0]' disguises 'b' to fix an absurd warning from clang.)\n*/\n#define addbuff(b,v)\t(memcpy(&b[0], &(v), sizeof(v)), b += sizeof(v))\n\n\nstatic unsigned int luai_makeseed (void) {\n  unsigned int buff[BUFSEED];\n  unsigned int res;\n  unsigned int i;\n  time_t t = time(NULL);\n  char *b = (char*)buff;\n  addbuff(b, b);  /* local variable's address */\n  addbuff(b, t);  /* time */\n  /* fill (rare but possible) remain of the buffer with zeros */\n  memset(b, 0, sizeof(buff) - BUFSEEDB);\n  res = buff[0];\n  for (i = 1; i < BUFSEED; i++)\n    res ^= (res >> 3) + (res << 7) + buff[i];\n  return res;\n}\n\n#endif\n\n\nLUALIB_API unsigned int luaL_makeseed (lua_State *L) {\n  (void)L;  /* unused */\n  return luai_makeseed();\n}\n\n\nLUALIB_API lua_State *luaL_newstate (void) {\n  lua_State *L = lua_newstate(l_alloc, NULL, luai_makeseed());\n  if (l_likely(L)) {\n    lua_atpanic(L, &panic);\n    lua_setwarnf(L, warnfoff, L);  /* default is warnings off */\n  }\n  return L;\n}\n\n\nLUALIB_API void luaL_checkversion_ (lua_State *L, lua_Number ver, size_t sz) {\n  lua_Number v = lua_version(L);\n  if (sz != LUAL_NUMSIZES)  /* check numeric types */\n    luaL_error(L, \"core and library have incompatible numeric types\");\n  else if (v != ver)\n    luaL_error(L, \"version mismatch: app. needs %f, Lua core provides %f\",\n                  (LUAI_UACNUMBER)ver, (LUAI_UACNUMBER)v);\n}\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lauxlib.h",
		"is_binary":	false,
		"content":	"/*\n** $Id: lauxlib.h $\n** Auxiliary functions for building Lua libraries\n** See Copyright Notice in lua.h\n*/\n\n\n#ifndef lauxlib_h\n#define lauxlib_h\n\n\n#include <stddef.h>\n#include <stdio.h>\n\n#include \"luaconf.h\"\n#include \"lua.h\"\n\n\n/* global table */\n#define LUA_GNAME\t\"_G\"\n\n\ntypedef struct luaL_Buffer luaL_Buffer;\n\n\n/* extra error code for 'luaL_loadfilex' */\n#define LUA_ERRFILE     (LUA_ERRERR+1)\n\n\n/* key, in the registry, for table of loaded modules */\n#define LUA_LOADED_TABLE\t\"_LOADED\"\n\n\n/* key, in the registry, for table of preloaded loaders */\n#define LUA_PRELOAD_TABLE\t\"_PRELOAD\"\n\n\ntypedef struct luaL_Reg {\n  const char *name;\n  lua_CFunction func;\n} luaL_Reg;\n\n\n#define LUAL_NUMSIZES\t(sizeof(lua_Integer)*16 + sizeof(lua_Number))\n\nLUALIB_API void (luaL_checkversion_) (lua_State *L, lua_Number ver, size_t sz);\n#define luaL_checkversion(L)  \\\n\t  luaL_checkversion_(L, LUA_VERSION_NUM, LUAL_NUMSIZES)\n\nLUALIB_API int (luaL_getmetafield) (lua_State *L, int obj, const char *e);\nLUALIB_API int (luaL_callmeta) (lua_State *L, int obj, const char *e);\nLUALIB_API const char *(luaL_tolstring) (lua_State *L, int idx, size_t *len);\nLUALIB_API int (luaL_argerror) (lua_State *L, int arg, const char *extramsg);\nLUALIB_API int (luaL_typeerror) (lua_State *L, int arg, const char *tname);\nLUALIB_API const char *(luaL_checklstring) (lua_State *L, int arg,\n                                                          size_t *l);\nLUALIB_API const char *(luaL_optlstring) (lua_State *L, int arg,\n                                          const char *def, size_t *l);\nLUALIB_API lua_Number (luaL_checknumber) (lua_State *L, int arg);\nLUALIB_API lua_Number (luaL_optnumber) (lua_State *L, int arg, lua_Number def);\n\nLUALIB_API lua_Integer (luaL_checkinteger) (lua_State *L, int arg);\nLUALIB_API lua_Integer (luaL_optinteger) (lua_State *L, int arg,\n                                          lua_Integer def);\n\nLUALIB_API void (luaL_checkstack) (lua_State *L, int sz, const char *msg);\nLUALIB_API void (luaL_checktype) (lua_State *L, int arg, int t);\nLUALIB_API void (luaL_checkany) (lua_State *L, int arg);\n\nLUALIB_API int   (luaL_newmetatable) (lua_State *L, const char *tname);\nLUALIB_API void  (luaL_setmetatable) (lua_State *L, const char *tname);\nLUALIB_API void *(luaL_testudata) (lua_State *L, int ud, const char *tname);\nLUALIB_API void *(luaL_checkudata) (lua_State *L, int ud, const char *tname);\n\nLUALIB_API void (luaL_where) (lua_State *L, int lvl);\nLUALIB_API int (luaL_error) (lua_State *L, const char *fmt, ...);\n\nLUALIB_API int (luaL_checkoption) (lua_State *L, int arg, const char *def,\n                                   const char *const lst[]);\n\nLUALIB_API int (luaL_fileresult) (lua_State *L, int stat, const char *fname);\nLUALIB_API int (luaL_execresult) (lua_State *L, int stat);\n\n\n/* predefined references */\n#define LUA_NOREF       (-2)\n#define LUA_REFNIL      (-1)\n\nLUALIB_API int (luaL_ref) (lua_State *L, int t);\nLUALIB_API void (luaL_unref) (lua_State *L, int t, int ref);\n\nLUALIB_API int (luaL_loadfilex) (lua_State *L, const char *filename,\n                                               const char *mode);\n\n#define luaL_loadfile(L,f)\tluaL_loadfilex(L,f,NULL)\n\nLUALIB_API int (luaL_loadbufferx) (lua_State *L, const char *buff, size_t sz,\n                                   const char *name, const char *mode);\nLUALIB_API int (luaL_loadstring) (lua_State *L, const char *s);\n\nLUALIB_API lua_State *(luaL_newstate) (void);\n\nLUALIB_API unsigned luaL_makeseed (lua_State *L);\n\nLUALIB_API lua_Integer (luaL_len) (lua_State *L, int idx);\n\nLUALIB_API void (luaL_addgsub) (luaL_Buffer *b, const char *s,\n                                     const char *p, const char *r);\nLUALIB_API const char *(luaL_gsub) (lua_State *L, const char *s,\n                                    const char *p, const char *r);\n\nLUALIB_API void (luaL_setfuncs) (lua_State *L, const luaL_Reg *l, int nup);\n\nLUALIB_API int (luaL_getsubtable) (lua_State *L, int idx, const char *fname);\n\nLUALIB_API void (luaL_traceback) (lua_State *L, lua_State *L1,\n                                  const char *msg, int level);\n\nLUALIB_API void (luaL_requiref) (lua_State *L, const char *modname,\n                                 lua_CFunction openf, int glb);\n\n/*\n** ===============================================================\n** some useful macros\n** ===============================================================\n*/\n\n\n#define luaL_newlibtable(L,l)\t\\\n  lua_createtable(L, 0, sizeof(l)/sizeof((l)[0]) - 1)\n\n#define luaL_newlib(L,l)  \\\n  (luaL_checkversion(L), luaL_newlibtable(L,l), luaL_setfuncs(L,l,0))\n\n#define luaL_argcheck(L, cond,arg,extramsg)\t\\\n\t((void)(luai_likely(cond) || luaL_argerror(L, (arg), (extramsg))))\n\n#define luaL_argexpected(L,cond,arg,tname)\t\\\n\t((void)(luai_likely(cond) || luaL_typeerror(L, (arg), (tname))))\n\n#define luaL_checkstring(L,n)\t(luaL_checklstring(L, (n), NULL))\n#define luaL_optstring(L,n,d)\t(luaL_optlstring(L, (n), (d), NULL))\n\n#define luaL_typename(L,i)\tlua_typename(L, lua_type(L,(i)))\n\n#define luaL_dofile(L, fn) \\\n\t(luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))\n\n#define luaL_dostring(L, s) \\\n\t(luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))\n\n#define luaL_getmetatable(L,n)\t(lua_getfield(L, LUA_REGISTRYINDEX, (n)))\n\n#define luaL_opt(L,f,n,d)\t(lua_isnoneornil(L,(n)) ? (d) : f(L,(n)))\n\n#define luaL_loadbuffer(L,s,sz,n)\tluaL_loadbufferx(L,s,sz,n,NULL)\n\n\n/*\n** Perform arithmetic operations on lua_Integer values with wrap-around\n** semantics, as the Lua core does.\n*/\n#define luaL_intop(op,v1,v2)  \\\n\t((lua_Integer)((lua_Unsigned)(v1) op (lua_Unsigned)(v2)))\n\n\n/* push the value used to represent failure/error */\n#define luaL_pushfail(L)\tlua_pushnil(L)\n\n\n/*\n** Internal assertions for in-house debugging\n*/\n#if !defined(lua_assert)\n\n#if defined LUAI_ASSERT\n  #include <assert.h>\n  #define lua_assert(c)\t\tassert(c)\n#else\n  #define lua_assert(c)\t\t((void)0)\n#endif\n\n#endif\n\n\n\n/*\n** {======================================================\n** Generic Buffer manipulation\n** =======================================================\n*/\n\nstruct luaL_Buffer {\n  char *b;  /* buffer address */\n  size_t size;  /* buffer size */\n  size_t n;  /* number of characters in buffer */\n  lua_State *L;\n  union {\n    LUAI_MAXALIGN;  /* ensure maximum alignment for buffer */\n    char b[LUAL_BUFFERSIZE];  /* initial buffer */\n  } init;\n};\n\n\n#define luaL_bufflen(bf)\t((bf)->n)\n#define luaL_buffaddr(bf)\t((bf)->b)\n\n\n#define luaL_addchar(B,c) \\\n  ((void)((B)->n < (B)->size || luaL_prepbuffsize((B), 1)), \\\n   ((B)->b[(B)->n++] = (c)))\n\n#define luaL_addsize(B,s)\t((B)->n += (s))\n\n#define luaL_buffsub(B,s)\t((B)->n -= (s))\n\nLUALIB_API void (luaL_buffinit) (lua_State *L, luaL_Buffer *B);\nLUALIB_API char *(luaL_prepbuffsize) (luaL_Buffer *B, size_t sz);\nLUALIB_API void (luaL_addlstring) (luaL_Buffer *B, const char *s, size_t l);\nLUALIB_API void (luaL_addstring) (luaL_Buffer *B, const char *s);\nLUALIB_API void (luaL_addvalue) (luaL_Buffer *B);\nLUALIB_API void (luaL_pushresult) (luaL_Buffer *B);\nLUALIB_API void (luaL_pushresultsize) (luaL_Buffer *B, size_t sz);\nLUALIB_API char *(luaL_buffinitsize) (lua_State *L, luaL_Buffer *B, size_t sz);\n\n#define luaL_prepbuffer(B)\tluaL_prepbuffsize(B, LUAL_BUFFERSIZE)\n\n/* }====================================================== */\n\n\n\n/*\n** {======================================================\n** File handles for IO library\n** =======================================================\n*/\n\n/*\n** A file handle is a userdata with metatable 'LUA_FILEHANDLE' and\n** initial structure 'luaL_Stream' (it may contain other fields\n** after that initial structure).\n*/\n\n#define LUA_FILEHANDLE          \"FILE*\"\n\n\ntypedef struct luaL_Stream {\n  FILE *f;  /* stream (NULL for incompletely created streams) */\n  lua_CFunction closef;  /* to close stream (NULL for closed streams) */\n} luaL_Stream;\n\n/* }====================================================== */\n\n/*\n** {==================================================================\n** \"Abstraction Layer\" for basic report of messages and errors\n** ===================================================================\n*/\n\n/* print a string */\n#if !defined(lua_writestring)\n#define lua_writestring(s,l)   fwrite((s), sizeof(char), (l), stdout)\n#endif\n\n/* print a newline and flush the output */\n#if !defined(lua_writeline)\n#define lua_writeline()        (lua_writestring(\"\\n\", 1), fflush(stdout))\n#endif\n\n/* print an error message */\n#if !defined(lua_writestringerror)\n#define lua_writestringerror(s,p) \\\n        (fprintf(stderr, (s), (p)), fflush(stderr))\n#endif\n\n/* }================================================================== */\n\n\n/*\n** {============================================================\n** Compatibility with deprecated conversions\n** =============================================================\n*/\n#if defined(LUA_COMPAT_APIINTCASTS)\n\n#define luaL_checkunsigned(L,a)\t((lua_Unsigned)luaL_checkinteger(L,a))\n#define luaL_optunsigned(L,a,d)\t\\\n\t((lua_Unsigned)luaL_optinteger(L,a,(lua_Integer)(d)))\n\n#define luaL_checkint(L,n)\t((int)luaL_checkinteger(L, (n)))\n#define luaL_optint(L,n,d)\t((int)luaL_optinteger(L, (n), (d)))\n\n#define luaL_checklong(L,n)\t((long)luaL_checkinteger(L, (n)))\n#define luaL_optlong(L,n,d)\t((long)luaL_optinteger(L, (n), (d)))\n\n#endif\n/* }============================================================ */\n\n\n\n#endif\n\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lbaselib.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: lbaselib.c $\n** Basic library\n** See Copyright Notice in lua.h\n*/\n\n#define lbaselib_c\n#define LUA_LIB\n\n#include \"lprefix.h\"\n\n\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n\n\nstatic int luaB_print (lua_State *L) {\n  int n = lua_gettop(L);  /* number of arguments */\n  int i;\n  for (i = 1; i <= n; i++) {  /* for each argument */\n    size_t l;\n    const char *s = luaL_tolstring(L, i, &l);  /* convert it to string */\n    if (i > 1)  /* not the first element? */\n      lua_writestring(\"\\t\", 1);  /* add a tab before it */\n    lua_writestring(s, l);  /* print it */\n    lua_pop(L, 1);  /* pop result */\n  }\n  lua_writeline();\n  return 0;\n}\n\n\n/*\n** Creates a warning with all given arguments.\n** Check first for errors; otherwise an error may interrupt\n** the composition of a warning, leaving it unfinished.\n*/\nstatic int luaB_warn (lua_State *L) {\n  int n = lua_gettop(L);  /* number of arguments */\n  int i;\n  luaL_checkstring(L, 1);  /* at least one argument */\n  for (i = 2; i <= n; i++)\n    luaL_checkstring(L, i);  /* make sure all arguments are strings */\n  for (i = 1; i < n; i++)  /* compose warning */\n    lua_warning(L, lua_tostring(L, i), 1);\n  lua_warning(L, lua_tostring(L, n), 0);  /* close warning */\n  return 0;\n}\n\n\n#define SPACECHARS\t\" \\f\\n\\r\\t\\v\"\n\nstatic const char *b_str2int (const char *s, int base, lua_Integer *pn) {\n  lua_Unsigned n = 0;\n  int neg = 0;\n  s += strspn(s, SPACECHARS);  /* skip initial spaces */\n  if (*s == '-') { s++; neg = 1; }  /* handle sign */\n  else if (*s == '+') s++;\n  if (!isalnum((unsigned char)*s))  /* no digit? */\n    return NULL;\n  do {\n    int digit = (isdigit((unsigned char)*s)) ? *s - '0'\n                   : (toupper((unsigned char)*s) - 'A') + 10;\n    if (digit >= base) return NULL;  /* invalid numeral */\n    n = n * base + digit;\n    s++;\n  } while (isalnum((unsigned char)*s));\n  s += strspn(s, SPACECHARS);  /* skip trailing spaces */\n  *pn = (lua_Integer)((neg) ? (0u - n) : n);\n  return s;\n}\n\n\nstatic int luaB_tonumber (lua_State *L) {\n  if (lua_isnoneornil(L, 2)) {  /* standard conversion? */\n    if (lua_type(L, 1) == LUA_TNUMBER) {  /* already a number? */\n      lua_settop(L, 1);  /* yes; return it */\n      return 1;\n    }\n    else {\n      size_t l;\n      const char *s = lua_tolstring(L, 1, &l);\n      if (s != NULL && lua_stringtonumber(L, s) == l + 1)\n        return 1;  /* successful conversion to number */\n      /* else not a number */\n      luaL_checkany(L, 1);  /* (but there must be some parameter) */\n    }\n  }\n  else {\n    size_t l;\n    const char *s;\n    lua_Integer n = 0;  /* to avoid warnings */\n    lua_Integer base = luaL_checkinteger(L, 2);\n    luaL_checktype(L, 1, LUA_TSTRING);  /* no numbers as strings */\n    s = lua_tolstring(L, 1, &l);\n    luaL_argcheck(L, 2 <= base && base <= 36, 2, \"base out of range\");\n    if (b_str2int(s, (int)base, &n) == s + l) {\n      lua_pushinteger(L, n);\n      return 1;\n    }  /* else not a number */\n  }  /* else not a number */\n  luaL_pushfail(L);  /* not a number */\n  return 1;\n}\n\n\nstatic int luaB_error (lua_State *L) {\n  int level = (int)luaL_optinteger(L, 2, 1);\n  lua_settop(L, 1);\n  if (lua_type(L, 1) == LUA_TSTRING && level > 0) {\n    luaL_where(L, level);   /* add extra information */\n    lua_pushvalue(L, 1);\n    lua_concat(L, 2);\n  }\n  return lua_error(L);\n}\n\n\nstatic int luaB_getmetatable (lua_State *L) {\n  luaL_checkany(L, 1);\n  if (!lua_getmetatable(L, 1)) {\n    lua_pushnil(L);\n    return 1;  /* no metatable */\n  }\n  luaL_getmetafield(L, 1, \"__metatable\");\n  return 1;  /* returns either __metatable field (if present) or metatable */\n}\n\n\nstatic int luaB_setmetatable (lua_State *L) {\n  int t = lua_type(L, 2);\n  luaL_checktype(L, 1, LUA_TTABLE);\n  luaL_argexpected(L, t == LUA_TNIL || t == LUA_TTABLE, 2, \"nil or table\");\n  if (l_unlikely(luaL_getmetafield(L, 1, \"__metatable\") != LUA_TNIL))\n    return luaL_error(L, \"cannot change a protected metatable\");\n  lua_settop(L, 2);\n  lua_setmetatable(L, 1);\n  return 1;\n}\n\n\nstatic int luaB_rawequal (lua_State *L) {\n  luaL_checkany(L, 1);\n  luaL_checkany(L, 2);\n  lua_pushboolean(L, lua_rawequal(L, 1, 2));\n  return 1;\n}\n\n\nstatic int luaB_rawlen (lua_State *L) {\n  int t = lua_type(L, 1);\n  luaL_argexpected(L, t == LUA_TTABLE || t == LUA_TSTRING, 1,\n                      \"table or string\");\n  lua_pushinteger(L, lua_rawlen(L, 1));\n  return 1;\n}\n\n\nstatic int luaB_rawget (lua_State *L) {\n  luaL_checktype(L, 1, LUA_TTABLE);\n  luaL_checkany(L, 2);\n  lua_settop(L, 2);\n  lua_rawget(L, 1);\n  return 1;\n}\n\nstatic int luaB_rawset (lua_State *L) {\n  luaL_checktype(L, 1, LUA_TTABLE);\n  luaL_checkany(L, 2);\n  luaL_checkany(L, 3);\n  lua_settop(L, 3);\n  lua_rawset(L, 1);\n  return 1;\n}\n\n\nstatic int pushmode (lua_State *L, int oldmode) {\n  if (oldmode == -1)\n    luaL_pushfail(L);  /* invalid call to 'lua_gc' */\n  else\n    lua_pushstring(L, (oldmode == LUA_GCINC) ? \"incremental\"\n                                             : \"generational\");\n  return 1;\n}\n\n\n/*\n** check whether call to 'lua_gc' was valid (not inside a finalizer)\n*/\n#define checkvalres(res) { if (res == -1) break; }\n\nstatic int luaB_collectgarbage (lua_State *L) {\n  static const char *const opts[] = {\"stop\", \"restart\", \"collect\",\n    \"count\", \"step\", \"isrunning\", \"generational\", \"incremental\",\n    \"param\", NULL};\n  static const char optsnum[] = {LUA_GCSTOP, LUA_GCRESTART, LUA_GCCOLLECT,\n    LUA_GCCOUNT, LUA_GCSTEP, LUA_GCISRUNNING, LUA_GCGEN, LUA_GCINC,\n    LUA_GCPARAM};\n  int o = optsnum[luaL_checkoption(L, 1, \"collect\", opts)];\n  switch (o) {\n    case LUA_GCCOUNT: {\n      int k = lua_gc(L, o);\n      int b = lua_gc(L, LUA_GCCOUNTB);\n      checkvalres(k);\n      lua_pushnumber(L, (lua_Number)k + ((lua_Number)b/1024));\n      return 1;\n    }\n    case LUA_GCSTEP: {\n      lua_Integer n = luaL_optinteger(L, 2, 0);\n      int res = lua_gc(L, o, (int)n);\n      checkvalres(res);\n      lua_pushboolean(L, res);\n      return 1;\n    }\n    case LUA_GCISRUNNING: {\n      int res = lua_gc(L, o);\n      checkvalres(res);\n      lua_pushboolean(L, res);\n      return 1;\n    }\n    case LUA_GCGEN: {\n      return pushmode(L, lua_gc(L, o));\n    }\n    case LUA_GCINC: {\n      return pushmode(L, lua_gc(L, o));\n    }\n    case LUA_GCPARAM: {\n      static const char *const params[] = {\n        \"minormul\", \"majorminor\", \"minormajor\",\n        \"pause\", \"stepmul\", \"stepsize\", NULL};\n      static const char pnum[] = {\n        LUA_GCPMINORMUL, LUA_GCPMAJORMINOR, LUA_GCPMINORMAJOR,\n        LUA_GCPPAUSE, LUA_GCPSTEPMUL, LUA_GCPSTEPSIZE};\n      int p = pnum[luaL_checkoption(L, 2, NULL, params)];\n      lua_Integer value = luaL_optinteger(L, 3, -1);\n      lua_pushinteger(L, lua_gc(L, o, p, (int)value));\n      return 1;\n    }\n    default: {\n      int res = lua_gc(L, o);\n      checkvalres(res);\n      lua_pushinteger(L, res);\n      return 1;\n    }\n  }\n  luaL_pushfail(L);  /* invalid call (inside a finalizer) */\n  return 1;\n}\n\n\nstatic int luaB_type (lua_State *L) {\n  int t = lua_type(L, 1);\n  luaL_argcheck(L, t != LUA_TNONE, 1, \"value expected\");\n  lua_pushstring(L, lua_typename(L, t));\n  return 1;\n}\n\n\nstatic int luaB_next (lua_State *L) {\n  luaL_checktype(L, 1, LUA_TTABLE);\n  lua_settop(L, 2);  /* create a 2nd argument if there isn't one */\n  if (lua_next(L, 1))\n    return 2;\n  else {\n    lua_pushnil(L);\n    return 1;\n  }\n}\n\n\nstatic int pairscont (lua_State *L, int status, lua_KContext k) {\n  (void)L; (void)status; (void)k;  /* unused */\n  return 3;\n}\n\nstatic int luaB_pairs (lua_State *L) {\n  luaL_checkany(L, 1);\n  if (luaL_getmetafield(L, 1, \"__pairs\") == LUA_TNIL) {  /* no metamethod? */\n    lua_pushcfunction(L, luaB_next);  /* will return generator, */\n    lua_pushvalue(L, 1);  /* state, */\n    lua_pushnil(L);  /* and initial value */\n  }\n  else {\n    lua_pushvalue(L, 1);  /* argument 'self' to metamethod */\n    lua_callk(L, 1, 3, 0, pairscont);  /* get 3 values from metamethod */\n  }\n  return 3;\n}\n\n\n/*\n** Traversal function for 'ipairs'\n*/\nstatic int ipairsaux (lua_State *L) {\n  lua_Integer i = luaL_checkinteger(L, 2);\n  i = luaL_intop(+, i, 1);\n  lua_pushinteger(L, i);\n  return (lua_geti(L, 1, i) == LUA_TNIL) ? 1 : 2;\n}\n\n\n/*\n** 'ipairs' function. Returns 'ipairsaux', given \"table\", 0.\n** (The given \"table\" may not be a table.)\n*/\nstatic int luaB_ipairs (lua_State *L) {\n  luaL_checkany(L, 1);\n  lua_pushcfunction(L, ipairsaux);  /* iteration function */\n  lua_pushvalue(L, 1);  /* state */\n  lua_pushinteger(L, 0);  /* initial value */\n  return 3;\n}\n\n\nstatic int load_aux (lua_State *L, int status, int envidx) {\n  if (l_likely(status == LUA_OK)) {\n    if (envidx != 0) {  /* 'env' parameter? */\n      lua_pushvalue(L, envidx);  /* environment for loaded function */\n      if (!lua_setupvalue(L, -2, 1))  /* set it as 1st upvalue */\n        lua_pop(L, 1);  /* remove 'env' if not used by previous call */\n    }\n    return 1;\n  }\n  else {  /* error (message is on top of the stack) */\n    luaL_pushfail(L);\n    lua_insert(L, -2);  /* put before error message */\n    return 2;  /* return fail plus error message */\n  }\n}\n\n\nstatic const char *getmode (lua_State *L, int idx) {\n  const char *mode = luaL_optstring(L, idx, \"bt\");\n  if (strchr(mode, 'B') != NULL)  /* Lua code cannot use fixed buffers */\n    luaL_argerror(L, idx, \"invalid mode\");\n  return mode;\n}\n\n\nstatic int luaB_loadfile (lua_State *L) {\n  const char *fname = luaL_optstring(L, 1, NULL);\n  const char *mode = getmode(L, 2);\n  int env = (!lua_isnone(L, 3) ? 3 : 0);  /* 'env' index or 0 if no 'env' */\n  int status = luaL_loadfilex(L, fname, mode);\n  return load_aux(L, status, env);\n}\n\n\n/*\n** {======================================================\n** Generic Read function\n** =======================================================\n*/\n\n\n/*\n** reserved slot, above all arguments, to hold a copy of the returned\n** string to avoid it being collected while parsed. 'load' has four\n** optional arguments (chunk, source name, mode, and environment).\n*/\n#define RESERVEDSLOT\t5\n\n\n/*\n** Reader for generic 'load' function: 'lua_load' uses the\n** stack for internal stuff, so the reader cannot change the\n** stack top. Instead, it keeps its resulting string in a\n** reserved slot inside the stack.\n*/\nstatic const char *generic_reader (lua_State *L, void *ud, size_t *size) {\n  (void)(ud);  /* not used */\n  luaL_checkstack(L, 2, \"too many nested functions\");\n  lua_pushvalue(L, 1);  /* get function */\n  lua_call(L, 0, 1);  /* call it */\n  if (lua_isnil(L, -1)) {\n    lua_pop(L, 1);  /* pop result */\n    *size = 0;\n    return NULL;\n  }\n  else if (l_unlikely(!lua_isstring(L, -1)))\n    luaL_error(L, \"reader function must return a string\");\n  lua_replace(L, RESERVEDSLOT);  /* save string in reserved slot */\n  return lua_tolstring(L, RESERVEDSLOT, size);\n}\n\n\nstatic int luaB_load (lua_State *L) {\n  int status;\n  size_t l;\n  const char *s = lua_tolstring(L, 1, &l);\n  const char *mode = getmode(L, 3);\n  int env = (!lua_isnone(L, 4) ? 4 : 0);  /* 'env' index or 0 if no 'env' */\n  if (s != NULL) {  /* loading a string? */\n    const char *chunkname = luaL_optstring(L, 2, s);\n    status = luaL_loadbufferx(L, s, l, chunkname, mode);\n  }\n  else {  /* loading from a reader function */\n    const char *chunkname = luaL_optstring(L, 2, \"=(load)\");\n    luaL_checktype(L, 1, LUA_TFUNCTION);\n    lua_settop(L, RESERVEDSLOT);  /* create reserved slot */\n    status = lua_load(L, generic_reader, NULL, chunkname, mode);\n  }\n  return load_aux(L, status, env);\n}\n\n/* }====================================================== */\n\n\nstatic int dofilecont (lua_State *L, int d1, lua_KContext d2) {\n  (void)d1;  (void)d2;  /* only to match 'lua_Kfunction' prototype */\n  return lua_gettop(L) - 1;\n}\n\n\nstatic int luaB_dofile (lua_State *L) {\n  const char *fname = luaL_optstring(L, 1, NULL);\n  lua_settop(L, 1);\n  if (l_unlikely(luaL_loadfile(L, fname) != LUA_OK))\n    return lua_error(L);\n  lua_callk(L, 0, LUA_MULTRET, 0, dofilecont);\n  return dofilecont(L, 0, 0);\n}\n\n\nstatic int luaB_assert (lua_State *L) {\n  if (l_likely(lua_toboolean(L, 1)))  /* condition is true? */\n    return lua_gettop(L);  /* return all arguments */\n  else {  /* error */\n    luaL_checkany(L, 1);  /* there must be a condition */\n    lua_remove(L, 1);  /* remove it */\n    lua_pushliteral(L, \"assertion failed!\");  /* default message */\n    lua_settop(L, 1);  /* leave only message (default if no other one) */\n    return luaB_error(L);  /* call 'error' */\n  }\n}\n\n\nstatic int luaB_select (lua_State *L) {\n  int n = lua_gettop(L);\n  if (lua_type(L, 1) == LUA_TSTRING && *lua_tostring(L, 1) == '#') {\n    lua_pushinteger(L, n-1);\n    return 1;\n  }\n  else {\n    lua_Integer i = luaL_checkinteger(L, 1);\n    if (i < 0) i = n + i;\n    else if (i > n) i = n;\n    luaL_argcheck(L, 1 <= i, 1, \"index out of range\");\n    return n - (int)i;\n  }\n}\n\n\n/*\n** Continuation function for 'pcall' and 'xpcall'. Both functions\n** already pushed a 'true' before doing the call, so in case of success\n** 'finishpcall' only has to return everything in the stack minus\n** 'extra' values (where 'extra' is exactly the number of items to be\n** ignored).\n*/\nstatic int finishpcall (lua_State *L, int status, lua_KContext extra) {\n  if (l_unlikely(status != LUA_OK && status != LUA_YIELD)) {  /* error? */\n    lua_pushboolean(L, 0);  /* first result (false) */\n    lua_pushvalue(L, -2);  /* error message */\n    return 2;  /* return false, msg */\n  }\n  else\n    return lua_gettop(L) - (int)extra;  /* return all results */\n}\n\n\nstatic int luaB_pcall (lua_State *L) {\n  int status;\n  luaL_checkany(L, 1);\n  lua_pushboolean(L, 1);  /* first result if no errors */\n  lua_insert(L, 1);  /* put it in place */\n  status = lua_pcallk(L, lua_gettop(L) - 2, LUA_MULTRET, 0, 0, finishpcall);\n  return finishpcall(L, status, 0);\n}\n\n\n/*\n** Do a protected call with error handling. After 'lua_rotate', the\n** stack will have <f, err, true, f, [args...]>; so, the function passes\n** 2 to 'finishpcall' to skip the 2 first values when returning results.\n*/\nstatic int luaB_xpcall (lua_State *L) {\n  int status;\n  int n = lua_gettop(L);\n  luaL_checktype(L, 2, LUA_TFUNCTION);  /* check error function */\n  lua_pushboolean(L, 1);  /* first result */\n  lua_pushvalue(L, 1);  /* function */\n  lua_rotate(L, 3, 2);  /* move them below function's arguments */\n  status = lua_pcallk(L, n - 2, LUA_MULTRET, 2, 2, finishpcall);\n  return finishpcall(L, status, 2);\n}\n\n\nstatic int luaB_tostring (lua_State *L) {\n  luaL_checkany(L, 1);\n  luaL_tolstring(L, 1, NULL);\n  return 1;\n}\n\n\nstatic const luaL_Reg base_funcs[] = {\n  {\"assert\", luaB_assert},\n  {\"collectgarbage\", luaB_collectgarbage},\n  {\"dofile\", luaB_dofile},\n  {\"error\", luaB_error},\n  {\"getmetatable\", luaB_getmetatable},\n  {\"ipairs\", luaB_ipairs},\n  {\"loadfile\", luaB_loadfile},\n  {\"load\", luaB_load},\n  {\"next\", luaB_next},\n  {\"pairs\", luaB_pairs},\n  {\"pcall\", luaB_pcall},\n  {\"print\", luaB_print},\n  {\"warn\", luaB_warn},\n  {\"rawequal\", luaB_rawequal},\n  {\"rawlen\", luaB_rawlen},\n  {\"rawget\", luaB_rawget},\n  {\"rawset\", luaB_rawset},\n  {\"select\", luaB_select},\n  {\"setmetatable\", luaB_setmetatable},\n  {\"tonumber\", luaB_tonumber},\n  {\"tostring\", luaB_tostring},\n  {\"type\", luaB_type},\n  {\"xpcall\", luaB_xpcall},\n  /* placeholders */\n  {LUA_GNAME, NULL},\n  {\"_VERSION\", NULL},\n  {NULL, NULL}\n};\n\n\nLUAMOD_API int luaopen_base (lua_State *L) {\n  /* open lib into global table */\n  lua_pushglobaltable(L);\n  luaL_setfuncs(L, base_funcs, 0);\n  /* set global _G */\n  lua_pushvalue(L, -1);\n  lua_setfield(L, -2, LUA_GNAME);\n  /* set global _VERSION */\n  lua_pushliteral(L, LUA_VERSION);\n  lua_setfield(L, -2, \"_VERSION\");\n  return 1;\n}\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lcode.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: lcode.c $\n** Code generator for Lua\n** See Copyright Notice in lua.h\n*/\n\n#define lcode_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include <stdlib.h>\n\n#include \"lua.h\"\n\n#include \"lcode.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lgc.h\"\n#include \"llex.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lparser.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"lvm.h\"\n\n\n/* Maximum number of registers in a Lua function (must fit in 8 bits) */\n#define MAXREGS\t\t255\n\n\n#define hasjumps(e)\t((e)->t != (e)->f)\n\n\nstatic int codesJ (FuncState *fs, OpCode o, int sj, int k);\n\n\n\n/* semantic error */\nl_noret luaK_semerror (LexState *ls, const char *msg) {\n  ls->t.token = 0;  /* remove \"near <token>\" from final message */\n  luaX_syntaxerror(ls, msg);\n}\n\n\n/*\n** If expression is a numeric constant, fills 'v' with its value\n** and returns 1. Otherwise, returns 0.\n*/\nstatic int tonumeral (const expdesc *e, TValue *v) {\n  if (hasjumps(e))\n    return 0;  /* not a numeral */\n  switch (e->k) {\n    case VKINT:\n      if (v) setivalue(v, e->u.ival);\n      return 1;\n    case VKFLT:\n      if (v) setfltvalue(v, e->u.nval);\n      return 1;\n    default: return 0;\n  }\n}\n\n\n/*\n** Get the constant value from a constant expression\n*/\nstatic TValue *const2val (FuncState *fs, const expdesc *e) {\n  lua_assert(e->k == VCONST);\n  return &fs->ls->dyd->actvar.arr[e->u.info].k;\n}\n\n\n/*\n** If expression is a constant, fills 'v' with its value\n** and returns 1. Otherwise, returns 0.\n*/\nint luaK_exp2const (FuncState *fs, const expdesc *e, TValue *v) {\n  if (hasjumps(e))\n    return 0;  /* not a constant */\n  switch (e->k) {\n    case VFALSE:\n      setbfvalue(v);\n      return 1;\n    case VTRUE:\n      setbtvalue(v);\n      return 1;\n    case VNIL:\n      setnilvalue(v);\n      return 1;\n    case VKSTR: {\n      setsvalue(fs->ls->L, v, e->u.strval);\n      return 1;\n    }\n    case VCONST: {\n      setobj(fs->ls->L, v, const2val(fs, e));\n      return 1;\n    }\n    default: return tonumeral(e, v);\n  }\n}\n\n\n/*\n** Return the previous instruction of the current code. If there\n** may be a jump target between the current instruction and the\n** previous one, return an invalid instruction (to avoid wrong\n** optimizations).\n*/\nstatic Instruction *previousinstruction (FuncState *fs) {\n  static const Instruction invalidinstruction = ~(Instruction)0;\n  if (fs->pc > fs->lasttarget)\n    return &fs->f->code[fs->pc - 1];  /* previous instruction */\n  else\n    return cast(Instruction*, &invalidinstruction);\n}\n\n\n/*\n** Create a OP_LOADNIL instruction, but try to optimize: if the previous\n** instruction is also OP_LOADNIL and ranges are compatible, adjust\n** range of previous instruction instead of emitting a new one. (For\n** instance, 'local a; local b' will generate a single opcode.)\n*/\nvoid luaK_nil (FuncState *fs, int from, int n) {\n  int l = from + n - 1;  /* last register to set nil */\n  Instruction *previous = previousinstruction(fs);\n  if (GET_OPCODE(*previous) == OP_LOADNIL) {  /* previous is LOADNIL? */\n    int pfrom = GETARG_A(*previous);  /* get previous range */\n    int pl = pfrom + GETARG_B(*previous);\n    if ((pfrom <= from && from <= pl + 1) ||\n        (from <= pfrom && pfrom <= l + 1)) {  /* can connect both? */\n      if (pfrom < from) from = pfrom;  /* from = min(from, pfrom) */\n      if (pl > l) l = pl;  /* l = max(l, pl) */\n      SETARG_A(*previous, from);\n      SETARG_B(*previous, l - from);\n      return;\n    }  /* else go through */\n  }\n  luaK_codeABC(fs, OP_LOADNIL, from, n - 1, 0);  /* else no optimization */\n}\n\n\n/*\n** Gets the destination address of a jump instruction. Used to traverse\n** a list of jumps.\n*/\nstatic int getjump (FuncState *fs, int pc) {\n  int offset = GETARG_sJ(fs->f->code[pc]);\n  if (offset == NO_JUMP)  /* point to itself represents end of list */\n    return NO_JUMP;  /* end of list */\n  else\n    return (pc+1)+offset;  /* turn offset into absolute position */\n}\n\n\n/*\n** Fix jump instruction at position 'pc' to jump to 'dest'.\n** (Jump addresses are relative in Lua)\n*/\nstatic void fixjump (FuncState *fs, int pc, int dest) {\n  Instruction *jmp = &fs->f->code[pc];\n  int offset = dest - (pc + 1);\n  lua_assert(dest != NO_JUMP);\n  if (!(-OFFSET_sJ <= offset && offset <= MAXARG_sJ - OFFSET_sJ))\n    luaX_syntaxerror(fs->ls, \"control structure too long\");\n  lua_assert(GET_OPCODE(*jmp) == OP_JMP);\n  SETARG_sJ(*jmp, offset);\n}\n\n\n/*\n** Concatenate jump-list 'l2' into jump-list 'l1'\n*/\nvoid luaK_concat (FuncState *fs, int *l1, int l2) {\n  if (l2 == NO_JUMP) return;  /* nothing to concatenate? */\n  else if (*l1 == NO_JUMP)  /* no original list? */\n    *l1 = l2;  /* 'l1' points to 'l2' */\n  else {\n    int list = *l1;\n    int next;\n    while ((next = getjump(fs, list)) != NO_JUMP)  /* find last element */\n      list = next;\n    fixjump(fs, list, l2);  /* last element links to 'l2' */\n  }\n}\n\n\n/*\n** Create a jump instruction and return its position, so its destination\n** can be fixed later (with 'fixjump').\n*/\nint luaK_jump (FuncState *fs) {\n  return codesJ(fs, OP_JMP, NO_JUMP, 0);\n}\n\n\n/*\n** Code a 'return' instruction\n*/\nvoid luaK_ret (FuncState *fs, int first, int nret) {\n  OpCode op;\n  switch (nret) {\n    case 0: op = OP_RETURN0; break;\n    case 1: op = OP_RETURN1; break;\n    default: op = OP_RETURN; break;\n  }\n  luaK_codeABC(fs, op, first, nret + 1, 0);\n}\n\n\n/*\n** Code a \"conditional jump\", that is, a test or comparison opcode\n** followed by a jump. Return jump position.\n*/\nstatic int condjump (FuncState *fs, OpCode op, int A, int B, int C, int k) {\n  luaK_codeABCk(fs, op, A, B, C, k);\n  return luaK_jump(fs);\n}\n\n\n/*\n** returns current 'pc' and marks it as a jump target (to avoid wrong\n** optimizations with consecutive instructions not in the same basic block).\n*/\nint luaK_getlabel (FuncState *fs) {\n  fs->lasttarget = fs->pc;\n  return fs->pc;\n}\n\n\n/*\n** Returns the position of the instruction \"controlling\" a given\n** jump (that is, its condition), or the jump itself if it is\n** unconditional.\n*/\nstatic Instruction *getjumpcontrol (FuncState *fs, int pc) {\n  Instruction *pi = &fs->f->code[pc];\n  if (pc >= 1 && testTMode(GET_OPCODE(*(pi-1))))\n    return pi-1;\n  else\n    return pi;\n}\n\n\n/*\n** Patch destination register for a TESTSET instruction.\n** If instruction in position 'node' is not a TESTSET, return 0 (\"fails\").\n** Otherwise, if 'reg' is not 'NO_REG', set it as the destination\n** register. Otherwise, change instruction to a simple 'TEST' (produces\n** no register value)\n*/\nstatic int patchtestreg (FuncState *fs, int node, int reg) {\n  Instruction *i = getjumpcontrol(fs, node);\n  if (GET_OPCODE(*i) != OP_TESTSET)\n    return 0;  /* cannot patch other instructions */\n  if (reg != NO_REG && reg != GETARG_B(*i))\n    SETARG_A(*i, reg);\n  else {\n     /* no register to put value or register already has the value;\n        change instruction to simple test */\n    *i = CREATE_ABCk(OP_TEST, GETARG_B(*i), 0, 0, GETARG_k(*i));\n  }\n  return 1;\n}\n\n\n/*\n** Traverse a list of tests ensuring no one produces a value\n*/\nstatic void removevalues (FuncState *fs, int list) {\n  for (; list != NO_JUMP; list = getjump(fs, list))\n      patchtestreg(fs, list, NO_REG);\n}\n\n\n/*\n** Traverse a list of tests, patching their destination address and\n** registers: tests producing values jump to 'vtarget' (and put their\n** values in 'reg'), other tests jump to 'dtarget'.\n*/\nstatic void patchlistaux (FuncState *fs, int list, int vtarget, int reg,\n                          int dtarget) {\n  while (list != NO_JUMP) {\n    int next = getjump(fs, list);\n    if (patchtestreg(fs, list, reg))\n      fixjump(fs, list, vtarget);\n    else\n      fixjump(fs, list, dtarget);  /* jump to default target */\n    list = next;\n  }\n}\n\n\n/*\n** Path all jumps in 'list' to jump to 'target'.\n** (The assert means that we cannot fix a jump to a forward address\n** because we only know addresses once code is generated.)\n*/\nvoid luaK_patchlist (FuncState *fs, int list, int target) {\n  lua_assert(target <= fs->pc);\n  patchlistaux(fs, list, target, NO_REG, target);\n}\n\n\nvoid luaK_patchtohere (FuncState *fs, int list) {\n  int hr = luaK_getlabel(fs);  /* mark \"here\" as a jump target */\n  luaK_patchlist(fs, list, hr);\n}\n\n\n/* limit for difference between lines in relative line info. */\n#define LIMLINEDIFF\t0x80\n\n\n/*\n** Save line info for a new instruction. If difference from last line\n** does not fit in a byte, of after that many instructions, save a new\n** absolute line info; (in that case, the special value 'ABSLINEINFO'\n** in 'lineinfo' signals the existence of this absolute information.)\n** Otherwise, store the difference from last line in 'lineinfo'.\n*/\nstatic void savelineinfo (FuncState *fs, Proto *f, int line) {\n  int linedif = line - fs->previousline;\n  int pc = fs->pc - 1;  /* last instruction coded */\n  if (abs(linedif) >= LIMLINEDIFF || fs->iwthabs++ >= MAXIWTHABS) {\n    luaM_growvector(fs->ls->L, f->abslineinfo, fs->nabslineinfo,\n                    f->sizeabslineinfo, AbsLineInfo, MAX_INT, \"lines\");\n    f->abslineinfo[fs->nabslineinfo].pc = pc;\n    f->abslineinfo[fs->nabslineinfo++].line = line;\n    linedif = ABSLINEINFO;  /* signal that there is absolute information */\n    fs->iwthabs = 1;  /* restart counter */\n  }\n  luaM_growvector(fs->ls->L, f->lineinfo, pc, f->sizelineinfo, ls_byte,\n                  MAX_INT, \"opcodes\");\n  f->lineinfo[pc] = linedif;\n  fs->previousline = line;  /* last line saved */\n}\n\n\n/*\n** Remove line information from the last instruction.\n** If line information for that instruction is absolute, set 'iwthabs'\n** above its max to force the new (replacing) instruction to have\n** absolute line info, too.\n*/\nstatic void removelastlineinfo (FuncState *fs) {\n  Proto *f = fs->f;\n  int pc = fs->pc - 1;  /* last instruction coded */\n  if (f->lineinfo[pc] != ABSLINEINFO) {  /* relative line info? */\n    fs->previousline -= f->lineinfo[pc];  /* correct last line saved */\n    fs->iwthabs--;  /* undo previous increment */\n  }\n  else {  /* absolute line information */\n    lua_assert(f->abslineinfo[fs->nabslineinfo - 1].pc == pc);\n    fs->nabslineinfo--;  /* remove it */\n    fs->iwthabs = MAXIWTHABS + 1;  /* force next line info to be absolute */\n  }\n}\n\n\n/*\n** Remove the last instruction created, correcting line information\n** accordingly.\n*/\nstatic void removelastinstruction (FuncState *fs) {\n  removelastlineinfo(fs);\n  fs->pc--;\n}\n\n\n/*\n** Emit instruction 'i', checking for array sizes and saving also its\n** line information. Return 'i' position.\n*/\nint luaK_code (FuncState *fs, Instruction i) {\n  Proto *f = fs->f;\n  /* put new instruction in code array */\n  luaM_growvector(fs->ls->L, f->code, fs->pc, f->sizecode, Instruction,\n                  MAX_INT, \"opcodes\");\n  f->code[fs->pc++] = i;\n  savelineinfo(fs, f, fs->ls->lastline);\n  return fs->pc - 1;  /* index of new instruction */\n}\n\n\n/*\n** Format and emit an 'iABC' instruction. (Assertions check consistency\n** of parameters versus opcode.)\n*/\nint luaK_codeABCk (FuncState *fs, OpCode o, int a, int b, int c, int k) {\n  lua_assert(getOpMode(o) == iABC);\n  lua_assert(a <= MAXARG_A && b <= MAXARG_B &&\n             c <= MAXARG_C && (k & ~1) == 0);\n  return luaK_code(fs, CREATE_ABCk(o, a, b, c, k));\n}\n\n\n/*\n** Format and emit an 'iABx' instruction.\n*/\nint luaK_codeABx (FuncState *fs, OpCode o, int a, unsigned int bc) {\n  lua_assert(getOpMode(o) == iABx);\n  lua_assert(a <= MAXARG_A && bc <= MAXARG_Bx);\n  return luaK_code(fs, CREATE_ABx(o, a, bc));\n}\n\n\n/*\n** Format and emit an 'iAsBx' instruction.\n*/\nstatic int codeAsBx (FuncState *fs, OpCode o, int a, int bc) {\n  unsigned int b = bc + OFFSET_sBx;\n  lua_assert(getOpMode(o) == iAsBx);\n  lua_assert(a <= MAXARG_A && b <= MAXARG_Bx);\n  return luaK_code(fs, CREATE_ABx(o, a, b));\n}\n\n\n/*\n** Format and emit an 'isJ' instruction.\n*/\nstatic int codesJ (FuncState *fs, OpCode o, int sj, int k) {\n  unsigned int j = sj + OFFSET_sJ;\n  lua_assert(getOpMode(o) == isJ);\n  lua_assert(j <= MAXARG_sJ && (k & ~1) == 0);\n  return luaK_code(fs, CREATE_sJ(o, j, k));\n}\n\n\n/*\n** Emit an \"extra argument\" instruction (format 'iAx')\n*/\nstatic int codeextraarg (FuncState *fs, int a) {\n  lua_assert(a <= MAXARG_Ax);\n  return luaK_code(fs, CREATE_Ax(OP_EXTRAARG, a));\n}\n\n\n/*\n** Emit a \"load constant\" instruction, using either 'OP_LOADK'\n** (if constant index 'k' fits in 18 bits) or an 'OP_LOADKX'\n** instruction with \"extra argument\".\n*/\nstatic int luaK_codek (FuncState *fs, int reg, int k) {\n  if (k <= MAXARG_Bx)\n    return luaK_codeABx(fs, OP_LOADK, reg, k);\n  else {\n    int p = luaK_codeABx(fs, OP_LOADKX, reg, 0);\n    codeextraarg(fs, k);\n    return p;\n  }\n}\n\n\n/*\n** Check register-stack level, keeping track of its maximum size\n** in field 'maxstacksize'\n*/\nvoid luaK_checkstack (FuncState *fs, int n) {\n  int newstack = fs->freereg + n;\n  if (newstack > fs->f->maxstacksize) {\n    if (newstack >= MAXREGS)\n      luaX_syntaxerror(fs->ls,\n        \"function or expression needs too many registers\");\n    fs->f->maxstacksize = cast_byte(newstack);\n  }\n}\n\n\n/*\n** Reserve 'n' registers in register stack\n*/\nvoid luaK_reserveregs (FuncState *fs, int n) {\n  luaK_checkstack(fs, n);\n  fs->freereg += n;\n}\n\n\n/*\n** Free register 'reg', if it is neither a constant index nor\n** a local variable.\n)\n*/\nstatic void freereg (FuncState *fs, int reg) {\n  if (reg >= luaY_nvarstack(fs)) {\n    fs->freereg--;\n    lua_assert(reg == fs->freereg);\n  }\n}\n\n\n/*\n** Free two registers in proper order\n*/\nstatic void freeregs (FuncState *fs, int r1, int r2) {\n  if (r1 > r2) {\n    freereg(fs, r1);\n    freereg(fs, r2);\n  }\n  else {\n    freereg(fs, r2);\n    freereg(fs, r1);\n  }\n}\n\n\n/*\n** Free register used by expression 'e' (if any)\n*/\nstatic void freeexp (FuncState *fs, expdesc *e) {\n  if (e->k == VNONRELOC)\n    freereg(fs, e->u.info);\n}\n\n\n/*\n** Free registers used by expressions 'e1' and 'e2' (if any) in proper\n** order.\n*/\nstatic void freeexps (FuncState *fs, expdesc *e1, expdesc *e2) {\n  int r1 = (e1->k == VNONRELOC) ? e1->u.info : -1;\n  int r2 = (e2->k == VNONRELOC) ? e2->u.info : -1;\n  freeregs(fs, r1, r2);\n}\n\n\n/*\n** Add constant 'v' to prototype's list of constants (field 'k').\n** Use scanner's table to cache position of constants in constant list\n** and try to reuse constants. Because some values should not be used\n** as keys (nil cannot be a key, integer keys can collapse with float\n** keys), the caller must provide a useful 'key' for indexing the cache.\n** Note that all functions share the same table, so entering or exiting\n** a function can make some indices wrong.\n*/\nstatic int addk (FuncState *fs, TValue *key, TValue *v) {\n  TValue val;\n  lua_State *L = fs->ls->L;\n  Proto *f = fs->f;\n  int tag = luaH_get(fs->ls->h, key, &val);  /* query scanner table */\n  int k, oldsize;\n  if (tag == LUA_VNUMINT) {  /* is there an index there? */\n    k = cast_int(ivalue(&val));\n    /* correct value? (warning: must distinguish floats from integers!) */\n    if (k < fs->nk && ttypetag(&f->k[k]) == ttypetag(v) &&\n                      luaV_rawequalobj(&f->k[k], v))\n      return k;  /* reuse index */\n  }\n  /* constant not found; create a new entry */\n  oldsize = f->sizek;\n  k = fs->nk;\n  /* numerical value does not need GC barrier;\n     table has no metatable, so it does not need to invalidate cache */\n  setivalue(&val, k);\n  luaH_set(L, fs->ls->h, key, &val);\n  luaM_growvector(L, f->k, k, f->sizek, TValue, MAXARG_Ax, \"constants\");\n  while (oldsize < f->sizek) setnilvalue(&f->k[oldsize++]);\n  setobj(L, &f->k[k], v);\n  fs->nk++;\n  luaC_barrier(L, f, v);\n  return k;\n}\n\n\n/*\n** Add a string to list of constants and return its index.\n*/\nstatic int stringK (FuncState *fs, TString *s) {\n  TValue o;\n  setsvalue(fs->ls->L, &o, s);\n  return addk(fs, &o, &o);  /* use string itself as key */\n}\n\n\n/*\n** Add an integer to list of constants and return its index.\n*/\nstatic int luaK_intK (FuncState *fs, lua_Integer n) {\n  TValue o;\n  setivalue(&o, n);\n  return addk(fs, &o, &o);  /* use integer itself as key */\n}\n\n/*\n** Add a float to list of constants and return its index. Floats\n** with integral values need a different key, to avoid collision\n** with actual integers. To that, we add to the number its smaller\n** power-of-two fraction that is still significant in its scale.\n** For doubles, that would be 1/2^52.\n** (This method is not bulletproof: there may be another float\n** with that value, and for floats larger than 2^53 the result is\n** still an integer. At worst, this only wastes an entry with\n** a duplicate.)\n*/\nstatic int luaK_numberK (FuncState *fs, lua_Number r) {\n  TValue o;\n  lua_Integer ik;\n  setfltvalue(&o, r);\n  if (!luaV_flttointeger(r, &ik, F2Ieq))  /* not an integral value? */\n    return addk(fs, &o, &o);  /* use number itself as key */\n  else {  /* must build an alternative key */\n    const int nbm = l_floatatt(MANT_DIG);\n    const lua_Number q = l_mathop(ldexp)(l_mathop(1.0), -nbm + 1);\n    const lua_Number k = (ik == 0) ? q : r + r*q;  /* new key */\n    TValue kv;\n    setfltvalue(&kv, k);\n    /* result is not an integral value, unless value is too large */\n    lua_assert(!luaV_flttointeger(k, &ik, F2Ieq) ||\n                l_mathop(fabs)(r) >= l_mathop(1e6));\n    return addk(fs, &kv, &o);\n  }\n}\n\n\n/*\n** Add a false to list of constants and return its index.\n*/\nstatic int boolF (FuncState *fs) {\n  TValue o;\n  setbfvalue(&o);\n  return addk(fs, &o, &o);  /* use boolean itself as key */\n}\n\n\n/*\n** Add a true to list of constants and return its index.\n*/\nstatic int boolT (FuncState *fs) {\n  TValue o;\n  setbtvalue(&o);\n  return addk(fs, &o, &o);  /* use boolean itself as key */\n}\n\n\n/*\n** Add nil to list of constants and return its index.\n*/\nstatic int nilK (FuncState *fs) {\n  TValue k, v;\n  setnilvalue(&v);\n  /* cannot use nil as key; instead use table itself to represent nil */\n  sethvalue(fs->ls->L, &k, fs->ls->h);\n  return addk(fs, &k, &v);\n}\n\n\n/*\n** Check whether 'i' can be stored in an 'sC' operand. Equivalent to\n** (0 <= int2sC(i) && int2sC(i) <= MAXARG_C) but without risk of\n** overflows in the hidden addition inside 'int2sC'.\n*/\nstatic int fitsC (lua_Integer i) {\n  return (l_castS2U(i) + OFFSET_sC <= cast_uint(MAXARG_C));\n}\n\n\n/*\n** Check whether 'i' can be stored in an 'sBx' operand.\n*/\nstatic int fitsBx (lua_Integer i) {\n  return (-OFFSET_sBx <= i && i <= MAXARG_Bx - OFFSET_sBx);\n}\n\n\nvoid luaK_int (FuncState *fs, int reg, lua_Integer i) {\n  if (fitsBx(i))\n    codeAsBx(fs, OP_LOADI, reg, cast_int(i));\n  else\n    luaK_codek(fs, reg, luaK_intK(fs, i));\n}\n\n\nstatic void luaK_float (FuncState *fs, int reg, lua_Number f) {\n  lua_Integer fi;\n  if (luaV_flttointeger(f, &fi, F2Ieq) && fitsBx(fi))\n    codeAsBx(fs, OP_LOADF, reg, cast_int(fi));\n  else\n    luaK_codek(fs, reg, luaK_numberK(fs, f));\n}\n\n\n/*\n** Convert a constant in 'v' into an expression description 'e'\n*/\nstatic void const2exp (TValue *v, expdesc *e) {\n  switch (ttypetag(v)) {\n    case LUA_VNUMINT:\n      e->k = VKINT; e->u.ival = ivalue(v);\n      break;\n    case LUA_VNUMFLT:\n      e->k = VKFLT; e->u.nval = fltvalue(v);\n      break;\n    case LUA_VFALSE:\n      e->k = VFALSE;\n      break;\n    case LUA_VTRUE:\n      e->k = VTRUE;\n      break;\n    case LUA_VNIL:\n      e->k = VNIL;\n      break;\n    case LUA_VSHRSTR:  case LUA_VLNGSTR:\n      e->k = VKSTR; e->u.strval = tsvalue(v);\n      break;\n    default: lua_assert(0);\n  }\n}\n\n\n/*\n** Fix an expression to return the number of results 'nresults'.\n** 'e' must be a multi-ret expression (function call or vararg).\n*/\nvoid luaK_setreturns (FuncState *fs, expdesc *e, int nresults) {\n  Instruction *pc = &getinstruction(fs, e);\n  if (e->k == VCALL)  /* expression is an open function call? */\n    SETARG_C(*pc, nresults + 1);\n  else {\n    lua_assert(e->k == VVARARG);\n    SETARG_C(*pc, nresults + 1);\n    SETARG_A(*pc, fs->freereg);\n    luaK_reserveregs(fs, 1);\n  }\n}\n\n\n/*\n** Convert a VKSTR to a VK\n*/\nstatic void str2K (FuncState *fs, expdesc *e) {\n  lua_assert(e->k == VKSTR);\n  e->u.info = stringK(fs, e->u.strval);\n  e->k = VK;\n}\n\n\n/*\n** Fix an expression to return one result.\n** If expression is not a multi-ret expression (function call or\n** vararg), it already returns one result, so nothing needs to be done.\n** Function calls become VNONRELOC expressions (as its result comes\n** fixed in the base register of the call), while vararg expressions\n** become VRELOC (as OP_VARARG puts its results where it wants).\n** (Calls are created returning one result, so that does not need\n** to be fixed.)\n*/\nvoid luaK_setoneret (FuncState *fs, expdesc *e) {\n  if (e->k == VCALL) {  /* expression is an open function call? */\n    /* already returns 1 value */\n    lua_assert(GETARG_C(getinstruction(fs, e)) == 2);\n    e->k = VNONRELOC;  /* result has fixed position */\n    e->u.info = GETARG_A(getinstruction(fs, e));\n  }\n  else if (e->k == VVARARG) {\n    SETARG_C(getinstruction(fs, e), 2);\n    e->k = VRELOC;  /* can relocate its simple result */\n  }\n}\n\n\n/*\n** Ensure that expression 'e' is not a variable (nor a <const>).\n** (Expression still may have jump lists.)\n*/\nvoid luaK_dischargevars (FuncState *fs, expdesc *e) {\n  switch (e->k) {\n    case VCONST: {\n      const2exp(const2val(fs, e), e);\n      break;\n    }\n    case VLOCAL: {  /* already in a register */\n      e->u.info = e->u.var.ridx;\n      e->k = VNONRELOC;  /* becomes a non-relocatable value */\n      break;\n    }\n    case VUPVAL: {  /* move value to some (pending) register */\n      e->u.info = luaK_codeABC(fs, OP_GETUPVAL, 0, e->u.info, 0);\n      e->k = VRELOC;\n      break;\n    }\n    case VINDEXUP: {\n      e->u.info = luaK_codeABC(fs, OP_GETTABUP, 0, e->u.ind.t, e->u.ind.idx);\n      e->k = VRELOC;\n      break;\n    }\n    case VINDEXI: {\n      freereg(fs, e->u.ind.t);\n      e->u.info = luaK_codeABC(fs, OP_GETI, 0, e->u.ind.t, e->u.ind.idx);\n      e->k = VRELOC;\n      break;\n    }\n    case VINDEXSTR: {\n      freereg(fs, e->u.ind.t);\n      e->u.info = luaK_codeABC(fs, OP_GETFIELD, 0, e->u.ind.t, e->u.ind.idx);\n      e->k = VRELOC;\n      break;\n    }\n    case VINDEXED: {\n      freeregs(fs, e->u.ind.t, e->u.ind.idx);\n      e->u.info = luaK_codeABC(fs, OP_GETTABLE, 0, e->u.ind.t, e->u.ind.idx);\n      e->k = VRELOC;\n      break;\n    }\n    case VVARARG: case VCALL: {\n      luaK_setoneret(fs, e);\n      break;\n    }\n    default: break;  /* there is one value available (somewhere) */\n  }\n}\n\n\n/*\n** Ensure expression value is in register 'reg', making 'e' a\n** non-relocatable expression.\n** (Expression still may have jump lists.)\n*/\nstatic void discharge2reg (FuncState *fs, expdesc *e, int reg) {\n  luaK_dischargevars(fs, e);\n  switch (e->k) {\n    case VNIL: {\n      luaK_nil(fs, reg, 1);\n      break;\n    }\n    case VFALSE: {\n      luaK_codeABC(fs, OP_LOADFALSE, reg, 0, 0);\n      break;\n    }\n    case VTRUE: {\n      luaK_codeABC(fs, OP_LOADTRUE, reg, 0, 0);\n      break;\n    }\n    case VKSTR: {\n      str2K(fs, e);\n    }  /* FALLTHROUGH */\n    case VK: {\n      luaK_codek(fs, reg, e->u.info);\n      break;\n    }\n    case VKFLT: {\n      luaK_float(fs, reg, e->u.nval);\n      break;\n    }\n    case VKINT: {\n      luaK_int(fs, reg, e->u.ival);\n      break;\n    }\n    case VRELOC: {\n      Instruction *pc = &getinstruction(fs, e);\n      SETARG_A(*pc, reg);  /* instruction will put result in 'reg' */\n      break;\n    }\n    case VNONRELOC: {\n      if (reg != e->u.info)\n        luaK_codeABC(fs, OP_MOVE, reg, e->u.info, 0);\n      break;\n    }\n    default: {\n      lua_assert(e->k == VJMP);\n      return;  /* nothing to do... */\n    }\n  }\n  e->u.info = reg;\n  e->k = VNONRELOC;\n}\n\n\n/*\n** Ensure expression value is in a register, making 'e' a\n** non-relocatable expression.\n** (Expression still may have jump lists.)\n*/\nstatic void discharge2anyreg (FuncState *fs, expdesc *e) {\n  if (e->k != VNONRELOC) {  /* no fixed register yet? */\n    luaK_reserveregs(fs, 1);  /* get a register */\n    discharge2reg(fs, e, fs->freereg-1);  /* put value there */\n  }\n}\n\n\nstatic int code_loadbool (FuncState *fs, int A, OpCode op) {\n  luaK_getlabel(fs);  /* those instructions may be jump targets */\n  return luaK_codeABC(fs, op, A, 0, 0);\n}\n\n\n/*\n** check whether list has any jump that do not produce a value\n** or produce an inverted value\n*/\nstatic int need_value (FuncState *fs, int list) {\n  for (; list != NO_JUMP; list = getjump(fs, list)) {\n    Instruction i = *getjumpcontrol(fs, list);\n    if (GET_OPCODE(i) != OP_TESTSET) return 1;\n  }\n  return 0;  /* not found */\n}\n\n\n/*\n** Ensures final expression result (which includes results from its\n** jump lists) is in register 'reg'.\n** If expression has jumps, need to patch these jumps either to\n** its final position or to \"load\" instructions (for those tests\n** that do not produce values).\n*/\nstatic void exp2reg (FuncState *fs, expdesc *e, int reg) {\n  discharge2reg(fs, e, reg);\n  if (e->k == VJMP)  /* expression itself is a test? */\n    luaK_concat(fs, &e->t, e->u.info);  /* put this jump in 't' list */\n  if (hasjumps(e)) {\n    int final;  /* position after whole expression */\n    int p_f = NO_JUMP;  /* position of an eventual LOAD false */\n    int p_t = NO_JUMP;  /* position of an eventual LOAD true */\n    if (need_value(fs, e->t) || need_value(fs, e->f)) {\n      int fj = (e->k == VJMP) ? NO_JUMP : luaK_jump(fs);\n      p_f = code_loadbool(fs, reg, OP_LFALSESKIP);  /* skip next inst. */\n      p_t = code_loadbool(fs, reg, OP_LOADTRUE);\n      /* jump around these booleans if 'e' is not a test */\n      luaK_patchtohere(fs, fj);\n    }\n    final = luaK_getlabel(fs);\n    patchlistaux(fs, e->f, final, reg, p_f);\n    patchlistaux(fs, e->t, final, reg, p_t);\n  }\n  e->f = e->t = NO_JUMP;\n  e->u.info = reg;\n  e->k = VNONRELOC;\n}\n\n\n/*\n** Ensures final expression result is in next available register.\n*/\nvoid luaK_exp2nextreg (FuncState *fs, expdesc *e) {\n  luaK_dischargevars(fs, e);\n  freeexp(fs, e);\n  luaK_reserveregs(fs, 1);\n  exp2reg(fs, e, fs->freereg - 1);\n}\n\n\n/*\n** Ensures final expression result is in some (any) register\n** and return that register.\n*/\nint luaK_exp2anyreg (FuncState *fs, expdesc *e) {\n  luaK_dischargevars(fs, e);\n  if (e->k == VNONRELOC) {  /* expression already has a register? */\n    if (!hasjumps(e))  /* no jumps? */\n      return e->u.info;  /* result is already in a register */\n    if (e->u.info >= luaY_nvarstack(fs)) {  /* reg. is not a local? */\n      exp2reg(fs, e, e->u.info);  /* put final result in it */\n      return e->u.info;\n    }\n    /* else expression has jumps and cannot change its register\n       to hold the jump values, because it is a local variable.\n       Go through to the default case. */\n  }\n  luaK_exp2nextreg(fs, e);  /* default: use next available register */\n  return e->u.info;\n}\n\n\n/*\n** Ensures final expression result is either in a register\n** or in an upvalue.\n*/\nvoid luaK_exp2anyregup (FuncState *fs, expdesc *e) {\n  if (e->k != VUPVAL || hasjumps(e))\n    luaK_exp2anyreg(fs, e);\n}\n\n\n/*\n** Ensures final expression result is either in a register\n** or it is a constant.\n*/\nvoid luaK_exp2val (FuncState *fs, expdesc *e) {\n  if (hasjumps(e))\n    luaK_exp2anyreg(fs, e);\n  else\n    luaK_dischargevars(fs, e);\n}\n\n\n/*\n** Try to make 'e' a K expression with an index in the range of R/K\n** indices. Return true iff succeeded.\n*/\nstatic int luaK_exp2K (FuncState *fs, expdesc *e) {\n  if (!hasjumps(e)) {\n    int info;\n    switch (e->k) {  /* move constants to 'k' */\n      case VTRUE: info = boolT(fs); break;\n      case VFALSE: info = boolF(fs); break;\n      case VNIL: info = nilK(fs); break;\n      case VKINT: info = luaK_intK(fs, e->u.ival); break;\n      case VKFLT: info = luaK_numberK(fs, e->u.nval); break;\n      case VKSTR: info = stringK(fs, e->u.strval); break;\n      case VK: info = e->u.info; break;\n      default: return 0;  /* not a constant */\n    }\n    if (info <= MAXINDEXRK) {  /* does constant fit in 'argC'? */\n      e->k = VK;  /* make expression a 'K' expression */\n      e->u.info = info;\n      return 1;\n    }\n  }\n  /* else, expression doesn't fit; leave it unchanged */\n  return 0;\n}\n\n\n/*\n** Ensures final expression result is in a valid R/K index\n** (that is, it is either in a register or in 'k' with an index\n** in the range of R/K indices).\n** Returns 1 iff expression is K.\n*/\nstatic int exp2RK (FuncState *fs, expdesc *e) {\n  if (luaK_exp2K(fs, e))\n    return 1;\n  else {  /* not a constant in the right range: put it in a register */\n    luaK_exp2anyreg(fs, e);\n    return 0;\n  }\n}\n\n\nstatic void codeABRK (FuncState *fs, OpCode o, int a, int b,\n                      expdesc *ec) {\n  int k = exp2RK(fs, ec);\n  luaK_codeABCk(fs, o, a, b, ec->u.info, k);\n}\n\n\n/*\n** Generate code to store result of expression 'ex' into variable 'var'.\n*/\nvoid luaK_storevar (FuncState *fs, expdesc *var, expdesc *ex) {\n  switch (var->k) {\n    case VLOCAL: {\n      freeexp(fs, ex);\n      exp2reg(fs, ex, var->u.var.ridx);  /* compute 'ex' into proper place */\n      return;\n    }\n    case VUPVAL: {\n      int e = luaK_exp2anyreg(fs, ex);\n      luaK_codeABC(fs, OP_SETUPVAL, e, var->u.info, 0);\n      break;\n    }\n    case VINDEXUP: {\n      codeABRK(fs, OP_SETTABUP, var->u.ind.t, var->u.ind.idx, ex);\n      break;\n    }\n    case VINDEXI: {\n      codeABRK(fs, OP_SETI, var->u.ind.t, var->u.ind.idx, ex);\n      break;\n    }\n    case VINDEXSTR: {\n      codeABRK(fs, OP_SETFIELD, var->u.ind.t, var->u.ind.idx, ex);\n      break;\n    }\n    case VINDEXED: {\n      codeABRK(fs, OP_SETTABLE, var->u.ind.t, var->u.ind.idx, ex);\n      break;\n    }\n    default: lua_assert(0);  /* invalid var kind to store */\n  }\n  freeexp(fs, ex);\n}\n\n\n/*\n** Emit SELF instruction (convert expression 'e' into 'e:key(e,').\n*/\nvoid luaK_self (FuncState *fs, expdesc *e, expdesc *key) {\n  int ereg;\n  luaK_exp2anyreg(fs, e);\n  ereg = e->u.info;  /* register where 'e' was placed */\n  freeexp(fs, e);\n  e->u.info = fs->freereg;  /* base register for op_self */\n  e->k = VNONRELOC;  /* self expression has a fixed register */\n  luaK_reserveregs(fs, 2);  /* function and 'self' produced by op_self */\n  codeABRK(fs, OP_SELF, e->u.info, ereg, key);\n  freeexp(fs, key);\n}\n\n\n/*\n** Negate condition 'e' (where 'e' is a comparison).\n*/\nstatic void negatecondition (FuncState *fs, expdesc *e) {\n  Instruction *pc = getjumpcontrol(fs, e->u.info);\n  lua_assert(testTMode(GET_OPCODE(*pc)) && GET_OPCODE(*pc) != OP_TESTSET &&\n                                           GET_OPCODE(*pc) != OP_TEST);\n  SETARG_k(*pc, (GETARG_k(*pc) ^ 1));\n}\n\n\n/*\n** Emit instruction to jump if 'e' is 'cond' (that is, if 'cond'\n** is true, code will jump if 'e' is true.) Return jump position.\n** Optimize when 'e' is 'not' something, inverting the condition\n** and removing the 'not'.\n*/\nstatic int jumponcond (FuncState *fs, expdesc *e, int cond) {\n  if (e->k == VRELOC) {\n    Instruction ie = getinstruction(fs, e);\n    if (GET_OPCODE(ie) == OP_NOT) {\n      removelastinstruction(fs);  /* remove previous OP_NOT */\n      return condjump(fs, OP_TEST, GETARG_B(ie), 0, 0, !cond);\n    }\n    /* else go through */\n  }\n  discharge2anyreg(fs, e);\n  freeexp(fs, e);\n  return condjump(fs, OP_TESTSET, NO_REG, e->u.info, 0, cond);\n}\n\n\n/*\n** Emit code to go through if 'e' is true, jump otherwise.\n*/\nvoid luaK_goiftrue (FuncState *fs, expdesc *e) {\n  int pc;  /* pc of new jump */\n  luaK_dischargevars(fs, e);\n  switch (e->k) {\n    case VJMP: {  /* condition? */\n      negatecondition(fs, e);  /* jump when it is false */\n      pc = e->u.info;  /* save jump position */\n      break;\n    }\n    case VK: case VKFLT: case VKINT: case VKSTR: case VTRUE: {\n      pc = NO_JUMP;  /* always true; do nothing */\n      break;\n    }\n    default: {\n      pc = jumponcond(fs, e, 0);  /* jump when false */\n      break;\n    }\n  }\n  luaK_concat(fs, &e->f, pc);  /* insert new jump in false list */\n  luaK_patchtohere(fs, e->t);  /* true list jumps to here (to go through) */\n  e->t = NO_JUMP;\n}\n\n\n/*\n** Emit code to go through if 'e' is false, jump otherwise.\n*/\nvoid luaK_goiffalse (FuncState *fs, expdesc *e) {\n  int pc;  /* pc of new jump */\n  luaK_dischargevars(fs, e);\n  switch (e->k) {\n    case VJMP: {\n      pc = e->u.info;  /* already jump if true */\n      break;\n    }\n    case VNIL: case VFALSE: {\n      pc = NO_JUMP;  /* always false; do nothing */\n      break;\n    }\n    default: {\n      pc = jumponcond(fs, e, 1);  /* jump if true */\n      break;\n    }\n  }\n  luaK_concat(fs, &e->t, pc);  /* insert new jump in 't' list */\n  luaK_patchtohere(fs, e->f);  /* false list jumps to here (to go through) */\n  e->f = NO_JUMP;\n}\n\n\n/*\n** Code 'not e', doing constant folding.\n*/\nstatic void codenot (FuncState *fs, expdesc *e) {\n  switch (e->k) {\n    case VNIL: case VFALSE: {\n      e->k = VTRUE;  /* true == not nil == not false */\n      break;\n    }\n    case VK: case VKFLT: case VKINT: case VKSTR: case VTRUE: {\n      e->k = VFALSE;  /* false == not \"x\" == not 0.5 == not 1 == not true */\n      break;\n    }\n    case VJMP: {\n      negatecondition(fs, e);\n      break;\n    }\n    case VRELOC:\n    case VNONRELOC: {\n      discharge2anyreg(fs, e);\n      freeexp(fs, e);\n      e->u.info = luaK_codeABC(fs, OP_NOT, 0, e->u.info, 0);\n      e->k = VRELOC;\n      break;\n    }\n    default: lua_assert(0);  /* cannot happen */\n  }\n  /* interchange true and false lists */\n  { int temp = e->f; e->f = e->t; e->t = temp; }\n  removevalues(fs, e->f);  /* values are useless when negated */\n  removevalues(fs, e->t);\n}\n\n\n/*\n** Check whether expression 'e' is a short literal string\n*/\nstatic int isKstr (FuncState *fs, expdesc *e) {\n  return (e->k == VK && !hasjumps(e) && e->u.info <= MAXARG_B &&\n          ttisshrstring(&fs->f->k[e->u.info]));\n}\n\n/*\n** Check whether expression 'e' is a literal integer.\n*/\nstatic int isKint (expdesc *e) {\n  return (e->k == VKINT && !hasjumps(e));\n}\n\n\n/*\n** Check whether expression 'e' is a literal integer in\n** proper range to fit in register C\n*/\nstatic int isCint (expdesc *e) {\n  return isKint(e) && (l_castS2U(e->u.ival) <= l_castS2U(MAXARG_C));\n}\n\n\n/*\n** Check whether expression 'e' is a literal integer in\n** proper range to fit in register sC\n*/\nstatic int isSCint (expdesc *e) {\n  return isKint(e) && fitsC(e->u.ival);\n}\n\n\n/*\n** Check whether expression 'e' is a literal integer or float in\n** proper range to fit in a register (sB or sC).\n*/\nstatic int isSCnumber (expdesc *e, int *pi, int *isfloat) {\n  lua_Integer i;\n  if (e->k == VKINT)\n    i = e->u.ival;\n  else if (e->k == VKFLT && luaV_flttointeger(e->u.nval, &i, F2Ieq))\n    *isfloat = 1;\n  else\n    return 0;  /* not a number */\n  if (!hasjumps(e) && fitsC(i)) {\n    *pi = int2sC(cast_int(i));\n    return 1;\n  }\n  else\n    return 0;\n}\n\n\n/*\n** Create expression 't[k]'. 't' must have its final result already in a\n** register or upvalue. Upvalues can only be indexed by literal strings.\n** Keys can be literal strings in the constant table or arbitrary\n** values in registers.\n*/\nvoid luaK_indexed (FuncState *fs, expdesc *t, expdesc *k) {\n  if (k->k == VKSTR)\n    str2K(fs, k);\n  lua_assert(!hasjumps(t) &&\n             (t->k == VLOCAL || t->k == VNONRELOC || t->k == VUPVAL));\n  if (t->k == VUPVAL && !isKstr(fs, k))  /* upvalue indexed by non 'Kstr'? */\n    luaK_exp2anyreg(fs, t);  /* put it in a register */\n  if (t->k == VUPVAL) {\n    lua_assert(isKstr(fs, k));\n    t->u.ind.t = t->u.info;  /* upvalue index */\n    t->u.ind.idx = k->u.info;  /* literal short string */\n    t->k = VINDEXUP;\n  }\n  else {\n    /* register index of the table */\n    t->u.ind.t = (t->k == VLOCAL) ? t->u.var.ridx: t->u.info;\n    if (isKstr(fs, k)) {\n      t->u.ind.idx = k->u.info;  /* literal short string */\n      t->k = VINDEXSTR;\n    }\n    else if (isCint(k)) {\n      t->u.ind.idx = cast_int(k->u.ival);  /* int. constant in proper range */\n      t->k = VINDEXI;\n    }\n    else {\n      t->u.ind.idx = luaK_exp2anyreg(fs, k);  /* register */\n      t->k = VINDEXED;\n    }\n  }\n}\n\n\n/*\n** Return false if folding can raise an error.\n** Bitwise operations need operands convertible to integers; division\n** operations cannot have 0 as divisor.\n*/\nstatic int validop (int op, TValue *v1, TValue *v2) {\n  switch (op) {\n    case LUA_OPBAND: case LUA_OPBOR: case LUA_OPBXOR:\n    case LUA_OPSHL: case LUA_OPSHR: case LUA_OPBNOT: {  /* conversion errors */\n      lua_Integer i;\n      return (luaV_tointegerns(v1, &i, LUA_FLOORN2I) &&\n              luaV_tointegerns(v2, &i, LUA_FLOORN2I));\n    }\n    case LUA_OPDIV: case LUA_OPIDIV: case LUA_OPMOD:  /* division by 0 */\n      return (nvalue(v2) != 0);\n    default: return 1;  /* everything else is valid */\n  }\n}\n\n\n/*\n** Try to \"constant-fold\" an operation; return 1 iff successful.\n** (In this case, 'e1' has the final result.)\n*/\nstatic int constfolding (FuncState *fs, int op, expdesc *e1,\n                                        const expdesc *e2) {\n  TValue v1, v2, res;\n  if (!tonumeral(e1, &v1) || !tonumeral(e2, &v2) || !validop(op, &v1, &v2))\n    return 0;  /* non-numeric operands or not safe to fold */\n  luaO_rawarith(fs->ls->L, op, &v1, &v2, &res);  /* does operation */\n  if (ttisinteger(&res)) {\n    e1->k = VKINT;\n    e1->u.ival = ivalue(&res);\n  }\n  else {  /* folds neither NaN nor 0.0 (to avoid problems with -0.0) */\n    lua_Number n = fltvalue(&res);\n    if (luai_numisnan(n) || n == 0)\n      return 0;\n    e1->k = VKFLT;\n    e1->u.nval = n;\n  }\n  return 1;\n}\n\n\n/*\n** Convert a BinOpr to an OpCode  (ORDER OPR - ORDER OP)\n*/\nl_sinline OpCode binopr2op (BinOpr opr, BinOpr baser, OpCode base) {\n  lua_assert(baser <= opr &&\n            ((baser == OPR_ADD && opr <= OPR_SHR) ||\n             (baser == OPR_LT && opr <= OPR_LE)));\n  return cast(OpCode, (cast_int(opr) - cast_int(baser)) + cast_int(base));\n}\n\n\n/*\n** Convert a UnOpr to an OpCode  (ORDER OPR - ORDER OP)\n*/\nl_sinline OpCode unopr2op (UnOpr opr) {\n  return cast(OpCode, (cast_int(opr) - cast_int(OPR_MINUS)) +\n                                       cast_int(OP_UNM));\n}\n\n\n/*\n** Convert a BinOpr to a tag method  (ORDER OPR - ORDER TM)\n*/\nl_sinline TMS binopr2TM (BinOpr opr) {\n  lua_assert(OPR_ADD <= opr && opr <= OPR_SHR);\n  return cast(TMS, (cast_int(opr) - cast_int(OPR_ADD)) + cast_int(TM_ADD));\n}\n\n\n/*\n** Emit code for unary expressions that \"produce values\"\n** (everything but 'not').\n** Expression to produce final result will be encoded in 'e'.\n*/\nstatic void codeunexpval (FuncState *fs, OpCode op, expdesc *e, int line) {\n  int r = luaK_exp2anyreg(fs, e);  /* opcodes operate only on registers */\n  freeexp(fs, e);\n  e->u.info = luaK_codeABC(fs, op, 0, r, 0);  /* generate opcode */\n  e->k = VRELOC;  /* all those operations are relocatable */\n  luaK_fixline(fs, line);\n}\n\n\n/*\n** Emit code for binary expressions that \"produce values\"\n** (everything but logical operators 'and'/'or' and comparison\n** operators).\n** Expression to produce final result will be encoded in 'e1'.\n*/\nstatic void finishbinexpval (FuncState *fs, expdesc *e1, expdesc *e2,\n                             OpCode op, int v2, int flip, int line,\n                             OpCode mmop, TMS event) {\n  int v1 = luaK_exp2anyreg(fs, e1);\n  int pc = luaK_codeABCk(fs, op, 0, v1, v2, 0);\n  freeexps(fs, e1, e2);\n  e1->u.info = pc;\n  e1->k = VRELOC;  /* all those operations are relocatable */\n  luaK_fixline(fs, line);\n  luaK_codeABCk(fs, mmop, v1, v2, event, flip);  /* to call metamethod */\n  luaK_fixline(fs, line);\n}\n\n\n/*\n** Emit code for binary expressions that \"produce values\" over\n** two registers.\n*/\nstatic void codebinexpval (FuncState *fs, BinOpr opr,\n                           expdesc *e1, expdesc *e2, int line) {\n  OpCode op = binopr2op(opr, OPR_ADD, OP_ADD);\n  int v2 = luaK_exp2anyreg(fs, e2);  /* make sure 'e2' is in a register */\n  /* 'e1' must be already in a register or it is a constant */\n  lua_assert((VNIL <= e1->k && e1->k <= VKSTR) ||\n             e1->k == VNONRELOC || e1->k == VRELOC);\n  lua_assert(OP_ADD <= op && op <= OP_SHR);\n  finishbinexpval(fs, e1, e2, op, v2, 0, line, OP_MMBIN, binopr2TM(opr));\n}\n\n\n/*\n** Code binary operators with immediate operands.\n*/\nstatic void codebini (FuncState *fs, OpCode op,\n                       expdesc *e1, expdesc *e2, int flip, int line,\n                       TMS event) {\n  int v2 = int2sC(cast_int(e2->u.ival));  /* immediate operand */\n  lua_assert(e2->k == VKINT);\n  finishbinexpval(fs, e1, e2, op, v2, flip, line, OP_MMBINI, event);\n}\n\n\n/*\n** Code binary operators with K operand.\n*/\nstatic void codebinK (FuncState *fs, BinOpr opr,\n                      expdesc *e1, expdesc *e2, int flip, int line) {\n  TMS event = binopr2TM(opr);\n  int v2 = e2->u.info;  /* K index */\n  OpCode op = binopr2op(opr, OPR_ADD, OP_ADDK);\n  finishbinexpval(fs, e1, e2, op, v2, flip, line, OP_MMBINK, event);\n}\n\n\n/* Try to code a binary operator negating its second operand.\n** For the metamethod, 2nd operand must keep its original value.\n*/\nstatic int finishbinexpneg (FuncState *fs, expdesc *e1, expdesc *e2,\n                             OpCode op, int line, TMS event) {\n  if (!isKint(e2))\n    return 0;  /* not an integer constant */\n  else {\n    lua_Integer i2 = e2->u.ival;\n    if (!(fitsC(i2) && fitsC(-i2)))\n      return 0;  /* not in the proper range */\n    else {  /* operating a small integer constant */\n      int v2 = cast_int(i2);\n      finishbinexpval(fs, e1, e2, op, int2sC(-v2), 0, line, OP_MMBINI, event);\n      /* correct metamethod argument */\n      SETARG_B(fs->f->code[fs->pc - 1], int2sC(v2));\n      return 1;  /* successfully coded */\n    }\n  }\n}\n\n\nstatic void swapexps (expdesc *e1, expdesc *e2) {\n  expdesc temp = *e1; *e1 = *e2; *e2 = temp;  /* swap 'e1' and 'e2' */\n}\n\n\n/*\n** Code binary operators with no constant operand.\n*/\nstatic void codebinNoK (FuncState *fs, BinOpr opr,\n                        expdesc *e1, expdesc *e2, int flip, int line) {\n  if (flip)\n    swapexps(e1, e2);  /* back to original order */\n  codebinexpval(fs, opr, e1, e2, line);  /* use standard operators */\n}\n\n\n/*\n** Code arithmetic operators ('+', '-', ...). If second operand is a\n** constant in the proper range, use variant opcodes with K operands.\n*/\nstatic void codearith (FuncState *fs, BinOpr opr,\n                       expdesc *e1, expdesc *e2, int flip, int line) {\n  if (tonumeral(e2, NULL) && luaK_exp2K(fs, e2))  /* K operand? */\n    codebinK(fs, opr, e1, e2, flip, line);\n  else  /* 'e2' is neither an immediate nor a K operand */\n    codebinNoK(fs, opr, e1, e2, flip, line);\n}\n\n\n/*\n** Code commutative operators ('+', '*'). If first operand is a\n** numeric constant, change order of operands to try to use an\n** immediate or K operator.\n*/\nstatic void codecommutative (FuncState *fs, BinOpr op,\n                             expdesc *e1, expdesc *e2, int line) {\n  int flip = 0;\n  if (tonumeral(e1, NULL)) {  /* is first operand a numeric constant? */\n    swapexps(e1, e2);  /* change order */\n    flip = 1;\n  }\n  if (op == OPR_ADD && isSCint(e2))  /* immediate operand? */\n    codebini(fs, OP_ADDI, e1, e2, flip, line, TM_ADD);\n  else\n    codearith(fs, op, e1, e2, flip, line);\n}\n\n\n/*\n** Code bitwise operations; they are all commutative, so the function\n** tries to put an integer constant as the 2nd operand (a K operand).\n*/\nstatic void codebitwise (FuncState *fs, BinOpr opr,\n                         expdesc *e1, expdesc *e2, int line) {\n  int flip = 0;\n  if (e1->k == VKINT) {\n    swapexps(e1, e2);  /* 'e2' will be the constant operand */\n    flip = 1;\n  }\n  if (e2->k == VKINT && luaK_exp2K(fs, e2))  /* K operand? */\n    codebinK(fs, opr, e1, e2, flip, line);\n  else  /* no constants */\n    codebinNoK(fs, opr, e1, e2, flip, line);\n}\n\n\n/*\n** Emit code for order comparisons. When using an immediate operand,\n** 'isfloat' tells whether the original value was a float.\n*/\nstatic void codeorder (FuncState *fs, BinOpr opr, expdesc *e1, expdesc *e2) {\n  int r1, r2;\n  int im;\n  int isfloat = 0;\n  OpCode op;\n  if (isSCnumber(e2, &im, &isfloat)) {\n    /* use immediate operand */\n    r1 = luaK_exp2anyreg(fs, e1);\n    r2 = im;\n    op = binopr2op(opr, OPR_LT, OP_LTI);\n  }\n  else if (isSCnumber(e1, &im, &isfloat)) {\n    /* transform (A < B) to (B > A) and (A <= B) to (B >= A) */\n    r1 = luaK_exp2anyreg(fs, e2);\n    r2 = im;\n    op = binopr2op(opr, OPR_LT, OP_GTI);\n  }\n  else {  /* regular case, compare two registers */\n    r1 = luaK_exp2anyreg(fs, e1);\n    r2 = luaK_exp2anyreg(fs, e2);\n    op = binopr2op(opr, OPR_LT, OP_LT);\n  }\n  freeexps(fs, e1, e2);\n  e1->u.info = condjump(fs, op, r1, r2, isfloat, 1);\n  e1->k = VJMP;\n}\n\n\n/*\n** Emit code for equality comparisons ('==', '~=').\n** 'e1' was already put as RK by 'luaK_infix'.\n*/\nstatic void codeeq (FuncState *fs, BinOpr opr, expdesc *e1, expdesc *e2) {\n  int r1, r2;\n  int im;\n  int isfloat = 0;  /* not needed here, but kept for symmetry */\n  OpCode op;\n  if (e1->k != VNONRELOC) {\n    lua_assert(e1->k == VK || e1->k == VKINT || e1->k == VKFLT);\n    swapexps(e1, e2);\n  }\n  r1 = luaK_exp2anyreg(fs, e1);  /* 1st expression must be in register */\n  if (isSCnumber(e2, &im, &isfloat)) {\n    op = OP_EQI;\n    r2 = im;  /* immediate operand */\n  }\n  else if (exp2RK(fs, e2)) {  /* 2nd expression is constant? */\n    op = OP_EQK;\n    r2 = e2->u.info;  /* constant index */\n  }\n  else {\n    op = OP_EQ;  /* will compare two registers */\n    r2 = luaK_exp2anyreg(fs, e2);\n  }\n  freeexps(fs, e1, e2);\n  e1->u.info = condjump(fs, op, r1, r2, isfloat, (opr == OPR_EQ));\n  e1->k = VJMP;\n}\n\n\n/*\n** Apply prefix operation 'op' to expression 'e'.\n*/\nvoid luaK_prefix (FuncState *fs, UnOpr opr, expdesc *e, int line) {\n  static const expdesc ef = {VKINT, {0}, NO_JUMP, NO_JUMP};\n  luaK_dischargevars(fs, e);\n  switch (opr) {\n    case OPR_MINUS: case OPR_BNOT:  /* use 'ef' as fake 2nd operand */\n      if (constfolding(fs, opr + LUA_OPUNM, e, &ef))\n        break;\n      /* else */ /* FALLTHROUGH */\n    case OPR_LEN:\n      codeunexpval(fs, unopr2op(opr), e, line);\n      break;\n    case OPR_NOT: codenot(fs, e); break;\n    default: lua_assert(0);\n  }\n}\n\n\n/*\n** Process 1st operand 'v' of binary operation 'op' before reading\n** 2nd operand.\n*/\nvoid luaK_infix (FuncState *fs, BinOpr op, expdesc *v) {\n  luaK_dischargevars(fs, v);\n  switch (op) {\n    case OPR_AND: {\n      luaK_goiftrue(fs, v);  /* go ahead only if 'v' is true */\n      break;\n    }\n    case OPR_OR: {\n      luaK_goiffalse(fs, v);  /* go ahead only if 'v' is false */\n      break;\n    }\n    case OPR_CONCAT: {\n      luaK_exp2nextreg(fs, v);  /* operand must be on the stack */\n      break;\n    }\n    case OPR_ADD: case OPR_SUB:\n    case OPR_MUL: case OPR_DIV: case OPR_IDIV:\n    case OPR_MOD: case OPR_POW:\n    case OPR_BAND: case OPR_BOR: case OPR_BXOR:\n    case OPR_SHL: case OPR_SHR: {\n      if (!tonumeral(v, NULL))\n        luaK_exp2anyreg(fs, v);\n      /* else keep numeral, which may be folded or used as an immediate\n         operand */\n      break;\n    }\n    case OPR_EQ: case OPR_NE: {\n      if (!tonumeral(v, NULL))\n        exp2RK(fs, v);\n      /* else keep numeral, which may be an immediate operand */\n      break;\n    }\n    case OPR_LT: case OPR_LE:\n    case OPR_GT: case OPR_GE: {\n      int dummy, dummy2;\n      if (!isSCnumber(v, &dummy, &dummy2))\n        luaK_exp2anyreg(fs, v);\n      /* else keep numeral, which may be an immediate operand */\n      break;\n    }\n    default: lua_assert(0);\n  }\n}\n\n/*\n** Create code for '(e1 .. e2)'.\n** For '(e1 .. e2.1 .. e2.2)' (which is '(e1 .. (e2.1 .. e2.2))',\n** because concatenation is right associative), merge both CONCATs.\n*/\nstatic void codeconcat (FuncState *fs, expdesc *e1, expdesc *e2, int line) {\n  Instruction *ie2 = previousinstruction(fs);\n  if (GET_OPCODE(*ie2) == OP_CONCAT) {  /* is 'e2' a concatenation? */\n    int n = GETARG_B(*ie2);  /* # of elements concatenated in 'e2' */\n    lua_assert(e1->u.info + 1 == GETARG_A(*ie2));\n    freeexp(fs, e2);\n    SETARG_A(*ie2, e1->u.info);  /* correct first element ('e1') */\n    SETARG_B(*ie2, n + 1);  /* will concatenate one more element */\n  }\n  else {  /* 'e2' is not a concatenation */\n    luaK_codeABC(fs, OP_CONCAT, e1->u.info, 2, 0);  /* new concat opcode */\n    freeexp(fs, e2);\n    luaK_fixline(fs, line);\n  }\n}\n\n\n/*\n** Finalize code for binary operation, after reading 2nd operand.\n*/\nvoid luaK_posfix (FuncState *fs, BinOpr opr,\n                  expdesc *e1, expdesc *e2, int line) {\n  luaK_dischargevars(fs, e2);\n  if (foldbinop(opr) && constfolding(fs, opr + LUA_OPADD, e1, e2))\n    return;  /* done by folding */\n  switch (opr) {\n    case OPR_AND: {\n      lua_assert(e1->t == NO_JUMP);  /* list closed by 'luaK_infix' */\n      luaK_concat(fs, &e2->f, e1->f);\n      *e1 = *e2;\n      break;\n    }\n    case OPR_OR: {\n      lua_assert(e1->f == NO_JUMP);  /* list closed by 'luaK_infix' */\n      luaK_concat(fs, &e2->t, e1->t);\n      *e1 = *e2;\n      break;\n    }\n    case OPR_CONCAT: {  /* e1 .. e2 */\n      luaK_exp2nextreg(fs, e2);\n      codeconcat(fs, e1, e2, line);\n      break;\n    }\n    case OPR_ADD: case OPR_MUL: {\n      codecommutative(fs, opr, e1, e2, line);\n      break;\n    }\n    case OPR_SUB: {\n      if (finishbinexpneg(fs, e1, e2, OP_ADDI, line, TM_SUB))\n        break; /* coded as (r1 + -I) */\n      /* ELSE */\n    }  /* FALLTHROUGH */\n    case OPR_DIV: case OPR_IDIV: case OPR_MOD: case OPR_POW: {\n      codearith(fs, opr, e1, e2, 0, line);\n      break;\n    }\n    case OPR_BAND: case OPR_BOR: case OPR_BXOR: {\n      codebitwise(fs, opr, e1, e2, line);\n      break;\n    }\n    case OPR_SHL: {\n      if (isSCint(e1)) {\n        swapexps(e1, e2);\n        codebini(fs, OP_SHLI, e1, e2, 1, line, TM_SHL);  /* I << r2 */\n      }\n      else if (finishbinexpneg(fs, e1, e2, OP_SHRI, line, TM_SHL)) {\n        /* coded as (r1 >> -I) */;\n      }\n      else  /* regular case (two registers) */\n       codebinexpval(fs, opr, e1, e2, line);\n      break;\n    }\n    case OPR_SHR: {\n      if (isSCint(e2))\n        codebini(fs, OP_SHRI, e1, e2, 0, line, TM_SHR);  /* r1 >> I */\n      else  /* regular case (two registers) */\n        codebinexpval(fs, opr, e1, e2, line);\n      break;\n    }\n    case OPR_EQ: case OPR_NE: {\n      codeeq(fs, opr, e1, e2);\n      break;\n    }\n    case OPR_GT: case OPR_GE: {\n      /* '(a > b)' <=> '(b < a)';  '(a >= b)' <=> '(b <= a)' */\n      swapexps(e1, e2);\n      opr = cast(BinOpr, (opr - OPR_GT) + OPR_LT);\n    }  /* FALLTHROUGH */\n    case OPR_LT: case OPR_LE: {\n      codeorder(fs, opr, e1, e2);\n      break;\n    }\n    default: lua_assert(0);\n  }\n}\n\n\n/*\n** Change line information associated with current position, by removing\n** previous info and adding it again with new line.\n*/\nvoid luaK_fixline (FuncState *fs, int line) {\n  removelastlineinfo(fs);\n  savelineinfo(fs, fs->f, line);\n}\n\n\nvoid luaK_settablesize (FuncState *fs, int pc, int ra, int asize, int hsize) {\n  Instruction *inst = &fs->f->code[pc];\n  int rb = (hsize != 0) ? luaO_ceillog2(hsize) + 1 : 0;  /* hash size */\n  int extra = asize / (MAXARG_C + 1);  /* higher bits of array size */\n  int rc = asize % (MAXARG_C + 1);  /* lower bits of array size */\n  int k = (extra > 0);  /* true iff needs extra argument */\n  *inst = CREATE_ABCk(OP_NEWTABLE, ra, rb, rc, k);\n  *(inst + 1) = CREATE_Ax(OP_EXTRAARG, extra);\n}\n\n\n/*\n** Emit a SETLIST instruction.\n** 'base' is register that keeps table;\n** 'nelems' is #table plus those to be stored now;\n** 'tostore' is number of values (in registers 'base + 1',...) to add to\n** table (or LUA_MULTRET to add up to stack top).\n*/\nvoid luaK_setlist (FuncState *fs, int base, int nelems, int tostore) {\n  lua_assert(tostore != 0 && tostore <= LFIELDS_PER_FLUSH);\n  if (tostore == LUA_MULTRET)\n    tostore = 0;\n  if (nelems <= MAXARG_C)\n    luaK_codeABC(fs, OP_SETLIST, base, tostore, nelems);\n  else {\n    int extra = nelems / (MAXARG_C + 1);\n    nelems %= (MAXARG_C + 1);\n    luaK_codeABCk(fs, OP_SETLIST, base, tostore, nelems, 1);\n    codeextraarg(fs, extra);\n  }\n  fs->freereg = base + 1;  /* free registers with list values */\n}\n\n\n/*\n** return the final target of a jump (skipping jumps to jumps)\n*/\nstatic int finaltarget (Instruction *code, int i) {\n  int count;\n  for (count = 0; count < 100; count++) {  /* avoid infinite loops */\n    Instruction pc = code[i];\n    if (GET_OPCODE(pc) != OP_JMP)\n      break;\n     else\n       i += GETARG_sJ(pc) + 1;\n  }\n  return i;\n}\n\n\n/*\n** Do a final pass over the code of a function, doing small peephole\n** optimizations and adjustments.\n*/\nvoid luaK_finish (FuncState *fs) {\n  int i;\n  Proto *p = fs->f;\n  for (i = 0; i < fs->pc; i++) {\n    Instruction *pc = &p->code[i];\n    lua_assert(i == 0 || isOT(*(pc - 1)) == isIT(*pc));\n    switch (GET_OPCODE(*pc)) {\n      case OP_RETURN0: case OP_RETURN1: {\n        if (!(fs->needclose || (p->flag & PF_ISVARARG)))\n          break;  /* no extra work */\n        /* else use OP_RETURN to do the extra work */\n        SET_OPCODE(*pc, OP_RETURN);\n      }  /* FALLTHROUGH */\n      case OP_RETURN: case OP_TAILCALL: {\n        if (fs->needclose)\n          SETARG_k(*pc, 1);  /* signal that it needs to close */\n        if (p->flag & PF_ISVARARG)\n          SETARG_C(*pc, p->numparams + 1);  /* signal that it is vararg */\n        break;\n      }\n      case OP_JMP: {\n        int target = finaltarget(p->code, i);\n        fixjump(fs, i, target);\n        break;\n      }\n      default: break;\n    }\n  }\n}\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lcode.h",
		"is_binary":	false,
		"content":	"/*\n** $Id: lcode.h $\n** Code generator for Lua\n** See Copyright Notice in lua.h\n*/\n\n#ifndef lcode_h\n#define lcode_h\n\n#include \"llex.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lparser.h\"\n\n\n/*\n** Marks the end of a patch list. It is an invalid value both as an absolute\n** address, and as a list link (would link an element to itself).\n*/\n#define NO_JUMP (-1)\n\n\n/*\n** grep \"ORDER OPR\" if you change these enums  (ORDER OP)\n*/\ntypedef enum BinOpr {\n  /* arithmetic operators */\n  OPR_ADD, OPR_SUB, OPR_MUL, OPR_MOD, OPR_POW,\n  OPR_DIV, OPR_IDIV,\n  /* bitwise operators */\n  OPR_BAND, OPR_BOR, OPR_BXOR,\n  OPR_SHL, OPR_SHR,\n  /* string operator */\n  OPR_CONCAT,\n  /* comparison operators */\n  OPR_EQ, OPR_LT, OPR_LE,\n  OPR_NE, OPR_GT, OPR_GE,\n  /* logical operators */\n  OPR_AND, OPR_OR,\n  OPR_NOBINOPR\n} BinOpr;\n\n\n/* true if operation is foldable (that is, it is arithmetic or bitwise) */\n#define foldbinop(op)\t((op) <= OPR_SHR)\n\n\n#define luaK_codeABC(fs,o,a,b,c)\tluaK_codeABCk(fs,o,a,b,c,0)\n\n\ntypedef enum UnOpr { OPR_MINUS, OPR_BNOT, OPR_NOT, OPR_LEN, OPR_NOUNOPR } UnOpr;\n\n\n/* get (pointer to) instruction of given 'expdesc' */\n#define getinstruction(fs,e)\t((fs)->f->code[(e)->u.info])\n\n\n#define luaK_setmultret(fs,e)\tluaK_setreturns(fs, e, LUA_MULTRET)\n\n#define luaK_jumpto(fs,t)\tluaK_patchlist(fs, luaK_jump(fs), t)\n\nLUAI_FUNC int luaK_code (FuncState *fs, Instruction i);\nLUAI_FUNC int luaK_codeABx (FuncState *fs, OpCode o, int A, unsigned Bx);\nLUAI_FUNC int luaK_codeABCk (FuncState *fs, OpCode o, int A,\n                                            int B, int C, int k);\nLUAI_FUNC int luaK_exp2const (FuncState *fs, const expdesc *e, TValue *v);\nLUAI_FUNC void luaK_fixline (FuncState *fs, int line);\nLUAI_FUNC void luaK_nil (FuncState *fs, int from, int n);\nLUAI_FUNC void luaK_reserveregs (FuncState *fs, int n);\nLUAI_FUNC void luaK_checkstack (FuncState *fs, int n);\nLUAI_FUNC void luaK_int (FuncState *fs, int reg, lua_Integer n);\nLUAI_FUNC void luaK_dischargevars (FuncState *fs, expdesc *e);\nLUAI_FUNC int luaK_exp2anyreg (FuncState *fs, expdesc *e);\nLUAI_FUNC void luaK_exp2anyregup (FuncState *fs, expdesc *e);\nLUAI_FUNC void luaK_exp2nextreg (FuncState *fs, expdesc *e);\nLUAI_FUNC void luaK_exp2val (FuncState *fs, expdesc *e);\nLUAI_FUNC void luaK_self (FuncState *fs, expdesc *e, expdesc *key);\nLUAI_FUNC void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k);\nLUAI_FUNC void luaK_goiftrue (FuncState *fs, expdesc *e);\nLUAI_FUNC void luaK_goiffalse (FuncState *fs, expdesc *e);\nLUAI_FUNC void luaK_storevar (FuncState *fs, expdesc *var, expdesc *e);\nLUAI_FUNC void luaK_setreturns (FuncState *fs, expdesc *e, int nresults);\nLUAI_FUNC void luaK_setoneret (FuncState *fs, expdesc *e);\nLUAI_FUNC int luaK_jump (FuncState *fs);\nLUAI_FUNC void luaK_ret (FuncState *fs, int first, int nret);\nLUAI_FUNC void luaK_patchlist (FuncState *fs, int list, int target);\nLUAI_FUNC void luaK_patchtohere (FuncState *fs, int list);\nLUAI_FUNC void luaK_concat (FuncState *fs, int *l1, int l2);\nLUAI_FUNC int luaK_getlabel (FuncState *fs);\nLUAI_FUNC void luaK_prefix (FuncState *fs, UnOpr op, expdesc *v, int line);\nLUAI_FUNC void luaK_infix (FuncState *fs, BinOpr op, expdesc *v);\nLUAI_FUNC void luaK_posfix (FuncState *fs, BinOpr op, expdesc *v1,\n                            expdesc *v2, int line);\nLUAI_FUNC void luaK_settablesize (FuncState *fs, int pc,\n                                  int ra, int asize, int hsize);\nLUAI_FUNC void luaK_setlist (FuncState *fs, int base, int nelems, int tostore);\nLUAI_FUNC void luaK_finish (FuncState *fs);\nLUAI_FUNC l_noret luaK_semerror (LexState *ls, const char *msg);\n\n\n#endif\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lcorolib.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: lcorolib.c $\n** Coroutine Library\n** See Copyright Notice in lua.h\n*/\n\n#define lcorolib_c\n#define LUA_LIB\n\n#include \"lprefix.h\"\n\n\n#include <stdlib.h>\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n\n\nstatic lua_State *getco (lua_State *L) {\n  lua_State *co = lua_tothread(L, 1);\n  luaL_argexpected(L, co, 1, \"thread\");\n  return co;\n}\n\n\n/*\n** Resumes a coroutine. Returns the number of results for non-error\n** cases or -1 for errors.\n*/\nstatic int auxresume (lua_State *L, lua_State *co, int narg) {\n  int status, nres;\n  if (l_unlikely(!lua_checkstack(co, narg))) {\n    lua_pushliteral(L, \"too many arguments to resume\");\n    return -1;  /* error flag */\n  }\n  lua_xmove(L, co, narg);\n  status = lua_resume(co, L, narg, &nres);\n  if (l_likely(status == LUA_OK || status == LUA_YIELD)) {\n    if (l_unlikely(!lua_checkstack(L, nres + 1))) {\n      lua_pop(co, nres);  /* remove results anyway */\n      lua_pushliteral(L, \"too many results to resume\");\n      return -1;  /* error flag */\n    }\n    lua_xmove(co, L, nres);  /* move yielded values */\n    return nres;\n  }\n  else {\n    lua_xmove(co, L, 1);  /* move error message */\n    return -1;  /* error flag */\n  }\n}\n\n\nstatic int luaB_coresume (lua_State *L) {\n  lua_State *co = getco(L);\n  int r;\n  r = auxresume(L, co, lua_gettop(L) - 1);\n  if (l_unlikely(r < 0)) {\n    lua_pushboolean(L, 0);\n    lua_insert(L, -2);\n    return 2;  /* return false + error message */\n  }\n  else {\n    lua_pushboolean(L, 1);\n    lua_insert(L, -(r + 1));\n    return r + 1;  /* return true + 'resume' returns */\n  }\n}\n\n\nstatic int luaB_auxwrap (lua_State *L) {\n  lua_State *co = lua_tothread(L, lua_upvalueindex(1));\n  int r = auxresume(L, co, lua_gettop(L));\n  if (l_unlikely(r < 0)) {  /* error? */\n    int stat = lua_status(co);\n    if (stat != LUA_OK && stat != LUA_YIELD) {  /* error in the coroutine? */\n      stat = lua_closethread(co, L);  /* close its tbc variables */\n      lua_assert(stat != LUA_OK);\n      lua_xmove(co, L, 1);  /* move error message to the caller */\n    }\n    if (stat != LUA_ERRMEM &&  /* not a memory error and ... */\n        lua_type(L, -1) == LUA_TSTRING) {  /* ... error object is a string? */\n      luaL_where(L, 1);  /* add extra info, if available */\n      lua_insert(L, -2);\n      lua_concat(L, 2);\n    }\n    return lua_error(L);  /* propagate error */\n  }\n  return r;\n}\n\n\nstatic int luaB_cocreate (lua_State *L) {\n  lua_State *NL;\n  luaL_checktype(L, 1, LUA_TFUNCTION);\n  NL = lua_newthread(L);\n  lua_pushvalue(L, 1);  /* move function to top */\n  lua_xmove(L, NL, 1);  /* move function from L to NL */\n  return 1;\n}\n\n\nstatic int luaB_cowrap (lua_State *L) {\n  luaB_cocreate(L);\n  lua_pushcclosure(L, luaB_auxwrap, 1);\n  return 1;\n}\n\n\nstatic int luaB_yield (lua_State *L) {\n  return lua_yield(L, lua_gettop(L));\n}\n\n\n#define COS_RUN\t\t0\n#define COS_DEAD\t1\n#define COS_YIELD\t2\n#define COS_NORM\t3\n\n\nstatic const char *const statname[] =\n  {\"running\", \"dead\", \"suspended\", \"normal\"};\n\n\nstatic int auxstatus (lua_State *L, lua_State *co) {\n  if (L == co) return COS_RUN;\n  else {\n    switch (lua_status(co)) {\n      case LUA_YIELD:\n        return COS_YIELD;\n      case LUA_OK: {\n        lua_Debug ar;\n        if (lua_getstack(co, 0, &ar))  /* does it have frames? */\n          return COS_NORM;  /* it is running */\n        else if (lua_gettop(co) == 0)\n            return COS_DEAD;\n        else\n          return COS_YIELD;  /* initial state */\n      }\n      default:  /* some error occurred */\n        return COS_DEAD;\n    }\n  }\n}\n\n\nstatic int luaB_costatus (lua_State *L) {\n  lua_State *co = getco(L);\n  lua_pushstring(L, statname[auxstatus(L, co)]);\n  return 1;\n}\n\n\nstatic int luaB_yieldable (lua_State *L) {\n  lua_State *co = lua_isnone(L, 1) ? L : getco(L);\n  lua_pushboolean(L, lua_isyieldable(co));\n  return 1;\n}\n\n\nstatic int luaB_corunning (lua_State *L) {\n  int ismain = lua_pushthread(L);\n  lua_pushboolean(L, ismain);\n  return 2;\n}\n\n\nstatic int luaB_close (lua_State *L) {\n  lua_State *co = getco(L);\n  int status = auxstatus(L, co);\n  switch (status) {\n    case COS_DEAD: case COS_YIELD: {\n      status = lua_closethread(co, L);\n      if (status == LUA_OK) {\n        lua_pushboolean(L, 1);\n        return 1;\n      }\n      else {\n        lua_pushboolean(L, 0);\n        lua_xmove(co, L, 1);  /* move error message */\n        return 2;\n      }\n    }\n    default:  /* normal or running coroutine */\n      return luaL_error(L, \"cannot close a %s coroutine\", statname[status]);\n  }\n}\n\n\nstatic const luaL_Reg co_funcs[] = {\n  {\"create\", luaB_cocreate},\n  {\"resume\", luaB_coresume},\n  {\"running\", luaB_corunning},\n  {\"status\", luaB_costatus},\n  {\"wrap\", luaB_cowrap},\n  {\"yield\", luaB_yield},\n  {\"isyieldable\", luaB_yieldable},\n  {\"close\", luaB_close},\n  {NULL, NULL}\n};\n\n\n\nLUAMOD_API int luaopen_coroutine (lua_State *L) {\n  luaL_newlib(L, co_funcs);\n  return 1;\n}\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lctype.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: lctype.c $\n** 'ctype' functions for Lua\n** See Copyright Notice in lua.h\n*/\n\n#define lctype_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include \"lctype.h\"\n\n#if !LUA_USE_CTYPE\t/* { */\n\n#include <limits.h>\n\n\n#if defined (LUA_UCID)\t\t/* accept UniCode IDentifiers? */\n/* consider all non-ascii codepoints to be alphabetic */\n#define NONA\t\t0x01\n#else\n#define NONA\t\t0x00\t/* default */\n#endif\n\n\nLUAI_DDEF const lu_byte luai_ctype_[UCHAR_MAX + 2] = {\n  0x00,  /* EOZ */\n  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,\t/* 0. */\n  0x00,  0x08,  0x08,  0x08,  0x08,  0x08,  0x00,  0x00,\n  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,\t/* 1. */\n  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,\n  0x0c,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,\t/* 2. */\n  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,\n  0x16,  0x16,  0x16,  0x16,  0x16,  0x16,  0x16,  0x16,\t/* 3. */\n  0x16,  0x16,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,\n  0x04,  0x15,  0x15,  0x15,  0x15,  0x15,  0x15,  0x05,\t/* 4. */\n  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,\n  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,\t/* 5. */\n  0x05,  0x05,  0x05,  0x04,  0x04,  0x04,  0x04,  0x05,\n  0x04,  0x15,  0x15,  0x15,  0x15,  0x15,  0x15,  0x05,\t/* 6. */\n  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,\n  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,\t/* 7. */\n  0x05,  0x05,  0x05,  0x04,  0x04,  0x04,  0x04,  0x00,\n  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,\t/* 8. */\n  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,\n  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,\t/* 9. */\n  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,\n  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,\t/* a. */\n  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,\n  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,\t/* b. */\n  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,\n  0x00,  0x00,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,\t/* c. */\n  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,\n  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,\t/* d. */\n  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,\n  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,\t/* e. */\n  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,\n  NONA,  NONA,  NONA,  NONA,  NONA,  0x00,  0x00,  0x00,\t/* f. */\n  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00\n};\n\n#endif\t\t\t/* } */\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lctype.h",
		"is_binary":	false,
		"content":	"/*\n** $Id: lctype.h $\n** 'ctype' functions for Lua\n** See Copyright Notice in lua.h\n*/\n\n#ifndef lctype_h\n#define lctype_h\n\n#include \"lua.h\"\n\n\n/*\n** WARNING: the functions defined here do not necessarily correspond\n** to the similar functions in the standard C ctype.h. They are\n** optimized for the specific needs of Lua.\n*/\n\n#if !defined(LUA_USE_CTYPE)\n\n#if 'A' == 65 && '0' == 48\n/* ASCII case: can use its own tables; faster and fixed */\n#define LUA_USE_CTYPE\t0\n#else\n/* must use standard C ctype */\n#define LUA_USE_CTYPE\t1\n#endif\n\n#endif\n\n\n#if !LUA_USE_CTYPE\t/* { */\n\n#include <limits.h>\n\n#include \"llimits.h\"\n\n\n#define ALPHABIT\t0\n#define DIGITBIT\t1\n#define PRINTBIT\t2\n#define SPACEBIT\t3\n#define XDIGITBIT\t4\n\n\n#define MASK(B)\t\t(1 << (B))\n\n\n/*\n** add 1 to char to allow index -1 (EOZ)\n*/\n#define testprop(c,p)\t(luai_ctype_[(c)+1] & (p))\n\n/*\n** 'lalpha' (Lua alphabetic) and 'lalnum' (Lua alphanumeric) both include '_'\n*/\n#define lislalpha(c)\ttestprop(c, MASK(ALPHABIT))\n#define lislalnum(c)\ttestprop(c, (MASK(ALPHABIT) | MASK(DIGITBIT)))\n#define lisdigit(c)\ttestprop(c, MASK(DIGITBIT))\n#define lisspace(c)\ttestprop(c, MASK(SPACEBIT))\n#define lisprint(c)\ttestprop(c, MASK(PRINTBIT))\n#define lisxdigit(c)\ttestprop(c, MASK(XDIGITBIT))\n\n\n/*\n** In ASCII, this 'ltolower' is correct for alphabetic characters and\n** for '.'. That is enough for Lua needs. ('check_exp' ensures that\n** the character either is an upper-case letter or is unchanged by\n** the transformation, which holds for lower-case letters and '.'.)\n*/\n#define ltolower(c)  \\\n  check_exp(('A' <= (c) && (c) <= 'Z') || (c) == ((c) | ('A' ^ 'a')),  \\\n            (c) | ('A' ^ 'a'))\n\n\n/* one entry for each character and for -1 (EOZ) */\nLUAI_DDEC(const lu_byte luai_ctype_[UCHAR_MAX + 2];)\n\n\n#else\t\t\t/* }{ */\n\n/*\n** use standard C ctypes\n*/\n\n#include <ctype.h>\n\n\n#define lislalpha(c)\t(isalpha(c) || (c) == '_')\n#define lislalnum(c)\t(isalnum(c) || (c) == '_')\n#define lisdigit(c)\t(isdigit(c))\n#define lisspace(c)\t(isspace(c))\n#define lisprint(c)\t(isprint(c))\n#define lisxdigit(c)\t(isxdigit(c))\n\n#define ltolower(c)\t(tolower(c))\n\n#endif\t\t\t/* } */\n\n#endif\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/ldblib.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: ldblib.c $\n** Interface from Lua to its debug API\n** See Copyright Notice in lua.h\n*/\n\n#define ldblib_c\n#define LUA_LIB\n\n#include \"lprefix.h\"\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n\n\n/*\n** The hook table at registry[HOOKKEY] maps threads to their current\n** hook function.\n*/\nstatic const char *const HOOKKEY = \"_HOOKKEY\";\n\n\n/*\n** If L1 != L, L1 can be in any state, and therefore there are no\n** guarantees about its stack space; any push in L1 must be\n** checked.\n*/\nstatic void checkstack (lua_State *L, lua_State *L1, int n) {\n  if (l_unlikely(L != L1 && !lua_checkstack(L1, n)))\n    luaL_error(L, \"stack overflow\");\n}\n\n\nstatic int db_getregistry (lua_State *L) {\n  lua_pushvalue(L, LUA_REGISTRYINDEX);\n  return 1;\n}\n\n\nstatic int db_getmetatable (lua_State *L) {\n  luaL_checkany(L, 1);\n  if (!lua_getmetatable(L, 1)) {\n    lua_pushnil(L);  /* no metatable */\n  }\n  return 1;\n}\n\n\nstatic int db_setmetatable (lua_State *L) {\n  int t = lua_type(L, 2);\n  luaL_argexpected(L, t == LUA_TNIL || t == LUA_TTABLE, 2, \"nil or table\");\n  lua_settop(L, 2);\n  lua_setmetatable(L, 1);\n  return 1;  /* return 1st argument */\n}\n\n\nstatic int db_getuservalue (lua_State *L) {\n  int n = (int)luaL_optinteger(L, 2, 1);\n  if (lua_type(L, 1) != LUA_TUSERDATA)\n    luaL_pushfail(L);\n  else if (lua_getiuservalue(L, 1, n) != LUA_TNONE) {\n    lua_pushboolean(L, 1);\n    return 2;\n  }\n  return 1;\n}\n\n\nstatic int db_setuservalue (lua_State *L) {\n  int n = (int)luaL_optinteger(L, 3, 1);\n  luaL_checktype(L, 1, LUA_TUSERDATA);\n  luaL_checkany(L, 2);\n  lua_settop(L, 2);\n  if (!lua_setiuservalue(L, 1, n))\n    luaL_pushfail(L);\n  return 1;\n}\n\n\n/*\n** Auxiliary function used by several library functions: check for\n** an optional thread as function's first argument and set 'arg' with\n** 1 if this argument is present (so that functions can skip it to\n** access their other arguments)\n*/\nstatic lua_State *getthread (lua_State *L, int *arg) {\n  if (lua_isthread(L, 1)) {\n    *arg = 1;\n    return lua_tothread(L, 1);\n  }\n  else {\n    *arg = 0;\n    return L;  /* function will operate over current thread */\n  }\n}\n\n\n/*\n** Variations of 'lua_settable', used by 'db_getinfo' to put results\n** from 'lua_getinfo' into result table. Key is always a string;\n** value can be a string, an int, or a boolean.\n*/\nstatic void settabss (lua_State *L, const char *k, const char *v) {\n  lua_pushstring(L, v);\n  lua_setfield(L, -2, k);\n}\n\nstatic void settabsi (lua_State *L, const char *k, int v) {\n  lua_pushinteger(L, v);\n  lua_setfield(L, -2, k);\n}\n\nstatic void settabsb (lua_State *L, const char *k, int v) {\n  lua_pushboolean(L, v);\n  lua_setfield(L, -2, k);\n}\n\n\n/*\n** In function 'db_getinfo', the call to 'lua_getinfo' may push\n** results on the stack; later it creates the result table to put\n** these objects. Function 'treatstackoption' puts the result from\n** 'lua_getinfo' on top of the result table so that it can call\n** 'lua_setfield'.\n*/\nstatic void treatstackoption (lua_State *L, lua_State *L1, const char *fname) {\n  if (L == L1)\n    lua_rotate(L, -2, 1);  /* exchange object and table */\n  else\n    lua_xmove(L1, L, 1);  /* move object to the \"main\" stack */\n  lua_setfield(L, -2, fname);  /* put object into table */\n}\n\n\n/*\n** Calls 'lua_getinfo' and collects all results in a new table.\n** L1 needs stack space for an optional input (function) plus\n** two optional outputs (function and line table) from function\n** 'lua_getinfo'.\n*/\nstatic int db_getinfo (lua_State *L) {\n  lua_Debug ar;\n  int arg;\n  lua_State *L1 = getthread(L, &arg);\n  const char *options = luaL_optstring(L, arg+2, \"flnSrtu\");\n  checkstack(L, L1, 3);\n  luaL_argcheck(L, options[0] != '>', arg + 2, \"invalid option '>'\");\n  if (lua_isfunction(L, arg + 1)) {  /* info about a function? */\n    options = lua_pushfstring(L, \">%s\", options);  /* add '>' to 'options' */\n    lua_pushvalue(L, arg + 1);  /* move function to 'L1' stack */\n    lua_xmove(L, L1, 1);\n  }\n  else {  /* stack level */\n    if (!lua_getstack(L1, (int)luaL_checkinteger(L, arg + 1), &ar)) {\n      luaL_pushfail(L);  /* level out of range */\n      return 1;\n    }\n  }\n  if (!lua_getinfo(L1, options, &ar))\n    return luaL_argerror(L, arg+2, \"invalid option\");\n  lua_newtable(L);  /* table to collect results */\n  if (strchr(options, 'S')) {\n    lua_pushlstring(L, ar.source, ar.srclen);\n    lua_setfield(L, -2, \"source\");\n    settabss(L, \"short_src\", ar.short_src);\n    settabsi(L, \"linedefined\", ar.linedefined);\n    settabsi(L, \"lastlinedefined\", ar.lastlinedefined);\n    settabss(L, \"what\", ar.what);\n  }\n  if (strchr(options, 'l'))\n    settabsi(L, \"currentline\", ar.currentline);\n  if (strchr(options, 'u')) {\n    settabsi(L, \"nups\", ar.nups);\n    settabsi(L, \"nparams\", ar.nparams);\n    settabsb(L, \"isvararg\", ar.isvararg);\n  }\n  if (strchr(options, 'n')) {\n    settabss(L, \"name\", ar.name);\n    settabss(L, \"namewhat\", ar.namewhat);\n  }\n  if (strchr(options, 'r')) {\n    settabsi(L, \"ftransfer\", ar.ftransfer);\n    settabsi(L, \"ntransfer\", ar.ntransfer);\n  }\n  if (strchr(options, 't'))\n    settabsb(L, \"istailcall\", ar.istailcall);\n  if (strchr(options, 'L'))\n    treatstackoption(L, L1, \"activelines\");\n  if (strchr(options, 'f'))\n    treatstackoption(L, L1, \"func\");\n  return 1;  /* return table */\n}\n\n\nstatic int db_getlocal (lua_State *L) {\n  int arg;\n  lua_State *L1 = getthread(L, &arg);\n  int nvar = (int)luaL_checkinteger(L, arg + 2);  /* local-variable index */\n  if (lua_isfunction(L, arg + 1)) {  /* function argument? */\n    lua_pushvalue(L, arg + 1);  /* push function */\n    lua_pushstring(L, lua_getlocal(L, NULL, nvar));  /* push local name */\n    return 1;  /* return only name (there is no value) */\n  }\n  else {  /* stack-level argument */\n    lua_Debug ar;\n    const char *name;\n    int level = (int)luaL_checkinteger(L, arg + 1);\n    if (l_unlikely(!lua_getstack(L1, level, &ar)))  /* out of range? */\n      return luaL_argerror(L, arg+1, \"level out of range\");\n    checkstack(L, L1, 1);\n    name = lua_getlocal(L1, &ar, nvar);\n    if (name) {\n      lua_xmove(L1, L, 1);  /* move local value */\n      lua_pushstring(L, name);  /* push name */\n      lua_rotate(L, -2, 1);  /* re-order */\n      return 2;\n    }\n    else {\n      luaL_pushfail(L);  /* no name (nor value) */\n      return 1;\n    }\n  }\n}\n\n\nstatic int db_setlocal (lua_State *L) {\n  int arg;\n  const char *name;\n  lua_State *L1 = getthread(L, &arg);\n  lua_Debug ar;\n  int level = (int)luaL_checkinteger(L, arg + 1);\n  int nvar = (int)luaL_checkinteger(L, arg + 2);\n  if (l_unlikely(!lua_getstack(L1, level, &ar)))  /* out of range? */\n    return luaL_argerror(L, arg+1, \"level out of range\");\n  luaL_checkany(L, arg+3);\n  lua_settop(L, arg+3);\n  checkstack(L, L1, 1);\n  lua_xmove(L, L1, 1);\n  name = lua_setlocal(L1, &ar, nvar);\n  if (name == NULL)\n    lua_pop(L1, 1);  /* pop value (if not popped by 'lua_setlocal') */\n  lua_pushstring(L, name);\n  return 1;\n}\n\n\n/*\n** get (if 'get' is true) or set an upvalue from a closure\n*/\nstatic int auxupvalue (lua_State *L, int get) {\n  const char *name;\n  int n = (int)luaL_checkinteger(L, 2);  /* upvalue index */\n  luaL_checktype(L, 1, LUA_TFUNCTION);  /* closure */\n  name = get ? lua_getupvalue(L, 1, n) : lua_setupvalue(L, 1, n);\n  if (name == NULL) return 0;\n  lua_pushstring(L, name);\n  lua_insert(L, -(get+1));  /* no-op if get is false */\n  return get + 1;\n}\n\n\nstatic int db_getupvalue (lua_State *L) {\n  return auxupvalue(L, 1);\n}\n\n\nstatic int db_setupvalue (lua_State *L) {\n  luaL_checkany(L, 3);\n  return auxupvalue(L, 0);\n}\n\n\n/*\n** Check whether a given upvalue from a given closure exists and\n** returns its index\n*/\nstatic void *checkupval (lua_State *L, int argf, int argnup, int *pnup) {\n  void *id;\n  int nup = (int)luaL_checkinteger(L, argnup);  /* upvalue index */\n  luaL_checktype(L, argf, LUA_TFUNCTION);  /* closure */\n  id = lua_upvalueid(L, argf, nup);\n  if (pnup) {\n    luaL_argcheck(L, id != NULL, argnup, \"invalid upvalue index\");\n    *pnup = nup;\n  }\n  return id;\n}\n\n\nstatic int db_upvalueid (lua_State *L) {\n  void *id = checkupval(L, 1, 2, NULL);\n  if (id != NULL)\n    lua_pushlightuserdata(L, id);\n  else\n    luaL_pushfail(L);\n  return 1;\n}\n\n\nstatic int db_upvaluejoin (lua_State *L) {\n  int n1, n2;\n  checkupval(L, 1, 2, &n1);\n  checkupval(L, 3, 4, &n2);\n  luaL_argcheck(L, !lua_iscfunction(L, 1), 1, \"Lua function expected\");\n  luaL_argcheck(L, !lua_iscfunction(L, 3), 3, \"Lua function expected\");\n  lua_upvaluejoin(L, 1, n1, 3, n2);\n  return 0;\n}\n\n\n/*\n** Call hook function registered at hook table for the current\n** thread (if there is one)\n*/\nstatic void hookf (lua_State *L, lua_Debug *ar) {\n  static const char *const hooknames[] =\n    {\"call\", \"return\", \"line\", \"count\", \"tail call\"};\n  lua_getfield(L, LUA_REGISTRYINDEX, HOOKKEY);\n  lua_pushthread(L);\n  if (lua_rawget(L, -2) == LUA_TFUNCTION) {  /* is there a hook function? */\n    lua_pushstring(L, hooknames[(int)ar->event]);  /* push event name */\n    if (ar->currentline >= 0)\n      lua_pushinteger(L, ar->currentline);  /* push current line */\n    else lua_pushnil(L);\n    lua_assert(lua_getinfo(L, \"lS\", ar));\n    lua_call(L, 2, 0);  /* call hook function */\n  }\n}\n\n\n/*\n** Convert a string mask (for 'sethook') into a bit mask\n*/\nstatic int makemask (const char *smask, int count) {\n  int mask = 0;\n  if (strchr(smask, 'c')) mask |= LUA_MASKCALL;\n  if (strchr(smask, 'r')) mask |= LUA_MASKRET;\n  if (strchr(smask, 'l')) mask |= LUA_MASKLINE;\n  if (count > 0) mask |= LUA_MASKCOUNT;\n  return mask;\n}\n\n\n/*\n** Convert a bit mask (for 'gethook') into a string mask\n*/\nstatic char *unmakemask (int mask, char *smask) {\n  int i = 0;\n  if (mask & LUA_MASKCALL) smask[i++] = 'c';\n  if (mask & LUA_MASKRET) smask[i++] = 'r';\n  if (mask & LUA_MASKLINE) smask[i++] = 'l';\n  smask[i] = '\\0';\n  return smask;\n}\n\n\nstatic int db_sethook (lua_State *L) {\n  int arg, mask, count;\n  lua_Hook func;\n  lua_State *L1 = getthread(L, &arg);\n  if (lua_isnoneornil(L, arg+1)) {  /* no hook? */\n    lua_settop(L, arg+1);\n    func = NULL; mask = 0; count = 0;  /* turn off hooks */\n  }\n  else {\n    const char *smask = luaL_checkstring(L, arg+2);\n    luaL_checktype(L, arg+1, LUA_TFUNCTION);\n    count = (int)luaL_optinteger(L, arg + 3, 0);\n    func = hookf; mask = makemask(smask, count);\n  }\n  if (!luaL_getsubtable(L, LUA_REGISTRYINDEX, HOOKKEY)) {\n    /* table just created; initialize it */\n    lua_pushliteral(L, \"k\");\n    lua_setfield(L, -2, \"__mode\");  /** hooktable.__mode = \"k\" */\n    lua_pushvalue(L, -1);\n    lua_setmetatable(L, -2);  /* metatable(hooktable) = hooktable */\n  }\n  checkstack(L, L1, 1);\n  lua_pushthread(L1); lua_xmove(L1, L, 1);  /* key (thread) */\n  lua_pushvalue(L, arg + 1);  /* value (hook function) */\n  lua_rawset(L, -3);  /* hooktable[L1] = new Lua hook */\n  lua_sethook(L1, func, mask, count);\n  return 0;\n}\n\n\nstatic int db_gethook (lua_State *L) {\n  int arg;\n  lua_State *L1 = getthread(L, &arg);\n  char buff[5];\n  int mask = lua_gethookmask(L1);\n  lua_Hook hook = lua_gethook(L1);\n  if (hook == NULL) {  /* no hook? */\n    luaL_pushfail(L);\n    return 1;\n  }\n  else if (hook != hookf)  /* external hook? */\n    lua_pushliteral(L, \"external hook\");\n  else {  /* hook table must exist */\n    lua_getfield(L, LUA_REGISTRYINDEX, HOOKKEY);\n    checkstack(L, L1, 1);\n    lua_pushthread(L1); lua_xmove(L1, L, 1);\n    lua_rawget(L, -2);   /* 1st result = hooktable[L1] */\n    lua_remove(L, -2);  /* remove hook table */\n  }\n  lua_pushstring(L, unmakemask(mask, buff));  /* 2nd result = mask */\n  lua_pushinteger(L, lua_gethookcount(L1));  /* 3rd result = count */\n  return 3;\n}\n\n\nstatic int db_debug (lua_State *L) {\n  for (;;) {\n    char buffer[250];\n    lua_writestringerror(\"%s\", \"lua_debug> \");\n    if (fgets(buffer, sizeof(buffer), stdin) == NULL ||\n        strcmp(buffer, \"cont\\n\") == 0)\n      return 0;\n    if (luaL_loadbuffer(L, buffer, strlen(buffer), \"=(debug command)\") ||\n        lua_pcall(L, 0, 0, 0))\n      lua_writestringerror(\"%s\\n\", luaL_tolstring(L, -1, NULL));\n    lua_settop(L, 0);  /* remove eventual returns */\n  }\n}\n\n\nstatic int db_traceback (lua_State *L) {\n  int arg;\n  lua_State *L1 = getthread(L, &arg);\n  const char *msg = lua_tostring(L, arg + 1);\n  if (msg == NULL && !lua_isnoneornil(L, arg + 1))  /* non-string 'msg'? */\n    lua_pushvalue(L, arg + 1);  /* return it untouched */\n  else {\n    int level = (int)luaL_optinteger(L, arg + 2, (L == L1) ? 1 : 0);\n    luaL_traceback(L, L1, msg, level);\n  }\n  return 1;\n}\n\n\nstatic const luaL_Reg dblib[] = {\n  {\"debug\", db_debug},\n  {\"getuservalue\", db_getuservalue},\n  {\"gethook\", db_gethook},\n  {\"getinfo\", db_getinfo},\n  {\"getlocal\", db_getlocal},\n  {\"getregistry\", db_getregistry},\n  {\"getmetatable\", db_getmetatable},\n  {\"getupvalue\", db_getupvalue},\n  {\"upvaluejoin\", db_upvaluejoin},\n  {\"upvalueid\", db_upvalueid},\n  {\"setuservalue\", db_setuservalue},\n  {\"sethook\", db_sethook},\n  {\"setlocal\", db_setlocal},\n  {\"setmetatable\", db_setmetatable},\n  {\"setupvalue\", db_setupvalue},\n  {\"traceback\", db_traceback},\n  {NULL, NULL}\n};\n\n\nLUAMOD_API int luaopen_debug (lua_State *L) {\n  luaL_newlib(L, dblib);\n  return 1;\n}\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/ldebug.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: ldebug.c $\n** Debug Interface\n** See Copyright Notice in lua.h\n*/\n\n#define ldebug_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <stdarg.h>\n#include <stddef.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lapi.h\"\n#include \"lcode.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n#include \"lvm.h\"\n\n\n\n#define noLuaClosure(f)\t\t((f) == NULL || (f)->c.tt == LUA_VCCL)\n\n\nstatic const char *funcnamefromcall (lua_State *L, CallInfo *ci,\n                                                   const char **name);\n\n\nstatic int currentpc (CallInfo *ci) {\n  lua_assert(isLua(ci));\n  return pcRel(ci->u.l.savedpc, ci_func(ci)->p);\n}\n\n\n/*\n** Get a \"base line\" to find the line corresponding to an instruction.\n** Base lines are regularly placed at MAXIWTHABS intervals, so usually\n** an integer division gets the right place. When the source file has\n** large sequences of empty/comment lines, it may need extra entries,\n** so the original estimate needs a correction.\n** If the original estimate is -1, the initial 'if' ensures that the\n** 'while' will run at least once.\n** The assertion that the estimate is a lower bound for the correct base\n** is valid as long as the debug info has been generated with the same\n** value for MAXIWTHABS or smaller. (Previous releases use a little\n** smaller value.)\n*/\nstatic int getbaseline (const Proto *f, int pc, int *basepc) {\n  if (f->sizeabslineinfo == 0 || pc < f->abslineinfo[0].pc) {\n    *basepc = -1;  /* start from the beginning */\n    return f->linedefined;\n  }\n  else {\n    int i = cast_uint(pc) / MAXIWTHABS - 1;  /* get an estimate */\n    /* estimate must be a lower bound of the correct base */\n    lua_assert(i < 0 ||\n              (i < f->sizeabslineinfo && f->abslineinfo[i].pc <= pc));\n    while (i + 1 < f->sizeabslineinfo && pc >= f->abslineinfo[i + 1].pc)\n      i++;  /* low estimate; adjust it */\n    *basepc = f->abslineinfo[i].pc;\n    return f->abslineinfo[i].line;\n  }\n}\n\n\n/*\n** Get the line corresponding to instruction 'pc' in function 'f';\n** first gets a base line and from there does the increments until\n** the desired instruction.\n*/\nint luaG_getfuncline (const Proto *f, int pc) {\n  if (f->lineinfo == NULL)  /* no debug information? */\n    return -1;\n  else {\n    int basepc;\n    int baseline = getbaseline(f, pc, &basepc);\n    while (basepc++ < pc) {  /* walk until given instruction */\n      lua_assert(f->lineinfo[basepc] != ABSLINEINFO);\n      baseline += f->lineinfo[basepc];  /* correct line */\n    }\n    return baseline;\n  }\n}\n\n\nstatic int getcurrentline (CallInfo *ci) {\n  return luaG_getfuncline(ci_func(ci)->p, currentpc(ci));\n}\n\n\n/*\n** Set 'trap' for all active Lua frames.\n** This function can be called during a signal, under \"reasonable\"\n** assumptions. A new 'ci' is completely linked in the list before it\n** becomes part of the \"active\" list, and we assume that pointers are\n** atomic; see comment in next function.\n** (A compiler doing interprocedural optimizations could, theoretically,\n** reorder memory writes in such a way that the list could be\n** temporarily broken while inserting a new element. We simply assume it\n** has no good reasons to do that.)\n*/\nstatic void settraps (CallInfo *ci) {\n  for (; ci != NULL; ci = ci->previous)\n    if (isLua(ci))\n      ci->u.l.trap = 1;\n}\n\n\n/*\n** This function can be called during a signal, under \"reasonable\"\n** assumptions.\n** Fields 'basehookcount' and 'hookcount' (set by 'resethookcount')\n** are for debug only, and it is no problem if they get arbitrary\n** values (causes at most one wrong hook call). 'hookmask' is an atomic\n** value. We assume that pointers are atomic too (e.g., gcc ensures that\n** for all platforms where it runs). Moreover, 'hook' is always checked\n** before being called (see 'luaD_hook').\n*/\nLUA_API void lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {\n  if (func == NULL || mask == 0) {  /* turn off hooks? */\n    mask = 0;\n    func = NULL;\n  }\n  L->hook = func;\n  L->basehookcount = count;\n  resethookcount(L);\n  L->hookmask = cast_byte(mask);\n  if (mask)\n    settraps(L->ci);  /* to trace inside 'luaV_execute' */\n}\n\n\nLUA_API lua_Hook lua_gethook (lua_State *L) {\n  return L->hook;\n}\n\n\nLUA_API int lua_gethookmask (lua_State *L) {\n  return L->hookmask;\n}\n\n\nLUA_API int lua_gethookcount (lua_State *L) {\n  return L->basehookcount;\n}\n\n\nLUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar) {\n  int status;\n  CallInfo *ci;\n  if (level < 0) return 0;  /* invalid (negative) level */\n  lua_lock(L);\n  for (ci = L->ci; level > 0 && ci != &L->base_ci; ci = ci->previous)\n    level--;\n  if (level == 0 && ci != &L->base_ci) {  /* level found? */\n    status = 1;\n    ar->i_ci = ci;\n  }\n  else status = 0;  /* no such level */\n  lua_unlock(L);\n  return status;\n}\n\n\nstatic const char *upvalname (const Proto *p, int uv) {\n  TString *s = check_exp(uv < p->sizeupvalues, p->upvalues[uv].name);\n  if (s == NULL) return \"?\";\n  else return getstr(s);\n}\n\n\nstatic const char *findvararg (CallInfo *ci, int n, StkId *pos) {\n  if (clLvalue(s2v(ci->func.p))->p->flag & PF_ISVARARG) {\n    int nextra = ci->u.l.nextraargs;\n    if (n >= -nextra) {  /* 'n' is negative */\n      *pos = ci->func.p - nextra - (n + 1);\n      return \"(vararg)\";  /* generic name for any vararg */\n    }\n  }\n  return NULL;  /* no such vararg */\n}\n\n\nconst char *luaG_findlocal (lua_State *L, CallInfo *ci, int n, StkId *pos) {\n  StkId base = ci->func.p + 1;\n  const char *name = NULL;\n  if (isLua(ci)) {\n    if (n < 0)  /* access to vararg values? */\n      return findvararg(ci, n, pos);\n    else\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n  }\n  if (name == NULL) {  /* no 'standard' name? */\n    StkId limit = (ci == L->ci) ? L->top.p : ci->next->func.p;\n    if (limit - base >= n && n > 0) {  /* is 'n' inside 'ci' stack? */\n      /* generic name for any valid slot */\n      name = isLua(ci) ? \"(temporary)\" : \"(C temporary)\";\n    }\n    else\n      return NULL;  /* no name */\n  }\n  if (pos)\n    *pos = base + (n - 1);\n  return name;\n}\n\n\nLUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n) {\n  const char *name;\n  lua_lock(L);\n  if (ar == NULL) {  /* information about non-active function? */\n    if (!isLfunction(s2v(L->top.p - 1)))  /* not a Lua function? */\n      name = NULL;\n    else  /* consider live variables at function start (parameters) */\n      name = luaF_getlocalname(clLvalue(s2v(L->top.p - 1))->p, n, 0);\n  }\n  else {  /* active function; get information through 'ar' */\n    StkId pos = NULL;  /* to avoid warnings */\n    name = luaG_findlocal(L, ar->i_ci, n, &pos);\n    if (name) {\n      setobjs2s(L, L->top.p, pos);\n      api_incr_top(L);\n    }\n  }\n  lua_unlock(L);\n  return name;\n}\n\n\nLUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {\n  StkId pos = NULL;  /* to avoid warnings */\n  const char *name;\n  lua_lock(L);\n  name = luaG_findlocal(L, ar->i_ci, n, &pos);\n  if (name) {\n    api_checkpop(L, 1);\n    setobjs2s(L, pos, L->top.p - 1);\n    L->top.p--;  /* pop value */\n  }\n  lua_unlock(L);\n  return name;\n}\n\n\nstatic void funcinfo (lua_Debug *ar, Closure *cl) {\n  if (noLuaClosure(cl)) {\n    ar->source = \"=[C]\";\n    ar->srclen = LL(\"=[C]\");\n    ar->linedefined = -1;\n    ar->lastlinedefined = -1;\n    ar->what = \"C\";\n  }\n  else {\n    const Proto *p = cl->l.p;\n    if (p->source) {\n      ar->source = getlstr(p->source, ar->srclen);\n    }\n    else {\n      ar->source = \"=?\";\n      ar->srclen = LL(\"=?\");\n    }\n    ar->linedefined = p->linedefined;\n    ar->lastlinedefined = p->lastlinedefined;\n    ar->what = (ar->linedefined == 0) ? \"main\" : \"Lua\";\n  }\n  luaO_chunkid(ar->short_src, ar->source, ar->srclen);\n}\n\n\nstatic int nextline (const Proto *p, int currentline, int pc) {\n  if (p->lineinfo[pc] != ABSLINEINFO)\n    return currentline + p->lineinfo[pc];\n  else\n    return luaG_getfuncline(p, pc);\n}\n\n\nstatic void collectvalidlines (lua_State *L, Closure *f) {\n  if (noLuaClosure(f)) {\n    setnilvalue(s2v(L->top.p));\n    api_incr_top(L);\n  }\n  else {\n    int i;\n    TValue v;\n    const Proto *p = f->l.p;\n    int currentline = p->linedefined;\n    Table *t = luaH_new(L);  /* new table to store active lines */\n    sethvalue2s(L, L->top.p, t);  /* push it on stack */\n    api_incr_top(L);\n    setbtvalue(&v);  /* boolean 'true' to be the value of all indices */\n    if (!(p->flag & PF_ISVARARG))  /* regular function? */\n      i = 0;  /* consider all instructions */\n    else {  /* vararg function */\n      lua_assert(GET_OPCODE(p->code[0]) == OP_VARARGPREP);\n      currentline = nextline(p, currentline, 0);\n      i = 1;  /* skip first instruction (OP_VARARGPREP) */\n    }\n    for (; i < p->sizelineinfo; i++) {  /* for each instruction */\n      currentline = nextline(p, currentline, i);  /* get its line */\n      luaH_setint(L, t, currentline, &v);  /* table[line] = true */\n    }\n  }\n}\n\n\nstatic const char *getfuncname (lua_State *L, CallInfo *ci, const char **name) {\n  /* calling function is a known function? */\n  if (ci != NULL && !(ci->callstatus & CIST_TAIL))\n    return funcnamefromcall(L, ci->previous, name);\n  else return NULL;  /* no way to find a name */\n}\n\n\nstatic int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,\n                       Closure *f, CallInfo *ci) {\n  int status = 1;\n  for (; *what; what++) {\n    switch (*what) {\n      case 'S': {\n        funcinfo(ar, f);\n        break;\n      }\n      case 'l': {\n        ar->currentline = (ci && isLua(ci)) ? getcurrentline(ci) : -1;\n        break;\n      }\n      case 'u': {\n        ar->nups = (f == NULL) ? 0 : f->c.nupvalues;\n        if (noLuaClosure(f)) {\n          ar->isvararg = 1;\n          ar->nparams = 0;\n        }\n        else {\n          ar->isvararg = f->l.p->flag & PF_ISVARARG;\n          ar->nparams = f->l.p->numparams;\n        }\n        break;\n      }\n      case 't': {\n        ar->istailcall = (ci) ? ci->callstatus & CIST_TAIL : 0;\n        break;\n      }\n      case 'n': {\n        ar->namewhat = getfuncname(L, ci, &ar->name);\n        if (ar->namewhat == NULL) {\n          ar->namewhat = \"\";  /* not found */\n          ar->name = NULL;\n        }\n        break;\n      }\n      case 'r': {\n        if (ci == NULL || !(ci->callstatus & CIST_TRAN))\n          ar->ftransfer = ar->ntransfer = 0;\n        else {\n          ar->ftransfer = ci->u2.transferinfo.ftransfer;\n          ar->ntransfer = ci->u2.transferinfo.ntransfer;\n        }\n        break;\n      }\n      case 'L':\n      case 'f':  /* handled by lua_getinfo */\n        break;\n      default: status = 0;  /* invalid option */\n    }\n  }\n  return status;\n}\n\n\nLUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar) {\n  int status;\n  Closure *cl;\n  CallInfo *ci;\n  TValue *func;\n  lua_lock(L);\n  if (*what == '>') {\n    ci = NULL;\n    func = s2v(L->top.p - 1);\n    api_check(L, ttisfunction(func), \"function expected\");\n    what++;  /* skip the '>' */\n    L->top.p--;  /* pop function */\n  }\n  else {\n    ci = ar->i_ci;\n    func = s2v(ci->func.p);\n    lua_assert(ttisfunction(func));\n  }\n  cl = ttisclosure(func) ? clvalue(func) : NULL;\n  status = auxgetinfo(L, what, ar, cl, ci);\n  if (strchr(what, 'f')) {\n    setobj2s(L, L->top.p, func);\n    api_incr_top(L);\n  }\n  if (strchr(what, 'L'))\n    collectvalidlines(L, cl);\n  lua_unlock(L);\n  return status;\n}\n\n\n/*\n** {======================================================\n** Symbolic Execution\n** =======================================================\n*/\n\n\nstatic int filterpc (int pc, int jmptarget) {\n  if (pc < jmptarget)  /* is code conditional (inside a jump)? */\n    return -1;  /* cannot know who sets that register */\n  else return pc;  /* current position sets that register */\n}\n\n\n/*\n** Try to find last instruction before 'lastpc' that modified register 'reg'.\n*/\nstatic int findsetreg (const Proto *p, int lastpc, int reg) {\n  int pc;\n  int setreg = -1;  /* keep last instruction that changed 'reg' */\n  int jmptarget = 0;  /* any code before this address is conditional */\n  if (testMMMode(GET_OPCODE(p->code[lastpc])))\n    lastpc--;  /* previous instruction was not actually executed */\n  for (pc = 0; pc < lastpc; pc++) {\n    Instruction i = p->code[pc];\n    OpCode op = GET_OPCODE(i);\n    int a = GETARG_A(i);\n    int change;  /* true if current instruction changed 'reg' */\n    switch (op) {\n      case OP_LOADNIL: {  /* set registers from 'a' to 'a+b' */\n        int b = GETARG_B(i);\n        change = (a <= reg && reg <= a + b);\n        break;\n      }\n      case OP_TFORCALL: {  /* affect all regs above its base */\n        change = (reg >= a + 2);\n        break;\n      }\n      case OP_CALL:\n      case OP_TAILCALL: {  /* affect all registers above base */\n        change = (reg >= a);\n        break;\n      }\n      case OP_JMP: {  /* doesn't change registers, but changes 'jmptarget' */\n        int b = GETARG_sJ(i);\n        int dest = pc + 1 + b;\n        /* jump does not skip 'lastpc' and is larger than current one? */\n        if (dest <= lastpc && dest > jmptarget)\n          jmptarget = dest;  /* update 'jmptarget' */\n        change = 0;\n        break;\n      }\n      default:  /* any instruction that sets A */\n        change = (testAMode(op) && reg == a);\n        break;\n    }\n    if (change)\n      setreg = filterpc(pc, jmptarget);\n  }\n  return setreg;\n}\n\n\n/*\n** Find a \"name\" for the constant 'c'.\n*/\nstatic const char *kname (const Proto *p, int index, const char **name) {\n  TValue *kvalue = &p->k[index];\n  if (ttisstring(kvalue)) {\n    *name = getstr(tsvalue(kvalue));\n    return \"constant\";\n  }\n  else {\n    *name = \"?\";\n    return NULL;\n  }\n}\n\n\nstatic const char *basicgetobjname (const Proto *p, int *ppc, int reg,\n                                    const char **name) {\n  int pc = *ppc;\n  *name = luaF_getlocalname(p, reg + 1, pc);\n  if (*name)  /* is a local? */\n    return \"local\";\n  /* else try symbolic execution */\n  *ppc = pc = findsetreg(p, pc, reg);\n  if (pc != -1) {  /* could find instruction? */\n    Instruction i = p->code[pc];\n    OpCode op = GET_OPCODE(i);\n    switch (op) {\n      case OP_MOVE: {\n        int b = GETARG_B(i);  /* move from 'b' to 'a' */\n        if (b < GETARG_A(i))\n          return basicgetobjname(p, ppc, b, name);  /* get name for 'b' */\n        break;\n      }\n      case OP_GETUPVAL: {\n        *name = upvalname(p, GETARG_B(i));\n        return \"upvalue\";\n      }\n      case OP_LOADK: return kname(p, GETARG_Bx(i), name);\n      case OP_LOADKX: return kname(p, GETARG_Ax(p->code[pc + 1]), name);\n      default: break;\n    }\n  }\n  return NULL;  /* could not find reasonable name */\n}\n\n\n/*\n** Find a \"name\" for the register 'c'.\n*/\nstatic void rname (const Proto *p, int pc, int c, const char **name) {\n  const char *what = basicgetobjname(p, &pc, c, name); /* search for 'c' */\n  if (!(what && *what == 'c'))  /* did not find a constant name? */\n    *name = \"?\";\n}\n\n\n/*\n** Find a \"name\" for a 'C' value in an RK instruction.\n*/\nstatic void rkname (const Proto *p, int pc, Instruction i, const char **name) {\n  int c = GETARG_C(i);  /* key index */\n  if (GETARG_k(i))  /* is 'c' a constant? */\n    kname(p, c, name);\n  else  /* 'c' is a register */\n    rname(p, pc, c, name);\n}\n\n\n/*\n** Check whether table being indexed by instruction 'i' is the\n** environment '_ENV'\n*/\nstatic const char *isEnv (const Proto *p, int pc, Instruction i, int isup) {\n  int t = GETARG_B(i);  /* table index */\n  const char *name;  /* name of indexed variable */\n  if (isup)  /* is 't' an upvalue? */\n    name = upvalname(p, t);\n  else  /* 't' is a register */\n    basicgetobjname(p, &pc, t, &name);\n  return (name && strcmp(name, LUA_ENV) == 0) ? \"global\" : \"field\";\n}\n\n\n/*\n** Extend 'basicgetobjname' to handle table accesses\n*/\nstatic const char *getobjname (const Proto *p, int lastpc, int reg,\n                               const char **name) {\n  const char *kind = basicgetobjname(p, &lastpc, reg, name);\n  if (kind != NULL)\n    return kind;\n  else if (lastpc != -1) {  /* could find instruction? */\n    Instruction i = p->code[lastpc];\n    OpCode op = GET_OPCODE(i);\n    switch (op) {\n      case OP_GETTABUP: {\n        int k = GETARG_C(i);  /* key index */\n        kname(p, k, name);\n        return isEnv(p, lastpc, i, 1);\n      }\n      case OP_GETTABLE: {\n        int k = GETARG_C(i);  /* key index */\n        rname(p, lastpc, k, name);\n        return isEnv(p, lastpc, i, 0);\n      }\n      case OP_GETI: {\n        *name = \"integer index\";\n        return \"field\";\n      }\n      case OP_GETFIELD: {\n        int k = GETARG_C(i);  /* key index */\n        kname(p, k, name);\n        return isEnv(p, lastpc, i, 0);\n      }\n      case OP_SELF: {\n        rkname(p, lastpc, i, name);\n        return \"method\";\n      }\n      default: break;  /* go through to return NULL */\n    }\n  }\n  return NULL;  /* could not find reasonable name */\n}\n\n\n/*\n** Try to find a name for a function based on the code that called it.\n** (Only works when function was called by a Lua function.)\n** Returns what the name is (e.g., \"for iterator\", \"method\",\n** \"metamethod\") and sets '*name' to point to the name.\n*/\nstatic const char *funcnamefromcode (lua_State *L, const Proto *p,\n                                     int pc, const char **name) {\n  TMS tm = (TMS)0;  /* (initial value avoids warnings) */\n  Instruction i = p->code[pc];  /* calling instruction */\n  switch (GET_OPCODE(i)) {\n    case OP_CALL:\n    case OP_TAILCALL:\n      return getobjname(p, pc, GETARG_A(i), name);  /* get function name */\n    case OP_TFORCALL: {  /* for iterator */\n      *name = \"for iterator\";\n       return \"for iterator\";\n    }\n    /* other instructions can do calls through metamethods */\n    case OP_SELF: case OP_GETTABUP: case OP_GETTABLE:\n    case OP_GETI: case OP_GETFIELD:\n      tm = TM_INDEX;\n      break;\n    case OP_SETTABUP: case OP_SETTABLE: case OP_SETI: case OP_SETFIELD:\n      tm = TM_NEWINDEX;\n      break;\n    case OP_MMBIN: case OP_MMBINI: case OP_MMBINK: {\n      tm = cast(TMS, GETARG_C(i));\n      break;\n    }\n    case OP_UNM: tm = TM_UNM; break;\n    case OP_BNOT: tm = TM_BNOT; break;\n    case OP_LEN: tm = TM_LEN; break;\n    case OP_CONCAT: tm = TM_CONCAT; break;\n    case OP_EQ: tm = TM_EQ; break;\n    /* no cases for OP_EQI and OP_EQK, as they don't call metamethods */\n    case OP_LT: case OP_LTI: case OP_GTI: tm = TM_LT; break;\n    case OP_LE: case OP_LEI: case OP_GEI: tm = TM_LE; break;\n    case OP_CLOSE: case OP_RETURN: tm = TM_CLOSE; break;\n    default:\n      return NULL;  /* cannot find a reasonable name */\n  }\n  *name = getshrstr(G(L)->tmname[tm]) + 2;\n  return \"metamethod\";\n}\n\n\n/*\n** Try to find a name for a function based on how it was called.\n*/\nstatic const char *funcnamefromcall (lua_State *L, CallInfo *ci,\n                                                   const char **name) {\n  if (ci->callstatus & CIST_HOOKED) {  /* was it called inside a hook? */\n    *name = \"?\";\n    return \"hook\";\n  }\n  else if (ci->callstatus & CIST_FIN) {  /* was it called as a finalizer? */\n    *name = \"__gc\";\n    return \"metamethod\";  /* report it as such */\n  }\n  else if (isLua(ci))\n    return funcnamefromcode(L, ci_func(ci)->p, currentpc(ci), name);\n  else\n    return NULL;\n}\n\n/* }====================================================== */\n\n\n\n/*\n** Check whether pointer 'o' points to some value in the stack frame of\n** the current function and, if so, returns its index.  Because 'o' may\n** not point to a value in this stack, we cannot compare it with the\n** region boundaries (undefined behavior in ISO C).\n*/\nstatic int instack (CallInfo *ci, const TValue *o) {\n  int pos;\n  StkId base = ci->func.p + 1;\n  for (pos = 0; base + pos < ci->top.p; pos++) {\n    if (o == s2v(base + pos))\n      return pos;\n  }\n  return -1;  /* not found */\n}\n\n\n/*\n** Checks whether value 'o' came from an upvalue. (That can only happen\n** with instructions OP_GETTABUP/OP_SETTABUP, which operate directly on\n** upvalues.)\n*/\nstatic const char *getupvalname (CallInfo *ci, const TValue *o,\n                                 const char **name) {\n  LClosure *c = ci_func(ci);\n  int i;\n  for (i = 0; i < c->nupvalues; i++) {\n    if (c->upvals[i]->v.p == o) {\n      *name = upvalname(c->p, i);\n      return \"upvalue\";\n    }\n  }\n  return NULL;\n}\n\n\nstatic const char *formatvarinfo (lua_State *L, const char *kind,\n                                                const char *name) {\n  if (kind == NULL)\n    return \"\";  /* no information */\n  else\n    return luaO_pushfstring(L, \" (%s '%s')\", kind, name);\n}\n\n/*\n** Build a string with a \"description\" for the value 'o', such as\n** \"variable 'x'\" or \"upvalue 'y'\".\n*/\nstatic const char *varinfo (lua_State *L, const TValue *o) {\n  CallInfo *ci = L->ci;\n  const char *name = NULL;  /* to avoid warnings */\n  const char *kind = NULL;\n  if (isLua(ci)) {\n    kind = getupvalname(ci, o, &name);  /* check whether 'o' is an upvalue */\n    if (!kind) {  /* not an upvalue? */\n      int reg = instack(ci, o);  /* try a register */\n      if (reg >= 0)  /* is 'o' a register? */\n        kind = getobjname(ci_func(ci)->p, currentpc(ci), reg, &name);\n    }\n  }\n  return formatvarinfo(L, kind, name);\n}\n\n\n/*\n** Raise a type error\n*/\nstatic l_noret typeerror (lua_State *L, const TValue *o, const char *op,\n                          const char *extra) {\n  const char *t = luaT_objtypename(L, o);\n  luaG_runerror(L, \"attempt to %s a %s value%s\", op, t, extra);\n}\n\n\n/*\n** Raise a type error with \"standard\" information about the faulty\n** object 'o' (using 'varinfo').\n*/\nl_noret luaG_typeerror (lua_State *L, const TValue *o, const char *op) {\n  typeerror(L, o, op, varinfo(L, o));\n}\n\n\n/*\n** Raise an error for calling a non-callable object. Try to find a name\n** for the object based on how it was called ('funcnamefromcall'); if it\n** cannot get a name there, try 'varinfo'.\n*/\nl_noret luaG_callerror (lua_State *L, const TValue *o) {\n  CallInfo *ci = L->ci;\n  const char *name = NULL;  /* to avoid warnings */\n  const char *kind = funcnamefromcall(L, ci, &name);\n  const char *extra = kind ? formatvarinfo(L, kind, name) : varinfo(L, o);\n  typeerror(L, o, \"call\", extra);\n}\n\n\nl_noret luaG_forerror (lua_State *L, const TValue *o, const char *what) {\n  luaG_runerror(L, \"bad 'for' %s (number expected, got %s)\",\n                   what, luaT_objtypename(L, o));\n}\n\n\nl_noret luaG_concaterror (lua_State *L, const TValue *p1, const TValue *p2) {\n  if (ttisstring(p1) || cvt2str(p1)) p1 = p2;\n  luaG_typeerror(L, p1, \"concatenate\");\n}\n\n\nl_noret luaG_opinterror (lua_State *L, const TValue *p1,\n                         const TValue *p2, const char *msg) {\n  if (!ttisnumber(p1))  /* first operand is wrong? */\n    p2 = p1;  /* now second is wrong */\n  luaG_typeerror(L, p2, msg);\n}\n\n\n/*\n** Error when both values are convertible to numbers, but not to integers\n*/\nl_noret luaG_tointerror (lua_State *L, const TValue *p1, const TValue *p2) {\n  lua_Integer temp;\n  if (!luaV_tointegerns(p1, &temp, LUA_FLOORN2I))\n    p2 = p1;\n  luaG_runerror(L, \"number%s has no integer representation\", varinfo(L, p2));\n}\n\n\nl_noret luaG_ordererror (lua_State *L, const TValue *p1, const TValue *p2) {\n  const char *t1 = luaT_objtypename(L, p1);\n  const char *t2 = luaT_objtypename(L, p2);\n  if (strcmp(t1, t2) == 0)\n    luaG_runerror(L, \"attempt to compare two %s values\", t1);\n  else\n    luaG_runerror(L, \"attempt to compare %s with %s\", t1, t2);\n}\n\n\n/* add src:line information to 'msg' */\nconst char *luaG_addinfo (lua_State *L, const char *msg, TString *src,\n                                        int line) {\n  char buff[LUA_IDSIZE];\n  if (src) {\n    size_t idlen;\n    const char *id = getlstr(src, idlen);\n    luaO_chunkid(buff, id, idlen);\n  }\n  else {  /* no source available; use \"?\" instead */\n    buff[0] = '?'; buff[1] = '\\0';\n  }\n  return luaO_pushfstring(L, \"%s:%d: %s\", buff, line, msg);\n}\n\n\nl_noret luaG_errormsg (lua_State *L) {\n  if (L->errfunc != 0) {  /* is there an error handling function? */\n    StkId errfunc = restorestack(L, L->errfunc);\n    lua_assert(ttisfunction(s2v(errfunc)));\n    setobjs2s(L, L->top.p, L->top.p - 1);  /* move argument */\n    setobjs2s(L, L->top.p - 1, errfunc);  /* push function */\n    L->top.p++;  /* assume EXTRA_STACK */\n    luaD_callnoyield(L, L->top.p - 2, 1);  /* call it */\n  }\n  luaD_throw(L, LUA_ERRRUN);\n}\n\n\nl_noret luaG_runerror (lua_State *L, const char *fmt, ...) {\n  CallInfo *ci = L->ci;\n  const char *msg;\n  va_list argp;\n  luaC_checkGC(L);  /* error message uses memory */\n  va_start(argp, fmt);\n  msg = luaO_pushvfstring(L, fmt, argp);  /* format message */\n  va_end(argp);\n  if (isLua(ci)) {  /* if Lua function, add source:line information */\n    luaG_addinfo(L, msg, ci_func(ci)->p->source, getcurrentline(ci));\n    setobjs2s(L, L->top.p - 2, L->top.p - 1);  /* remove 'msg' */\n    L->top.p--;\n  }\n  luaG_errormsg(L);\n}\n\n\n/*\n** Check whether new instruction 'newpc' is in a different line from\n** previous instruction 'oldpc'. More often than not, 'newpc' is only\n** one or a few instructions after 'oldpc' (it must be after, see\n** caller), so try to avoid calling 'luaG_getfuncline'. If they are\n** too far apart, there is a good chance of a ABSLINEINFO in the way,\n** so it goes directly to 'luaG_getfuncline'.\n*/\nstatic int changedline (const Proto *p, int oldpc, int newpc) {\n  if (p->lineinfo == NULL)  /* no debug information? */\n    return 0;\n  if (newpc - oldpc < MAXIWTHABS / 2) {  /* not too far apart? */\n    int delta = 0;  /* line difference */\n    int pc = oldpc;\n    for (;;) {\n      int lineinfo = p->lineinfo[++pc];\n      if (lineinfo == ABSLINEINFO)\n        break;  /* cannot compute delta; fall through */\n      delta += lineinfo;\n      if (pc == newpc)\n        return (delta != 0);  /* delta computed successfully */\n    }\n  }\n  /* either instructions are too far apart or there is an absolute line\n     info in the way; compute line difference explicitly */\n  return (luaG_getfuncline(p, oldpc) != luaG_getfuncline(p, newpc));\n}\n\n\n/*\n** Traces Lua calls. If code is running the first instruction of a function,\n** and function is not vararg, and it is not coming from an yield,\n** calls 'luaD_hookcall'. (Vararg functions will call 'luaD_hookcall'\n** after adjusting its variable arguments; otherwise, they could call\n** a line/count hook before the call hook. Functions coming from\n** an yield already called 'luaD_hookcall' before yielding.)\n*/\nint luaG_tracecall (lua_State *L) {\n  CallInfo *ci = L->ci;\n  Proto *p = ci_func(ci)->p;\n  ci->u.l.trap = 1;  /* ensure hooks will be checked */\n  if (ci->u.l.savedpc == p->code) {  /* first instruction (not resuming)? */\n    if (p->flag & PF_ISVARARG)\n      return 0;  /* hooks will start at VARARGPREP instruction */\n    else if (!(ci->callstatus & CIST_HOOKYIELD))  /* not yieded? */\n      luaD_hookcall(L, ci);  /* check 'call' hook */\n  }\n  return 1;  /* keep 'trap' on */\n}\n\n\n/*\n** Traces the execution of a Lua function. Called before the execution\n** of each opcode, when debug is on. 'L->oldpc' stores the last\n** instruction traced, to detect line changes. When entering a new\n** function, 'npci' will be zero and will test as a new line whatever\n** the value of 'oldpc'.  Some exceptional conditions may return to\n** a function without setting 'oldpc'. In that case, 'oldpc' may be\n** invalid; if so, use zero as a valid value. (A wrong but valid 'oldpc'\n** at most causes an extra call to a line hook.)\n** This function is not \"Protected\" when called, so it should correct\n** 'L->top.p' before calling anything that can run the GC.\n*/\nint luaG_traceexec (lua_State *L, const Instruction *pc) {\n  CallInfo *ci = L->ci;\n  lu_byte mask = L->hookmask;\n  const Proto *p = ci_func(ci)->p;\n  int counthook;\n  if (!(mask & (LUA_MASKLINE | LUA_MASKCOUNT))) {  /* no hooks? */\n    ci->u.l.trap = 0;  /* don't need to stop again */\n    return 0;  /* turn off 'trap' */\n  }\n  pc++;  /* reference is always next instruction */\n  ci->u.l.savedpc = pc;  /* save 'pc' */\n  counthook = (mask & LUA_MASKCOUNT) && (--L->hookcount == 0);\n  if (counthook)\n    resethookcount(L);  /* reset count */\n  else if (!(mask & LUA_MASKLINE))\n    return 1;  /* no line hook and count != 0; nothing to be done now */\n  if (ci->callstatus & CIST_HOOKYIELD) {  /* hook yielded last time? */\n    ci->callstatus &= ~CIST_HOOKYIELD;  /* erase mark */\n    return 1;  /* do not call hook again (VM yielded, so it did not move) */\n  }\n  if (!isIT(*(ci->u.l.savedpc - 1)))  /* top not being used? */\n    L->top.p = ci->top.p;  /* correct top */\n  if (counthook)\n    luaD_hook(L, LUA_HOOKCOUNT, -1, 0, 0);  /* call count hook */\n  if (mask & LUA_MASKLINE) {\n    /* 'L->oldpc' may be invalid; use zero in this case */\n    int oldpc = (L->oldpc < p->sizecode) ? L->oldpc : 0;\n    int npci = pcRel(pc, p);\n    if (npci <= oldpc ||  /* call hook when jump back (loop), */\n        changedline(p, oldpc, npci)) {  /* or when enter new line */\n      int newline = luaG_getfuncline(p, npci);\n      luaD_hook(L, LUA_HOOKLINE, newline, 0, 0);  /* call line hook */\n    }\n    L->oldpc = npci;  /* 'pc' of last call to line hook */\n  }\n  if (L->status == LUA_YIELD) {  /* did hook yield? */\n    if (counthook)\n      L->hookcount = 1;  /* undo decrement to zero */\n    ci->callstatus |= CIST_HOOKYIELD;  /* mark that it yielded */\n    luaD_throw(L, LUA_YIELD);\n  }\n  return 1;  /* keep 'trap' on */\n}\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/ldebug.h",
		"is_binary":	false,
		"content":	"/*\n** $Id: ldebug.h $\n** Auxiliary functions from Debug Interface module\n** See Copyright Notice in lua.h\n*/\n\n#ifndef ldebug_h\n#define ldebug_h\n\n\n#include \"lstate.h\"\n\n\n#define pcRel(pc, p)\t(cast_int((pc) - (p)->code) - 1)\n\n\n/* Active Lua function (given call info) */\n#define ci_func(ci)\t\t(clLvalue(s2v((ci)->func.p)))\n\n\n#define resethookcount(L)\t(L->hookcount = L->basehookcount)\n\n/*\n** mark for entries in 'lineinfo' array that has absolute information in\n** 'abslineinfo' array\n*/\n#define ABSLINEINFO\t(-0x80)\n\n\n/*\n** MAXimum number of successive Instructions WiTHout ABSolute line\n** information. (A power of two allows fast divisions.)\n*/\n#if !defined(MAXIWTHABS)\n#define MAXIWTHABS\t128\n#endif\n\n\nLUAI_FUNC int luaG_getfuncline (const Proto *f, int pc);\nLUAI_FUNC const char *luaG_findlocal (lua_State *L, CallInfo *ci, int n,\n                                                    StkId *pos);\nLUAI_FUNC l_noret luaG_typeerror (lua_State *L, const TValue *o,\n                                                const char *opname);\nLUAI_FUNC l_noret luaG_callerror (lua_State *L, const TValue *o);\nLUAI_FUNC l_noret luaG_forerror (lua_State *L, const TValue *o,\n                                               const char *what);\nLUAI_FUNC l_noret luaG_concaterror (lua_State *L, const TValue *p1,\n                                                  const TValue *p2);\nLUAI_FUNC l_noret luaG_opinterror (lua_State *L, const TValue *p1,\n                                                 const TValue *p2,\n                                                 const char *msg);\nLUAI_FUNC l_noret luaG_tointerror (lua_State *L, const TValue *p1,\n                                                 const TValue *p2);\nLUAI_FUNC l_noret luaG_ordererror (lua_State *L, const TValue *p1,\n                                                 const TValue *p2);\nLUAI_FUNC l_noret luaG_runerror (lua_State *L, const char *fmt, ...);\nLUAI_FUNC const char *luaG_addinfo (lua_State *L, const char *msg,\n                                                  TString *src, int line);\nLUAI_FUNC l_noret luaG_errormsg (lua_State *L);\nLUAI_FUNC int luaG_traceexec (lua_State *L, const Instruction *pc);\nLUAI_FUNC int luaG_tracecall (lua_State *L);\n\n\n#endif\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/ldo.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: ldo.c $\n** Stack and Call structure of Lua\n** See Copyright Notice in lua.h\n*/\n\n#define ldo_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <setjmp.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lapi.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lparser.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n#include \"lundump.h\"\n#include \"lvm.h\"\n#include \"lzio.h\"\n\n\n\n#define errorstatus(s)\t((s) > LUA_YIELD)\n\n\n/*\n** {======================================================\n** Error-recovery functions\n** =======================================================\n*/\n\n/*\n** LUAI_THROW/LUAI_TRY define how Lua does exception handling. By\n** default, Lua handles errors with exceptions when compiling as\n** C++ code, with _longjmp/_setjmp when asked to use them, and with\n** longjmp/setjmp otherwise.\n*/\n#if !defined(LUAI_THROW)\t\t\t\t/* { */\n\n#if defined(__cplusplus) && !defined(LUA_USE_LONGJMP)\t/* { */\n\n/* C++ exceptions */\n#define LUAI_THROW(L,c)\t\tthrow(c)\n#define LUAI_TRY(L,c,a) \\\n\ttry { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }\n#define luai_jmpbuf\t\tint  /* dummy variable */\n\n#elif defined(LUA_USE_POSIX)\t\t\t\t/* }{ */\n\n/* in POSIX, try _longjmp/_setjmp (more efficient) */\n#define LUAI_THROW(L,c)\t\t_longjmp((c)->b, 1)\n#define LUAI_TRY(L,c,a)\t\tif (_setjmp((c)->b) == 0) { a }\n#define luai_jmpbuf\t\tjmp_buf\n\n#else\t\t\t\t\t\t\t/* }{ */\n\n/* ISO C handling with long jumps */\n#define LUAI_THROW(L,c)\t\tlongjmp((c)->b, 1)\n#define LUAI_TRY(L,c,a)\t\tif (setjmp((c)->b) == 0) { a }\n#define luai_jmpbuf\t\tjmp_buf\n\n#endif\t\t\t\t\t\t\t/* } */\n\n#endif\t\t\t\t\t\t\t/* } */\n\n\n\n/* chain list of long jump buffers */\nstruct lua_longjmp {\n  struct lua_longjmp *previous;\n  luai_jmpbuf b;\n  volatile int status;  /* error code */\n};\n\n\nvoid luaD_seterrorobj (lua_State *L, int errcode, StkId oldtop) {\n  switch (errcode) {\n    case LUA_ERRMEM: {  /* memory error? */\n      setsvalue2s(L, oldtop, G(L)->memerrmsg); /* reuse preregistered msg. */\n      break;\n    }\n    case LUA_ERRERR: {\n      setsvalue2s(L, oldtop, luaS_newliteral(L, \"error in private_lua_error handling\"));\n      break;\n    }\n    case LUA_OK: {  /* special case only for closing upvalues */\n      setnilvalue(s2v(oldtop));  /* no error message */\n      break;\n    }\n    default: {\n      lua_assert(errorstatus(errcode));  /* real error */\n      setobjs2s(L, oldtop, L->top.p - 1);  /* error message on current top */\n      break;\n    }\n  }\n  L->top.p = oldtop + 1;\n}\n\n\nl_noret luaD_throw (lua_State *L, int errcode) {\n  if (L->errorJmp) {  /* thread has an error handler? */\n    L->errorJmp->status = errcode;  /* set status */\n    LUAI_THROW(L, L->errorJmp);  /* jump to it */\n  }\n  else {  /* thread has no error handler */\n    global_State *g = G(L);\n    errcode = luaE_resetthread(L, errcode);  /* close all upvalues */\n    if (g->mainthread->errorJmp) {  /* main thread has a handler? */\n      setobjs2s(L, g->mainthread->top.p++, L->top.p - 1);  /* copy error obj. */\n      luaD_throw(g->mainthread, errcode);  /* re-throw in main thread */\n    }\n    else {  /* no handler at all; abort */\n      if (g->panic) {  /* panic function? */\n        lua_unlock(L);\n        g->panic(L);  /* call panic function (last chance to jump out) */\n      }\n      abort();\n    }\n  }\n}\n\n\nint luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {\n  l_uint32 oldnCcalls = L->nCcalls;\n  struct lua_longjmp lj;\n  lj.status = LUA_OK;\n  lj.previous = L->errorJmp;  /* chain new error handler */\n  L->errorJmp = &lj;\n  LUAI_TRY(L, &lj,\n    (*f)(L, ud);\n  );\n  L->errorJmp = lj.previous;  /* restore old error handler */\n  L->nCcalls = oldnCcalls;\n  return lj.status;\n}\n\n/* }====================================================== */\n\n\n/*\n** {==================================================================\n** Stack reallocation\n** ===================================================================\n*/\n\n\n/*\n** Change all pointers to the stack into offsets.\n*/\nstatic void relstack (lua_State *L) {\n  CallInfo *ci;\n  UpVal *up;\n  L->top.offset = savestack(L, L->top.p);\n  L->tbclist.offset = savestack(L, L->tbclist.p);\n  for (up = L->openupval; up != NULL; up = up->u.open.next)\n    up->v.offset = savestack(L, uplevel(up));\n  for (ci = L->ci; ci != NULL; ci = ci->previous) {\n    ci->top.offset = savestack(L, ci->top.p);\n    ci->func.offset = savestack(L, ci->func.p);\n  }\n}\n\n\n/*\n** Change back all offsets into pointers.\n*/\nstatic void correctstack (lua_State *L) {\n  CallInfo *ci;\n  UpVal *up;\n  L->top.p = restorestack(L, L->top.offset);\n  L->tbclist.p = restorestack(L, L->tbclist.offset);\n  for (up = L->openupval; up != NULL; up = up->u.open.next)\n    up->v.p = s2v(restorestack(L, up->v.offset));\n  for (ci = L->ci; ci != NULL; ci = ci->previous) {\n    ci->top.p = restorestack(L, ci->top.offset);\n    ci->func.p = restorestack(L, ci->func.offset);\n    if (isLua(ci))\n      ci->u.l.trap = 1;  /* signal to update 'trap' in 'luaV_execute' */\n  }\n}\n\n\n/* some space for error handling */\n#define ERRORSTACKSIZE\t(LUAI_MAXSTACK + 200)\n\n/*\n** Reallocate the stack to a new size, correcting all pointers into it.\n** In ISO C, any pointer use after the pointer has been deallocated is\n** undefined behavior. So, before the reallocation, all pointers are\n** changed to offsets, and after the reallocation they are changed back\n** to pointers. As during the reallocation the pointers are invalid, the\n** reallocation cannot run emergency collections.\n**\n** In case of allocation error, raise an error or return false according\n** to 'raiseerror'.\n*/\nint luaD_reallocstack (lua_State *L, int newsize, int raiseerror) {\n  int oldsize = stacksize(L);\n  int i;\n  StkId newstack;\n  int oldgcstop = G(L)->gcstopem;\n  lua_assert(newsize <= LUAI_MAXSTACK || newsize == ERRORSTACKSIZE);\n  relstack(L);  /* change pointers to offsets */\n  G(L)->gcstopem = 1;  /* stop emergency collection */\n  newstack = luaM_reallocvector(L, L->stack.p, oldsize + EXTRA_STACK,\n                                   newsize + EXTRA_STACK, StackValue);\n  G(L)->gcstopem = oldgcstop;  /* restore emergency collection */\n  if (l_unlikely(newstack == NULL)) {  /* reallocation failed? */\n    correctstack(L);  /* change offsets back to pointers */\n    if (raiseerror)\n      luaM_error(L);\n    else return 0;  /* do not raise an error */\n  }\n  L->stack.p = newstack;\n  correctstack(L);  /* change offsets back to pointers */\n  L->stack_last.p = L->stack.p + newsize;\n  for (i = oldsize + EXTRA_STACK; i < newsize + EXTRA_STACK; i++)\n    setnilvalue(s2v(newstack + i)); /* erase new segment */\n  return 1;\n}\n\n\n/*\n** Try to grow the stack by at least 'n' elements. When 'raiseerror'\n** is true, raises any error; otherwise, return 0 in case of errors.\n*/\nint luaD_growstack (lua_State *L, int n, int raiseerror) {\n  int size = stacksize(L);\n  if (l_unlikely(size > LUAI_MAXSTACK)) {\n    /* if stack is larger than maximum, thread is already using the\n       extra space reserved for errors, that is, thread is handling\n       a stack error; cannot grow further than that. */\n    lua_assert(stacksize(L) == ERRORSTACKSIZE);\n    if (raiseerror)\n      luaD_throw(L, LUA_ERRERR);  /* error inside message handler */\n    return 0;  /* if not 'raiseerror', just signal it */\n  }\n  else if (n < LUAI_MAXSTACK) {  /* avoids arithmetic overflows */\n    int newsize = 2 * size;  /* tentative new size */\n    int needed = cast_int(L->top.p - L->stack.p) + n;\n    if (newsize > LUAI_MAXSTACK)  /* cannot cross the limit */\n      newsize = LUAI_MAXSTACK;\n    if (newsize < needed)  /* but must respect what was asked for */\n      newsize = needed;\n    if (l_likely(newsize <= LUAI_MAXSTACK))\n      return luaD_reallocstack(L, newsize, raiseerror);\n  }\n  /* else stack overflow */\n  /* add extra size to be able to handle the error message */\n  luaD_reallocstack(L, ERRORSTACKSIZE, raiseerror);\n  if (raiseerror)\n    luaG_runerror(L, \"stack overflow\");\n  return 0;\n}\n\n\n/*\n** Compute how much of the stack is being used, by computing the\n** maximum top of all call frames in the stack and the current top.\n*/\nstatic int stackinuse (lua_State *L) {\n  CallInfo *ci;\n  int res;\n  StkId lim = L->top.p;\n  for (ci = L->ci; ci != NULL; ci = ci->previous) {\n    if (lim < ci->top.p) lim = ci->top.p;\n  }\n  lua_assert(lim <= L->stack_last.p + EXTRA_STACK);\n  res = cast_int(lim - L->stack.p) + 1;  /* part of stack in use */\n  if (res < LUA_MINSTACK)\n    res = LUA_MINSTACK;  /* ensure a minimum size */\n  return res;\n}\n\n\n/*\n** If stack size is more than 3 times the current use, reduce that size\n** to twice the current use. (So, the final stack size is at most 2/3 the\n** previous size, and half of its entries are empty.)\n** As a particular case, if stack was handling a stack overflow and now\n** it is not, 'max' (limited by LUAI_MAXSTACK) will be smaller than\n** stacksize (equal to ERRORSTACKSIZE in this case), and so the stack\n** will be reduced to a \"regular\" size.\n*/\nvoid luaD_shrinkstack (lua_State *L) {\n  int inuse = stackinuse(L);\n  int max = (inuse > LUAI_MAXSTACK / 3) ? LUAI_MAXSTACK : inuse * 3;\n  /* if thread is currently not handling a stack overflow and its\n     size is larger than maximum \"reasonable\" size, shrink it */\n  if (inuse <= LUAI_MAXSTACK && stacksize(L) > max) {\n    int nsize = (inuse > LUAI_MAXSTACK / 2) ? LUAI_MAXSTACK : inuse * 2;\n    luaD_reallocstack(L, nsize, 0);  /* ok if that fails */\n  }\n  else  /* don't change stack */\n    condmovestack(L,{},{});  /* (change only for debugging) */\n  luaE_shrinkCI(L);  /* shrink CI list */\n}\n\n\nvoid luaD_inctop (lua_State *L) {\n  luaD_checkstack(L, 1);\n  L->top.p++;\n}\n\n/* }================================================================== */\n\n\n/*\n** Call a hook for the given event. Make sure there is a hook to be\n** called. (Both 'L->hook' and 'L->hookmask', which trigger this\n** function, can be changed asynchronously by signals.)\n*/\nvoid luaD_hook (lua_State *L, int event, int line,\n                              int ftransfer, int ntransfer) {\n  lua_Hook hook = L->hook;\n  if (hook && L->allowhook) {  /* make sure there is a hook */\n    int mask = CIST_HOOKED;\n    CallInfo *ci = L->ci;\n    ptrdiff_t top = savestack(L, L->top.p);  /* preserve original 'top' */\n    ptrdiff_t ci_top = savestack(L, ci->top.p);  /* idem for 'ci->top' */\n    lua_Debug ar;\n    ar.event = event;\n    ar.currentline = line;\n    ar.i_ci = ci;\n    if (ntransfer != 0) {\n      mask |= CIST_TRAN;  /* 'ci' has transfer information */\n      ci->u2.transferinfo.ftransfer = ftransfer;\n      ci->u2.transferinfo.ntransfer = ntransfer;\n    }\n    if (isLua(ci) && L->top.p < ci->top.p)\n      L->top.p = ci->top.p;  /* protect entire activation register */\n    luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */\n    if (ci->top.p < L->top.p + LUA_MINSTACK)\n      ci->top.p = L->top.p + LUA_MINSTACK;\n    L->allowhook = 0;  /* cannot call hooks inside a hook */\n    ci->callstatus |= mask;\n    lua_unlock(L);\n    (*hook)(L, &ar);\n    lua_lock(L);\n    lua_assert(!L->allowhook);\n    L->allowhook = 1;\n    ci->top.p = restorestack(L, ci_top);\n    L->top.p = restorestack(L, top);\n    ci->callstatus &= ~mask;\n  }\n}\n\n\n/*\n** Executes a call hook for Lua functions. This function is called\n** whenever 'hookmask' is not zero, so it checks whether call hooks are\n** active.\n*/\nvoid luaD_hookcall (lua_State *L, CallInfo *ci) {\n  L->oldpc = 0;  /* set 'oldpc' for new function */\n  if (L->hookmask & LUA_MASKCALL) {  /* is call hook on? */\n    int event = (ci->callstatus & CIST_TAIL) ? LUA_HOOKTAILCALL\n                                             : LUA_HOOKCALL;\n    Proto *p = ci_func(ci)->p;\n    ci->u.l.savedpc++;  /* hooks assume 'pc' is already incremented */\n    luaD_hook(L, event, -1, 1, p->numparams);\n    ci->u.l.savedpc--;  /* correct 'pc' */\n  }\n}\n\n\n/*\n** Executes a return hook for Lua and C functions and sets/corrects\n** 'oldpc'. (Note that this correction is needed by the line hook, so it\n** is done even when return hooks are off.)\n*/\nstatic void rethook (lua_State *L, CallInfo *ci, int nres) {\n  if (L->hookmask & LUA_MASKRET) {  /* is return hook on? */\n    StkId firstres = L->top.p - nres;  /* index of first result */\n    int delta = 0;  /* correction for vararg functions */\n    int ftransfer;\n    if (isLua(ci)) {\n      Proto *p = ci_func(ci)->p;\n      if (p->flag & PF_ISVARARG)\n        delta = ci->u.l.nextraargs + p->numparams + 1;\n    }\n    ci->func.p += delta;  /* if vararg, back to virtual 'func' */\n    ftransfer = cast(unsigned short, firstres - ci->func.p);\n    luaD_hook(L, LUA_HOOKRET, -1, ftransfer, nres);  /* call it */\n    ci->func.p -= delta;\n  }\n  if (isLua(ci = ci->previous))\n    L->oldpc = pcRel(ci->u.l.savedpc, ci_func(ci)->p);  /* set 'oldpc' */\n}\n\n\n/*\n** Check whether 'func' has a '__call' metafield. If so, put it in the\n** stack, below original 'func', so that 'luaD_precall' can call it. Raise\n** an error if there is no '__call' metafield.\n*/\nstatic StkId tryfuncTM (lua_State *L, StkId func) {\n  const TValue *tm;\n  StkId p;\n  checkstackp(L, 1, func);  /* space for metamethod */\n  tm = luaT_gettmbyobj(L, s2v(func), TM_CALL);  /* (after previous GC) */\n  if (l_unlikely(ttisnil(tm)))\n    luaG_callerror(L, s2v(func));  /* nothing to call */\n  for (p = L->top.p; p > func; p--)  /* open space for metamethod */\n    setobjs2s(L, p, p-1);\n  L->top.p++;  /* stack space pre-allocated by the caller */\n  setobj2s(L, func, tm);  /* metamethod is the new function to be called */\n  return func;\n}\n\n\n/*\n** Given 'nres' results at 'firstResult', move 'wanted' of them to 'res'.\n** Handle most typical cases (zero results for commands, one result for\n** expressions, multiple results for tail calls/single parameters)\n** separated.\n*/\nl_sinline void moveresults (lua_State *L, StkId res, int nres, int wanted) {\n  StkId firstresult;\n  int i;\n  switch (wanted) {  /* handle typical cases separately */\n    case 0:  /* no values needed */\n      L->top.p = res;\n      return;\n    case 1:  /* one value needed */\n      if (nres == 0)   /* no results? */\n        setnilvalue(s2v(res));  /* adjust with nil */\n      else  /* at least one result */\n        setobjs2s(L, res, L->top.p - nres);  /* move it to proper place */\n      L->top.p = res + 1;\n      return;\n    case LUA_MULTRET:\n      wanted = nres;  /* we want all results */\n      break;\n    default:  /* two/more results and/or to-be-closed variables */\n      if (hastocloseCfunc(wanted)) {  /* to-be-closed variables? */\n        L->ci->callstatus |= CIST_CLSRET;  /* in case of yields */\n        L->ci->u2.nres = nres;\n        res = luaF_close(L, res, CLOSEKTOP, 1);\n        L->ci->callstatus &= ~CIST_CLSRET;\n        if (L->hookmask) {  /* if needed, call hook after '__close's */\n          ptrdiff_t savedres = savestack(L, res);\n          rethook(L, L->ci, nres);\n          res = restorestack(L, savedres);  /* hook can move stack */\n        }\n        wanted = decodeNresults(wanted);\n        if (wanted == LUA_MULTRET)\n          wanted = nres;  /* we want all results */\n      }\n      break;\n  }\n  /* generic case */\n  firstresult = L->top.p - nres;  /* index of first result */\n  if (nres > wanted)  /* extra results? */\n    nres = wanted;  /* don't need them */\n  for (i = 0; i < nres; i++)  /* move all results to correct place */\n    setobjs2s(L, res + i, firstresult + i);\n  for (; i < wanted; i++)  /* complete wanted number of results */\n    setnilvalue(s2v(res + i));\n  L->top.p = res + wanted;  /* top points after the last result */\n}\n\n\n/*\n** Finishes a function call: calls hook if necessary, moves current\n** number of results to proper place, and returns to previous call\n** info. If function has to close variables, hook must be called after\n** that.\n*/\nvoid luaD_poscall (lua_State *L, CallInfo *ci, int nres) {\n  int wanted = ci->nresults;\n  if (l_unlikely(L->hookmask && !hastocloseCfunc(wanted)))\n    rethook(L, ci, nres);\n  /* move results to proper place */\n  moveresults(L, ci->func.p, nres, wanted);\n  /* function cannot be in any of these cases when returning */\n  lua_assert(!(ci->callstatus &\n        (CIST_HOOKED | CIST_YPCALL | CIST_FIN | CIST_TRAN | CIST_CLSRET)));\n  L->ci = ci->previous;  /* back to caller (after closing variables) */\n}\n\n\n\n#define next_ci(L)  (L->ci->next ? L->ci->next : luaE_extendCI(L))\n\n\nl_sinline CallInfo *prepCallInfo (lua_State *L, StkId func, int nret,\n                                                int mask, StkId top) {\n  CallInfo *ci = L->ci = next_ci(L);  /* new frame */\n  ci->func.p = func;\n  ci->nresults = nret;\n  ci->callstatus = mask;\n  ci->top.p = top;\n  return ci;\n}\n\n\n/*\n** precall for C functions\n*/\nl_sinline int precallC (lua_State *L, StkId func, int nresults,\n                                            lua_CFunction f) {\n  int n;  /* number of returns */\n  CallInfo *ci;\n  checkstackp(L, LUA_MINSTACK, func);  /* ensure minimum stack size */\n  L->ci = ci = prepCallInfo(L, func, nresults, CIST_C,\n                               L->top.p + LUA_MINSTACK);\n  lua_assert(ci->top.p <= L->stack_last.p);\n  if (l_unlikely(L->hookmask & LUA_MASKCALL)) {\n    int narg = cast_int(L->top.p - func) - 1;\n    luaD_hook(L, LUA_HOOKCALL, -1, 1, narg);\n  }\n  lua_unlock(L);\n  n = (*f)(L);  /* do the actual call */\n  lua_lock(L);\n  api_checknelems(L, n);\n  luaD_poscall(L, ci, n);\n  return n;\n}\n\n\n/*\n** Prepare a function for a tail call, building its call info on top\n** of the current call info. 'narg1' is the number of arguments plus 1\n** (so that it includes the function itself). Return the number of\n** results, if it was a C function, or -1 for a Lua function.\n*/\nint luaD_pretailcall (lua_State *L, CallInfo *ci, StkId func,\n                                    int narg1, int delta) {\n retry:\n  switch (ttypetag(s2v(func))) {\n    case LUA_VCCL:  /* C closure */\n      return precallC(L, func, LUA_MULTRET, clCvalue(s2v(func))->f);\n    case LUA_VLCF:  /* light C function */\n      return precallC(L, func, LUA_MULTRET, fvalue(s2v(func)));\n    case LUA_VLCL: {  /* Lua function */\n      Proto *p = clLvalue(s2v(func))->p;\n      int fsize = p->maxstacksize;  /* frame size */\n      int nfixparams = p->numparams;\n      int i;\n      checkstackp(L, fsize - delta, func);\n      ci->func.p -= delta;  /* restore 'func' (if vararg) */\n      for (i = 0; i < narg1; i++)  /* move down function and arguments */\n        setobjs2s(L, ci->func.p + i, func + i);\n      func = ci->func.p;  /* moved-down function */\n      for (; narg1 <= nfixparams; narg1++)\n        setnilvalue(s2v(func + narg1));  /* complete missing arguments */\n      ci->top.p = func + 1 + fsize;  /* top for new function */\n      lua_assert(ci->top.p <= L->stack_last.p);\n      ci->u.l.savedpc = p->code;  /* starting point */\n      ci->callstatus |= CIST_TAIL;\n      L->top.p = func + narg1;  /* set top */\n      return -1;\n    }\n    default: {  /* not a function */\n      func = tryfuncTM(L, func);  /* try to get '__call' metamethod */\n      /* return luaD_pretailcall(L, ci, func, narg1 + 1, delta); */\n      narg1++;\n      goto retry;  /* try again */\n    }\n  }\n}\n\n\n/*\n** Prepares the call to a function (C or Lua). For C functions, also do\n** the call. The function to be called is at '*func'.  The arguments\n** are on the stack, right after the function.  Returns the CallInfo\n** to be executed, if it was a Lua function. Otherwise (a C function)\n** returns NULL, with all the results on the stack, starting at the\n** original function position.\n*/\nCallInfo *luaD_precall (lua_State *L, StkId func, int nresults) {\n retry:\n  switch (ttypetag(s2v(func))) {\n    case LUA_VCCL:  /* C closure */\n      precallC(L, func, nresults, clCvalue(s2v(func))->f);\n      return NULL;\n    case LUA_VLCF:  /* light C function */\n      precallC(L, func, nresults, fvalue(s2v(func)));\n      return NULL;\n    case LUA_VLCL: {  /* Lua function */\n      CallInfo *ci;\n      Proto *p = clLvalue(s2v(func))->p;\n      int narg = cast_int(L->top.p - func) - 1;  /* number of real arguments */\n      int nfixparams = p->numparams;\n      int fsize = p->maxstacksize;  /* frame size */\n      checkstackp(L, fsize, func);\n      L->ci = ci = prepCallInfo(L, func, nresults, 0, func + 1 + fsize);\n      ci->u.l.savedpc = p->code;  /* starting point */\n      for (; narg < nfixparams; narg++)\n        setnilvalue(s2v(L->top.p++));  /* complete missing arguments */\n      lua_assert(ci->top.p <= L->stack_last.p);\n      return ci;\n    }\n    default: {  /* not a function */\n      func = tryfuncTM(L, func);  /* try to get '__call' metamethod */\n      /* return luaD_precall(L, func, nresults); */\n      goto retry;  /* try again with metamethod */\n    }\n  }\n}\n\n\n/*\n** Call a function (C or Lua) through C. 'inc' can be 1 (increment\n** number of recursive invocations in the C stack) or nyci (the same\n** plus increment number of non-yieldable calls).\n** This function can be called with some use of EXTRA_STACK, so it should\n** check the stack before doing anything else. 'luaD_precall' already\n** does that.\n*/\nl_sinline void ccall (lua_State *L, StkId func, int nResults, l_uint32 inc) {\n  CallInfo *ci;\n  L->nCcalls += inc;\n  if (l_unlikely(getCcalls(L) >= LUAI_MAXCCALLS)) {\n    checkstackp(L, 0, func);  /* free any use of EXTRA_STACK */\n    luaE_checkcstack(L);\n  }\n  if ((ci = luaD_precall(L, func, nResults)) != NULL) {  /* Lua function? */\n    ci->callstatus = CIST_FRESH;  /* mark that it is a \"fresh\" execute */\n    luaV_execute(L, ci);  /* call it */\n  }\n  L->nCcalls -= inc;\n}\n\n\n/*\n** External interface for 'ccall'\n*/\nvoid luaD_call (lua_State *L, StkId func, int nResults) {\n  ccall(L, func, nResults, 1);\n}\n\n\n/*\n** Similar to 'luaD_call', but does not allow yields during the call.\n*/\nvoid luaD_callnoyield (lua_State *L, StkId func, int nResults) {\n  ccall(L, func, nResults, nyci);\n}\n\n\n/*\n** Finish the job of 'lua_pcallk' after it was interrupted by an yield.\n** (The caller, 'finishCcall', does the final call to 'adjustresults'.)\n** The main job is to complete the 'luaD_pcall' called by 'lua_pcallk'.\n** If a '__close' method yields here, eventually control will be back\n** to 'finishCcall' (when that '__close' method finally returns) and\n** 'finishpcallk' will run again and close any still pending '__close'\n** methods. Similarly, if a '__close' method errs, 'precover' calls\n** 'unroll' which calls ''finishCcall' and we are back here again, to\n** close any pending '__close' methods.\n** Note that, up to the call to 'luaF_close', the corresponding\n** 'CallInfo' is not modified, so that this repeated run works like the\n** first one (except that it has at least one less '__close' to do). In\n** particular, field CIST_RECST preserves the error status across these\n** multiple runs, changing only if there is a new error.\n*/\nstatic int finishpcallk (lua_State *L,  CallInfo *ci) {\n  int status = getcistrecst(ci);  /* get original status */\n  if (l_likely(status == LUA_OK))  /* no error? */\n    status = LUA_YIELD;  /* was interrupted by an yield */\n  else {  /* error */\n    StkId func = restorestack(L, ci->u2.funcidx);\n    L->allowhook = getoah(ci->callstatus);  /* restore 'allowhook' */\n    func = luaF_close(L, func, status, 1);  /* can yield or raise an error */\n    luaD_seterrorobj(L, status, func);\n    luaD_shrinkstack(L);   /* restore stack size in case of overflow */\n    setcistrecst(ci, LUA_OK);  /* clear original status */\n  }\n  ci->callstatus &= ~CIST_YPCALL;\n  L->errfunc = ci->u.c.old_errfunc;\n  /* if it is here, there were errors or yields; unlike 'lua_pcallk',\n     do not change status */\n  return status;\n}\n\n\n/*\n** Completes the execution of a C function interrupted by an yield.\n** The interruption must have happened while the function was either\n** closing its tbc variables in 'moveresults' or executing\n** 'lua_callk'/'lua_pcallk'. In the first case, it just redoes\n** 'luaD_poscall'. In the second case, the call to 'finishpcallk'\n** finishes the interrupted execution of 'lua_pcallk'.  After that, it\n** calls the continuation of the interrupted function and finally it\n** completes the job of the 'luaD_call' that called the function.  In\n** the call to 'adjustresults', we do not know the number of results\n** of the function called by 'lua_callk'/'lua_pcallk', so we are\n** conservative and use LUA_MULTRET (always adjust).\n*/\nstatic void finishCcall (lua_State *L, CallInfo *ci) {\n  int n;  /* actual number of results from C function */\n  if (ci->callstatus & CIST_CLSRET) {  /* was returning? */\n    lua_assert(hastocloseCfunc(ci->nresults));\n    n = ci->u2.nres;  /* just redo 'luaD_poscall' */\n    /* don't need to reset CIST_CLSRET, as it will be set again anyway */\n  }\n  else {\n    int status = LUA_YIELD;  /* default if there were no errors */\n    /* must have a continuation and must be able to call it */\n    lua_assert(ci->u.c.k != NULL && yieldable(L));\n    if (ci->callstatus & CIST_YPCALL)   /* was inside a 'lua_pcallk'? */\n      status = finishpcallk(L, ci);  /* finish it */\n    adjustresults(L, LUA_MULTRET);  /* finish 'lua_callk' */\n    lua_unlock(L);\n    n = (*ci->u.c.k)(L, status, ci->u.c.ctx);  /* call continuation */\n    lua_lock(L);\n    api_checknelems(L, n);\n  }\n  luaD_poscall(L, ci, n);  /* finish 'luaD_call' */\n}\n\n\n/*\n** Executes \"full continuation\" (everything in the stack) of a\n** previously interrupted coroutine until the stack is empty (or another\n** interruption long-jumps out of the loop).\n*/\nstatic void unroll (lua_State *L, void *ud) {\n  CallInfo *ci;\n  UNUSED(ud);\n  while ((ci = L->ci) != &L->base_ci) {  /* something in the stack */\n    if (!isLua(ci))  /* C function? */\n      finishCcall(L, ci);  /* complete its execution */\n    else {  /* Lua function */\n      luaV_finishOp(L);  /* finish interrupted instruction */\n      luaV_execute(L, ci);  /* execute down to higher C 'boundary' */\n    }\n  }\n}\n\n\n/*\n** Try to find a suspended protected call (a \"recover point\") for the\n** given thread.\n*/\nstatic CallInfo *findpcall (lua_State *L) {\n  CallInfo *ci;\n  for (ci = L->ci; ci != NULL; ci = ci->previous) {  /* search for a pcall */\n    if (ci->callstatus & CIST_YPCALL)\n      return ci;\n  }\n  return NULL;  /* no pending pcall */\n}\n\n\n/*\n** Signal an error in the call to 'lua_resume', not in the execution\n** of the coroutine itself. (Such errors should not be handled by any\n** coroutine error handler and should not kill the coroutine.)\n*/\nstatic int resume_error (lua_State *L, const char *msg, int narg) {\n  api_checkpop(L, narg);\n  L->top.p -= narg;  /* remove args from the stack */\n  setsvalue2s(L, L->top.p, luaS_new(L, msg));  /* push error message */\n  api_incr_top(L);\n  lua_unlock(L);\n  return LUA_ERRRUN;\n}\n\n\n/*\n** Do the work for 'lua_resume' in protected mode. Most of the work\n** depends on the status of the coroutine: initial state, suspended\n** inside a hook, or regularly suspended (optionally with a continuation\n** function), plus erroneous cases: non-suspended coroutine or dead\n** coroutine.\n*/\nstatic void resume (lua_State *L, void *ud) {\n  int n = *(cast(int*, ud));  /* number of arguments */\n  StkId firstArg = L->top.p - n;  /* first argument */\n  CallInfo *ci = L->ci;\n  if (L->status == LUA_OK)  /* starting a coroutine? */\n    ccall(L, firstArg - 1, LUA_MULTRET, 0);  /* just call its body */\n  else {  /* resuming from previous yield */\n    lua_assert(L->status == LUA_YIELD);\n    L->status = LUA_OK;  /* mark that it is running (again) */\n    if (isLua(ci)) {  /* yielded inside a hook? */\n      /* undo increment made by 'luaG_traceexec': instruction was not\n         executed yet */\n      lua_assert(ci->callstatus & CIST_HOOKYIELD);\n      ci->u.l.savedpc--;\n      L->top.p = firstArg;  /* discard arguments */\n      luaV_execute(L, ci);  /* just continue running Lua code */\n    }\n    else {  /* 'common' yield */\n      if (ci->u.c.k != NULL) {  /* does it have a continuation function? */\n        lua_unlock(L);\n        n = (*ci->u.c.k)(L, LUA_YIELD, ci->u.c.ctx); /* call continuation */\n        lua_lock(L);\n        api_checknelems(L, n);\n      }\n      luaD_poscall(L, ci, n);  /* finish 'luaD_call' */\n    }\n    unroll(L, NULL);  /* run continuation */\n  }\n}\n\n\n/*\n** Unrolls a coroutine in protected mode while there are recoverable\n** errors, that is, errors inside a protected call. (Any error\n** interrupts 'unroll', and this loop protects it again so it can\n** continue.) Stops with a normal end (status == LUA_OK), an yield\n** (status == LUA_YIELD), or an unprotected error ('findpcall' doesn't\n** find a recover point).\n*/\nstatic int precover (lua_State *L, int status) {\n  CallInfo *ci;\n  while (errorstatus(status) && (ci = findpcall(L)) != NULL) {\n    L->ci = ci;  /* go down to recovery functions */\n    setcistrecst(ci, status);  /* status to finish 'pcall' */\n    status = luaD_rawrunprotected(L, unroll, NULL);\n  }\n  return status;\n}\n\n\nLUA_API int lua_resume (lua_State *L, lua_State *from, int nargs,\n                                      int *nresults) {\n  int status;\n  lua_lock(L);\n  if (L->status == LUA_OK) {  /* may be starting a coroutine */\n    if (L->ci != &L->base_ci)  /* not in base level? */\n      return resume_error(L, \"cannot resume non-suspended coroutine\", nargs);\n    else if (L->top.p - (L->ci->func.p + 1) == nargs)  /* no function? */\n      return resume_error(L, \"cannot resume dead coroutine\", nargs);\n  }\n  else if (L->status != LUA_YIELD)  /* ended with errors? */\n    return resume_error(L, \"cannot resume dead coroutine\", nargs);\n  L->nCcalls = (from) ? getCcalls(from) : 0;\n  if (getCcalls(L) >= LUAI_MAXCCALLS)\n    return resume_error(L, \"C stack overflow\", nargs);\n  L->nCcalls++;\n  luai_userstateresume(L, nargs);\n  api_checkpop(L, (L->status == LUA_OK) ? nargs + 1 : nargs);\n  status = luaD_rawrunprotected(L, resume, &nargs);\n   /* continue running after recoverable errors */\n  status = precover(L, status);\n  if (l_likely(!errorstatus(status)))\n    lua_assert(status == L->status);  /* normal end or yield */\n  else {  /* unrecoverable error */\n    L->status = cast_byte(status);  /* mark thread as 'dead' */\n    luaD_seterrorobj(L, status, L->top.p);  /* push error message */\n    L->ci->top.p = L->top.p;\n  }\n  *nresults = (status == LUA_YIELD) ? L->ci->u2.nyield\n                                    : cast_int(L->top.p - (L->ci->func.p + 1));\n  lua_unlock(L);\n  return status;\n}\n\n\nLUA_API int lua_isyieldable (lua_State *L) {\n  return yieldable(L);\n}\n\n\nLUA_API int lua_yieldk (lua_State *L, int nresults, lua_KContext ctx,\n                        lua_KFunction k) {\n  CallInfo *ci;\n  luai_userstateyield(L, nresults);\n  lua_lock(L);\n  ci = L->ci;\n  api_checkpop(L, nresults);\n  if (l_unlikely(!yieldable(L))) {\n    if (L != G(L)->mainthread)\n      luaG_runerror(L, \"attempt to yield across a C-call boundary\");\n    else\n      luaG_runerror(L, \"attempt to yield from outside a coroutine\");\n  }\n  L->status = LUA_YIELD;\n  ci->u2.nyield = nresults;  /* save number of results */\n  if (isLua(ci)) {  /* inside a hook? */\n    lua_assert(!isLuacode(ci));\n    api_check(L, nresults == 0, \"hooks cannot yield values\");\n    api_check(L, k == NULL, \"hooks cannot continue after yielding\");\n  }\n  else {\n    if ((ci->u.c.k = k) != NULL)  /* is there a continuation? */\n      ci->u.c.ctx = ctx;  /* save context */\n    luaD_throw(L, LUA_YIELD);\n  }\n  lua_assert(ci->callstatus & CIST_HOOKED);  /* must be inside a hook */\n  lua_unlock(L);\n  return 0;  /* return to 'luaD_hook' */\n}\n\n\n/*\n** Auxiliary structure to call 'luaF_close' in protected mode.\n*/\nstruct CloseP {\n  StkId level;\n  int status;\n};\n\n\n/*\n** Auxiliary function to call 'luaF_close' in protected mode.\n*/\nstatic void closepaux (lua_State *L, void *ud) {\n  struct CloseP *pcl = cast(struct CloseP *, ud);\n  luaF_close(L, pcl->level, pcl->status, 0);\n}\n\n\n/*\n** Calls 'luaF_close' in protected mode. Return the original status\n** or, in case of errors, the new status.\n*/\nint luaD_closeprotected (lua_State *L, ptrdiff_t level, int status) {\n  CallInfo *old_ci = L->ci;\n  lu_byte old_allowhooks = L->allowhook;\n  for (;;) {  /* keep closing upvalues until no more errors */\n    struct CloseP pcl;\n    pcl.level = restorestack(L, level); pcl.status = status;\n    status = luaD_rawrunprotected(L, &closepaux, &pcl);\n    if (l_likely(status == LUA_OK))  /* no more errors? */\n      return pcl.status;\n    else {  /* an error occurred; restore saved state and repeat */\n      L->ci = old_ci;\n      L->allowhook = old_allowhooks;\n    }\n  }\n}\n\n\n/*\n** Call the C function 'func' in protected mode, restoring basic\n** thread information ('allowhook', etc.) and in particular\n** its stack level in case of errors.\n*/\nint luaD_pcall (lua_State *L, Pfunc func, void *u,\n                ptrdiff_t old_top, ptrdiff_t ef) {\n  int status;\n  CallInfo *old_ci = L->ci;\n  lu_byte old_allowhooks = L->allowhook;\n  ptrdiff_t old_errfunc = L->errfunc;\n  L->errfunc = ef;\n  status = luaD_rawrunprotected(L, func, u);\n  if (l_unlikely(status != LUA_OK)) {  /* an error occurred? */\n    L->ci = old_ci;\n    L->allowhook = old_allowhooks;\n    status = luaD_closeprotected(L, old_top, status);\n    luaD_seterrorobj(L, status, restorestack(L, old_top));\n    luaD_shrinkstack(L);   /* restore stack size in case of overflow */\n  }\n  L->errfunc = old_errfunc;\n  return status;\n}\n\n\n\n/*\n** Execute a protected parser.\n*/\nstruct SParser {  /* data to 'f_parser' */\n  ZIO *z;\n  Mbuffer buff;  /* dynamic structure used by the scanner */\n  Dyndata dyd;  /* dynamic structures used by the parser */\n  const char *mode;\n  const char *name;\n};\n\n\nstatic void checkmode (lua_State *L, const char *mode, const char *x) {\n  if (strchr(mode, x[0]) == NULL) {\n    luaO_pushfstring(L,\n       \"attempt to load a %s chunk (mode is '%s')\", x, mode);\n    luaD_throw(L, LUA_ERRSYNTAX);\n  }\n}\n\n\nstatic void f_parser (lua_State *L, void *ud) {\n  LClosure *cl;\n  struct SParser *p = cast(struct SParser *, ud);\n  const char *mode = p->mode ? p->mode : \"bt\";\n  int c = zgetc(p->z);  /* read first character */\n  if (c == LUA_SIGNATURE[0]) {\n    int fixed = 0;\n    if (strchr(mode, 'B') != NULL)\n      fixed = 1;\n    else\n      checkmode(L, mode, \"binary\");\n    cl = luaU_undump(L, p->z, p->name, fixed);\n  }\n  else {\n    checkmode(L, mode, \"text\");\n    cl = luaY_parser(L, p->z, &p->buff, &p->dyd, p->name, c);\n  }\n  lua_assert(cl->nupvalues == cl->p->sizeupvalues);\n  luaF_initupvals(L, cl);\n}\n\n\nint luaD_protectedparser (lua_State *L, ZIO *z, const char *name,\n                                        const char *mode) {\n  struct SParser p;\n  int status;\n  incnny(L);  /* cannot yield during parsing */\n  p.z = z; p.name = name; p.mode = mode;\n  p.dyd.actvar.arr = NULL; p.dyd.actvar.size = 0;\n  p.dyd.gt.arr = NULL; p.dyd.gt.size = 0;\n  p.dyd.label.arr = NULL; p.dyd.label.size = 0;\n  luaZ_initbuffer(L, &p.buff);\n  status = luaD_pcall(L, f_parser, &p, savestack(L, L->top.p), L->errfunc);\n  luaZ_freebuffer(L, &p.buff);\n  luaM_freearray(L, p.dyd.actvar.arr, p.dyd.actvar.size);\n  luaM_freearray(L, p.dyd.gt.arr, p.dyd.gt.size);\n  luaM_freearray(L, p.dyd.label.arr, p.dyd.label.size);\n  decnny(L);\n  return status;\n}\n\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/ldo.h",
		"is_binary":	false,
		"content":	"/*\n** $Id: ldo.h $\n** Stack and Call structure of Lua\n** See Copyright Notice in lua.h\n*/\n\n#ifndef ldo_h\n#define ldo_h\n\n\n#include \"llimits.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"lzio.h\"\n\n\n/*\n** Macro to check stack size and grow stack if needed.  Parameters\n** 'pre'/'pos' allow the macro to preserve a pointer into the\n** stack across reallocations, doing the work only when needed.\n** It also allows the running of one GC step when the stack is\n** reallocated.\n** 'condmovestack' is used in heavy tests to force a stack reallocation\n** at every check.\n*/\n#define luaD_checkstackaux(L,n,pre,pos)  \\\n\tif (l_unlikely(L->stack_last.p - L->top.p <= (n))) \\\n\t  { pre; luaD_growstack(L, n, 1); pos; } \\\n        else { condmovestack(L,pre,pos); }\n\n/* In general, 'pre'/'pos' are empty (nothing to save) */\n#define luaD_checkstack(L,n)\tluaD_checkstackaux(L,n,(void)0,(void)0)\n\n\n\n#define savestack(L,pt)\t\t(cast_charp(pt) - cast_charp(L->stack.p))\n#define restorestack(L,n)\tcast(StkId, cast_charp(L->stack.p) + (n))\n\n\n/* macro to check stack size, preserving 'p' */\n#define checkstackp(L,n,p)  \\\n  luaD_checkstackaux(L, n, \\\n    ptrdiff_t t__ = savestack(L, p),  /* save 'p' */ \\\n    p = restorestack(L, t__))  /* 'pos' part: restore 'p' */\n\n\n\n/* type of protected functions, to be ran by 'runprotected' */\ntypedef void (*Pfunc) (lua_State *L, void *ud);\n\nLUAI_FUNC void luaD_seterrorobj (lua_State *L, int errcode, StkId oldtop);\nLUAI_FUNC int luaD_protectedparser (lua_State *L, ZIO *z, const char *name,\n                                                  const char *mode);\nLUAI_FUNC void luaD_hook (lua_State *L, int event, int line,\n                                        int fTransfer, int nTransfer);\nLUAI_FUNC void luaD_hookcall (lua_State *L, CallInfo *ci);\nLUAI_FUNC int luaD_pretailcall (lua_State *L, CallInfo *ci, StkId func,\n                                              int narg1, int delta);\nLUAI_FUNC CallInfo *luaD_precall (lua_State *L, StkId func, int nResults);\nLUAI_FUNC void luaD_call (lua_State *L, StkId func, int nResults);\nLUAI_FUNC void luaD_callnoyield (lua_State *L, StkId func, int nResults);\nLUAI_FUNC int luaD_closeprotected (lua_State *L, ptrdiff_t level, int status);\nLUAI_FUNC int luaD_pcall (lua_State *L, Pfunc func, void *u,\n                                        ptrdiff_t oldtop, ptrdiff_t ef);\nLUAI_FUNC void luaD_poscall (lua_State *L, CallInfo *ci, int nres);\nLUAI_FUNC int luaD_reallocstack (lua_State *L, int newsize, int raiseerror);\nLUAI_FUNC int luaD_growstack (lua_State *L, int n, int raiseerror);\nLUAI_FUNC void luaD_shrinkstack (lua_State *L);\nLUAI_FUNC void luaD_inctop (lua_State *L);\n\nLUAI_FUNC l_noret luaD_throw (lua_State *L, int errcode);\nLUAI_FUNC int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud);\n\n#endif\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/ldump.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: ldump.c $\n** save precompiled Lua chunks\n** See Copyright Notice in lua.h\n*/\n\n#define ldump_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <limits.h>\n#include <stddef.h>\n\n#include \"lua.h\"\n\n#include \"lgc.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"ltable.h\"\n#include \"lundump.h\"\n\n\ntypedef struct {\n  lua_State *L;\n  lua_Writer writer;\n  void *data;\n  lu_mem offset;  /* current position relative to beginning of dump */\n  int strip;\n  int status;\n  Table *h;  /* table to track saved strings */\n  lua_Integer nstr;  /* counter for counting saved strings */\n} DumpState;\n\n\n/*\n** All high-level dumps go through dumpVector; you can change it to\n** change the endianness of the result\n*/\n#define dumpVector(D,v,n)\tdumpBlock(D,v,(n)*sizeof((v)[0]))\n\n#define dumpLiteral(D, s)\tdumpBlock(D,s,sizeof(s) - sizeof(char))\n\n\n/*\n** Dump the block of memory pointed by 'b' with given 'size'.\n** 'b' should not be NULL, except for the last call signaling the end\n** of the dump.\n*/\nstatic void dumpBlock (DumpState *D, const void *b, size_t size) {\n  if (D->status == 0) {  /* do not write anything after an error */\n    lua_unlock(D->L);\n    D->status = (*D->writer)(D->L, b, size, D->data);\n    lua_lock(D->L);\n    D->offset += size;\n  }\n}\n\n\n/*\n** Dump enough zeros to ensure that current position is a multiple of\n** 'align'.\n*/\nstatic void dumpAlign (DumpState *D, int align) {\n  int padding = align - (D->offset % align);\n  if (padding < align) {  /* padding == align means no padding */\n    static lua_Integer paddingContent = 0;\n    lua_assert(cast_uint(align) <= sizeof(lua_Integer));\n    dumpBlock(D, &paddingContent, padding);\n  }\n  lua_assert(D->offset % align == 0);\n}\n\n\n#define dumpVar(D,x)\t\tdumpVector(D,&x,1)\n\n\nstatic void dumpByte (DumpState *D, int y) {\n  lu_byte x = (lu_byte)y;\n  dumpVar(D, x);\n}\n\n\n/*\n** size for 'dumpVarint' buffer: each byte can store up to 7 bits.\n** (The \"+6\" rounds up the division.)\n*/\n#define DIBS    ((sizeof(size_t) * CHAR_BIT + 6) / 7)\n\n/*\n** Dumps an unsigned integer using the MSB Varint encoding\n*/\nstatic void dumpVarint (DumpState *D, size_t x) {\n  lu_byte buff[DIBS];\n  int n = 1;\n  buff[DIBS - 1] = x & 0x7f;  /* fill least-significant byte */\n  while ((x >>= 7) != 0)  /* fill other bytes in reverse order */\n    buff[DIBS - (++n)] = (x & 0x7f) | 0x80;\n  dumpVector(D, buff + DIBS - n, n);\n}\n\n\nstatic void dumpSize (DumpState *D, size_t sz) {\n  dumpVarint(D, sz);\n}\n\nstatic void dumpInt (DumpState *D, int x) {\n  lua_assert(x >= 0);\n  dumpVarint(D, cast(size_t, x));\n}\n\n\nstatic void dumpNumber (DumpState *D, lua_Number x) {\n  dumpVar(D, x);\n}\n\n\nstatic void dumpInteger (DumpState *D, lua_Integer x) {\n  dumpVar(D, x);\n}\n\n\n/*\n** Dump a String. First dump its \"size\": size==0 means NULL;\n** size==1 is followed by an index and means \"reuse saved string with\n** that index\"; size>=2 is followed by the string contents with real\n** size==size-2 and means that string, which will be saved with\n** the next available index.\n*/\nstatic void dumpString (DumpState *D, TString *ts) {\n  if (ts == NULL)\n    dumpSize(D, 0);\n  else {\n    TValue idx;\n    int tag = luaH_getstr(D->h, ts, &idx);\n    if (!tagisempty(tag)) {  /* string already saved? */\n      dumpSize(D, 1);  /* reuse a saved string */\n      dumpSize(D, cast_sizet(ivalue(&idx)));  /* index of saved string */\n    }\n    else {  /* must write and save the string */\n      TValue key, value;  /* to save the string in the hash */\n      size_t size;\n      const char *s = getlstr(ts, size);\n      dumpSize(D, size + 2);\n      dumpVector(D, s, size + 1);  /* include ending '\\0' */\n      D->nstr++;  /* one more saved string */\n      setsvalue(D->L, &key, ts);  /* the string is the key */\n      setivalue(&value, D->nstr);  /* its index is the value */\n      luaH_set(D->L, D->h, &key, &value);  /* h[ts] = nstr */\n      /* integer value does not need barrier */\n    }\n  }\n}\n\n\nstatic void dumpCode (DumpState *D, const Proto *f) {\n  dumpInt(D, f->sizecode);\n  dumpAlign(D, sizeof(f->code[0]));\n  lua_assert(f->code != NULL);\n  dumpVector(D, f->code, f->sizecode);\n}\n\n\nstatic void dumpFunction (DumpState *D, const Proto *f);\n\nstatic void dumpConstants (DumpState *D, const Proto *f) {\n  int i;\n  int n = f->sizek;\n  dumpInt(D, n);\n  for (i = 0; i < n; i++) {\n    const TValue *o = &f->k[i];\n    int tt = ttypetag(o);\n    dumpByte(D, tt);\n    switch (tt) {\n      case LUA_VNUMFLT:\n        dumpNumber(D, fltvalue(o));\n        break;\n      case LUA_VNUMINT:\n        dumpInteger(D, ivalue(o));\n        break;\n      case LUA_VSHRSTR:\n      case LUA_VLNGSTR:\n        dumpString(D, tsvalue(o));\n        break;\n      default:\n        lua_assert(tt == LUA_VNIL || tt == LUA_VFALSE || tt == LUA_VTRUE);\n    }\n  }\n}\n\n\nstatic void dumpProtos (DumpState *D, const Proto *f) {\n  int i;\n  int n = f->sizep;\n  dumpInt(D, n);\n  for (i = 0; i < n; i++)\n    dumpFunction(D, f->p[i]);\n}\n\n\nstatic void dumpUpvalues (DumpState *D, const Proto *f) {\n  int i, n = f->sizeupvalues;\n  dumpInt(D, n);\n  for (i = 0; i < n; i++) {\n    dumpByte(D, f->upvalues[i].instack);\n    dumpByte(D, f->upvalues[i].idx);\n    dumpByte(D, f->upvalues[i].kind);\n  }\n}\n\n\nstatic void dumpDebug (DumpState *D, const Proto *f) {\n  int i, n;\n  n = (D->strip) ? 0 : f->sizelineinfo;\n  dumpInt(D, n);\n  if (f->lineinfo != NULL)\n    dumpVector(D, f->lineinfo, n);\n  n = (D->strip) ? 0 : f->sizeabslineinfo;\n  dumpInt(D, n);\n  if (n > 0) {\n    /* 'abslineinfo' is an array of structures of int's */\n    dumpAlign(D, sizeof(int));\n    dumpVector(D, f->abslineinfo, n);\n  }\n  n = (D->strip) ? 0 : f->sizelocvars;\n  dumpInt(D, n);\n  for (i = 0; i < n; i++) {\n    dumpString(D, f->locvars[i].varname);\n    dumpInt(D, f->locvars[i].startpc);\n    dumpInt(D, f->locvars[i].endpc);\n  }\n  n = (D->strip) ? 0 : f->sizeupvalues;\n  dumpInt(D, n);\n  for (i = 0; i < n; i++)\n    dumpString(D, f->upvalues[i].name);\n}\n\n\nstatic void dumpFunction (DumpState *D, const Proto *f) {\n  dumpInt(D, f->linedefined);\n  dumpInt(D, f->lastlinedefined);\n  dumpByte(D, f->numparams);\n  dumpByte(D, f->flag);\n  dumpByte(D, f->maxstacksize);\n  dumpCode(D, f);\n  dumpConstants(D, f);\n  dumpUpvalues(D, f);\n  dumpProtos(D, f);\n  dumpString(D, D->strip ? NULL : f->source);\n  dumpDebug(D, f);\n}\n\n\nstatic void dumpHeader (DumpState *D) {\n  dumpLiteral(D, LUA_SIGNATURE);\n  dumpByte(D, LUAC_VERSION);\n  dumpByte(D, LUAC_FORMAT);\n  dumpLiteral(D, LUAC_DATA);\n  dumpByte(D, sizeof(Instruction));\n  dumpByte(D, sizeof(lua_Integer));\n  dumpByte(D, sizeof(lua_Number));\n  dumpInteger(D, LUAC_INT);\n  dumpNumber(D, LUAC_NUM);\n}\n\n\n/*\n** dump Lua function as precompiled chunk\n*/\nint luaU_dump (lua_State *L, const Proto *f, lua_Writer w, void *data,\n               int strip) {\n  DumpState D;\n  D.h = luaH_new(L);  /* aux. table to keep strings already dumped */\n  sethvalue2s(L, L->top.p, D.h);  /* anchor it */\n  L->top.p++;\n  D.L = L;\n  D.writer = w;\n  D.offset = 0;\n  D.data = data;\n  D.strip = strip;\n  D.status = 0;\n  D.nstr = 0;\n  dumpHeader(&D);\n  dumpByte(&D, f->sizeupvalues);\n  dumpFunction(&D, f);\n  dumpBlock(&D, NULL, 0);  /* signal end of dump */\n  return D.status;\n}\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lfunc.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: lfunc.c $\n** Auxiliary functions to manipulate prototypes and closures\n** See Copyright Notice in lua.h\n*/\n\n#define lfunc_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <stddef.h>\n\n#include \"lua.h\"\n\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n\n\n\nCClosure *luaF_newCclosure (lua_State *L, int nupvals) {\n  GCObject *o = luaC_newobj(L, LUA_VCCL, sizeCclosure(nupvals));\n  CClosure *c = gco2ccl(o);\n  c->nupvalues = cast_byte(nupvals);\n  return c;\n}\n\n\nLClosure *luaF_newLclosure (lua_State *L, int nupvals) {\n  GCObject *o = luaC_newobj(L, LUA_VLCL, sizeLclosure(nupvals));\n  LClosure *c = gco2lcl(o);\n  c->p = NULL;\n  c->nupvalues = cast_byte(nupvals);\n  while (nupvals--) c->upvals[nupvals] = NULL;\n  return c;\n}\n\n\n/*\n** fill a closure with new closed upvalues\n*/\nvoid luaF_initupvals (lua_State *L, LClosure *cl) {\n  int i;\n  for (i = 0; i < cl->nupvalues; i++) {\n    GCObject *o = luaC_newobj(L, LUA_VUPVAL, sizeof(UpVal));\n    UpVal *uv = gco2upv(o);\n    uv->v.p = &uv->u.value;  /* make it closed */\n    setnilvalue(uv->v.p);\n    cl->upvals[i] = uv;\n    luaC_objbarrier(L, cl, uv);\n  }\n}\n\n\n/*\n** Create a new upvalue at the given level, and link it to the list of\n** open upvalues of 'L' after entry 'prev'.\n**/\nstatic UpVal *newupval (lua_State *L, StkId level, UpVal **prev) {\n  GCObject *o = luaC_newobj(L, LUA_VUPVAL, sizeof(UpVal));\n  UpVal *uv = gco2upv(o);\n  UpVal *next = *prev;\n  uv->v.p = s2v(level);  /* current value lives in the stack */\n  uv->u.open.next = next;  /* link it to list of open upvalues */\n  uv->u.open.previous = prev;\n  if (next)\n    next->u.open.previous = &uv->u.open.next;\n  *prev = uv;\n  if (!isintwups(L)) {  /* thread not in list of threads with upvalues? */\n    L->twups = G(L)->twups;  /* link it to the list */\n    G(L)->twups = L;\n  }\n  return uv;\n}\n\n\n/*\n** Find and reuse, or create if it does not exist, an upvalue\n** at the given level.\n*/\nUpVal *luaF_findupval (lua_State *L, StkId level) {\n  UpVal **pp = &L->openupval;\n  UpVal *p;\n  lua_assert(isintwups(L) || L->openupval == NULL);\n  while ((p = *pp) != NULL && uplevel(p) >= level) {  /* search for it */\n    lua_assert(!isdead(G(L), p));\n    if (uplevel(p) == level)  /* corresponding upvalue? */\n      return p;  /* return it */\n    pp = &p->u.open.next;\n  }\n  /* not found: create a new upvalue after 'pp' */\n  return newupval(L, level, pp);\n}\n\n\n/*\n** Call closing method for object 'obj' with error message 'err'. The\n** boolean 'yy' controls whether the call is yieldable.\n** (This function assumes EXTRA_STACK.)\n*/\nstatic void callclosemethod (lua_State *L, TValue *obj, TValue *err, int yy) {\n  StkId top = L->top.p;\n  const TValue *tm = luaT_gettmbyobj(L, obj, TM_CLOSE);\n  setobj2s(L, top, tm);  /* will call metamethod... */\n  setobj2s(L, top + 1, obj);  /* with 'self' as the 1st argument */\n  setobj2s(L, top + 2, err);  /* and error msg. as 2nd argument */\n  L->top.p = top + 3;  /* add function and arguments */\n  if (yy)\n    luaD_call(L, top, 0);\n  else\n    luaD_callnoyield(L, top, 0);\n}\n\n\n/*\n** Check whether object at given level has a close metamethod and raise\n** an error if not.\n*/\nstatic void checkclosemth (lua_State *L, StkId level) {\n  const TValue *tm = luaT_gettmbyobj(L, s2v(level), TM_CLOSE);\n  if (ttisnil(tm)) {  /* no metamethod? */\n    int idx = cast_int(level - L->ci->func.p);  /* variable index */\n    const char *vname = luaG_findlocal(L, L->ci, idx, NULL);\n    if (vname == NULL) vname = \"?\";\n    luaG_runerror(L, \"variable '%s' got a non-closable value\", vname);\n  }\n}\n\n\n/*\n** Prepare and call a closing method.\n** If status is CLOSEKTOP, the call to the closing method will be pushed\n** at the top of the stack. Otherwise, values can be pushed right after\n** the 'level' of the upvalue being closed, as everything after that\n** won't be used again.\n*/\nstatic void prepcallclosemth (lua_State *L, StkId level, int status, int yy) {\n  TValue *uv = s2v(level);  /* value being closed */\n  TValue *errobj;\n  if (status == CLOSEKTOP)\n    errobj = &G(L)->nilvalue;  /* error object is nil */\n  else {  /* 'luaD_seterrorobj' will set top to level + 2 */\n    errobj = s2v(level + 1);  /* error object goes after 'uv' */\n    luaD_seterrorobj(L, status, level + 1);  /* set error object */\n  }\n  callclosemethod(L, uv, errobj, yy);\n}\n\n\n/*\n** Maximum value for deltas in 'tbclist', dependent on the type\n** of delta. (This macro assumes that an 'L' is in scope where it\n** is used.)\n*/\n#define MAXDELTA  \\\n\t((256ul << ((sizeof(L->stack.p->tbclist.delta) - 1) * 8)) - 1)\n\n\n/*\n** Insert a variable in the list of to-be-closed variables.\n*/\nvoid luaF_newtbcupval (lua_State *L, StkId level) {\n  lua_assert(level > L->tbclist.p);\n  if (l_isfalse(s2v(level)))\n    return;  /* false doesn't need to be closed */\n  checkclosemth(L, level);  /* value must have a close method */\n  while (cast_uint(level - L->tbclist.p) > MAXDELTA) {\n    L->tbclist.p += MAXDELTA;  /* create a dummy node at maximum delta */\n    L->tbclist.p->tbclist.delta = 0;\n  }\n  level->tbclist.delta = cast(unsigned short, level - L->tbclist.p);\n  L->tbclist.p = level;\n}\n\n\nvoid luaF_unlinkupval (UpVal *uv) {\n  lua_assert(upisopen(uv));\n  *uv->u.open.previous = uv->u.open.next;\n  if (uv->u.open.next)\n    uv->u.open.next->u.open.previous = uv->u.open.previous;\n}\n\n\n/*\n** Close all upvalues up to the given stack level.\n*/\nvoid luaF_closeupval (lua_State *L, StkId level) {\n  UpVal *uv;\n  StkId upl;  /* stack index pointed by 'uv' */\n  while ((uv = L->openupval) != NULL && (upl = uplevel(uv)) >= level) {\n    TValue *slot = &uv->u.value;  /* new position for value */\n    lua_assert(uplevel(uv) < L->top.p);\n    luaF_unlinkupval(uv);  /* remove upvalue from 'openupval' list */\n    setobj(L, slot, uv->v.p);  /* move value to upvalue slot */\n    uv->v.p = slot;  /* now current value lives here */\n    if (!iswhite(uv)) {  /* neither white nor dead? */\n      nw2black(uv);  /* closed upvalues cannot be gray */\n      luaC_barrier(L, uv, slot);\n    }\n  }\n}\n\n\n/*\n** Remove first element from the tbclist plus its dummy nodes.\n*/\nstatic void poptbclist (lua_State *L) {\n  StkId tbc = L->tbclist.p;\n  lua_assert(tbc->tbclist.delta > 0);  /* first element cannot be dummy */\n  tbc -= tbc->tbclist.delta;\n  while (tbc > L->stack.p && tbc->tbclist.delta == 0)\n    tbc -= MAXDELTA;  /* remove dummy nodes */\n  L->tbclist.p = tbc;\n}\n\n\n/*\n** Close all upvalues and to-be-closed variables up to the given stack\n** level. Return restored 'level'.\n*/\nStkId luaF_close (lua_State *L, StkId level, int status, int yy) {\n  ptrdiff_t levelrel = savestack(L, level);\n  luaF_closeupval(L, level);  /* first, close the upvalues */\n  while (L->tbclist.p >= level) {  /* traverse tbc's down to that level */\n    StkId tbc = L->tbclist.p;  /* get variable index */\n    poptbclist(L);  /* remove it from list */\n    prepcallclosemth(L, tbc, status, yy);  /* close variable */\n    level = restorestack(L, levelrel);\n  }\n  return level;\n}\n\n\nProto *luaF_newproto (lua_State *L) {\n  GCObject *o = luaC_newobj(L, LUA_VPROTO, sizeof(Proto));\n  Proto *f = gco2p(o);\n  f->k = NULL;\n  f->sizek = 0;\n  f->p = NULL;\n  f->sizep = 0;\n  f->code = NULL;\n  f->sizecode = 0;\n  f->lineinfo = NULL;\n  f->sizelineinfo = 0;\n  f->abslineinfo = NULL;\n  f->sizeabslineinfo = 0;\n  f->upvalues = NULL;\n  f->sizeupvalues = 0;\n  f->numparams = 0;\n  f->flag = 0;\n  f->maxstacksize = 0;\n  f->locvars = NULL;\n  f->sizelocvars = 0;\n  f->linedefined = 0;\n  f->lastlinedefined = 0;\n  f->source = NULL;\n  return f;\n}\n\n\nvoid luaF_freeproto (lua_State *L, Proto *f) {\n  if (!(f->flag & PF_FIXED)) {\n    luaM_freearray(L, f->code, f->sizecode);\n    luaM_freearray(L, f->lineinfo, f->sizelineinfo);\n    luaM_freearray(L, f->abslineinfo, f->sizeabslineinfo);\n  }\n  luaM_freearray(L, f->p, f->sizep);\n  luaM_freearray(L, f->k, f->sizek);\n  luaM_freearray(L, f->locvars, f->sizelocvars);\n  luaM_freearray(L, f->upvalues, f->sizeupvalues);\n  luaM_free(L, f);\n}\n\n\n/*\n** Look for n-th local variable at line 'line' in function 'func'.\n** Returns NULL if not found.\n*/\nconst char *luaF_getlocalname (const Proto *f, int local_number, int pc) {\n  int i;\n  for (i = 0; i<f->sizelocvars && f->locvars[i].startpc <= pc; i++) {\n    if (pc < f->locvars[i].endpc) {  /* is variable active? */\n      local_number--;\n      if (local_number == 0)\n        return getstr(f->locvars[i].varname);\n    }\n  }\n  return NULL;  /* not found */\n}\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lfunc.h",
		"is_binary":	false,
		"content":	"/*\n** $Id: lfunc.h $\n** Auxiliary functions to manipulate prototypes and closures\n** See Copyright Notice in lua.h\n*/\n\n#ifndef lfunc_h\n#define lfunc_h\n\n\n#include \"lobject.h\"\n\n\n#define sizeCclosure(n)\t(cast_int(offsetof(CClosure, upvalue)) + \\\n                         cast_int(sizeof(TValue)) * (n))\n\n#define sizeLclosure(n)\t(cast_int(offsetof(LClosure, upvals)) + \\\n                         cast_int(sizeof(TValue *)) * (n))\n\n\n/* test whether thread is in 'twups' list */\n#define isintwups(L)\t(L->twups != L)\n\n\n/*\n** maximum number of upvalues in a closure (both C and Lua). (Value\n** must fit in a VM register.)\n*/\n#define MAXUPVAL\t255\n\n\n#define upisopen(up)\t((up)->v.p != &(up)->u.value)\n\n\n#define uplevel(up)\tcheck_exp(upisopen(up), cast(StkId, (up)->v.p))\n\n\n/*\n** maximum number of misses before giving up the cache of closures\n** in prototypes\n*/\n#define MAXMISS\t\t10\n\n\n\n/* special status to close upvalues preserving the top of the stack */\n#define CLOSEKTOP\t(-1)\n\n\nLUAI_FUNC Proto *luaF_newproto (lua_State *L);\nLUAI_FUNC CClosure *luaF_newCclosure (lua_State *L, int nupvals);\nLUAI_FUNC LClosure *luaF_newLclosure (lua_State *L, int nupvals);\nLUAI_FUNC void luaF_initupvals (lua_State *L, LClosure *cl);\nLUAI_FUNC UpVal *luaF_findupval (lua_State *L, StkId level);\nLUAI_FUNC void luaF_newtbcupval (lua_State *L, StkId level);\nLUAI_FUNC void luaF_closeupval (lua_State *L, StkId level);\nLUAI_FUNC StkId luaF_close (lua_State *L, StkId level, int status, int yy);\nLUAI_FUNC void luaF_unlinkupval (UpVal *uv);\nLUAI_FUNC void luaF_freeproto (lua_State *L, Proto *f);\nLUAI_FUNC const char *luaF_getlocalname (const Proto *func, int local_number,\n                                         int pc);\n\n\n#endif\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lgc.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: lgc.c $\n** Garbage Collector\n** See Copyright Notice in lua.h\n*/\n\n#define lgc_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n#include <string.h>\n\n\n#include \"lua.h\"\n\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"llex.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n\n\n/*\n** Number of fixed (luaC_fix) objects in a Lua state: metafield names,\n** plus reserved words, plus \"_ENV\", plus the memory-error message.\n*/\n#define NFIXED\t\t(TM_N + NUM_RESERVED + 2)\n\n\n/*\n** Maximum number of elements to sweep in each single step.\n** (Large enough to dissipate fixed overheads but small enough\n** to allow small steps for the collector.)\n*/\n#define GCSWEEPMAX\t20\n\n\n/* mask with all color bits */\n#define maskcolors\t(bitmask(BLACKBIT) | WHITEBITS)\n\n/* mask with all GC bits */\n#define maskgcbits      (maskcolors | AGEBITS)\n\n\n/* macro to erase all color bits then set only the current white bit */\n#define makewhite(g,x)\t\\\n  (x->marked = cast_byte((x->marked & ~maskcolors) | luaC_white(g)))\n\n/* make an object gray (neither white nor black) */\n#define set2gray(x)\tresetbits(x->marked, maskcolors)\n\n\n/* make an object black (coming from any color) */\n#define set2black(x)  \\\n  (x->marked = cast_byte((x->marked & ~WHITEBITS) | bitmask(BLACKBIT)))\n\n\n#define valiswhite(x)   (iscollectable(x) && iswhite(gcvalue(x)))\n\n#define keyiswhite(n)   (keyiscollectable(n) && iswhite(gckey(n)))\n\n\n/*\n** Protected access to objects in values\n*/\n#define gcvalueN(o)     (iscollectable(o) ? gcvalue(o) : NULL)\n\n\n/*\n** Access to collectable objects in array part of tables\n*/\n#define gcvalarr(t,i)  \\\n\t((*getArrTag(t,i) & BIT_ISCOLLECTABLE) ? getArrVal(t,i)->gc : NULL)\n\n\n#define markvalue(g,o) { checkliveness(g->mainthread,o); \\\n  if (valiswhite(o)) reallymarkobject(g,gcvalue(o)); }\n\n#define markkey(g, n)\t{ if keyiswhite(n) reallymarkobject(g,gckey(n)); }\n\n#define markobject(g,t)\t{ if (iswhite(t)) reallymarkobject(g, obj2gco(t)); }\n\n/*\n** mark an object that can be NULL (either because it is really optional,\n** or it was stripped as debug info, or inside an uncompleted structure)\n*/\n#define markobjectN(g,t)\t{ if (t) markobject(g,t); }\n\n\nstatic void reallymarkobject (global_State *g, GCObject *o);\nstatic l_obj atomic (lua_State *L);\nstatic void entersweep (lua_State *L);\n\n\n/*\n** {======================================================\n** Generic functions\n** =======================================================\n*/\n\n\n/*\n** one after last element in a hash array\n*/\n#define gnodelast(h)\tgnode(h, cast_sizet(sizenode(h)))\n\n\nstatic GCObject **getgclist (GCObject *o) {\n  switch (o->tt) {\n    case LUA_VTABLE: return &gco2t(o)->gclist;\n    case LUA_VLCL: return &gco2lcl(o)->gclist;\n    case LUA_VCCL: return &gco2ccl(o)->gclist;\n    case LUA_VTHREAD: return &gco2th(o)->gclist;\n    case LUA_VPROTO: return &gco2p(o)->gclist;\n    case LUA_VUSERDATA: {\n      Udata *u = gco2u(o);\n      lua_assert(u->nuvalue > 0);\n      return &u->gclist;\n    }\n    default: lua_assert(0); return 0;\n  }\n}\n\n\n/*\n** Link a collectable object 'o' with a known type into the list 'p'.\n** (Must be a macro to access the 'gclist' field in different types.)\n*/\n#define linkgclist(o,p)\tlinkgclist_(obj2gco(o), &(o)->gclist, &(p))\n\nstatic void linkgclist_ (GCObject *o, GCObject **pnext, GCObject **list) {\n  lua_assert(!isgray(o));  /* cannot be in a gray list */\n  *pnext = *list;\n  *list = o;\n  set2gray(o);  /* now it is */\n}\n\n\n/*\n** Link a generic collectable object 'o' into the list 'p'.\n*/\n#define linkobjgclist(o,p) linkgclist_(obj2gco(o), getgclist(o), &(p))\n\n\n\n/*\n** Clear keys for empty entries in tables. If entry is empty, mark its\n** entry as dead. This allows the collection of the key, but keeps its\n** entry in the table: its removal could break a chain and could break\n** a table traversal.  Other places never manipulate dead keys, because\n** its associated empty value is enough to signal that the entry is\n** logically empty.\n*/\nstatic void clearkey (Node *n) {\n  lua_assert(isempty(gval(n)));\n  if (keyiscollectable(n))\n    setdeadkey(n);  /* unused key; remove it */\n}\n\n\n/*\n** tells whether a key or value can be cleared from a weak\n** table. Non-collectable objects are never removed from weak\n** tables. Strings behave as 'values', so are never removed too. for\n** other objects: if really collected, cannot keep them; for objects\n** being finalized, keep them in keys, but not in values\n*/\nstatic int iscleared (global_State *g, const GCObject *o) {\n  if (o == NULL) return 0;  /* non-collectable value */\n  else if (novariant(o->tt) == LUA_TSTRING) {\n    markobject(g, o);  /* strings are 'values', so are never weak */\n    return 0;\n  }\n  else return iswhite(o);\n}\n\n\n/*\n** Barrier that moves collector forward, that is, marks the white object\n** 'v' being pointed by the black object 'o'.  In the generational\n** mode, 'v' must also become old, if 'o' is old; however, it cannot\n** be changed directly to OLD, because it may still point to non-old\n** objects. So, it is marked as OLD0. In the next cycle it will become\n** OLD1, and in the next it will finally become OLD (regular old). By\n** then, any object it points to will also be old.  If called in the\n** incremental sweep phase, it clears the black object to white (sweep\n** it) to avoid other barrier calls for this same object. (That cannot\n** be done is generational mode, as its sweep does not distinguish\n** whites from deads.)\n*/\nvoid luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {\n  global_State *g = G(L);\n  lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));\n  if (keepinvariant(g)) {  /* must keep invariant? */\n    reallymarkobject(g, v);  /* restore invariant */\n    if (isold(o)) {\n      lua_assert(!isold(v));  /* white object could not be old */\n      setage(v, G_OLD0);  /* restore generational invariant */\n    }\n  }\n  else {  /* sweep phase */\n    lua_assert(issweepphase(g));\n    if (g->gckind != KGC_GENMINOR)  /* incremental mode? */\n      makewhite(g, o);  /* mark 'o' as white to avoid other barriers */\n  }\n}\n\n\n/*\n** barrier that moves collector backward, that is, mark the black object\n** pointing to a white object as gray again.\n*/\nvoid luaC_barrierback_ (lua_State *L, GCObject *o) {\n  global_State *g = G(L);\n  lua_assert(isblack(o) && !isdead(g, o));\n  lua_assert((g->gckind != KGC_GENMINOR)\n          || (isold(o) && getage(o) != G_TOUCHED1));\n  if (getage(o) == G_TOUCHED2)  /* already in gray list? */\n    set2gray(o);  /* make it gray to become touched1 */\n  else  /* link it in 'grayagain' and paint it gray */\n    linkobjgclist(o, g->grayagain);\n  if (isold(o))  /* generational mode? */\n    setage(o, G_TOUCHED1);  /* touched in current cycle */\n}\n\n\nvoid luaC_fix (lua_State *L, GCObject *o) {\n  global_State *g = G(L);\n  lua_assert(g->allgc == o);  /* object must be 1st in 'allgc' list! */\n  set2gray(o);  /* they will be gray forever */\n  setage(o, G_OLD);  /* and old forever */\n  g->allgc = o->next;  /* remove object from 'allgc' list */\n  o->next = g->fixedgc;  /* link it to 'fixedgc' list */\n  g->fixedgc = o;\n}\n\n\n/*\n** create a new collectable object (with given type, size, and offset)\n** and link it to 'allgc' list.\n*/\nGCObject *luaC_newobjdt (lua_State *L, int tt, size_t sz, size_t offset) {\n  global_State *g = G(L);\n  char *p = cast_charp(luaM_newobject(L, novariant(tt), sz));\n  GCObject *o = cast(GCObject *, p + offset);\n  g->GCdebt--;\n  o->marked = luaC_white(g);\n  o->tt = tt;\n  o->next = g->allgc;\n  g->allgc = o;\n  return o;\n}\n\n\n/*\n** create a new collectable object with no offset.\n*/\nGCObject *luaC_newobj (lua_State *L, int tt, size_t sz) {\n  return luaC_newobjdt(L, tt, sz, 0);\n}\n\n/* }====================================================== */\n\n\n\n/*\n** {======================================================\n** Mark functions\n** =======================================================\n*/\n\n\n/*\n** Mark an object.  Userdata with no user values, strings, and closed\n** upvalues are visited and turned black here.  Open upvalues are\n** already indirectly linked through their respective threads in the\n** 'twups' list, so they don't go to the gray list; nevertheless, they\n** are kept gray to avoid barriers, as their values will be revisited\n** by the thread or by 'remarkupvals'.  Other objects are added to the\n** gray list to be visited (and turned black) later.  Both userdata and\n** upvalues can call this function recursively, but this recursion goes\n** for at most two levels: An upvalue cannot refer to another upvalue\n** (only closures can), and a userdata's metatable must be a table.\n*/\nstatic void reallymarkobject (global_State *g, GCObject *o) {\n  g->marked++;\n  switch (o->tt) {\n    case LUA_VSHRSTR:\n    case LUA_VLNGSTR: {\n      set2black(o);  /* nothing to visit */\n      break;\n    }\n    case LUA_VUPVAL: {\n      UpVal *uv = gco2upv(o);\n      if (upisopen(uv))\n        set2gray(uv);  /* open upvalues are kept gray */\n      else\n        set2black(uv);  /* closed upvalues are visited here */\n      markvalue(g, uv->v.p);  /* mark its content */\n      break;\n    }\n    case LUA_VUSERDATA: {\n      Udata *u = gco2u(o);\n      if (u->nuvalue == 0) {  /* no user values? */\n        markobjectN(g, u->metatable);  /* mark its metatable */\n        set2black(u);  /* nothing else to mark */\n        break;\n      }\n      /* else... */\n    }  /* FALLTHROUGH */\n    case LUA_VLCL: case LUA_VCCL: case LUA_VTABLE:\n    case LUA_VTHREAD: case LUA_VPROTO: {\n      linkobjgclist(o, g->gray);  /* to be visited later */\n      break;\n    }\n    default: lua_assert(0); break;\n  }\n}\n\n\n/*\n** mark metamethods for basic types\n*/\nstatic void markmt (global_State *g) {\n  int i;\n  for (i=0; i < LUA_NUMTYPES; i++)\n    markobjectN(g, g->mt[i]);\n}\n\n\n/*\n** mark all objects in list of being-finalized\n*/\nstatic l_obj markbeingfnz (global_State *g) {\n  GCObject *o;\n  l_obj count = 0;\n  for (o = g->tobefnz; o != NULL; o = o->next) {\n    count++;\n    markobject(g, o);\n  }\n  return count;\n}\n\n\n/*\n** For each non-marked thread, simulates a barrier between each open\n** upvalue and its value. (If the thread is collected, the value will be\n** assigned to the upvalue, but then it can be too late for the barrier\n** to act. The \"barrier\" does not need to check colors: A non-marked\n** thread must be young; upvalues cannot be older than their threads; so\n** any visited upvalue must be young too.) Also removes the thread from\n** the list, as it was already visited. Removes also threads with no\n** upvalues, as they have nothing to be checked. (If the thread gets an\n** upvalue later, it will be linked in the list again.)\n*/\nstatic l_obj remarkupvals (global_State *g) {\n  l_obj work = 0;\n  lua_State *thread;\n  lua_State **p = &g->twups;\n  while ((thread = *p) != NULL) {\n    if (!iswhite(thread) && thread->openupval != NULL)\n      p = &thread->twups;  /* keep marked thread with upvalues in the list */\n    else {  /* thread is not marked or without upvalues */\n      UpVal *uv;\n      lua_assert(!isold(thread) || thread->openupval == NULL);\n      *p = thread->twups;  /* remove thread from the list */\n      thread->twups = thread;  /* mark that it is out of list */\n      for (uv = thread->openupval; uv != NULL; uv = uv->u.open.next) {\n        lua_assert(getage(uv) <= getage(thread));\n        if (!iswhite(uv)) {  /* upvalue already visited? */\n          lua_assert(upisopen(uv) && isgray(uv));\n          markvalue(g, uv->v.p);  /* mark its value */\n        }\n      }\n    }\n    work++;\n  }\n  return work;\n}\n\n\nstatic void cleargraylists (global_State *g) {\n  g->gray = g->grayagain = NULL;\n  g->weak = g->allweak = g->ephemeron = NULL;\n}\n\n\n/*\n** mark root set and reset all gray lists, to start a new collection.\n** 'marked' is initialized with the number of fixed objects in the state,\n** to count the total number of live objects during a cycle. (That is\n** the metafield names, plus the reserved words, plus \"_ENV\" plus the\n** memory-error message.)\n*/\nstatic void restartcollection (global_State *g) {\n  cleargraylists(g);\n  g->marked = NFIXED;\n  markobject(g, g->mainthread);\n  markvalue(g, &g->l_registry);\n  markmt(g);\n  markbeingfnz(g);  /* mark any finalizing object left from previous cycle */\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Traverse functions\n** =======================================================\n*/\n\n\n/*\n** Check whether object 'o' should be kept in the 'grayagain' list for\n** post-processing by 'correctgraylist'. (It could put all old objects\n** in the list and leave all the work to 'correctgraylist', but it is\n** more efficient to avoid adding elements that will be removed.) Only\n** TOUCHED1 objects need to be in the list. TOUCHED2 doesn't need to go\n** back to a gray list, but then it must become OLD. (That is what\n** 'correctgraylist' does when it finds a TOUCHED2 object.)\n*/\nstatic void genlink (global_State *g, GCObject *o) {\n  lua_assert(isblack(o));\n  if (getage(o) == G_TOUCHED1) {  /* touched in this cycle? */\n    linkobjgclist(o, g->grayagain);  /* link it back in 'grayagain' */\n  }  /* everything else do not need to be linked back */\n  else if (getage(o) == G_TOUCHED2)\n    setage(o, G_OLD);  /* advance age */\n}\n\n\n/*\n** Traverse a table with weak values and link it to proper list. During\n** propagate phase, keep it in 'grayagain' list, to be revisited in the\n** atomic phase. In the atomic phase, if table has any white value,\n** put it in 'weak' list, to be cleared.\n*/\nstatic void traverseweakvalue (global_State *g, Table *h) {\n  Node *n, *limit = gnodelast(h);\n  /* if there is array part, assume it may have white values (it is not\n     worth traversing it now just to check) */\n  int hasclears = (h->alimit > 0);\n  for (n = gnode(h, 0); n < limit; n++) {  /* traverse hash part */\n    if (isempty(gval(n)))  /* entry is empty? */\n      clearkey(n);  /* clear its key */\n    else {\n      lua_assert(!keyisnil(n));\n      markkey(g, n);\n      if (!hasclears && iscleared(g, gcvalueN(gval(n))))  /* a white value? */\n        hasclears = 1;  /* table will have to be cleared */\n    }\n  }\n  if (g->gcstate == GCSatomic && hasclears)\n    linkgclist(h, g->weak);  /* has to be cleared later */\n  else\n    linkgclist(h, g->grayagain);  /* must retraverse it in atomic phase */\n}\n\n\n/*\n** Traverse the array part of a table.\n*/\nstatic int traversearray (global_State *g, Table *h) {\n  unsigned asize = luaH_realasize(h);\n  int marked = 0;  /* true if some object is marked in this traversal */\n  unsigned i;\n  for (i = 0; i < asize; i++) {\n    GCObject *o = gcvalarr(h, i);\n    if (o != NULL && iswhite(o)) {\n      marked = 1;\n      reallymarkobject(g, o);\n    }\n  }\n  return marked;\n}\n\n\n/*\n** Traverse an ephemeron table and link it to proper list. Returns true\n** iff any object was marked during this traversal (which implies that\n** convergence has to continue). During propagation phase, keep table\n** in 'grayagain' list, to be visited again in the atomic phase. In\n** the atomic phase, if table has any white->white entry, it has to\n** be revisited during ephemeron convergence (as that key may turn\n** black). Otherwise, if it has any white key, table has to be cleared\n** (in the atomic phase). In generational mode, some tables\n** must be kept in some gray list for post-processing; this is done\n** by 'genlink'.\n*/\nstatic int traverseephemeron (global_State *g, Table *h, int inv) {\n  int hasclears = 0;  /* true if table has white keys */\n  int hasww = 0;  /* true if table has entry \"white-key -> white-value\" */\n  unsigned int i;\n  unsigned int nsize = sizenode(h);\n  int marked = traversearray(g, h);  /* traverse array part */\n  /* traverse hash part; if 'inv', traverse descending\n     (see 'convergeephemerons') */\n  for (i = 0; i < nsize; i++) {\n    Node *n = inv ? gnode(h, nsize - 1 - i) : gnode(h, i);\n    if (isempty(gval(n)))  /* entry is empty? */\n      clearkey(n);  /* clear its key */\n    else if (iscleared(g, gckeyN(n))) {  /* key is not marked (yet)? */\n      hasclears = 1;  /* table must be cleared */\n      if (valiswhite(gval(n)))  /* value not marked yet? */\n        hasww = 1;  /* white-white entry */\n    }\n    else if (valiswhite(gval(n))) {  /* value not marked yet? */\n      marked = 1;\n      reallymarkobject(g, gcvalue(gval(n)));  /* mark it now */\n    }\n  }\n  /* link table into proper list */\n  if (g->gcstate == GCSpropagate)\n    linkgclist(h, g->grayagain);  /* must retraverse it in atomic phase */\n  else if (hasww)  /* table has white->white entries? */\n    linkgclist(h, g->ephemeron);  /* have to propagate again */\n  else if (hasclears)  /* table has white keys? */\n    linkgclist(h, g->allweak);  /* may have to clean white keys */\n  else\n    genlink(g, obj2gco(h));  /* check whether collector still needs to see it */\n  return marked;\n}\n\n\nstatic void traversestrongtable (global_State *g, Table *h) {\n  Node *n, *limit = gnodelast(h);\n  traversearray(g, h);\n  for (n = gnode(h, 0); n < limit; n++) {  /* traverse hash part */\n    if (isempty(gval(n)))  /* entry is empty? */\n      clearkey(n);  /* clear its key */\n    else {\n      lua_assert(!keyisnil(n));\n      markkey(g, n);\n      markvalue(g, gval(n));\n    }\n  }\n  genlink(g, obj2gco(h));\n}\n\n\nstatic void traversetable (global_State *g, Table *h) {\n  const char *weakkey, *weakvalue;\n  const TValue *mode = gfasttm(g, h->metatable, TM_MODE);\n  TString *smode;\n  markobjectN(g, h->metatable);\n  if (mode && ttisshrstring(mode) &&  /* is there a weak mode? */\n      (cast_void(smode = tsvalue(mode)),\n       cast_void(weakkey = strchr(getshrstr(smode), 'k')),\n       cast_void(weakvalue = strchr(getshrstr(smode), 'v')),\n       (weakkey || weakvalue))) {  /* is really weak? */\n    if (!weakkey)  /* strong keys? */\n      traverseweakvalue(g, h);\n    else if (!weakvalue)  /* strong values? */\n      traverseephemeron(g, h, 0);\n    else  /* all weak */\n      linkgclist(h, g->allweak);  /* nothing to traverse now */\n  }\n  else  /* not weak */\n    traversestrongtable(g, h);\n}\n\n\nstatic void traverseudata (global_State *g, Udata *u) {\n  int i;\n  markobjectN(g, u->metatable);  /* mark its metatable */\n  for (i = 0; i < u->nuvalue; i++)\n    markvalue(g, &u->uv[i].uv);\n  genlink(g, obj2gco(u));\n}\n\n\n/*\n** Traverse a prototype. (While a prototype is being build, its\n** arrays can be larger than needed; the extra slots are filled with\n** NULL, so the use of 'markobjectN')\n*/\nstatic void traverseproto (global_State *g, Proto *f) {\n  int i;\n  markobjectN(g, f->source);\n  for (i = 0; i < f->sizek; i++)  /* mark literals */\n    markvalue(g, &f->k[i]);\n  for (i = 0; i < f->sizeupvalues; i++)  /* mark upvalue names */\n    markobjectN(g, f->upvalues[i].name);\n  for (i = 0; i < f->sizep; i++)  /* mark nested protos */\n    markobjectN(g, f->p[i]);\n  for (i = 0; i < f->sizelocvars; i++)  /* mark local-variable names */\n    markobjectN(g, f->locvars[i].varname);\n}\n\n\nstatic void traverseCclosure (global_State *g, CClosure *cl) {\n  int i;\n  for (i = 0; i < cl->nupvalues; i++)  /* mark its upvalues */\n    markvalue(g, &cl->upvalue[i]);\n}\n\n/*\n** Traverse a Lua closure, marking its prototype and its upvalues.\n** (Both can be NULL while closure is being created.)\n*/\nstatic void traverseLclosure (global_State *g, LClosure *cl) {\n  int i;\n  markobjectN(g, cl->p);  /* mark its prototype */\n  for (i = 0; i < cl->nupvalues; i++) {  /* visit its upvalues */\n    UpVal *uv = cl->upvals[i];\n    markobjectN(g, uv);  /* mark upvalue */\n  }\n}\n\n\n/*\n** Traverse a thread, marking the elements in the stack up to its top\n** and cleaning the rest of the stack in the final traversal. That\n** ensures that the entire stack have valid (non-dead) objects.\n** Threads have no barriers. In gen. mode, old threads must be visited\n** at every cycle, because they might point to young objects.  In inc.\n** mode, the thread can still be modified before the end of the cycle,\n** and therefore it must be visited again in the atomic phase. To ensure\n** these visits, threads must return to a gray list if they are not new\n** (which can only happen in generational mode) or if the traverse is in\n** the propagate phase (which can only happen in incremental mode).\n*/\nstatic void traversethread (global_State *g, lua_State *th) {\n  UpVal *uv;\n  StkId o = th->stack.p;\n  if (isold(th) || g->gcstate == GCSpropagate)\n    linkgclist(th, g->grayagain);  /* insert into 'grayagain' list */\n  if (o == NULL)\n    return;  /* stack not completely built yet */\n  lua_assert(g->gcstate == GCSatomic ||\n             th->openupval == NULL || isintwups(th));\n  for (; o < th->top.p; o++)  /* mark live elements in the stack */\n    markvalue(g, s2v(o));\n  for (uv = th->openupval; uv != NULL; uv = uv->u.open.next)\n    markobject(g, uv);  /* open upvalues cannot be collected */\n  if (g->gcstate == GCSatomic) {  /* final traversal? */\n    if (!g->gcemergency)\n      luaD_shrinkstack(th); /* do not change stack in emergency cycle */\n    for (o = th->top.p; o < th->stack_last.p + EXTRA_STACK; o++)\n      setnilvalue(s2v(o));  /* clear dead stack slice */\n    /* 'remarkupvals' may have removed thread from 'twups' list */\n    if (!isintwups(th) && th->openupval != NULL) {\n      th->twups = g->twups;  /* link it back to the list */\n      g->twups = th;\n    }\n  }\n}\n\n\n/*\n** traverse one gray object, turning it to black.\n*/\nstatic void propagatemark (global_State *g) {\n  GCObject *o = g->gray;\n  nw2black(o);\n  g->gray = *getgclist(o);  /* remove from 'gray' list */\n  switch (o->tt) {\n    case LUA_VTABLE: traversetable(g, gco2t(o)); break;\n    case LUA_VUSERDATA: traverseudata(g, gco2u(o)); break;\n    case LUA_VLCL: traverseLclosure(g, gco2lcl(o)); break;\n    case LUA_VCCL: traverseCclosure(g, gco2ccl(o)); break;\n    case LUA_VPROTO: traverseproto(g, gco2p(o)); break;\n    case LUA_VTHREAD: traversethread(g, gco2th(o)); break;\n    default: lua_assert(0);\n  }\n}\n\n\nstatic l_obj propagateall (global_State *g) {\n  l_obj work = 0;\n  while (g->gray) {\n    propagatemark(g);\n    work++;\n  }\n  return work;\n}\n\n\n/*\n** Traverse all ephemeron tables propagating marks from keys to values.\n** Repeat until it converges, that is, nothing new is marked. 'dir'\n** inverts the direction of the traversals, trying to speed up\n** convergence on chains in the same table.\n*/\nstatic l_obj convergeephemerons (global_State *g) {\n  int changed;\n  l_obj work = 0;\n  int dir = 0;\n  do {\n    GCObject *w;\n    GCObject *next = g->ephemeron;  /* get ephemeron list */\n    g->ephemeron = NULL;  /* tables may return to this list when traversed */\n    changed = 0;\n    while ((w = next) != NULL) {  /* for each ephemeron table */\n      Table *h = gco2t(w);\n      next = h->gclist;  /* list is rebuilt during loop */\n      nw2black(h);  /* out of the list (for now) */\n      if (traverseephemeron(g, h, dir)) {  /* marked some value? */\n        propagateall(g);  /* propagate changes */\n        changed = 1;  /* will have to revisit all ephemeron tables */\n      }\n      work++;\n    }\n    dir = !dir;  /* invert direction next time */\n  } while (changed);  /* repeat until no more changes */\n  return work;\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Sweep Functions\n** =======================================================\n*/\n\n\n/*\n** clear entries with unmarked keys from all weaktables in list 'l'\n*/\nstatic l_obj clearbykeys (global_State *g, GCObject *l) {\n  l_obj work = 0;\n  for (; l; l = gco2t(l)->gclist) {\n    Table *h = gco2t(l);\n    Node *limit = gnodelast(h);\n    Node *n;\n    for (n = gnode(h, 0); n < limit; n++) {\n      if (iscleared(g, gckeyN(n)))  /* unmarked key? */\n        setempty(gval(n));  /* remove entry */\n      if (isempty(gval(n)))  /* is entry empty? */\n        clearkey(n);  /* clear its key */\n    }\n    work++;\n  }\n  return work;\n}\n\n\n/*\n** clear entries with unmarked values from all weaktables in list 'l' up\n** to element 'f'\n*/\nstatic l_obj clearbyvalues (global_State *g, GCObject *l, GCObject *f) {\n  l_obj work = 0;\n  for (; l != f; l = gco2t(l)->gclist) {\n    Table *h = gco2t(l);\n    Node *n, *limit = gnodelast(h);\n    unsigned int i;\n    unsigned int asize = luaH_realasize(h);\n    for (i = 0; i < asize; i++) {\n      GCObject *o = gcvalarr(h, i);\n      if (iscleared(g, o))  /* value was collected? */\n        *getArrTag(h, i) = LUA_VEMPTY;  /* remove entry */\n    }\n    for (n = gnode(h, 0); n < limit; n++) {\n      if (iscleared(g, gcvalueN(gval(n))))  /* unmarked value? */\n        setempty(gval(n));  /* remove entry */\n      if (isempty(gval(n)))  /* is entry empty? */\n        clearkey(n);  /* clear its key */\n    }\n    work++;\n  }\n  return work;\n}\n\n\nstatic void freeupval (lua_State *L, UpVal *uv) {\n  if (upisopen(uv))\n    luaF_unlinkupval(uv);\n  luaM_free(L, uv);\n}\n\n\nstatic void freeobj (lua_State *L, GCObject *o) {\n  G(L)->totalobjs--;\n  switch (o->tt) {\n    case LUA_VPROTO:\n      luaF_freeproto(L, gco2p(o));\n      break;\n    case LUA_VUPVAL:\n      freeupval(L, gco2upv(o));\n      break;\n    case LUA_VLCL: {\n      LClosure *cl = gco2lcl(o);\n      luaM_freemem(L, cl, sizeLclosure(cl->nupvalues));\n      break;\n    }\n    case LUA_VCCL: {\n      CClosure *cl = gco2ccl(o);\n      luaM_freemem(L, cl, sizeCclosure(cl->nupvalues));\n      break;\n    }\n    case LUA_VTABLE:\n      luaH_free(L, gco2t(o));\n      break;\n    case LUA_VTHREAD:\n      luaE_freethread(L, gco2th(o));\n      break;\n    case LUA_VUSERDATA: {\n      Udata *u = gco2u(o);\n      luaM_freemem(L, o, sizeudata(u->nuvalue, u->len));\n      break;\n    }\n    case LUA_VSHRSTR: {\n      TString *ts = gco2ts(o);\n      luaS_remove(L, ts);  /* remove it from hash table */\n      luaM_freemem(L, ts, sizestrshr(ts->shrlen));\n      break;\n    }\n    case LUA_VLNGSTR: {\n      TString *ts = gco2ts(o);\n      if (ts->shrlen == LSTRMEM)  /* must free external string? */\n        (*ts->falloc)(ts->ud, ts->contents, ts->u.lnglen + 1, 0);\n      luaM_freemem(L, ts, luaS_sizelngstr(ts->u.lnglen, ts->shrlen));\n      break;\n    }\n    default: lua_assert(0);\n  }\n}\n\n\n/*\n** sweep at most 'countin' elements from a list of GCObjects erasing dead\n** objects, where a dead object is one marked with the old (non current)\n** white; change all non-dead objects back to white (and new), preparing\n** for next collection cycle. Return where to continue the traversal or\n** NULL if list is finished.\n*/\nstatic GCObject **sweeplist (lua_State *L, GCObject **p, l_obj countin) {\n  global_State *g = G(L);\n  int ow = otherwhite(g);\n  l_obj i;\n  int white = luaC_white(g);  /* current white */\n  for (i = 0; *p != NULL && i < countin; i++) {\n    GCObject *curr = *p;\n    int marked = curr->marked;\n    if (isdeadm(ow, marked)) {  /* is 'curr' dead? */\n      *p = curr->next;  /* remove 'curr' from list */\n      freeobj(L, curr);  /* erase 'curr' */\n    }\n    else {  /* change mark to 'white' and age to 'new' */\n      curr->marked = cast_byte((marked & ~maskgcbits) | white | G_NEW);\n      p = &curr->next;  /* go to next element */\n    }\n  }\n  return (*p == NULL) ? NULL : p;\n}\n\n\n/*\n** sweep a list until a live object (or end of list)\n*/\nstatic GCObject **sweeptolive (lua_State *L, GCObject **p) {\n  GCObject **old = p;\n  do {\n    p = sweeplist(L, p, 1);\n  } while (p == old);\n  return p;\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Finalization\n** =======================================================\n*/\n\n/*\n** If possible, shrink string table.\n*/\nstatic void checkSizes (lua_State *L, global_State *g) {\n  if (!g->gcemergency) {\n    if (g->strt.nuse < g->strt.size / 4)  /* string table too big? */\n      luaS_resize(L, g->strt.size / 2);\n  }\n}\n\n\n/*\n** Get the next udata to be finalized from the 'tobefnz' list, and\n** link it back into the 'allgc' list.\n*/\nstatic GCObject *udata2finalize (global_State *g) {\n  GCObject *o = g->tobefnz;  /* get first element */\n  lua_assert(tofinalize(o));\n  g->tobefnz = o->next;  /* remove it from 'tobefnz' list */\n  o->next = g->allgc;  /* return it to 'allgc' list */\n  g->allgc = o;\n  resetbit(o->marked, FINALIZEDBIT);  /* object is \"normal\" again */\n  if (issweepphase(g))\n    makewhite(g, o);  /* \"sweep\" object */\n  else if (getage(o) == G_OLD1)\n    g->firstold1 = o;  /* it is the first OLD1 object in the list */\n  return o;\n}\n\n\nstatic void dothecall (lua_State *L, void *ud) {\n  UNUSED(ud);\n  luaD_callnoyield(L, L->top.p - 2, 0);\n}\n\n\nstatic void GCTM (lua_State *L) {\n  global_State *g = G(L);\n  const TValue *tm;\n  TValue v;\n  lua_assert(!g->gcemergency);\n  setgcovalue(L, &v, udata2finalize(g));\n  tm = luaT_gettmbyobj(L, &v, TM_GC);\n  if (!notm(tm)) {  /* is there a finalizer? */\n    int status;\n    lu_byte oldah = L->allowhook;\n    int oldgcstp  = g->gcstp;\n    g->gcstp |= GCSTPGC;  /* avoid GC steps */\n    L->allowhook = 0;  /* stop debug hooks during GC metamethod */\n    setobj2s(L, L->top.p++, tm);  /* push finalizer... */\n    setobj2s(L, L->top.p++, &v);  /* ... and its argument */\n    L->ci->callstatus |= CIST_FIN;  /* will run a finalizer */\n    status = luaD_pcall(L, dothecall, NULL, savestack(L, L->top.p - 2), 0);\n    L->ci->callstatus &= ~CIST_FIN;  /* not running a finalizer anymore */\n    L->allowhook = oldah;  /* restore hooks */\n    g->gcstp = oldgcstp;  /* restore state */\n    if (l_unlikely(status != LUA_OK)) {  /* error while running __gc? */\n      luaE_warnerror(L, \"__gc\");\n      L->top.p--;  /* pops error object */\n    }\n  }\n}\n\n\n/*\n** call all pending finalizers\n*/\nstatic void callallpendingfinalizers (lua_State *L) {\n  global_State *g = G(L);\n  while (g->tobefnz)\n    GCTM(L);\n}\n\n\n/*\n** find last 'next' field in list 'p' list (to add elements in its end)\n*/\nstatic GCObject **findlast (GCObject **p) {\n  while (*p != NULL)\n    p = &(*p)->next;\n  return p;\n}\n\n\n/*\n** Move all unreachable objects (or 'all' objects) that need\n** finalization from list 'finobj' to list 'tobefnz' (to be finalized).\n** (Note that objects after 'finobjold1' cannot be white, so they\n** don't need to be traversed. In incremental mode, 'finobjold1' is NULL,\n** so the whole list is traversed.)\n*/\nstatic void separatetobefnz (global_State *g, int all) {\n  GCObject *curr;\n  GCObject **p = &g->finobj;\n  GCObject **lastnext = findlast(&g->tobefnz);\n  while ((curr = *p) != g->finobjold1) {  /* traverse all finalizable objects */\n    lua_assert(tofinalize(curr));\n    if (!(iswhite(curr) || all))  /* not being collected? */\n      p = &curr->next;  /* don't bother with it */\n    else {\n      if (curr == g->finobjsur)  /* removing 'finobjsur'? */\n        g->finobjsur = curr->next;  /* correct it */\n      *p = curr->next;  /* remove 'curr' from 'finobj' list */\n      curr->next = *lastnext;  /* link at the end of 'tobefnz' list */\n      *lastnext = curr;\n      lastnext = &curr->next;\n    }\n  }\n}\n\n\n/*\n** If pointer 'p' points to 'o', move it to the next element.\n*/\nstatic void checkpointer (GCObject **p, GCObject *o) {\n  if (o == *p)\n    *p = o->next;\n}\n\n\n/*\n** Correct pointers to objects inside 'allgc' list when\n** object 'o' is being removed from the list.\n*/\nstatic void correctpointers (global_State *g, GCObject *o) {\n  checkpointer(&g->survival, o);\n  checkpointer(&g->old1, o);\n  checkpointer(&g->reallyold, o);\n  checkpointer(&g->firstold1, o);\n}\n\n\n/*\n** if object 'o' has a finalizer, remove it from 'allgc' list (must\n** search the list to find it) and link it in 'finobj' list.\n*/\nvoid luaC_checkfinalizer (lua_State *L, GCObject *o, Table *mt) {\n  global_State *g = G(L);\n  if (tofinalize(o) ||                 /* obj. is already marked... */\n      gfasttm(g, mt, TM_GC) == NULL ||    /* or has no finalizer... */\n      (g->gcstp & GCSTPCLS))                   /* or closing state? */\n    return;  /* nothing to be done */\n  else {  /* move 'o' to 'finobj' list */\n    GCObject **p;\n    if (issweepphase(g)) {\n      makewhite(g, o);  /* \"sweep\" object 'o' */\n      if (g->sweepgc == &o->next)  /* should not remove 'sweepgc' object */\n        g->sweepgc = sweeptolive(L, g->sweepgc);  /* change 'sweepgc' */\n    }\n    else\n      correctpointers(g, o);\n    /* search for pointer pointing to 'o' */\n    for (p = &g->allgc; *p != o; p = &(*p)->next) { /* empty */ }\n    *p = o->next;  /* remove 'o' from 'allgc' list */\n    o->next = g->finobj;  /* link it in 'finobj' list */\n    g->finobj = o;\n    l_setbit(o->marked, FINALIZEDBIT);  /* mark it as such */\n  }\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Generational Collector\n** =======================================================\n*/\n\n\n/*\n** Set the \"time\" to wait before starting a new incremental cycle;\n** cycle will start when number of objects in use hits the threshold of\n** approximately (marked * pause / 100).\n*/\nstatic void setpause (global_State *g) {\n  l_obj threshold = applygcparam(g, PAUSE, g->marked);\n  l_obj debt = threshold - gettotalobjs(g);\n  if (debt < 0) debt = 0;\n  luaE_setdebt(g, debt);\n}\n\n\n/*\n** Sweep a list of objects to enter generational mode.  Deletes dead\n** objects and turns the non dead to old. All non-dead threads---which\n** are now old---must be in a gray list. Everything else is not in a\n** gray list. Open upvalues are also kept gray.\n*/\nstatic void sweep2old (lua_State *L, GCObject **p) {\n  GCObject *curr;\n  global_State *g = G(L);\n  while ((curr = *p) != NULL) {\n    if (iswhite(curr)) {  /* is 'curr' dead? */\n      lua_assert(isdead(g, curr));\n      *p = curr->next;  /* remove 'curr' from list */\n      freeobj(L, curr);  /* erase 'curr' */\n    }\n    else {  /* all surviving objects become old */\n      setage(curr, G_OLD);\n      if (curr->tt == LUA_VTHREAD) {  /* threads must be watched */\n        lua_State *th = gco2th(curr);\n        linkgclist(th, g->grayagain);  /* insert into 'grayagain' list */\n      }\n      else if (curr->tt == LUA_VUPVAL && upisopen(gco2upv(curr)))\n        set2gray(curr);  /* open upvalues are always gray */\n      else  /* everything else is black */\n        nw2black(curr);\n      p = &curr->next;  /* go to next element */\n    }\n  }\n}\n\n\n/*\n** Sweep for generational mode. Delete dead objects. (Because the\n** collection is not incremental, there are no \"new white\" objects\n** during the sweep. So, any white object must be dead.) For\n** non-dead objects, advance their ages and clear the color of\n** new objects. (Old objects keep their colors.)\n** The ages of G_TOUCHED1 and G_TOUCHED2 objects cannot be advanced\n** here, because these old-generation objects are usually not swept\n** here.  They will all be advanced in 'correctgraylist'. That function\n** will also remove objects turned white here from any gray list.\n*/\nstatic GCObject **sweepgen (lua_State *L, global_State *g, GCObject **p,\n                            GCObject *limit, GCObject **pfirstold1,\n                            l_obj *paddedold) {\n  static const lu_byte nextage[] = {\n    G_SURVIVAL,  /* from G_NEW */\n    G_OLD1,      /* from G_SURVIVAL */\n    G_OLD1,      /* from G_OLD0 */\n    G_OLD,       /* from G_OLD1 */\n    G_OLD,       /* from G_OLD (do not change) */\n    G_TOUCHED1,  /* from G_TOUCHED1 (do not change) */\n    G_TOUCHED2   /* from G_TOUCHED2 (do not change) */\n  };\n  l_obj addedold = 0;\n  int white = luaC_white(g);\n  GCObject *curr;\n  while ((curr = *p) != limit) {\n    if (iswhite(curr)) {  /* is 'curr' dead? */\n      lua_assert(!isold(curr) && isdead(g, curr));\n      *p = curr->next;  /* remove 'curr' from list */\n      freeobj(L, curr);  /* erase 'curr' */\n    }\n    else {  /* correct mark and age */\n      int age = getage(curr);\n      if (age == G_NEW) {  /* new objects go back to white */\n        int marked = curr->marked & ~maskgcbits;  /* erase GC bits */\n        curr->marked = cast_byte(marked | G_SURVIVAL | white);\n      }\n      else {  /* all other objects will be old, and so keep their color */\n        lua_assert(age != G_OLD1);  /* advanced in 'markold' */\n        setage(curr, nextage[age]);\n        if (getage(curr) == G_OLD1) {\n          addedold++;  /* one more object becoming old */\n          if (*pfirstold1 == NULL)\n            *pfirstold1 = curr;  /* first OLD1 object in the list */\n        }\n      }\n      p = &curr->next;  /* go to next element */\n    }\n  }\n  *paddedold += addedold;\n  return p;\n}\n\n\n/*\n** Correct a list of gray objects. Return a pointer to the last element\n** left on the list, so that we can link another list to the end of\n** this one.\n** Because this correction is done after sweeping, young objects might\n** be turned white and still be in the list. They are only removed.\n** 'TOUCHED1' objects are advanced to 'TOUCHED2' and remain on the list;\n** Non-white threads also remain on the list. 'TOUCHED2' objects and\n** anything else become regular old, are marked black, and are removed\n** from the list.\n*/\nstatic GCObject **correctgraylist (GCObject **p) {\n  GCObject *curr;\n  while ((curr = *p) != NULL) {\n    GCObject **next = getgclist(curr);\n    if (iswhite(curr))\n      goto remove;  /* remove all white objects */\n    else if (getage(curr) == G_TOUCHED1) {  /* touched in this cycle? */\n      lua_assert(isgray(curr));\n      nw2black(curr);  /* make it black, for next barrier */\n      setage(curr, G_TOUCHED2);\n      goto remain;  /* keep it in the list and go to next element */\n    }\n    else if (curr->tt == LUA_VTHREAD) {\n      lua_assert(isgray(curr));\n      goto remain;  /* keep non-white threads on the list */\n    }\n    else {  /* everything else is removed */\n      lua_assert(isold(curr));  /* young objects should be white here */\n      if (getage(curr) == G_TOUCHED2)  /* advance from TOUCHED2... */\n        setage(curr, G_OLD);  /* ... to OLD */\n      nw2black(curr);  /* make object black (to be removed) */\n      goto remove;\n    }\n    remove: *p = *next; continue;\n    remain: p = next; continue;\n  }\n  return p;\n}\n\n\n/*\n** Correct all gray lists, coalescing them into 'grayagain'.\n*/\nstatic void correctgraylists (global_State *g) {\n  GCObject **list = correctgraylist(&g->grayagain);\n  *list = g->weak; g->weak = NULL;\n  list = correctgraylist(list);\n  *list = g->allweak; g->allweak = NULL;\n  list = correctgraylist(list);\n  *list = g->ephemeron; g->ephemeron = NULL;\n  correctgraylist(list);\n}\n\n\n/*\n** Mark black 'OLD1' objects when starting a new young collection.\n** Gray objects are already in some gray list, and so will be visited in\n** the atomic step.\n*/\nstatic void markold (global_State *g, GCObject *from, GCObject *to) {\n  GCObject *p;\n  for (p = from; p != to; p = p->next) {\n    if (getage(p) == G_OLD1) {\n      lua_assert(!iswhite(p));\n      setage(p, G_OLD);  /* now they are old */\n      if (isblack(p))\n        reallymarkobject(g, p);\n    }\n  }\n}\n\n\n/*\n** Finish a young-generation collection.\n*/\nstatic void finishgencycle (lua_State *L, global_State *g) {\n  correctgraylists(g);\n  checkSizes(L, g);\n  g->gcstate = GCSpropagate;  /* skip restart */\n  if (!g->gcemergency)\n    callallpendingfinalizers(L);\n}\n\n\n/*\n** Shifts from a minor collection to major collections. It starts in\n** the \"sweep all\" state to clear all objects, which are mostly black\n** in generational mode.\n*/\nstatic void minor2inc (lua_State *L, global_State *g, int kind) {\n  g->GCmajorminor = g->marked;  /* number of live objects */\n  g->gckind = kind;\n  g->reallyold = g->old1 = g->survival = NULL;\n  g->finobjrold = g->finobjold1 = g->finobjsur = NULL;\n  entersweep(L);  /* continue as an incremental cycle */\n  /* set a debt equal to the step size */\n  luaE_setdebt(g, applygcparam(g, STEPSIZE, 100));\n}\n\n\n/*\n** Decide whether to shift to major mode. It tests two conditions:\n** 1) Whether the number of added old objects in this collection is more\n** than half the number of new objects. ('step' is the number of objects\n** created between minor collections. Except for forward barriers, it\n** is the maximum number of objects that can become old in each minor\n** collection.)\n** 2) Whether the accumulated number of added old objects is larger\n** than 'minormajor'% of the number of lived objects after the last\n** major collection. (That percentage is computed in 'limit'.)\n*/\nstatic int checkminormajor (global_State *g, l_obj addedold1) {\n  l_obj step = applygcparam(g, MINORMUL, g->GCmajorminor);\n  l_obj limit = applygcparam(g, MINORMAJOR, g->GCmajorminor);\n  return (addedold1 >= (step >> 1) || g->marked >= limit);\n}\n\n/*\n** Does a young collection. First, mark 'OLD1' objects. Then does the\n** atomic step. Then, check whether to continue in minor mode. If so,\n** sweep all lists and advance pointers. Finally, finish the collection.\n*/\nstatic void youngcollection (lua_State *L, global_State *g) {\n  l_obj addedold1 = 0;\n  l_obj marked = g->marked;  /* preserve 'g->marked' */\n  GCObject **psurvival;  /* to point to first non-dead survival object */\n  GCObject *dummy;  /* dummy out parameter to 'sweepgen' */\n  lua_assert(g->gcstate == GCSpropagate);\n  if (g->firstold1) {  /* are there regular OLD1 objects? */\n    markold(g, g->firstold1, g->reallyold);  /* mark them */\n    g->firstold1 = NULL;  /* no more OLD1 objects (for now) */\n  }\n  markold(g, g->finobj, g->finobjrold);\n  markold(g, g->tobefnz, NULL);\n\n  atomic(L);  /* will lose 'g->marked' */\n\n  /* sweep nursery and get a pointer to its last live element */\n  g->gcstate = GCSswpallgc;\n  psurvival = sweepgen(L, g, &g->allgc, g->survival, &g->firstold1, &addedold1);\n  /* sweep 'survival' */\n  sweepgen(L, g, psurvival, g->old1, &g->firstold1, &addedold1);\n  g->reallyold = g->old1;\n  g->old1 = *psurvival;  /* 'survival' survivals are old now */\n  g->survival = g->allgc;  /* all news are survivals */\n\n  /* repeat for 'finobj' lists */\n  dummy = NULL;  /* no 'firstold1' optimization for 'finobj' lists */\n  psurvival = sweepgen(L, g, &g->finobj, g->finobjsur, &dummy, &addedold1);\n  /* sweep 'survival' */\n  sweepgen(L, g, psurvival, g->finobjold1, &dummy, &addedold1);\n  g->finobjrold = g->finobjold1;\n  g->finobjold1 = *psurvival;  /* 'survival' survivals are old now */\n  g->finobjsur = g->finobj;  /* all news are survivals */\n\n  sweepgen(L, g, &g->tobefnz, NULL, &dummy, &addedold1);\n\n  /* keep total number of added old1 objects */\n  g->marked = marked + addedold1;\n\n  /* decide whether to shift to major mode */\n  if (checkminormajor(g, addedold1)) {\n    minor2inc(L, g, KGC_GENMAJOR);  /* go to major mode */\n    g->marked = 0;  /* avoid pause in first major cycle */\n  }\n  else\n    finishgencycle(L, g);  /* still in minor mode; finish it */\n}\n\n\n/*\n** Clears all gray lists, sweeps objects, and prepare sublists to enter\n** generational mode. The sweeps remove dead objects and turn all\n** surviving objects to old. Threads go back to 'grayagain'; everything\n** else is turned black (not in any gray list).\n*/\nstatic void atomic2gen (lua_State *L, global_State *g) {\n  cleargraylists(g);\n  /* sweep all elements making them old */\n  g->gcstate = GCSswpallgc;\n  sweep2old(L, &g->allgc);\n  /* everything alive now is old */\n  g->reallyold = g->old1 = g->survival = g->allgc;\n  g->firstold1 = NULL;  /* there are no OLD1 objects anywhere */\n\n  /* repeat for 'finobj' lists */\n  sweep2old(L, &g->finobj);\n  g->finobjrold = g->finobjold1 = g->finobjsur = g->finobj;\n\n  sweep2old(L, &g->tobefnz);\n\n  g->gckind = KGC_GENMINOR;\n  g->GCmajorminor = g->marked;  /* \"base\" for number of objects */\n  g->marked = 0;  /* to count the number of added old1 objects */\n  finishgencycle(L, g);\n}\n\n\n/*\n** Set debt for the next minor collection, which will happen when\n** total number of objects grows 'genminormul'%.\n*/\nstatic void setminordebt (global_State *g) {\n  luaE_setdebt(g, applygcparam(g, MINORMUL, g->GCmajorminor));\n}\n\n\n/*\n** Enter generational mode. Must go until the end of an atomic cycle\n** to ensure that all objects are correctly marked and weak tables\n** are cleared. Then, turn all objects into old and finishes the\n** collection.\n*/\nstatic void entergen (lua_State *L, global_State *g) {\n  luaC_runtilstate(L, GCSpause, 1);  /* prepare to start a new cycle */\n  luaC_runtilstate(L, GCSpropagate, 1);  /* start new cycle */\n  atomic(L);  /* propagates all and then do the atomic stuff */\n  atomic2gen(L, g);\n  setminordebt(g);  /* set debt assuming next cycle will be minor */\n}\n\n\n/*\n** Change collector mode to 'newmode'.\n*/\nvoid luaC_changemode (lua_State *L, int newmode) {\n  global_State *g = G(L);\n  if (g->gckind == KGC_GENMAJOR)  /* doing major collections? */\n    g->gckind = KGC_INC;  /* already incremental but in name */\n  if (newmode != g->gckind) {  /* does it need to change? */\n    if (newmode == KGC_INC)  /* entering incremental mode? */\n      minor2inc(L, g, KGC_INC);  /* entering incremental mode */\n    else {\n      lua_assert(newmode == KGC_GENMINOR);\n      entergen(L, g);\n    }\n  }\n}\n\n\n/*\n** Does a full collection in generational mode.\n*/\nstatic void fullgen (lua_State *L, global_State *g) {\n  minor2inc(L, g, KGC_INC);\n  entergen(L, g);\n}\n\n\n/*\n** After an atomic incremental step from a major collection,\n** check whether collector could return to minor collections.\n** It checks whether the number of objects 'tobecollected'\n** is greater than 'majorminor'% of the number of objects added\n** since the last collection ('addedobjs').\n*/\nstatic int checkmajorminor (lua_State *L, global_State *g) {\n  if (g->gckind == KGC_GENMAJOR) {  /* generational mode? */\n    l_obj numobjs = gettotalobjs(g);\n    l_obj addedobjs = numobjs - g->GCmajorminor;\n    l_obj limit = applygcparam(g, MAJORMINOR, addedobjs);\n    l_obj tobecollected = numobjs - g->marked;\n    if (tobecollected > limit) {\n      atomic2gen(L, g);  /* return to generational mode */\n      setminordebt(g);\n      return 0;  /* exit incremental collection */\n    }\n  }\n  g->GCmajorminor = g->marked;  /* prepare for next collection */\n  return 1;  /* stay doing incremental collections */\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** GC control\n** =======================================================\n*/\n\n\n/*\n** Enter first sweep phase.\n** The call to 'sweeptolive' makes the pointer point to an object\n** inside the list (instead of to the header), so that the real sweep do\n** not need to skip objects created between \"now\" and the start of the\n** real sweep.\n*/\nstatic void entersweep (lua_State *L) {\n  global_State *g = G(L);\n  g->gcstate = GCSswpallgc;\n  lua_assert(g->sweepgc == NULL);\n  g->sweepgc = sweeptolive(L, &g->allgc);\n}\n\n\n/*\n** Delete all objects in list 'p' until (but not including) object\n** 'limit'.\n*/\nstatic void deletelist (lua_State *L, GCObject *p, GCObject *limit) {\n  while (p != limit) {\n    GCObject *next = p->next;\n    freeobj(L, p);\n    p = next;\n  }\n}\n\n\n/*\n** Call all finalizers of the objects in the given Lua state, and\n** then free all objects, except for the main thread.\n*/\nvoid luaC_freeallobjects (lua_State *L) {\n  global_State *g = G(L);\n  g->gcstp = GCSTPCLS;  /* no extra finalizers after here */\n  luaC_changemode(L, KGC_INC);\n  separatetobefnz(g, 1);  /* separate all objects with finalizers */\n  lua_assert(g->finobj == NULL);\n  callallpendingfinalizers(L);\n  deletelist(L, g->allgc, obj2gco(g->mainthread));\n  lua_assert(g->finobj == NULL);  /* no new finalizers */\n  deletelist(L, g->fixedgc, NULL);  /* collect fixed objects */\n  lua_assert(g->strt.nuse == 0);\n}\n\n\nstatic l_obj atomic (lua_State *L) {\n  l_obj work = 0;\n  global_State *g = G(L);\n  GCObject *origweak, *origall;\n  GCObject *grayagain = g->grayagain;  /* save original list */\n  g->grayagain = NULL;\n  lua_assert(g->ephemeron == NULL && g->weak == NULL);\n  lua_assert(!iswhite(g->mainthread));\n  g->gcstate = GCSatomic;\n  markobject(g, L);  /* mark running thread */\n  /* registry and global metatables may be changed by API */\n  markvalue(g, &g->l_registry);\n  markmt(g);  /* mark global metatables */\n  work += propagateall(g);  /* empties 'gray' list */\n  /* remark occasional upvalues of (maybe) dead threads */\n  work += remarkupvals(g);\n  work += propagateall(g);  /* propagate changes */\n  g->gray = grayagain;\n  work += propagateall(g);  /* traverse 'grayagain' list */\n  work += convergeephemerons(g);\n  /* at this point, all strongly accessible objects are marked. */\n  /* Clear values from weak tables, before checking finalizers */\n  work += clearbyvalues(g, g->weak, NULL);\n  work += clearbyvalues(g, g->allweak, NULL);\n  origweak = g->weak; origall = g->allweak;\n  separatetobefnz(g, 0);  /* separate objects to be finalized */\n  work += markbeingfnz(g);  /* mark objects that will be finalized */\n  work += propagateall(g);  /* remark, to propagate 'resurrection' */\n  work += convergeephemerons(g);\n  /* at this point, all resurrected objects are marked. */\n  /* remove dead objects from weak tables */\n  work += clearbykeys(g, g->ephemeron);  /* clear keys from all ephemeron */\n  work += clearbykeys(g, g->allweak);  /* clear keys from all 'allweak' */\n  /* clear values from resurrected weak tables */\n  work += clearbyvalues(g, g->weak, origweak);\n  work += clearbyvalues(g, g->allweak, origall);\n  luaS_clearcache(g);\n  g->currentwhite = cast_byte(otherwhite(g));  /* flip current white */\n  lua_assert(g->gray == NULL);\n  return work;\n}\n\n\n/*\n** Do a sweep step. The normal case (not fast) sweeps at most GCSWEEPMAX\n** elements. The fast case sweeps the whole list.\n*/\nstatic void sweepstep (lua_State *L, global_State *g,\n                       int nextstate, GCObject **nextlist, int fast) {\n  if (g->sweepgc)\n    g->sweepgc = sweeplist(L, g->sweepgc, fast ? MAX_LOBJ : GCSWEEPMAX);\n  else {  /* enter next state */\n    g->gcstate = nextstate;\n    g->sweepgc = nextlist;\n  }\n}\n\n\n/*\n** Performs one incremental \"step\" in an incremental garbage collection.\n** For indivisible work, a step goes to the next state. When marking\n** (propagating), a step traverses one object. When sweeping, a step\n** sweeps GCSWEEPMAX objects, to avoid a big overhead for sweeping\n** objects one by one. (Sweeping is inexpensive, no matter the\n** object.) When 'fast' is true, 'singlestep' tries to finish a state\n** \"as fast as possible\". In particular, it skips the propagation\n** phase and leaves all objects to be traversed by the atomic phase:\n** That avoids traversing twice some objects, such as theads and\n** weak tables.\n*/\nstatic l_obj singlestep (lua_State *L, int fast) {\n  global_State *g = G(L);\n  l_obj work;\n  lua_assert(!g->gcstopem);  /* collector is not reentrant */\n  g->gcstopem = 1;  /* no emergency collections while collecting */\n  switch (g->gcstate) {\n    case GCSpause: {\n      restartcollection(g);\n      g->gcstate = GCSpropagate;\n      work = 1;\n      break;\n    }\n    case GCSpropagate: {\n      if (fast || g->gray == NULL) {\n        g->gcstate = GCSenteratomic;  /* finish propagate phase */\n        work = 0;\n      }\n      else {\n        propagatemark(g);  /* traverse one gray object */\n        work = 1;\n      }\n      break;\n    }\n    case GCSenteratomic: {\n      work = atomic(L);\n      if (checkmajorminor(L, g))\n        entersweep(L);\n      break;\n    }\n    case GCSswpallgc: {  /* sweep \"regular\" objects */\n      sweepstep(L, g, GCSswpfinobj, &g->finobj, fast);\n      work = GCSWEEPMAX;\n      break;\n    }\n    case GCSswpfinobj: {  /* sweep objects with finalizers */\n      sweepstep(L, g, GCSswptobefnz, &g->tobefnz, fast);\n      work = GCSWEEPMAX;\n      break;\n    }\n    case GCSswptobefnz: {  /* sweep objects to be finalized */\n      sweepstep(L, g, GCSswpend, NULL, fast);\n      work = GCSWEEPMAX;\n      break;\n    }\n    case GCSswpend: {  /* finish sweeps */\n      checkSizes(L, g);\n      g->gcstate = GCScallfin;\n      work = 0;\n      break;\n    }\n    case GCScallfin: {  /* call finalizers */\n      if (g->tobefnz && !g->gcemergency) {\n        g->gcstopem = 0;  /* ok collections during finalizers */\n        GCTM(L);  /* call one finalizer */\n        work = 1;\n      }\n      else {  /* emergency mode or no more finalizers */\n        g->gcstate = GCSpause;  /* finish collection */\n        work = 0;\n      }\n      break;\n    }\n    default: lua_assert(0); return 0;\n  }\n  g->gcstopem = 0;\n  return work;\n}\n\n\n/*\n** Advances the garbage collector until it reaches the given state.\n** (The option 'fast' is only for testing; in normal code, 'fast'\n** here is always true.)\n*/\nvoid luaC_runtilstate (lua_State *L, int state, int fast) {\n  global_State *g = G(L);\n  lua_assert(g->gckind == KGC_INC);\n  while (state != g->gcstate)\n    singlestep(L, fast);\n}\n\n\n\n/*\n** Performs a basic incremental step. The debt and step size are\n** converted from bytes to \"units of work\"; then the function loops\n** running single steps until adding that many units of work or\n** finishing a cycle (pause state). Finally, it sets the debt that\n** controls when next step will be performed.\n*/\nstatic void incstep (lua_State *L, global_State *g) {\n  l_obj stepsize = applygcparam(g, STEPSIZE, 100);\n  l_obj work2do = applygcparam(g, STEPMUL, stepsize);\n  int fast = 0;\n  if (work2do == 0) {  /* special case: do a full collection */\n    work2do = MAX_LOBJ;  /* do unlimited work */\n    fast = 1;\n  }\n  do {  /* repeat until pause or enough work */\n    l_obj work = singlestep(L, fast);  /* perform one single step */\n    if (g->gckind == KGC_GENMINOR)  /* returned to minor collections? */\n      return;  /* nothing else to be done here */\n    work2do -= work;\n  } while (work2do > 0 && g->gcstate != GCSpause);\n  if (g->gcstate == GCSpause)\n    setpause(g);  /* pause until next cycle */\n  else\n    luaE_setdebt(g, stepsize);\n}\n\n/*\n** Performs a basic GC step if collector is running. (If collector is\n** not running, set a reasonable debt to avoid it being called at\n** every single check.)\n*/\nvoid luaC_step (lua_State *L) {\n  global_State *g = G(L);\n  lua_assert(!g->gcemergency);\n  if (!gcrunning(g))  /* not running? */\n    luaE_setdebt(g, 2000);\n  else {\n    switch (g->gckind) {\n      case KGC_INC: case KGC_GENMAJOR:\n        incstep(L, g);\n        break;\n      case KGC_GENMINOR:\n        youngcollection(L, g);\n        setminordebt(g);\n        break;\n    }\n  }\n}\n\n\n/*\n** Perform a full collection in incremental mode.\n** Before running the collection, check 'keepinvariant'; if it is true,\n** there may be some objects marked as black, so the collector has\n** to sweep all objects to turn them back to white (as white has not\n** changed, nothing will be collected).\n*/\nstatic void fullinc (lua_State *L, global_State *g) {\n  if (keepinvariant(g))  /* black objects? */\n    entersweep(L); /* sweep everything to turn them back to white */\n  /* finish any pending sweep phase to start a new cycle */\n  luaC_runtilstate(L, GCSpause, 1);\n  luaC_runtilstate(L, GCScallfin, 1);  /* run up to finalizers */\n  /* 'marked' must be correct after a full GC cycle */\n  lua_assert(g->marked == gettotalobjs(g));\n  luaC_runtilstate(L, GCSpause, 1);  /* finish collection */\n  setpause(g);\n}\n\n\n/*\n** Performs a full GC cycle; if 'isemergency', set a flag to avoid\n** some operations which could change the interpreter state in some\n** unexpected ways (running finalizers and shrinking some structures).\n*/\nvoid luaC_fullgc (lua_State *L, int isemergency) {\n  global_State *g = G(L);\n  lua_assert(!g->gcemergency);\n  g->gcemergency = isemergency;  /* set flag */\n  switch (g->gckind) {\n    case KGC_GENMINOR: fullgen(L, g); break;\n    case KGC_INC: fullinc(L, g); break;\n    case KGC_GENMAJOR:\n      g->gckind = KGC_INC;\n      fullinc(L, g);\n      g->gckind = KGC_GENMAJOR;\n      break;\n  }\n  g->gcemergency = 0;\n}\n\n/* }====================================================== */\n\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lgc.h",
		"is_binary":	false,
		"content":	"/*\n** $Id: lgc.h $\n** Garbage Collector\n** See Copyright Notice in lua.h\n*/\n\n#ifndef lgc_h\n#define lgc_h\n\n\n#include <stddef.h>\n\n\n#include \"lobject.h\"\n#include \"lstate.h\"\n\n/*\n** Collectable objects may have one of three colors: white, which means\n** the object is not marked; gray, which means the object is marked, but\n** its references may be not marked; and black, which means that the\n** object and all its references are marked.  The main invariant of the\n** garbage collector, while marking objects, is that a black object can\n** never point to a white one. Moreover, any gray object must be in a\n** \"gray list\" (gray, grayagain, weak, allweak, ephemeron) so that it\n** can be visited again before finishing the collection cycle. (Open\n** upvalues are an exception to this rule.)  These lists have no meaning\n** when the invariant is not being enforced (e.g., sweep phase).\n*/\n\n\n/*\n** Possible states of the Garbage Collector\n*/\n#define GCSpropagate\t0\n#define GCSenteratomic\t1\n#define GCSatomic\t2\n#define GCSswpallgc\t3\n#define GCSswpfinobj\t4\n#define GCSswptobefnz\t5\n#define GCSswpend\t6\n#define GCScallfin\t7\n#define GCSpause\t8\n\n\n#define issweepphase(g)  \\\n\t(GCSswpallgc <= (g)->gcstate && (g)->gcstate <= GCSswpend)\n\n\n/*\n** macro to tell when main invariant (white objects cannot point to black\n** ones) must be kept. During a collection, the sweep\n** phase may break the invariant, as objects turned white may point to\n** still-black objects. The invariant is restored when sweep ends and\n** all objects are white again.\n*/\n\n#define keepinvariant(g)\t((g)->gcstate <= GCSatomic)\n\n\n/*\n** some useful bit tricks\n*/\n#define resetbits(x,m)\t\t((x) &= cast_byte(~(m)))\n#define setbits(x,m)\t\t((x) |= (m))\n#define testbits(x,m)\t\t((x) & (m))\n#define bitmask(b)\t\t(1<<(b))\n#define bit2mask(b1,b2)\t\t(bitmask(b1) | bitmask(b2))\n#define l_setbit(x,b)\t\tsetbits(x, bitmask(b))\n#define resetbit(x,b)\t\tresetbits(x, bitmask(b))\n#define testbit(x,b)\t\ttestbits(x, bitmask(b))\n\n\n/*\n** Layout for bit use in 'marked' field. First three bits are\n** used for object \"age\" in generational mode. Last bit is used\n** by tests.\n*/\n#define WHITE0BIT\t3  /* object is white (type 0) */\n#define WHITE1BIT\t4  /* object is white (type 1) */\n#define BLACKBIT\t5  /* object is black */\n#define FINALIZEDBIT\t6  /* object has been marked for finalization */\n\n#define TESTBIT\t\t7\n\n\n\n#define WHITEBITS\tbit2mask(WHITE0BIT, WHITE1BIT)\n\n\n#define iswhite(x)      testbits((x)->marked, WHITEBITS)\n#define isblack(x)      testbit((x)->marked, BLACKBIT)\n#define isgray(x)  /* neither white nor black */  \\\n\t(!testbits((x)->marked, WHITEBITS | bitmask(BLACKBIT)))\n\n#define tofinalize(x)\ttestbit((x)->marked, FINALIZEDBIT)\n\n#define otherwhite(g)\t((g)->currentwhite ^ WHITEBITS)\n#define isdeadm(ow,m)\t((m) & (ow))\n#define isdead(g,v)\tisdeadm(otherwhite(g), (v)->marked)\n\n#define changewhite(x)\t((x)->marked ^= WHITEBITS)\n#define nw2black(x)  \\\n\tcheck_exp(!iswhite(x), l_setbit((x)->marked, BLACKBIT))\n\n#define luaC_white(g)\tcast_byte((g)->currentwhite & WHITEBITS)\n\n\n/* object age in generational mode */\n#define G_NEW\t\t0\t/* created in current cycle */\n#define G_SURVIVAL\t1\t/* created in previous cycle */\n#define G_OLD0\t\t2\t/* marked old by frw. barrier in this cycle */\n#define G_OLD1\t\t3\t/* first full cycle as old */\n#define G_OLD\t\t4\t/* really old object (not to be visited) */\n#define G_TOUCHED1\t5\t/* old object touched this cycle */\n#define G_TOUCHED2\t6\t/* old object touched in previous cycle */\n\n#define AGEBITS\t\t7  /* all age bits (111) */\n\n#define getage(o)\t((o)->marked & AGEBITS)\n#define setage(o,a)  ((o)->marked = cast_byte(((o)->marked & (~AGEBITS)) | a))\n#define isold(o)\t(getage(o) > G_SURVIVAL)\n\n\n/*\n** In generational mode, objects are created 'new'. After surviving one\n** cycle, they become 'survival'. Both 'new' and 'survival' can point\n** to any other object, as they are traversed at the end of the cycle.\n** We call them both 'young' objects.\n** If a survival object survives another cycle, it becomes 'old1'.\n** 'old1' objects can still point to survival objects (but not to\n** new objects), so they still must be traversed. After another cycle\n** (that, being old, 'old1' objects will \"survive\" no matter what)\n** finally the 'old1' object becomes really 'old', and then they\n** are no more traversed.\n**\n** To keep its invariants, the generational mode uses the same barriers\n** also used by the incremental mode. If a young object is caught in a\n** foward barrier, it cannot become old immediately, because it can\n** still point to other young objects. Instead, it becomes 'old0',\n** which in the next cycle becomes 'old1'. So, 'old0' objects is\n** old but can point to new and survival objects; 'old1' is old\n** but cannot point to new objects; and 'old' cannot point to any\n** young object.\n**\n** If any old object ('old0', 'old1', 'old') is caught in a back\n** barrier, it becomes 'touched1' and goes into a gray list, to be\n** visited at the end of the cycle.  There it evolves to 'touched2',\n** which can point to survivals but not to new objects. In yet another\n** cycle then it becomes 'old' again.\n**\n** The generational mode must also control the colors of objects,\n** because of the barriers.  While the mutator is running, young objects\n** are kept white. 'old', 'old1', and 'touched2' objects are kept black,\n** as they cannot point to new objects; exceptions are threads and open\n** upvalues, which age to 'old1' and 'old' but are kept gray. 'old0'\n** objects may be gray or black, as in the incremental mode. 'touched1'\n** objects are kept gray, as they must be visited again at the end of\n** the cycle.\n*/\n\n\n/* Default Values for GC parameters */\n\n/*\n** Minor collections will shift to major ones after LUAI_MINORMAJOR%\n** objects become old.\n*/\n#define LUAI_MINORMAJOR         100\n\n/*\n** Major collections will shift to minor ones after a collection\n** collects at least LUAI_MAJORMINOR% of the new objects.\n*/\n#define LUAI_MAJORMINOR         50\n\n/*\n** A young (minor) collection will run after creating LUAI_GENMINORMUL%\n** new objects.\n*/\n#define LUAI_GENMINORMUL         25\n\n\n/* incremental */\n\n/* Number of objects must be LUAI_GCPAUSE% before starting new cycle */\n#define LUAI_GCPAUSE    200\n\n/* Step multiplier. (Roughly, the collector handles LUAI_GCMUL% objects\n   for each new allocated object.) */\n#define LUAI_GCMUL      200\n\n/* How many objects to allocate before next GC step */\n#define LUAI_GCSTEPSIZE\t250\n\n\n#define setgcparam(g,p,v)  (g->gcparams[LUA_GCP##p] = luaO_codeparam(v))\n#define applygcparam(g,p,x)  luaO_applyparam(g->gcparams[LUA_GCP##p], x)\n\n/*\n** Control when GC is running:\n*/\n#define GCSTPUSR\t1  /* bit true when GC stopped by user */\n#define GCSTPGC\t\t2  /* bit true when GC stopped by itself */\n#define GCSTPCLS\t4  /* bit true when closing Lua state */\n#define gcrunning(g)\t((g)->gcstp == 0)\n\n\n/*\n** Does one step of collection when debt becomes zero. 'pre'/'pos'\n** allows some adjustments to be done only when needed. macro\n** 'condchangemem' is used only for heavy tests (forcing a full\n** GC cycle on every opportunity)\n*/\n#define luaC_condGC(L,pre,pos) \\\n\t{ if (G(L)->GCdebt <= 0) { pre; luaC_step(L); pos;}; \\\n\t  condchangemem(L,pre,pos); }\n\n/* more often than not, 'pre'/'pos' are empty */\n#define luaC_checkGC(L)\t\tluaC_condGC(L,(void)0,(void)0)\n\n\n#define luaC_objbarrier(L,p,o) (  \\\n\t(isblack(p) && iswhite(o)) ? \\\n\tluaC_barrier_(L,obj2gco(p),obj2gco(o)) : cast_void(0))\n\n#define luaC_barrier(L,p,v) (  \\\n\tiscollectable(v) ? luaC_objbarrier(L,p,gcvalue(v)) : cast_void(0))\n\n#define luaC_objbarrierback(L,p,o) (  \\\n\t(isblack(p) && iswhite(o)) ? luaC_barrierback_(L,p) : cast_void(0))\n\n#define luaC_barrierback(L,p,v) (  \\\n\tiscollectable(v) ? luaC_objbarrierback(L, p, gcvalue(v)) : cast_void(0))\n\nLUAI_FUNC void luaC_fix (lua_State *L, GCObject *o);\nLUAI_FUNC void luaC_freeallobjects (lua_State *L);\nLUAI_FUNC void luaC_step (lua_State *L);\nLUAI_FUNC void luaC_runtilstate (lua_State *L, int state, int fast);\nLUAI_FUNC void luaC_fullgc (lua_State *L, int isemergency);\nLUAI_FUNC GCObject *luaC_newobj (lua_State *L, int tt, size_t sz);\nLUAI_FUNC GCObject *luaC_newobjdt (lua_State *L, int tt, size_t sz,\n                                                 size_t offset);\nLUAI_FUNC void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v);\nLUAI_FUNC void luaC_barrierback_ (lua_State *L, GCObject *o);\nLUAI_FUNC void luaC_checkfinalizer (lua_State *L, GCObject *o, Table *mt);\nLUAI_FUNC void luaC_changemode (lua_State *L, int newmode);\n\n\n#endif\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/linit.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: linit.c $\n** Initialization of libraries for lua.c and other clients\n** See Copyright Notice in lua.h\n*/\n\n\n#define linit_c\n#define LUA_LIB\n\n\n#include \"lprefix.h\"\n\n\n#include <stddef.h>\n\n#include \"lua.h\"\n\n#include \"lualib.h\"\n#include \"lauxlib.h\"\n\n\n/*\n** Standard Libraries. (Must be listed in the same ORDER of their\n** respective constants LUA_<libname>K.)\n*/\nstatic const luaL_Reg stdlibs[] = {\n  {LUA_GNAME, luaopen_base},\n  {LUA_LOADLIBNAME, luaopen_package},\n  {LUA_COLIBNAME, luaopen_coroutine},\n  {LUA_DBLIBNAME, luaopen_debug},\n  {LUA_IOLIBNAME, luaopen_io},\n  {LUA_MATHLIBNAME, luaopen_math},\n  {LUA_OSLIBNAME, luaopen_os},\n  {LUA_STRLIBNAME, luaopen_string},\n  {LUA_TABLIBNAME, luaopen_table},\n  {LUA_UTF8LIBNAME, luaopen_utf8},\n  {NULL, NULL}\n};\n\n\n/*\n** require and preload selected standard libraries\n*/\nLUALIB_API void luaL_openselectedlibs (lua_State *L, int load, int preload) {\n  int mask;\n  const luaL_Reg *lib;\n  luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_PRELOAD_TABLE);\n  for (lib = stdlibs, mask = 1; lib->name != NULL; lib++, mask <<= 1) {\n    if (load & mask) {  /* selected? */\n      luaL_requiref(L, lib->name, lib->func, 1);  /* require library */\n      lua_pop(L, 1);  /* remove result from the stack */\n    }\n    else if (preload & mask) {  /* selected? */\n      lua_pushcfunction(L, lib->func);\n      lua_setfield(L, -2, lib->name);  /* add library to PRELOAD table */\n    }\n  }\n  lua_assert((mask >> 1) == LUA_UTF8LIBK);\n  lua_pop(L, 1);  /* remove PRELOAD table */\n}\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/liolib.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: liolib.c $\n** Standard I/O (and system) library\n** See Copyright Notice in lua.h\n*/\n\n#define liolib_c\n#define LUA_LIB\n\n#include \"lprefix.h\"\n\n\n#include <ctype.h>\n#include <errno.h>\n#include <locale.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n\n\n\n\n/*\n** Change this macro to accept other modes for 'fopen' besides\n** the standard ones.\n*/\n#if !defined(l_checkmode)\n\n/* accepted extensions to 'mode' in 'fopen' */\n#if !defined(L_MODEEXT)\n#define L_MODEEXT\t\"b\"\n#endif\n\n/* Check whether 'mode' matches '[rwa]%+?[L_MODEEXT]*' */\nstatic int l_checkmode (const char *mode) {\n  return (*mode != '\\0' && strchr(\"rwa\", *(mode++)) != NULL &&\n         (*mode != '+' || ((void)(++mode), 1)) &&  /* skip if char is '+' */\n         (strspn(mode, L_MODEEXT) == strlen(mode)));  /* check extensions */\n}\n\n#endif\n\n/*\n** {======================================================\n** l_popen spawns a new process connected to the current\n** one through the file streams.\n** =======================================================\n*/\n\n#if !defined(l_popen)\t\t/* { */\n\n#if defined(LUA_USE_POSIX)\t/* { */\n\n#define l_popen(L,c,m)\t\t(fflush(NULL), popen(c,m))\n#define l_pclose(L,file)\t(pclose(file))\n\n#elif defined(LUA_USE_WINDOWS)\t/* }{ */\n\n#define l_popen(L,c,m)\t\t(_popen(c,m))\n#define l_pclose(L,file)\t(_pclose(file))\n\n#if !defined(l_checkmodep)\n/* Windows accepts \"[rw][bt]?\" as valid modes */\n#define l_checkmodep(m)\t((m[0] == 'r' || m[0] == 'w') && \\\n  (m[1] == '\\0' || ((m[1] == 'b' || m[1] == 't') && m[2] == '\\0')))\n#endif\n\n#else\t\t\t\t/* }{ */\n\n/* ISO C definitions */\n#define l_popen(L,c,m)  \\\n\t  ((void)c, (void)m, \\\n\t  luaL_error(L, \"'popen' not supported\"), \\\n\t  (FILE*)0)\n#define l_pclose(L,file)\t\t((void)L, (void)file, -1)\n\n#endif\t\t\t\t/* } */\n\n#endif\t\t\t\t/* } */\n\n\n#if !defined(l_checkmodep)\n/* By default, Lua accepts only \"r\" or \"w\" as valid modes */\n#define l_checkmodep(m)        ((m[0] == 'r' || m[0] == 'w') && m[1] == '\\0')\n#endif\n\n/* }====================================================== */\n\n\n#if !defined(l_getc)\t\t/* { */\n\n#if defined(LUA_USE_POSIX)\n#define l_getc(f)\t\tgetc_unlocked(f)\n#define l_lockfile(f)\t\tflockfile(f)\n#define l_unlockfile(f)\t\tfunlockfile(f)\n#else\n#define l_getc(f)\t\tgetc(f)\n#define l_lockfile(f)\t\t((void)0)\n#define l_unlockfile(f)\t\t((void)0)\n#endif\n\n#endif\t\t\t\t/* } */\n\n\n/*\n** {======================================================\n** l_fseek: configuration for longer offsets\n** =======================================================\n*/\n\n#if !defined(l_fseek)\t\t/* { */\n\n#if defined(LUA_USE_POSIX)\t/* { */\n\n#include <sys/types.h>\n\n#define l_fseek(f,o,w)\t\tfseeko(f,o,w)\n#define l_ftell(f)\t\tftello(f)\n#define l_seeknum\t\toff_t\n\n#elif defined(LUA_USE_WINDOWS) && !defined(_CRTIMP_TYPEINFO) \\\n   && defined(_MSC_VER) && (_MSC_VER >= 1400)\t/* }{ */\n\n/* Windows (but not DDK) and Visual C++ 2005 or higher */\n#define l_fseek(f,o,w)\t\t_fseeki64(f,o,w)\n#define l_ftell(f)\t\t_ftelli64(f)\n#define l_seeknum\t\t__int64\n\n#else\t\t\t\t/* }{ */\n\n/* ISO C definitions */\n#define l_fseek(f,o,w)\t\tfseek(f,o,w)\n#define l_ftell(f)\t\tftell(f)\n#define l_seeknum\t\tlong\n\n#endif\t\t\t\t/* } */\n\n#endif\t\t\t\t/* } */\n\n/* }====================================================== */\n\n\n\n#define IO_PREFIX\t\"_IO_\"\n#define IOPREF_LEN\t(sizeof(IO_PREFIX)/sizeof(char) - 1)\n#define IO_INPUT\t(IO_PREFIX \"input\")\n#define IO_OUTPUT\t(IO_PREFIX \"output\")\n\n\ntypedef luaL_Stream LStream;\n\n\n#define tolstream(L)\t((LStream *)luaL_checkudata(L, 1, LUA_FILEHANDLE))\n\n#define isclosed(p)\t((p)->closef == NULL)\n\n\nstatic int io_type (lua_State *L) {\n  LStream *p;\n  luaL_checkany(L, 1);\n  p = (LStream *)luaL_testudata(L, 1, LUA_FILEHANDLE);\n  if (p == NULL)\n    luaL_pushfail(L);  /* not a file */\n  else if (isclosed(p))\n    lua_pushliteral(L, \"closed file\");\n  else\n    lua_pushliteral(L, \"file\");\n  return 1;\n}\n\n\nstatic int f_tostring (lua_State *L) {\n  LStream *p = tolstream(L);\n  if (isclosed(p))\n    lua_pushliteral(L, \"file (closed)\");\n  else\n    lua_pushfstring(L, \"file (%p)\", p->f);\n  return 1;\n}\n\n\nstatic FILE *tofile (lua_State *L) {\n  LStream *p = tolstream(L);\n  if (l_unlikely(isclosed(p)))\n    luaL_error(L, \"attempt to use a closed file\");\n  lua_assert(p->f);\n  return p->f;\n}\n\n\n/*\n** When creating file handles, always creates a 'closed' file handle\n** before opening the actual file; so, if there is a memory error, the\n** handle is in a consistent state.\n*/\nstatic LStream *newprefile (lua_State *L) {\n  LStream *p = (LStream *)lua_newuserdatauv(L, sizeof(LStream), 0);\n  p->closef = NULL;  /* mark file handle as 'closed' */\n  luaL_setmetatable(L, LUA_FILEHANDLE);\n  return p;\n}\n\n\n/*\n** Calls the 'close' function from a file handle. The 'volatile' avoids\n** a bug in some versions of the Clang compiler (e.g., clang 3.0 for\n** 32 bits).\n*/\nstatic int aux_close (lua_State *L) {\n  LStream *p = tolstream(L);\n  volatile lua_CFunction cf = p->closef;\n  p->closef = NULL;  /* mark stream as closed */\n  return (*cf)(L);  /* close it */\n}\n\n\nstatic int f_close (lua_State *L) {\n  tofile(L);  /* make sure argument is an open stream */\n  return aux_close(L);\n}\n\n\nstatic int io_close (lua_State *L) {\n  if (lua_isnone(L, 1))  /* no argument? */\n    lua_getfield(L, LUA_REGISTRYINDEX, IO_OUTPUT);  /* use default output */\n  return f_close(L);\n}\n\n\nstatic int f_gc (lua_State *L) {\n  LStream *p = tolstream(L);\n  if (!isclosed(p) && p->f != NULL)\n    aux_close(L);  /* ignore closed and incompletely open files */\n  return 0;\n}\n\n\n/*\n** function to close regular files\n*/\nstatic int io_fclose (lua_State *L) {\n  LStream *p = tolstream(L);\n  int res = fclose(p->f);\n  return luaL_fileresult(L, (res == 0), NULL);\n}\n\n\nstatic LStream *newfile (lua_State *L) {\n  LStream *p = newprefile(L);\n  p->f = NULL;\n  p->closef = &io_fclose;\n  return p;\n}\n\n\nstatic void opencheck (lua_State *L, const char *fname, const char *mode) {\n  LStream *p = newfile(L);\n  p->f = fopen(fname, mode);\n  if (l_unlikely(p->f == NULL))\n    luaL_error(L, \"cannot open file '%s' (%s)\", fname, strerror(errno));\n}\n\n\nstatic int io_open (lua_State *L) {\n  const char *filename = luaL_checkstring(L, 1);\n  const char *mode = luaL_optstring(L, 2, \"r\");\n  LStream *p = newfile(L);\n  const char *md = mode;  /* to traverse/check mode */\n  luaL_argcheck(L, l_checkmode(md), 2, \"invalid mode\");\n  p->f = fopen(filename, mode);\n  return (p->f == NULL) ? luaL_fileresult(L, 0, filename) : 1;\n}\n\n\n/*\n** function to close 'popen' files\n*/\nstatic int io_pclose (lua_State *L) {\n  LStream *p = tolstream(L);\n  errno = 0;\n  return luaL_execresult(L, l_pclose(L, p->f));\n}\n\n\nstatic int io_popen (lua_State *L) {\n  const char *filename = luaL_checkstring(L, 1);\n  const char *mode = luaL_optstring(L, 2, \"r\");\n  LStream *p = newprefile(L);\n  luaL_argcheck(L, l_checkmodep(mode), 2, \"invalid mode\");\n  p->f = l_popen(L, filename, mode);\n  p->closef = &io_pclose;\n  return (p->f == NULL) ? luaL_fileresult(L, 0, filename) : 1;\n}\n\n\nstatic int io_tmpfile (lua_State *L) {\n  LStream *p = newfile(L);\n  p->f = tmpfile();\n  return (p->f == NULL) ? luaL_fileresult(L, 0, NULL) : 1;\n}\n\n\nstatic FILE *getiofile (lua_State *L, const char *findex) {\n  LStream *p;\n  lua_getfield(L, LUA_REGISTRYINDEX, findex);\n  p = (LStream *)lua_touserdata(L, -1);\n  if (l_unlikely(isclosed(p)))\n    luaL_error(L, \"default %s file is closed\", findex + IOPREF_LEN);\n  return p->f;\n}\n\n\nstatic int g_iofile (lua_State *L, const char *f, const char *mode) {\n  if (!lua_isnoneornil(L, 1)) {\n    const char *filename = lua_tostring(L, 1);\n    if (filename)\n      opencheck(L, filename, mode);\n    else {\n      tofile(L);  /* check that it's a valid file handle */\n      lua_pushvalue(L, 1);\n    }\n    lua_setfield(L, LUA_REGISTRYINDEX, f);\n  }\n  /* return current value */\n  lua_getfield(L, LUA_REGISTRYINDEX, f);\n  return 1;\n}\n\n\nstatic int io_input (lua_State *L) {\n  return g_iofile(L, IO_INPUT, \"r\");\n}\n\n\nstatic int io_output (lua_State *L) {\n  return g_iofile(L, IO_OUTPUT, \"w\");\n}\n\n\nstatic int io_readline (lua_State *L);\n\n\n/*\n** maximum number of arguments to 'f:lines'/'io.lines' (it + 3 must fit\n** in the limit for upvalues of a closure)\n*/\n#define MAXARGLINE\t250\n\n/*\n** Auxiliary function to create the iteration function for 'lines'.\n** The iteration function is a closure over 'io_readline', with\n** the following upvalues:\n** 1) The file being read (first value in the stack)\n** 2) the number of arguments to read\n** 3) a boolean, true iff file has to be closed when finished ('toclose')\n** *) a variable number of format arguments (rest of the stack)\n*/\nstatic void aux_lines (lua_State *L, int toclose) {\n  int n = lua_gettop(L) - 1;  /* number of arguments to read */\n  luaL_argcheck(L, n <= MAXARGLINE, MAXARGLINE + 2, \"too many arguments\");\n  lua_pushvalue(L, 1);  /* file */\n  lua_pushinteger(L, n);  /* number of arguments to read */\n  lua_pushboolean(L, toclose);  /* close/not close file when finished */\n  lua_rotate(L, 2, 3);  /* move the three values to their positions */\n  lua_pushcclosure(L, io_readline, 3 + n);\n}\n\n\nstatic int f_lines (lua_State *L) {\n  tofile(L);  /* check that it's a valid file handle */\n  aux_lines(L, 0);\n  return 1;\n}\n\n\n/*\n** Return an iteration function for 'io.lines'. If file has to be\n** closed, also returns the file itself as a second result (to be\n** closed as the state at the exit of a generic for).\n*/\nstatic int io_lines (lua_State *L) {\n  int toclose;\n  if (lua_isnone(L, 1)) lua_pushnil(L);  /* at least one argument */\n  if (lua_isnil(L, 1)) {  /* no file name? */\n    lua_getfield(L, LUA_REGISTRYINDEX, IO_INPUT);  /* get default input */\n    lua_replace(L, 1);  /* put it at index 1 */\n    tofile(L);  /* check that it's a valid file handle */\n    toclose = 0;  /* do not close it after iteration */\n  }\n  else {  /* open a new file */\n    const char *filename = luaL_checkstring(L, 1);\n    opencheck(L, filename, \"r\");\n    lua_replace(L, 1);  /* put file at index 1 */\n    toclose = 1;  /* close it after iteration */\n  }\n  aux_lines(L, toclose);  /* push iteration function */\n  if (toclose) {\n    lua_pushnil(L);  /* state */\n    lua_pushnil(L);  /* control */\n    lua_pushvalue(L, 1);  /* file is the to-be-closed variable (4th result) */\n    return 4;\n  }\n  else\n    return 1;\n}\n\n\n/*\n** {======================================================\n** READ\n** =======================================================\n*/\n\n\n/* maximum length of a numeral */\n#if !defined (L_MAXLENNUM)\n#define L_MAXLENNUM     200\n#endif\n\n\n/* auxiliary structure used by 'read_number' */\ntypedef struct {\n  FILE *f;  /* file being read */\n  int c;  /* current character (look ahead) */\n  int n;  /* number of elements in buffer 'buff' */\n  char buff[L_MAXLENNUM + 1];  /* +1 for ending '\\0' */\n} RN;\n\n\n/*\n** Add current char to buffer (if not out of space) and read next one\n*/\nstatic int nextc (RN *rn) {\n  if (l_unlikely(rn->n >= L_MAXLENNUM)) {  /* buffer overflow? */\n    rn->buff[0] = '\\0';  /* invalidate result */\n    return 0;  /* fail */\n  }\n  else {\n    rn->buff[rn->n++] = rn->c;  /* save current char */\n    rn->c = l_getc(rn->f);  /* read next one */\n    return 1;\n  }\n}\n\n\n/*\n** Accept current char if it is in 'set' (of size 2)\n*/\nstatic int test2 (RN *rn, const char *set) {\n  if (rn->c == set[0] || rn->c == set[1])\n    return nextc(rn);\n  else return 0;\n}\n\n\n/*\n** Read a sequence of (hex)digits\n*/\nstatic int readdigits (RN *rn, int hex) {\n  int count = 0;\n  while ((hex ? isxdigit(rn->c) : isdigit(rn->c)) && nextc(rn))\n    count++;\n  return count;\n}\n\n\n/*\n** Read a number: first reads a valid prefix of a numeral into a buffer.\n** Then it calls 'lua_stringtonumber' to check whether the format is\n** correct and to convert it to a Lua number.\n*/\nstatic int read_number (lua_State *L, FILE *f) {\n  RN rn;\n  int count = 0;\n  int hex = 0;\n  char decp[2];\n  rn.f = f; rn.n = 0;\n  decp[0] = lua_getlocaledecpoint();  /* get decimal point from locale */\n  decp[1] = '.';  /* always accept a dot */\n  l_lockfile(rn.f);\n  do { rn.c = l_getc(rn.f); } while (isspace(rn.c));  /* skip spaces */\n  test2(&rn, \"-+\");  /* optional sign */\n  if (test2(&rn, \"00\")) {\n    if (test2(&rn, \"xX\")) hex = 1;  /* numeral is hexadecimal */\n    else count = 1;  /* count initial '0' as a valid digit */\n  }\n  count += readdigits(&rn, hex);  /* integral part */\n  if (test2(&rn, decp))  /* decimal point? */\n    count += readdigits(&rn, hex);  /* fractional part */\n  if (count > 0 && test2(&rn, (hex ? \"pP\" : \"eE\"))) {  /* exponent mark? */\n    test2(&rn, \"-+\");  /* exponent sign */\n    readdigits(&rn, 0);  /* exponent digits */\n  }\n  ungetc(rn.c, rn.f);  /* unread look-ahead char */\n  l_unlockfile(rn.f);\n  rn.buff[rn.n] = '\\0';  /* finish string */\n  if (l_likely(lua_stringtonumber(L, rn.buff)))\n    return 1;  /* ok, it is a valid number */\n  else {  /* invalid format */\n   lua_pushnil(L);  /* \"result\" to be removed */\n   return 0;  /* read fails */\n  }\n}\n\n\nstatic int test_eof (lua_State *L, FILE *f) {\n  int c = getc(f);\n  ungetc(c, f);  /* no-op when c == EOF */\n  lua_pushliteral(L, \"\");\n  return (c != EOF);\n}\n\n\nstatic int read_line (lua_State *L, FILE *f, int chop) {\n  luaL_Buffer b;\n  int c;\n  luaL_buffinit(L, &b);\n  do {  /* may need to read several chunks to get whole line */\n    char *buff = luaL_prepbuffer(&b);  /* preallocate buffer space */\n    int i = 0;\n    l_lockfile(f);  /* no memory errors can happen inside the lock */\n    while (i < LUAL_BUFFERSIZE && (c = l_getc(f)) != EOF && c != '\\n')\n      buff[i++] = c;  /* read up to end of line or buffer limit */\n    l_unlockfile(f);\n    luaL_addsize(&b, i);\n  } while (c != EOF && c != '\\n');  /* repeat until end of line */\n  if (!chop && c == '\\n')  /* want a newline and have one? */\n    luaL_addchar(&b, c);  /* add ending newline to result */\n  luaL_pushresult(&b);  /* close buffer */\n  /* return ok if read something (either a newline or something else) */\n  return (c == '\\n' || lua_rawlen(L, -1) > 0);\n}\n\n\nstatic void read_all (lua_State *L, FILE *f) {\n  size_t nr;\n  luaL_Buffer b;\n  luaL_buffinit(L, &b);\n  do {  /* read file in chunks of LUAL_BUFFERSIZE bytes */\n    char *p = luaL_prepbuffer(&b);\n    nr = fread(p, sizeof(char), LUAL_BUFFERSIZE, f);\n    luaL_addsize(&b, nr);\n  } while (nr == LUAL_BUFFERSIZE);\n  luaL_pushresult(&b);  /* close buffer */\n}\n\n\nstatic int read_chars (lua_State *L, FILE *f, size_t n) {\n  size_t nr;  /* number of chars actually read */\n  char *p;\n  luaL_Buffer b;\n  luaL_buffinit(L, &b);\n  p = luaL_prepbuffsize(&b, n);  /* prepare buffer to read whole block */\n  nr = fread(p, sizeof(char), n, f);  /* try to read 'n' chars */\n  luaL_addsize(&b, nr);\n  luaL_pushresult(&b);  /* close buffer */\n  return (nr > 0);  /* true iff read something */\n}\n\n\nstatic int g_read (lua_State *L, FILE *f, int first) {\n  int nargs = lua_gettop(L) - 1;\n  int n, success;\n  clearerr(f);\n  if (nargs == 0) {  /* no arguments? */\n    success = read_line(L, f, 1);\n    n = first + 1;  /* to return 1 result */\n  }\n  else {\n    /* ensure stack space for all results and for auxlib's buffer */\n    luaL_checkstack(L, nargs+LUA_MINSTACK, \"too many arguments\");\n    success = 1;\n    for (n = first; nargs-- && success; n++) {\n      if (lua_type(L, n) == LUA_TNUMBER) {\n        size_t l = (size_t)luaL_checkinteger(L, n);\n        success = (l == 0) ? test_eof(L, f) : read_chars(L, f, l);\n      }\n      else {\n        const char *p = luaL_checkstring(L, n);\n        if (*p == '*') p++;  /* skip optional '*' (for compatibility) */\n        switch (*p) {\n          case 'n':  /* number */\n            success = read_number(L, f);\n            break;\n          case 'l':  /* line */\n            success = read_line(L, f, 1);\n            break;\n          case 'L':  /* line with end-of-line */\n            success = read_line(L, f, 0);\n            break;\n          case 'a':  /* file */\n            read_all(L, f);  /* read entire file */\n            success = 1; /* always success */\n            break;\n          default:\n            return luaL_argerror(L, n, \"invalid format\");\n        }\n      }\n    }\n  }\n  if (ferror(f))\n    return luaL_fileresult(L, 0, NULL);\n  if (!success) {\n    lua_pop(L, 1);  /* remove last result */\n    luaL_pushfail(L);  /* push nil instead */\n  }\n  return n - first;\n}\n\n\nstatic int io_read (lua_State *L) {\n  return g_read(L, getiofile(L, IO_INPUT), 1);\n}\n\n\nstatic int f_read (lua_State *L) {\n  return g_read(L, tofile(L), 2);\n}\n\n\n/*\n** Iteration function for 'lines'.\n*/\nstatic int io_readline (lua_State *L) {\n  LStream *p = (LStream *)lua_touserdata(L, lua_upvalueindex(1));\n  int i;\n  int n = (int)lua_tointeger(L, lua_upvalueindex(2));\n  if (isclosed(p))  /* file is already closed? */\n    return luaL_error(L, \"file is already closed\");\n  lua_settop(L , 1);\n  luaL_checkstack(L, n, \"too many arguments\");\n  for (i = 1; i <= n; i++)  /* push arguments to 'g_read' */\n    lua_pushvalue(L, lua_upvalueindex(3 + i));\n  n = g_read(L, p->f, 2);  /* 'n' is number of results */\n  lua_assert(n > 0);  /* should return at least a nil */\n  if (lua_toboolean(L, -n))  /* read at least one value? */\n    return n;  /* return them */\n  else {  /* first result is false: EOF or error */\n    if (n > 1) {  /* is there error information? */\n      /* 2nd result is error message */\n      return luaL_error(L, \"%s\", lua_tostring(L, -n + 1));\n    }\n    if (lua_toboolean(L, lua_upvalueindex(3))) {  /* generator created file? */\n      lua_settop(L, 0);  /* clear stack */\n      lua_pushvalue(L, lua_upvalueindex(1));  /* push file at index 1 */\n      aux_close(L);  /* close it */\n    }\n    return 0;\n  }\n}\n\n/* }====================================================== */\n\n\nstatic int g_write (lua_State *L, FILE *f, int arg) {\n  int nargs = lua_gettop(L) - arg;\n  int status = 1;\n  for (; nargs--; arg++) {\n    if (lua_type(L, arg) == LUA_TNUMBER) {\n      /* optimization: could be done exactly as for strings */\n      int len = lua_isinteger(L, arg)\n                ? fprintf(f, LUA_INTEGER_FMT,\n                             (LUAI_UACINT)lua_tointeger(L, arg))\n                : fprintf(f, LUA_NUMBER_FMT,\n                             (LUAI_UACNUMBER)lua_tonumber(L, arg));\n      status = status && (len > 0);\n    }\n    else {\n      size_t l;\n      const char *s = luaL_checklstring(L, arg, &l);\n      status = status && (fwrite(s, sizeof(char), l, f) == l);\n    }\n  }\n  if (l_likely(status))\n    return 1;  /* file handle already on stack top */\n  else return luaL_fileresult(L, status, NULL);\n}\n\n\nstatic int io_write (lua_State *L) {\n  return g_write(L, getiofile(L, IO_OUTPUT), 1);\n}\n\n\nstatic int f_write (lua_State *L) {\n  FILE *f = tofile(L);\n  lua_pushvalue(L, 1);  /* push file at the stack top (to be returned) */\n  return g_write(L, f, 2);\n}\n\n\nstatic int f_seek (lua_State *L) {\n  static const int mode[] = {SEEK_SET, SEEK_CUR, SEEK_END};\n  static const char *const modenames[] = {\"set\", \"cur\", \"end\", NULL};\n  FILE *f = tofile(L);\n  int op = luaL_checkoption(L, 2, \"cur\", modenames);\n  lua_Integer p3 = luaL_optinteger(L, 3, 0);\n  l_seeknum offset = (l_seeknum)p3;\n  luaL_argcheck(L, (lua_Integer)offset == p3, 3,\n                  \"not an integer in proper range\");\n  op = l_fseek(f, offset, mode[op]);\n  if (l_unlikely(op))\n    return luaL_fileresult(L, 0, NULL);  /* error */\n  else {\n    lua_pushinteger(L, (lua_Integer)l_ftell(f));\n    return 1;\n  }\n}\n\n\nstatic int f_setvbuf (lua_State *L) {\n  static const int mode[] = {_IONBF, _IOFBF, _IOLBF};\n  static const char *const modenames[] = {\"no\", \"full\", \"line\", NULL};\n  FILE *f = tofile(L);\n  int op = luaL_checkoption(L, 2, NULL, modenames);\n  lua_Integer sz = luaL_optinteger(L, 3, LUAL_BUFFERSIZE);\n  int res = setvbuf(f, NULL, mode[op], (size_t)sz);\n  return luaL_fileresult(L, res == 0, NULL);\n}\n\n\n\nstatic int io_flush (lua_State *L) {\n  return luaL_fileresult(L, fflush(getiofile(L, IO_OUTPUT)) == 0, NULL);\n}\n\n\nstatic int f_flush (lua_State *L) {\n  return luaL_fileresult(L, fflush(tofile(L)) == 0, NULL);\n}\n\n\n/*\n** functions for 'io' library\n*/\nstatic const luaL_Reg iolib[] = {\n  {\"close\", io_close},\n  {\"flush\", io_flush},\n  {\"input\", io_input},\n  {\"lines\", io_lines},\n  {\"open\", io_open},\n  {\"output\", io_output},\n  {\"popen\", io_popen},\n  {\"read\", io_read},\n  {\"tmpfile\", io_tmpfile},\n  {\"type\", io_type},\n  {\"write\", io_write},\n  {NULL, NULL}\n};\n\n\n/*\n** methods for file handles\n*/\nstatic const luaL_Reg meth[] = {\n  {\"read\", f_read},\n  {\"write\", f_write},\n  {\"lines\", f_lines},\n  {\"flush\", f_flush},\n  {\"seek\", f_seek},\n  {\"close\", f_close},\n  {\"setvbuf\", f_setvbuf},\n  {NULL, NULL}\n};\n\n\n/*\n** metamethods for file handles\n*/\nstatic const luaL_Reg metameth[] = {\n  {\"__index\", NULL},  /* place holder */\n  {\"__gc\", f_gc},\n  {\"__close\", f_gc},\n  {\"__tostring\", f_tostring},\n  {NULL, NULL}\n};\n\n\nstatic void createmeta (lua_State *L) {\n  luaL_newmetatable(L, LUA_FILEHANDLE);  /* metatable for file handles */\n  luaL_setfuncs(L, metameth, 0);  /* add metamethods to new metatable */\n  luaL_newlibtable(L, meth);  /* create method table */\n  luaL_setfuncs(L, meth, 0);  /* add file methods to method table */\n  lua_setfield(L, -2, \"__index\");  /* metatable.__index = method table */\n  lua_pop(L, 1);  /* pop metatable */\n}\n\n\n/*\n** function to (not) close the standard files stdin, stdout, and stderr\n*/\nstatic int io_noclose (lua_State *L) {\n  LStream *p = tolstream(L);\n  p->closef = &io_noclose;  /* keep file opened */\n  luaL_pushfail(L);\n  lua_pushliteral(L, \"cannot close standard file\");\n  return 2;\n}\n\n\nstatic void createstdfile (lua_State *L, FILE *f, const char *k,\n                           const char *fname) {\n  LStream *p = newprefile(L);\n  p->f = f;\n  p->closef = &io_noclose;\n  if (k != NULL) {\n    lua_pushvalue(L, -1);\n    lua_setfield(L, LUA_REGISTRYINDEX, k);  /* add file to registry */\n  }\n  lua_setfield(L, -2, fname);  /* add file to module */\n}\n\n\nLUAMOD_API int luaopen_io (lua_State *L) {\n  luaL_newlib(L, iolib);  /* new module */\n  createmeta(L);\n  /* create (and set) default files */\n  createstdfile(L, stdin, IO_INPUT, \"stdin\");\n  createstdfile(L, stdout, IO_OUTPUT, \"stdout\");\n  createstdfile(L, stderr, NULL, \"stderr\");\n  return 1;\n}\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/ljumptab.h",
		"is_binary":	false,
		"content":	"/*\n** $Id: ljumptab.h $\n** Jump Table for the Lua interpreter\n** See Copyright Notice in lua.h\n*/\n\n\n#undef vmdispatch\n#undef vmcase\n#undef vmbreak\n\n#define vmdispatch(x)     goto *disptab[x];\n\n#define vmcase(l)     L_##l:\n\n#define vmbreak\t\tvmfetch(); vmdispatch(GET_OPCODE(i));\n\n\nstatic const void *const disptab[NUM_OPCODES] = {\n\n#if 0\n** you can update the following list with this command:\n**\n**  sed -n '/^OP_/\\!d; s/OP_/\\&\\&L_OP_/ ; s/,.*/,/ ; s/\\/.*// ; p'  lopcodes.h\n**\n#endif\n\n&&L_OP_MOVE,\n&&L_OP_LOADI,\n&&L_OP_LOADF,\n&&L_OP_LOADK,\n&&L_OP_LOADKX,\n&&L_OP_LOADFALSE,\n&&L_OP_LFALSESKIP,\n&&L_OP_LOADTRUE,\n&&L_OP_LOADNIL,\n&&L_OP_GETUPVAL,\n&&L_OP_SETUPVAL,\n&&L_OP_GETTABUP,\n&&L_OP_GETTABLE,\n&&L_OP_GETI,\n&&L_OP_GETFIELD,\n&&L_OP_SETTABUP,\n&&L_OP_SETTABLE,\n&&L_OP_SETI,\n&&L_OP_SETFIELD,\n&&L_OP_NEWTABLE,\n&&L_OP_SELF,\n&&L_OP_ADDI,\n&&L_OP_ADDK,\n&&L_OP_SUBK,\n&&L_OP_MULK,\n&&L_OP_MODK,\n&&L_OP_POWK,\n&&L_OP_DIVK,\n&&L_OP_IDIVK,\n&&L_OP_BANDK,\n&&L_OP_BORK,\n&&L_OP_BXORK,\n&&L_OP_SHRI,\n&&L_OP_SHLI,\n&&L_OP_ADD,\n&&L_OP_SUB,\n&&L_OP_MUL,\n&&L_OP_MOD,\n&&L_OP_POW,\n&&L_OP_DIV,\n&&L_OP_IDIV,\n&&L_OP_BAND,\n&&L_OP_BOR,\n&&L_OP_BXOR,\n&&L_OP_SHL,\n&&L_OP_SHR,\n&&L_OP_MMBIN,\n&&L_OP_MMBINI,\n&&L_OP_MMBINK,\n&&L_OP_UNM,\n&&L_OP_BNOT,\n&&L_OP_NOT,\n&&L_OP_LEN,\n&&L_OP_CONCAT,\n&&L_OP_CLOSE,\n&&L_OP_TBC,\n&&L_OP_JMP,\n&&L_OP_EQ,\n&&L_OP_LT,\n&&L_OP_LE,\n&&L_OP_EQK,\n&&L_OP_EQI,\n&&L_OP_LTI,\n&&L_OP_LEI,\n&&L_OP_GTI,\n&&L_OP_GEI,\n&&L_OP_TEST,\n&&L_OP_TESTSET,\n&&L_OP_CALL,\n&&L_OP_TAILCALL,\n&&L_OP_RETURN,\n&&L_OP_RETURN0,\n&&L_OP_RETURN1,\n&&L_OP_FORLOOP,\n&&L_OP_FORPREP,\n&&L_OP_TFORPREP,\n&&L_OP_TFORCALL,\n&&L_OP_TFORLOOP,\n&&L_OP_SETLIST,\n&&L_OP_CLOSURE,\n&&L_OP_VARARG,\n&&L_OP_VARARGPREP,\n&&L_OP_EXTRAARG\n\n};\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/llex.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: llex.c $\n** Lexical Analyzer\n** See Copyright Notice in lua.h\n*/\n\n#define llex_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <locale.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lctype.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lgc.h\"\n#include \"llex.h\"\n#include \"lobject.h\"\n#include \"lparser.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"lzio.h\"\n\n\n\n#define next(ls)\t(ls->current = zgetc(ls->z))\n\n\n\n#define currIsNewline(ls)\t(ls->current == '\\n' || ls->current == '\\r')\n\n\n/* ORDER RESERVED */\nstatic const char *const luaX_tokens [] = {\n    \"and\", \"break\", \"do\", \"else\", \"elseif\",\n    \"end\", \"false\", \"for\", \"function\", \"goto\", \"if\",\n    \"in\", \"local\", \"nil\", \"not\", \"or\", \"repeat\",\n    \"return\", \"then\", \"true\", \"until\", \"while\",\n    \"//\", \"..\", \"...\", \"==\", \">=\", \"<=\", \"~=\",\n    \"<<\", \">>\", \"::\", \"<eof>\",\n    \"<number>\", \"<integer>\", \"<name>\", \"<string>\"\n};\n\n\n#define save_and_next(ls) (save(ls, ls->current), next(ls))\n\n\nstatic l_noret lexerror (LexState *ls, const char *msg, int token);\n\n\nstatic void save (LexState *ls, int c) {\n  Mbuffer *b = ls->buff;\n  if (luaZ_bufflen(b) + 1 > luaZ_sizebuffer(b)) {\n    size_t newsize;\n    if (luaZ_sizebuffer(b) >= MAX_SIZE/2)\n      lexerror(ls, \"lexical element too long\", 0);\n    newsize = luaZ_sizebuffer(b) * 2;\n    luaZ_resizebuffer(ls->L, b, newsize);\n  }\n  b->buffer[luaZ_bufflen(b)++] = cast_char(c);\n}\n\n\nvoid luaX_init (lua_State *L) {\n  int i;\n  TString *e = luaS_newliteral(L, LUA_ENV);  /* create env name */\n  luaC_fix(L, obj2gco(e));  /* never collect this name */\n  for (i=0; i<NUM_RESERVED; i++) {\n    TString *ts = luaS_new(L, luaX_tokens[i]);\n    luaC_fix(L, obj2gco(ts));  /* reserved words are never collected */\n    ts->extra = cast_byte(i+1);  /* reserved word */\n  }\n}\n\n\nconst char *luaX_token2str (LexState *ls, int token) {\n  if (token < FIRST_RESERVED) {  /* single-byte symbols? */\n    if (lisprint(token))\n      return luaO_pushfstring(ls->L, \"'%c'\", token);\n    else  /* control character */\n      return luaO_pushfstring(ls->L, \"'<\\\\%d>'\", token);\n  }\n  else {\n    const char *s = luaX_tokens[token - FIRST_RESERVED];\n    if (token < TK_EOS)  /* fixed format (symbols and reserved words)? */\n      return luaO_pushfstring(ls->L, \"'%s'\", s);\n    else  /* names, strings, and numerals */\n      return s;\n  }\n}\n\n\nstatic const char *txtToken (LexState *ls, int token) {\n  switch (token) {\n    case TK_NAME: case TK_STRING:\n    case TK_FLT: case TK_INT:\n      save(ls, '\\0');\n      return luaO_pushfstring(ls->L, \"'%s'\", luaZ_buffer(ls->buff));\n    default:\n      return luaX_token2str(ls, token);\n  }\n}\n\n\nstatic l_noret lexerror (LexState *ls, const char *msg, int token) {\n  msg = luaG_addinfo(ls->L, msg, ls->source, ls->linenumber);\n  if (token)\n    luaO_pushfstring(ls->L, \"%s near %s\", msg, txtToken(ls, token));\n  luaD_throw(ls->L, LUA_ERRSYNTAX);\n}\n\n\nl_noret luaX_syntaxerror (LexState *ls, const char *msg) {\n  lexerror(ls, msg, ls->t.token);\n}\n\n\n/*\n** Creates a new string and anchors it in scanner's table so that it\n** will not be collected until the end of the compilation; by that time\n** it should be anchored somewhere. It also internalizes long strings,\n** ensuring there is only one copy of each unique string.  The table\n** here is used as a set: the string enters as the key, while its value\n** is irrelevant. We use the string itself as the value only because it\n** is a TValue readily available. Later, the code generation can change\n** this value.\n*/\nTString *luaX_newstring (LexState *ls, const char *str, size_t l) {\n  lua_State *L = ls->L;\n  TString *ts = luaS_newlstr(L, str, l);  /* create new string */\n  TString *oldts = luaH_getstrkey(ls->h, ts);\n  if (oldts != NULL)  /* string already present? */\n    return oldts;  /* use it */\n  else {  /* create a new entry */\n    TValue *stv = s2v(L->top.p++);  /* reserve stack space for string */\n    setsvalue(L, stv, ts);  /* temporarily anchor the string */\n    luaH_set(L, ls->h, stv, stv);  /* t[string] = string */\n    /* table is not a metatable, so it does not need to invalidate cache */\n    luaC_checkGC(L);\n    L->top.p--;  /* remove string from stack */\n  }\n  return ts;\n}\n\n\n/*\n** increment line number and skips newline sequence (any of\n** \\n, \\r, \\n\\r, or \\r\\n)\n*/\nstatic void inclinenumber (LexState *ls) {\n  int old = ls->current;\n  lua_assert(currIsNewline(ls));\n  next(ls);  /* skip '\\n' or '\\r' */\n  if (currIsNewline(ls) && ls->current != old)\n    next(ls);  /* skip '\\n\\r' or '\\r\\n' */\n  if (++ls->linenumber >= MAX_INT)\n    lexerror(ls, \"chunk has too many lines\", 0);\n}\n\n\nvoid luaX_setinput (lua_State *L, LexState *ls, ZIO *z, TString *source,\n                    int firstchar) {\n  ls->t.token = 0;\n  ls->L = L;\n  ls->current = firstchar;\n  ls->lookahead.token = TK_EOS;  /* no look-ahead token */\n  ls->z = z;\n  ls->fs = NULL;\n  ls->linenumber = 1;\n  ls->lastline = 1;\n  ls->source = source;\n  ls->envn = luaS_newliteral(L, LUA_ENV);  /* get env name */\n  luaZ_resizebuffer(ls->L, ls->buff, LUA_MINBUFFER);  /* initialize buffer */\n}\n\n\n\n/*\n** =======================================================\n** LEXICAL ANALYZER\n** =======================================================\n*/\n\n\nstatic int check_next1 (LexState *ls, int c) {\n  if (ls->current == c) {\n    next(ls);\n    return 1;\n  }\n  else return 0;\n}\n\n\n/*\n** Check whether current char is in set 'set' (with two chars) and\n** saves it\n*/\nstatic int check_next2 (LexState *ls, const char *set) {\n  lua_assert(set[2] == '\\0');\n  if (ls->current == set[0] || ls->current == set[1]) {\n    save_and_next(ls);\n    return 1;\n  }\n  else return 0;\n}\n\n\n/* LUA_NUMBER */\n/*\n** This function is quite liberal in what it accepts, as 'luaO_str2num'\n** will reject ill-formed numerals. Roughly, it accepts the following\n** pattern:\n**\n**   %d(%x|%.|([Ee][+-]?))* | 0[Xx](%x|%.|([Pp][+-]?))*\n**\n** The only tricky part is to accept [+-] only after a valid exponent\n** mark, to avoid reading '3-4' or '0xe+1' as a single number.\n**\n** The caller might have already read an initial dot.\n*/\nstatic int read_numeral (LexState *ls, SemInfo *seminfo) {\n  TValue obj;\n  const char *expo = \"Ee\";\n  int first = ls->current;\n  lua_assert(lisdigit(ls->current));\n  save_and_next(ls);\n  if (first == '0' && check_next2(ls, \"xX\"))  /* hexadecimal? */\n    expo = \"Pp\";\n  for (;;) {\n    if (check_next2(ls, expo))  /* exponent mark? */\n      check_next2(ls, \"-+\");  /* optional exponent sign */\n    else if (lisxdigit(ls->current) || ls->current == '.')  /* '%x|%.' */\n      save_and_next(ls);\n    else break;\n  }\n  if (lislalpha(ls->current))  /* is numeral touching a letter? */\n    save_and_next(ls);  /* force an error */\n  save(ls, '\\0');\n  if (luaO_str2num(luaZ_buffer(ls->buff), &obj) == 0)  /* format error? */\n    lexerror(ls, \"malformed number\", TK_FLT);\n  if (ttisinteger(&obj)) {\n    seminfo->i = ivalue(&obj);\n    return TK_INT;\n  }\n  else {\n    lua_assert(ttisfloat(&obj));\n    seminfo->r = fltvalue(&obj);\n    return TK_FLT;\n  }\n}\n\n\n/*\n** read a sequence '[=*[' or ']=*]', leaving the last bracket. If\n** sequence is well formed, return its number of '='s + 2; otherwise,\n** return 1 if it is a single bracket (no '='s and no 2nd bracket);\n** otherwise (an unfinished '[==...') return 0.\n*/\nstatic size_t skip_sep (LexState *ls) {\n  size_t count = 0;\n  int s = ls->current;\n  lua_assert(s == '[' || s == ']');\n  save_and_next(ls);\n  while (ls->current == '=') {\n    save_and_next(ls);\n    count++;\n  }\n  return (ls->current == s) ? count + 2\n         : (count == 0) ? 1\n         : 0;\n}\n\n\nstatic void read_long_string (LexState *ls, SemInfo *seminfo, size_t sep) {\n  int line = ls->linenumber;  /* initial line (for error message) */\n  save_and_next(ls);  /* skip 2nd '[' */\n  if (currIsNewline(ls))  /* string starts with a newline? */\n    inclinenumber(ls);  /* skip it */\n  for (;;) {\n    switch (ls->current) {\n      case EOZ: {  /* error */\n        const char *what = (seminfo ? \"string\" : \"comment\");\n        const char *msg = luaO_pushfstring(ls->L,\n                     \"unfinished long %s (starting at line %d)\", what, line);\n        lexerror(ls, msg, TK_EOS);\n        break;  /* to avoid warnings */\n      }\n      case ']': {\n        if (skip_sep(ls) == sep) {\n          save_and_next(ls);  /* skip 2nd ']' */\n          goto endloop;\n        }\n        break;\n      }\n      case '\\n': case '\\r': {\n        save(ls, '\\n');\n        inclinenumber(ls);\n        if (!seminfo) luaZ_resetbuffer(ls->buff);  /* avoid wasting space */\n        break;\n      }\n      default: {\n        if (seminfo) save_and_next(ls);\n        else next(ls);\n      }\n    }\n  } endloop:\n  if (seminfo)\n    seminfo->ts = luaX_newstring(ls, luaZ_buffer(ls->buff) + sep,\n                                     luaZ_bufflen(ls->buff) - 2 * sep);\n}\n\n\nstatic void esccheck (LexState *ls, int c, const char *msg) {\n  if (!c) {\n    if (ls->current != EOZ)\n      save_and_next(ls);  /* add current to buffer for error message */\n    lexerror(ls, msg, TK_STRING);\n  }\n}\n\n\nstatic int gethexa (LexState *ls) {\n  save_and_next(ls);\n  esccheck (ls, lisxdigit(ls->current), \"hexadecimal digit expected\");\n  return luaO_hexavalue(ls->current);\n}\n\n\nstatic int readhexaesc (LexState *ls) {\n  int r = gethexa(ls);\n  r = (r << 4) + gethexa(ls);\n  luaZ_buffremove(ls->buff, 2);  /* remove saved chars from buffer */\n  return r;\n}\n\n\nstatic unsigned long readutf8esc (LexState *ls) {\n  unsigned long r;\n  int i = 4;  /* chars to be removed: '\\', 'u', '{', and first digit */\n  save_and_next(ls);  /* skip 'u' */\n  esccheck(ls, ls->current == '{', \"missing '{'\");\n  r = gethexa(ls);  /* must have at least one digit */\n  while (cast_void(save_and_next(ls)), lisxdigit(ls->current)) {\n    i++;\n    esccheck(ls, r <= (0x7FFFFFFFu >> 4), \"UTF-8 value too large\");\n    r = (r << 4) + luaO_hexavalue(ls->current);\n  }\n  esccheck(ls, ls->current == '}', \"missing '}'\");\n  next(ls);  /* skip '}' */\n  luaZ_buffremove(ls->buff, i);  /* remove saved chars from buffer */\n  return r;\n}\n\n\nstatic void utf8esc (LexState *ls) {\n  char buff[UTF8BUFFSZ];\n  int n = luaO_utf8esc(buff, readutf8esc(ls));\n  for (; n > 0; n--)  /* add 'buff' to string */\n    save(ls, buff[UTF8BUFFSZ - n]);\n}\n\n\nstatic int readdecesc (LexState *ls) {\n  int i;\n  int r = 0;  /* result accumulator */\n  for (i = 0; i < 3 && lisdigit(ls->current); i++) {  /* read up to 3 digits */\n    r = 10*r + ls->current - '0';\n    save_and_next(ls);\n  }\n  esccheck(ls, r <= UCHAR_MAX, \"decimal escape too large\");\n  luaZ_buffremove(ls->buff, i);  /* remove read digits from buffer */\n  return r;\n}\n\n\nstatic void read_string (LexState *ls, int del, SemInfo *seminfo) {\n  save_and_next(ls);  /* keep delimiter (for error messages) */\n  while (ls->current != del) {\n    switch (ls->current) {\n      case EOZ:\n        lexerror(ls, \"unfinished string\", TK_EOS);\n        break;  /* to avoid warnings */\n      case '\\n':\n      case '\\r':\n        lexerror(ls, \"unfinished string\", TK_STRING);\n        break;  /* to avoid warnings */\n      case '\\\\': {  /* escape sequences */\n        int c;  /* final character to be saved */\n        save_and_next(ls);  /* keep '\\\\' for error messages */\n        switch (ls->current) {\n          case 'a': c = '\\a'; goto read_save;\n          case 'b': c = '\\b'; goto read_save;\n          case 'f': c = '\\f'; goto read_save;\n          case 'n': c = '\\n'; goto read_save;\n          case 'r': c = '\\r'; goto read_save;\n          case 't': c = '\\t'; goto read_save;\n          case 'v': c = '\\v'; goto read_save;\n          case 'x': c = readhexaesc(ls); goto read_save;\n          case 'u': utf8esc(ls);  goto no_save;\n          case '\\n': case '\\r':\n            inclinenumber(ls); c = '\\n'; goto only_save;\n          case '\\\\': case '\\\"': case '\\'':\n            c = ls->current; goto read_save;\n          case EOZ: goto no_save;  /* will raise an error next loop */\n          case 'z': {  /* zap following span of spaces */\n            luaZ_buffremove(ls->buff, 1);  /* remove '\\\\' */\n            next(ls);  /* skip the 'z' */\n            while (lisspace(ls->current)) {\n              if (currIsNewline(ls)) inclinenumber(ls);\n              else next(ls);\n            }\n            goto no_save;\n          }\n          default: {\n            esccheck(ls, lisdigit(ls->current), \"invalid escape sequence\");\n            c = readdecesc(ls);  /* digital escape '\\ddd' */\n            goto only_save;\n          }\n        }\n       read_save:\n         next(ls);\n         /* go through */\n       only_save:\n         luaZ_buffremove(ls->buff, 1);  /* remove '\\\\' */\n         save(ls, c);\n         /* go through */\n       no_save: break;\n      }\n      default:\n        save_and_next(ls);\n    }\n  }\n  save_and_next(ls);  /* skip delimiter */\n  seminfo->ts = luaX_newstring(ls, luaZ_buffer(ls->buff) + 1,\n                                   luaZ_bufflen(ls->buff) - 2);\n}\n\n\nstatic int llex (LexState *ls, SemInfo *seminfo) {\n  luaZ_resetbuffer(ls->buff);\n  for (;;) {\n    switch (ls->current) {\n      case '\\n': case '\\r': {  /* line breaks */\n        inclinenumber(ls);\n        break;\n      }\n      case ' ': case '\\f': case '\\t': case '\\v': {  /* spaces */\n        next(ls);\n        break;\n      }\n      case '-': {  /* '-' or '--' (comment) */\n        next(ls);\n        if (ls->current != '-') return '-';\n        /* else is a comment */\n        next(ls);\n        if (ls->current == '[') {  /* long comment? */\n          size_t sep = skip_sep(ls);\n          luaZ_resetbuffer(ls->buff);  /* 'skip_sep' may dirty the buffer */\n          if (sep >= 2) {\n            read_long_string(ls, NULL, sep);  /* skip long comment */\n            luaZ_resetbuffer(ls->buff);  /* previous call may dirty the buff. */\n            break;\n          }\n        }\n        /* else short comment */\n        while (!currIsNewline(ls) && ls->current != EOZ)\n          next(ls);  /* skip until end of line (or end of file) */\n        break;\n      }\n      case '[': {  /* long string or simply '[' */\n        size_t sep = skip_sep(ls);\n        if (sep >= 2) {\n          read_long_string(ls, seminfo, sep);\n          return TK_STRING;\n        }\n        else if (sep == 0)  /* '[=...' missing second bracket? */\n          lexerror(ls, \"invalid long string delimiter\", TK_STRING);\n        return '[';\n      }\n      case '=': {\n        next(ls);\n        if (check_next1(ls, '=')) return TK_EQ;  /* '==' */\n        else return '=';\n      }\n      case '<': {\n        next(ls);\n        if (check_next1(ls, '=')) return TK_LE;  /* '<=' */\n        else if (check_next1(ls, '<')) return TK_SHL;  /* '<<' */\n        else return '<';\n      }\n      case '>': {\n        next(ls);\n        if (check_next1(ls, '=')) return TK_GE;  /* '>=' */\n        else if (check_next1(ls, '>')) return TK_SHR;  /* '>>' */\n        else return '>';\n      }\n      case '/': {\n        next(ls);\n        if (check_next1(ls, '/')) return TK_IDIV;  /* '//' */\n        else return '/';\n      }\n      case '~': {\n        next(ls);\n        if (check_next1(ls, '=')) return TK_NE;  /* '~=' */\n        else return '~';\n      }\n      case ':': {\n        next(ls);\n        if (check_next1(ls, ':')) return TK_DBCOLON;  /* '::' */\n        else return ':';\n      }\n      case '\"': case '\\'': {  /* short literal strings */\n        read_string(ls, ls->current, seminfo);\n        return TK_STRING;\n      }\n      case '.': {  /* '.', '..', '...', or number */\n        save_and_next(ls);\n        if (check_next1(ls, '.')) {\n          if (check_next1(ls, '.'))\n            return TK_DOTS;   /* '...' */\n          else return TK_CONCAT;   /* '..' */\n        }\n        else if (!lisdigit(ls->current)) return '.';\n        else return read_numeral(ls, seminfo);\n      }\n      case '0': case '1': case '2': case '3': case '4':\n      case '5': case '6': case '7': case '8': case '9': {\n        return read_numeral(ls, seminfo);\n      }\n      case EOZ: {\n        return TK_EOS;\n      }\n      default: {\n        if (lislalpha(ls->current)) {  /* identifier or reserved word? */\n          TString *ts;\n          do {\n            save_and_next(ls);\n          } while (lislalnum(ls->current));\n          ts = luaX_newstring(ls, luaZ_buffer(ls->buff),\n                                  luaZ_bufflen(ls->buff));\n          seminfo->ts = ts;\n          if (isreserved(ts))  /* reserved word? */\n            return ts->extra - 1 + FIRST_RESERVED;\n          else {\n            return TK_NAME;\n          }\n        }\n        else {  /* single-char tokens ('+', '*', '%', '{', '}', ...) */\n          int c = ls->current;\n          next(ls);\n          return c;\n        }\n      }\n    }\n  }\n}\n\n\nvoid luaX_next (LexState *ls) {\n  ls->lastline = ls->linenumber;\n  if (ls->lookahead.token != TK_EOS) {  /* is there a look-ahead token? */\n    ls->t = ls->lookahead;  /* use this one */\n    ls->lookahead.token = TK_EOS;  /* and discharge it */\n  }\n  else\n    ls->t.token = llex(ls, &ls->t.seminfo);  /* read next token */\n}\n\n\nint luaX_lookahead (LexState *ls) {\n  lua_assert(ls->lookahead.token == TK_EOS);\n  ls->lookahead.token = llex(ls, &ls->lookahead.seminfo);\n  return ls->lookahead.token;\n}\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/llex.h",
		"is_binary":	false,
		"content":	"/*\n** $Id: llex.h $\n** Lexical Analyzer\n** See Copyright Notice in lua.h\n*/\n\n#ifndef llex_h\n#define llex_h\n\n#include <limits.h>\n\n#include \"lobject.h\"\n#include \"lzio.h\"\n\n\n/*\n** Single-char tokens (terminal symbols) are represented by their own\n** numeric code. Other tokens start at the following value.\n*/\n#define FIRST_RESERVED\t(UCHAR_MAX + 1)\n\n\n#if !defined(LUA_ENV)\n#define LUA_ENV\t\t\"_ENV\"\n#endif\n\n\n/*\n* WARNING: if you change the order of this enumeration,\n* grep \"ORDER RESERVED\"\n*/\nenum RESERVED {\n  /* terminal symbols denoted by reserved words */\n  TK_AND = FIRST_RESERVED, TK_BREAK,\n  TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION,\n  TK_GOTO, TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,\n  TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,\n  /* other terminal symbols */\n  TK_IDIV, TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE,\n  TK_SHL, TK_SHR,\n  TK_DBCOLON, TK_EOS,\n  TK_FLT, TK_INT, TK_NAME, TK_STRING\n};\n\n/* number of reserved words */\n#define NUM_RESERVED\t(cast_int(TK_WHILE-FIRST_RESERVED + 1))\n\n\ntypedef union {\n  lua_Number r;\n  lua_Integer i;\n  TString *ts;\n} SemInfo;  /* semantics information */\n\n\ntypedef struct Token {\n  int token;\n  SemInfo seminfo;\n} Token;\n\n\n/* state of the lexer plus state of the parser when shared by all\n   functions */\ntypedef struct LexState {\n  int current;  /* current character (charint) */\n  int linenumber;  /* input line counter */\n  int lastline;  /* line of last token 'consumed' */\n  Token t;  /* current token */\n  Token lookahead;  /* look ahead token */\n  struct FuncState *fs;  /* current function (parser) */\n  struct lua_State *L;\n  ZIO *z;  /* input stream */\n  Mbuffer *buff;  /* buffer for tokens */\n  Table *h;  /* to avoid collection/reuse strings */\n  struct Dyndata *dyd;  /* dynamic structures used by the parser */\n  TString *source;  /* current source name */\n  TString *envn;  /* environment variable name */\n} LexState;\n\n\nLUAI_FUNC void luaX_init (lua_State *L);\nLUAI_FUNC void luaX_setinput (lua_State *L, LexState *ls, ZIO *z,\n                              TString *source, int firstchar);\nLUAI_FUNC TString *luaX_newstring (LexState *ls, const char *str, size_t l);\nLUAI_FUNC void luaX_next (LexState *ls);\nLUAI_FUNC int luaX_lookahead (LexState *ls);\nLUAI_FUNC l_noret luaX_syntaxerror (LexState *ls, const char *s);\nLUAI_FUNC const char *luaX_token2str (LexState *ls, int token);\n\n\n#endif\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/llimits.h",
		"is_binary":	false,
		"content":	"/*\n** $Id: llimits.h $\n** Limits, basic types, and some other 'installation-dependent' definitions\n** See Copyright Notice in lua.h\n*/\n\n#ifndef llimits_h\n#define llimits_h\n\n\n#include <limits.h>\n#include <stddef.h>\n\n\n#include \"lua.h\"\n\n\n/*\n** 'lu_mem' is an unsigned integer big enough to count the total memory\n** used by Lua (in bytes). 'l_obj' is a signed integer big enough to\n** count the total number of objects used by Lua. (It is signed due\n** to the use of debt in several computations.)  Usually, 'size_t' and\n** 'ptrdiff_t' should work, but we use 'long' for 16-bit machines.\n*/\n#if defined(LUAI_MEM)\t\t/* { external definitions? */\ntypedef LUAI_UMEM lu_mem;\ntypedef LUAI_MEM l_obj;\n#elif LUAI_IS32INT\t/* }{ */\ntypedef size_t lu_mem;\ntypedef ptrdiff_t l_obj;\n#else  /* 16-bit ints */\t/* }{ */\ntypedef unsigned long lu_mem;\ntypedef long l_obj;\n#endif\t\t\t\t/* } */\n\n#define MAX_LOBJ  \\\n\tcast(l_obj, (cast(lu_mem, 1) << (sizeof(l_obj) * CHAR_BIT - 1)) - 1)\n\n\n/* chars used as small naturals (so that 'char' is reserved for characters) */\ntypedef unsigned char lu_byte;\ntypedef signed char ls_byte;\n\n\n/* maximum value for size_t */\n#define MAX_SIZET\t((size_t)(~(size_t)0))\n\n/*\n** Maximum size for strings and userdata visible for Lua (should be\n** representable in a lua_Integer)\n*/\n#define MAX_SIZE\t(sizeof(size_t) < sizeof(lua_Integer) ? MAX_SIZET \\\n                          : (size_t)(LUA_MAXINTEGER))\n\n\n#define MAX_INT\t\tINT_MAX  /* maximum value of an int */\n\n\n/*\n** floor of the log2 of the maximum signed value for integral type 't'.\n** (That is, maximum 'n' such that '2^n' fits in the given signed type.)\n*/\n#define log2maxs(t)\tcast_int(sizeof(t) * 8 - 2)\n\n\n/*\n** test whether an unsigned value is a power of 2 (or zero)\n*/\n#define ispow2(x)\t(((x) & ((x) - 1)) == 0)\n\n\n/* number of chars of a literal string without the ending \\0 */\n#define LL(x)   (sizeof(x)/sizeof(char) - 1)\n\n\n/*\n** conversion of pointer to unsigned integer: this is for hashing only;\n** there is no problem if the integer cannot hold the whole pointer\n** value. (In strict ISO C this may cause undefined behavior, but no\n** actual machine seems to bother.)\n*/\n#if !defined(LUA_USE_C89) && defined(__STDC_VERSION__) && \\\n    __STDC_VERSION__ >= 199901L\n#include <stdint.h>\n#if defined(UINTPTR_MAX)  /* even in C99 this type is optional */\n#define L_P2I\tuintptr_t\n#else  /* no 'intptr'? */\n#define L_P2I\tuintmax_t  /* use the largest available integer */\n#endif\n#else  /* C89 option */\n#define L_P2I\tsize_t\n#endif\n\n#define point2uint(p)\tcast_uint((L_P2I)(p) & UINT_MAX)\n\n\n\n/* types of 'usual argument conversions' for lua_Number and lua_Integer */\ntypedef LUAI_UACNUMBER l_uacNumber;\ntypedef LUAI_UACINT l_uacInt;\n\n\n/*\n** Internal assertions for in-house debugging\n*/\n#if defined LUAI_ASSERT\n#undef NDEBUG\n#include <assert.h>\n#define lua_assert(c)           assert(c)\n#endif\n\n#if defined(lua_assert)\n#define check_exp(c,e)\t\t(lua_assert(c), (e))\n/* to avoid problems with conditions too long */\n#define lua_longassert(c)\t((c) ? (void)0 : lua_assert(0))\n#else\n#define lua_assert(c)\t\t((void)0)\n#define check_exp(c,e)\t\t(e)\n#define lua_longassert(c)\t((void)0)\n#endif\n\n/*\n** assertion for checking API calls\n*/\n#if !defined(luai_apicheck)\n#define luai_apicheck(l,e)\t((void)l, lua_assert(e))\n#endif\n\n#define api_check(l,e,msg)\tluai_apicheck(l,(e) && msg)\n\n\n/* macro to avoid warnings about unused variables */\n#if !defined(UNUSED)\n#define UNUSED(x)\t((void)(x))\n#endif\n\n\n/* type casts (a macro highlights casts in the code) */\n#define cast(t, exp)\t((t)(exp))\n\n#define cast_void(i)\tcast(void, (i))\n#define cast_voidp(i)\tcast(void *, (i))\n#define cast_num(i)\tcast(lua_Number, (i))\n#define cast_int(i)\tcast(int, (i))\n#define cast_uint(i)\tcast(unsigned int, (i))\n#define cast_byte(i)\tcast(lu_byte, (i))\n#define cast_uchar(i)\tcast(unsigned char, (i))\n#define cast_char(i)\tcast(char, (i))\n#define cast_charp(i)\tcast(char *, (i))\n#define cast_sizet(i)\tcast(size_t, (i))\n\n\n/* cast a signed lua_Integer to lua_Unsigned */\n#if !defined(l_castS2U)\n#define l_castS2U(i)\t((lua_Unsigned)(i))\n#endif\n\n/*\n** cast a lua_Unsigned to a signed lua_Integer; this cast is\n** not strict ISO C, but two-complement architectures should\n** work fine.\n*/\n#if !defined(l_castU2S)\n#define l_castU2S(i)\t((lua_Integer)(i))\n#endif\n\n\n/*\n** non-return type\n*/\n#if !defined(l_noret)\n\n#if defined(__GNUC__)\n#define l_noret\t\tvoid __attribute__((noreturn))\n#elif defined(_MSC_VER) && _MSC_VER >= 1200\n#define l_noret\t\tvoid __declspec(noreturn)\n#else\n#define l_noret\t\tvoid\n#endif\n\n#endif\n\n\n/*\n** Inline functions\n*/\n#if !defined(LUA_USE_C89)\n#define l_inline\tinline\n#elif defined(__GNUC__)\n#define l_inline\t__inline__\n#else\n#define l_inline\t/* empty */\n#endif\n\n#define l_sinline\tstatic l_inline\n\n\n/*\n** type for virtual-machine instructions;\n** must be an unsigned with (at least) 4 bytes (see details in lopcodes.h)\n*/\n#if LUAI_IS32INT\ntypedef unsigned int l_uint32;\n#else\ntypedef unsigned long l_uint32;\n#endif\n\ntypedef l_uint32 Instruction;\n\n\n\n/*\n** Maximum length for short strings, that is, strings that are\n** internalized. (Cannot be smaller than reserved words or tags for\n** metamethods, as these strings must be internalized;\n** #(\"function\") = 8, #(\"__newindex\") = 10.)\n*/\n#if !defined(LUAI_MAXSHORTLEN)\n#define LUAI_MAXSHORTLEN\t40\n#endif\n\n\n/*\n** Initial size for the string table (must be power of 2).\n** The Lua core alone registers ~50 strings (reserved words +\n** metaevent keys + a few others). Libraries would typically add\n** a few dozens more.\n*/\n#if !defined(MINSTRTABSIZE)\n#define MINSTRTABSIZE\t128\n#endif\n\n\n/*\n** Size of cache for strings in the API. 'N' is the number of\n** sets (better be a prime) and \"M\" is the size of each set (M == 1\n** makes a direct cache.)\n*/\n#if !defined(STRCACHE_N)\n#define STRCACHE_N\t\t53\n#define STRCACHE_M\t\t2\n#endif\n\n\n/* minimum size for string buffer */\n#if !defined(LUA_MINBUFFER)\n#define LUA_MINBUFFER\t32\n#endif\n\n\n/*\n** Maximum depth for nested C calls, syntactical nested non-terminals,\n** and other features implemented through recursion in C. (Value must\n** fit in a 16-bit unsigned integer. It must also be compatible with\n** the size of the C stack.)\n*/\n#if !defined(LUAI_MAXCCALLS)\n#define LUAI_MAXCCALLS\t\t200\n#endif\n\n\n/*\n** macros that are executed whenever program enters the Lua core\n** ('lua_lock') and leaves the core ('lua_unlock')\n*/\n#if !defined(lua_lock)\n#define lua_lock(L)\t((void) 0)\n#define lua_unlock(L)\t((void) 0)\n#endif\n\n/*\n** macro executed during Lua functions at points where the\n** function can yield.\n*/\n#if !defined(luai_threadyield)\n#define luai_threadyield(L)\t{lua_unlock(L); lua_lock(L);}\n#endif\n\n\n/*\n** these macros allow user-specific actions when a thread is\n** created/deleted/resumed/yielded.\n*/\n#if !defined(luai_userstateopen)\n#define luai_userstateopen(L)\t\t((void)L)\n#endif\n\n#if !defined(luai_userstateclose)\n#define luai_userstateclose(L)\t\t((void)L)\n#endif\n\n#if !defined(luai_userstatethread)\n#define luai_userstatethread(L,L1)\t((void)L)\n#endif\n\n#if !defined(luai_userstatefree)\n#define luai_userstatefree(L,L1)\t((void)L)\n#endif\n\n#if !defined(luai_userstateresume)\n#define luai_userstateresume(L,n)\t((void)L)\n#endif\n\n#if !defined(luai_userstateyield)\n#define luai_userstateyield(L,n)\t((void)L)\n#endif\n\n\n\n/*\n** The luai_num* macros define the primitive operations over numbers.\n*/\n\n/* floor division (defined as 'floor(a/b)') */\n#if !defined(luai_numidiv)\n#define luai_numidiv(L,a,b)     ((void)L, l_floor(luai_numdiv(L,a,b)))\n#endif\n\n/* float division */\n#if !defined(luai_numdiv)\n#define luai_numdiv(L,a,b)      ((a)/(b))\n#endif\n\n/*\n** modulo: defined as 'a - floor(a/b)*b'; the direct computation\n** using this definition has several problems with rounding errors,\n** so it is better to use 'fmod'. 'fmod' gives the result of\n** 'a - trunc(a/b)*b', and therefore must be corrected when\n** 'trunc(a/b) ~= floor(a/b)'. That happens when the division has a\n** non-integer negative result: non-integer result is equivalent to\n** a non-zero remainder 'm'; negative result is equivalent to 'a' and\n** 'b' with different signs, or 'm' and 'b' with different signs\n** (as the result 'm' of 'fmod' has the same sign of 'a').\n*/\n#if !defined(luai_nummod)\n#define luai_nummod(L,a,b,m)  \\\n  { (void)L; (m) = l_mathop(private_lua_embed_fmod)(a,b); \\\n    if (((m) > 0) ? (b) < 0 : ((m) < 0 && (b) > 0)) (m) += (b); }\n#endif\n\n/* exponentiation */\n#if !defined(luai_numpow)\n#define luai_numpow(L,a,b)  \\\n  ((void)L, (b == 2) ? (a)*(a) : l_mathop(private_lua_embed_pow)(a,b))\n#endif\n\n/* the others are quite standard operations */\n#if !defined(luai_numadd)\n#define luai_numadd(L,a,b)      ((a)+(b))\n#define luai_numsub(L,a,b)      ((a)-(b))\n#define luai_nummul(L,a,b)      ((a)*(b))\n#define luai_numunm(L,a)        (-(a))\n#define luai_numeq(a,b)         ((a)==(b))\n#define luai_numlt(a,b)         ((a)<(b))\n#define luai_numle(a,b)         ((a)<=(b))\n#define luai_numgt(a,b)         ((a)>(b))\n#define luai_numge(a,b)         ((a)>=(b))\n#define luai_numisnan(a)        (!luai_numeq((a), (a)))\n#endif\n\n\n\n\n\n/*\n** macro to control inclusion of some hard tests on stack reallocation\n*/\n#if !defined(HARDSTACKTESTS)\n#define condmovestack(L,pre,pos)\t((void)0)\n#else\n/* realloc stack keeping its size */\n#define condmovestack(L,pre,pos)  \\\n  { int sz_ = stacksize(L); pre; luaD_reallocstack((L), sz_, 0); pos; }\n#endif\n\n#if !defined(HARDMEMTESTS)\n#define condchangemem(L,pre,pos)\t((void)0)\n#else\n#define condchangemem(L,pre,pos)  \\\n\t{ if (gcrunning(G(L))) { pre; luaC_fullgc(L, 0); pos; } }\n#endif\n\n#endif\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lmathlib.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: lmathlib.c $\n** Standard mathematical library\n** See Copyright Notice in lua.h\n*/\n\n#define lmathlib_c\n#define LUA_LIB\n\n#include \"lprefix.h\"\n\n\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include <stdlib.h>\n#include <time.h>\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n\n\n#undef PI\n#define PI\t(l_mathop(3.141592653589793238462643383279502884))\n\n\nstatic int math_abs (lua_State *L) {\n  if (lua_isinteger(L, 1)) {\n    lua_Integer n = lua_tointeger(L, 1);\n    if (n < 0) n = (lua_Integer)(0u - (lua_Unsigned)n);\n    lua_pushinteger(L, n);\n  }\n  else\n    lua_pushnumber(L, l_mathop(fabs)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_sin (lua_State *L) {\n  lua_pushnumber(L, l_mathop(sin)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_cos (lua_State *L) {\n  lua_pushnumber(L, l_mathop(cos)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_tan (lua_State *L) {\n  lua_pushnumber(L, l_mathop(tan)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_asin (lua_State *L) {\n  lua_pushnumber(L, l_mathop(asin)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_acos (lua_State *L) {\n  lua_pushnumber(L, l_mathop(acos)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_atan (lua_State *L) {\n  lua_Number y = luaL_checknumber(L, 1);\n  lua_Number x = luaL_optnumber(L, 2, 1);\n  lua_pushnumber(L, l_mathop(atan2)(y, x));\n  return 1;\n}\n\n\nstatic int math_toint (lua_State *L) {\n  int valid;\n  lua_Integer n = lua_tointegerx(L, 1, &valid);\n  if (l_likely(valid))\n    lua_pushinteger(L, n);\n  else {\n    luaL_checkany(L, 1);\n    luaL_pushfail(L);  /* value is not convertible to integer */\n  }\n  return 1;\n}\n\n\nstatic void pushnumint (lua_State *L, lua_Number d) {\n  lua_Integer n;\n  if (lua_numbertointeger(d, &n))  /* does 'd' fit in an integer? */\n    lua_pushinteger(L, n);  /* result is integer */\n  else\n    lua_pushnumber(L, d);  /* result is float */\n}\n\n\nstatic int math_floor (lua_State *L) {\n  if (lua_isinteger(L, 1))\n    lua_settop(L, 1);  /* integer is its own floor */\n  else {\n    lua_Number d = l_mathop(floor)(luaL_checknumber(L, 1));\n    pushnumint(L, d);\n  }\n  return 1;\n}\n\n\nstatic int math_ceil (lua_State *L) {\n  if (lua_isinteger(L, 1))\n    lua_settop(L, 1);  /* integer is its own ceil */\n  else {\n    lua_Number d = l_mathop(ceil)(luaL_checknumber(L, 1));\n    pushnumint(L, d);\n  }\n  return 1;\n}\n\n\nstatic int math_fmod (lua_State *L) {\n  if (lua_isinteger(L, 1) && lua_isinteger(L, 2)) {\n    lua_Integer d = lua_tointeger(L, 2);\n    if ((lua_Unsigned)d + 1u <= 1u) {  /* special cases: -1 or 0 */\n      luaL_argcheck(L, d != 0, 2, \"zero\");\n      lua_pushinteger(L, 0);  /* avoid overflow with 0x80000... / -1 */\n    }\n    else\n      lua_pushinteger(L, lua_tointeger(L, 1) % d);\n  }\n  else\n    lua_pushnumber(L, l_mathop(private_lua_embed_fmod)(luaL_checknumber(L, 1),\n                                     luaL_checknumber(L, 2)));\n  return 1;\n}\n\n\n/*\n** next function does not use 'modf', avoiding problems with 'double*'\n** (which is not compatible with 'float*') when lua_Number is not\n** 'double'.\n*/\nstatic int math_modf (lua_State *L) {\n  if (lua_isinteger(L ,1)) {\n    lua_settop(L, 1);  /* number is its own integer part */\n    lua_pushnumber(L, 0);  /* no fractional part */\n  }\n  else {\n    lua_Number n = luaL_checknumber(L, 1);\n    /* integer part (rounds toward zero) */\n    lua_Number ip = (n < 0) ? l_mathop(ceil)(n) : l_mathop(floor)(n);\n    pushnumint(L, ip);\n    /* fractional part (test needed for inf/-inf) */\n    lua_pushnumber(L, (n == ip) ? l_mathop(0.0) : (n - ip));\n  }\n  return 2;\n}\n\n\nstatic int math_sqrt (lua_State *L) {\n  lua_pushnumber(L, l_mathop(sqrt)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\n\nstatic int math_ult (lua_State *L) {\n  lua_Integer a = luaL_checkinteger(L, 1);\n  lua_Integer b = luaL_checkinteger(L, 2);\n  lua_pushboolean(L, (lua_Unsigned)a < (lua_Unsigned)b);\n  return 1;\n}\n\nstatic int math_log (lua_State *L) {\n  lua_Number x = luaL_checknumber(L, 1);\n  lua_Number res;\n  if (lua_isnoneornil(L, 2))\n    res = l_mathop(log)(x);\n  else {\n    lua_Number base = luaL_checknumber(L, 2);\n#if !defined(LUA_USE_C89)\n    if (base == l_mathop(2.0))\n      res = l_mathop(log2)(x);\n    else\n#endif\n    if (base == l_mathop(10.0))\n      res = l_mathop(log10)(x);\n    else\n      res = l_mathop(log)(x)/l_mathop(log)(base);\n  }\n  lua_pushnumber(L, res);\n  return 1;\n}\n\nstatic int math_exp (lua_State *L) {\n  lua_pushnumber(L, l_mathop(exp)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_deg (lua_State *L) {\n  lua_pushnumber(L, luaL_checknumber(L, 1) * (l_mathop(180.0) / PI));\n  return 1;\n}\n\nstatic int math_rad (lua_State *L) {\n  lua_pushnumber(L, luaL_checknumber(L, 1) * (PI / l_mathop(180.0)));\n  return 1;\n}\n\n\nstatic int math_min (lua_State *L) {\n  int n = lua_gettop(L);  /* number of arguments */\n  int imin = 1;  /* index of current minimum value */\n  int i;\n  luaL_argcheck(L, n >= 1, 1, \"value expected\");\n  for (i = 2; i <= n; i++) {\n    if (lua_compare(L, i, imin, LUA_OPLT))\n      imin = i;\n  }\n  lua_pushvalue(L, imin);\n  return 1;\n}\n\n\nstatic int math_max (lua_State *L) {\n  int n = lua_gettop(L);  /* number of arguments */\n  int imax = 1;  /* index of current maximum value */\n  int i;\n  luaL_argcheck(L, n >= 1, 1, \"value expected\");\n  for (i = 2; i <= n; i++) {\n    if (lua_compare(L, imax, i, LUA_OPLT))\n      imax = i;\n  }\n  lua_pushvalue(L, imax);\n  return 1;\n}\n\n\nstatic int math_type (lua_State *L) {\n  if (lua_type(L, 1) == LUA_TNUMBER)\n    lua_pushstring(L, (lua_isinteger(L, 1)) ? \"integer\" : \"float\");\n  else {\n    luaL_checkany(L, 1);\n    luaL_pushfail(L);\n  }\n  return 1;\n}\n\n\n\n/*\n** {==================================================================\n** Pseudo-Random Number Generator based on 'xoshiro256**'.\n** ===================================================================\n*/\n\n/*\n** This code uses lots of shifts. ANSI C does not allow shifts greater\n** than or equal to the width of the type being shifted, so some shifts\n** are written in convoluted ways to match that restriction. For\n** preprocessor tests, it assumes a width of 32 bits, so the maximum\n** shift there is 31 bits.\n*/\n\n\n/* number of binary digits in the mantissa of a float */\n#define FIGS\tl_floatatt(MANT_DIG)\n\n#if FIGS > 64\n/* there are only 64 random bits; use them all */\n#undef FIGS\n#define FIGS\t64\n#endif\n\n\n/*\n** LUA_RAND32 forces the use of 32-bit integers in the implementation\n** of the PRN generator (mainly for testing).\n*/\n#if !defined(LUA_RAND32) && !defined(Rand64)\n\n/* try to find an integer type with at least 64 bits */\n\n#if ((ULONG_MAX >> 31) >> 31) >= 3\n\n/* 'long' has at least 64 bits */\n#define Rand64\t\tunsigned long\n#define SRand64\t\tlong\n\n#elif !defined(LUA_USE_C89) && defined(LLONG_MAX)\n\n/* there is a 'long long' type (which must have at least 64 bits) */\n#define Rand64\t\tunsigned long long\n#define SRand64\t\tlong long\n\n#elif ((LUA_MAXUNSIGNED >> 31) >> 31) >= 3\n\n/* 'lua_Unsigned' has at least 64 bits */\n#define Rand64\t\tlua_Unsigned\n#define SRand64\t\tlua_Integer\n\n#endif\n\n#endif\n\n\n#if defined(Rand64)  /* { */\n\n/*\n** Standard implementation, using 64-bit integers.\n** If 'Rand64' has more than 64 bits, the extra bits do not interfere\n** with the 64 initial bits, except in a right shift. Moreover, the\n** final result has to discard the extra bits.\n*/\n\n/* avoid using extra bits when needed */\n#define trim64(x)\t((x) & 0xffffffffffffffffu)\n\n\n/* rotate left 'x' by 'n' bits */\nstatic Rand64 rotl (Rand64 x, int n) {\n  return (x << n) | (trim64(x) >> (64 - n));\n}\n\nstatic Rand64 nextrand (Rand64 *state) {\n  Rand64 state0 = state[0];\n  Rand64 state1 = state[1];\n  Rand64 state2 = state[2] ^ state0;\n  Rand64 state3 = state[3] ^ state1;\n  Rand64 res = rotl(state1 * 5, 7) * 9;\n  state[0] = state0 ^ state3;\n  state[1] = state1 ^ state2;\n  state[2] = state2 ^ (state1 << 17);\n  state[3] = rotl(state3, 45);\n  return res;\n}\n\n\n/*\n** Convert bits from a random integer into a float in the\n** interval [0,1), getting the higher FIG bits from the\n** random unsigned integer and converting that to a float.\n** Some old Microsoft compilers cannot cast an unsigned long\n** to a floating-point number, so we use a signed long as an\n** intermediary. When lua_Number is float or double, the shift ensures\n** that 'sx' is non negative; in that case, a good compiler will remove\n** the correction.\n*/\n\n/* must throw out the extra (64 - FIGS) bits */\n#define shift64_FIG\t(64 - FIGS)\n\n/* 2^(-FIGS) == 2^-1 / 2^(FIGS-1) */\n#define scaleFIG\t(l_mathop(0.5) / ((Rand64)1 << (FIGS - 1)))\n\nstatic lua_Number I2d (Rand64 x) {\n  SRand64 sx = (SRand64)(trim64(x) >> shift64_FIG);\n  lua_Number res = (lua_Number)(sx) * scaleFIG;\n  if (sx < 0)\n    res += l_mathop(1.0);  /* correct the two's complement if negative */\n  lua_assert(0 <= res && res < 1);\n  return res;\n}\n\n/* convert a 'Rand64' to a 'lua_Unsigned' */\n#define I2UInt(x)\t((lua_Unsigned)trim64(x))\n\n/* convert a 'lua_Unsigned' to a 'Rand64' */\n#define Int2I(x)\t((Rand64)(x))\n\n\n#else\t/* no 'Rand64'   }{ */\n\n/* get an integer with at least 32 bits */\n#if LUAI_IS32INT\ntypedef unsigned int lu_int32;\n#else\ntypedef unsigned long lu_int32;\n#endif\n\n\n/*\n** Use two 32-bit integers to represent a 64-bit quantity.\n*/\ntypedef struct Rand64 {\n  lu_int32 h;  /* higher half */\n  lu_int32 l;  /* lower half */\n} Rand64;\n\n\n/*\n** If 'lu_int32' has more than 32 bits, the extra bits do not interfere\n** with the 32 initial bits, except in a right shift and comparisons.\n** Moreover, the final result has to discard the extra bits.\n*/\n\n/* avoid using extra bits when needed */\n#define trim32(x)\t((x) & 0xffffffffu)\n\n\n/*\n** basic operations on 'Rand64' values\n*/\n\n/* build a new Rand64 value */\nstatic Rand64 packI (lu_int32 h, lu_int32 l) {\n  Rand64 result;\n  result.h = h;\n  result.l = l;\n  return result;\n}\n\n/* return i << n */\nstatic Rand64 Ishl (Rand64 i, int n) {\n  lua_assert(n > 0 && n < 32);\n  return packI((i.h << n) | (trim32(i.l) >> (32 - n)), i.l << n);\n}\n\n/* i1 ^= i2 */\nstatic void Ixor (Rand64 *i1, Rand64 i2) {\n  i1->h ^= i2.h;\n  i1->l ^= i2.l;\n}\n\n/* return i1 + i2 */\nstatic Rand64 Iadd (Rand64 i1, Rand64 i2) {\n  Rand64 result = packI(i1.h + i2.h, i1.l + i2.l);\n  if (trim32(result.l) < trim32(i1.l))  /* carry? */\n    result.h++;\n  return result;\n}\n\n/* return i * 5 */\nstatic Rand64 times5 (Rand64 i) {\n  return Iadd(Ishl(i, 2), i);  /* i * 5 == (i << 2) + i */\n}\n\n/* return i * 9 */\nstatic Rand64 times9 (Rand64 i) {\n  return Iadd(Ishl(i, 3), i);  /* i * 9 == (i << 3) + i */\n}\n\n/* return 'i' rotated left 'n' bits */\nstatic Rand64 rotl (Rand64 i, int n) {\n  lua_assert(n > 0 && n < 32);\n  return packI((i.h << n) | (trim32(i.l) >> (32 - n)),\n               (trim32(i.h) >> (32 - n)) | (i.l << n));\n}\n\n/* for offsets larger than 32, rotate right by 64 - offset */\nstatic Rand64 rotl1 (Rand64 i, int n) {\n  lua_assert(n > 32 && n < 64);\n  n = 64 - n;\n  return packI((trim32(i.h) >> n) | (i.l << (32 - n)),\n               (i.h << (32 - n)) | (trim32(i.l) >> n));\n}\n\n/*\n** implementation of 'xoshiro256**' algorithm on 'Rand64' values\n*/\nstatic Rand64 nextrand (Rand64 *state) {\n  Rand64 res = times9(rotl(times5(state[1]), 7));\n  Rand64 t = Ishl(state[1], 17);\n  Ixor(&state[2], state[0]);\n  Ixor(&state[3], state[1]);\n  Ixor(&state[1], state[2]);\n  Ixor(&state[0], state[3]);\n  Ixor(&state[2], t);\n  state[3] = rotl1(state[3], 45);\n  return res;\n}\n\n\n/*\n** Converts a 'Rand64' into a float.\n*/\n\n/* an unsigned 1 with proper type */\n#define UONE\t\t((lu_int32)1)\n\n\n#if FIGS <= 32\n\n/* 2^(-FIGS) */\n#define scaleFIG       (l_mathop(0.5) / (UONE << (FIGS - 1)))\n\n/*\n** get up to 32 bits from higher half, shifting right to\n** throw out the extra bits.\n*/\nstatic lua_Number I2d (Rand64 x) {\n  lua_Number h = (lua_Number)(trim32(x.h) >> (32 - FIGS));\n  return h * scaleFIG;\n}\n\n#else\t/* 32 < FIGS <= 64 */\n\n/* 2^(-FIGS) = 1.0 / 2^30 / 2^3 / 2^(FIGS-33) */\n#define scaleFIG  \\\n    (l_mathop(1.0) / (UONE << 30) / l_mathop(8.0) / (UONE << (FIGS - 33)))\n\n/*\n** use FIGS - 32 bits from lower half, throwing out the other\n** (32 - (FIGS - 32)) = (64 - FIGS) bits\n*/\n#define shiftLOW\t(64 - FIGS)\n\n/*\n** higher 32 bits go after those (FIGS - 32) bits: shiftHI = 2^(FIGS - 32)\n*/\n#define shiftHI\t\t((lua_Number)(UONE << (FIGS - 33)) * l_mathop(2.0))\n\n\nstatic lua_Number I2d (Rand64 x) {\n  lua_Number h = (lua_Number)trim32(x.h) * shiftHI;\n  lua_Number l = (lua_Number)(trim32(x.l) >> shiftLOW);\n  return (h + l) * scaleFIG;\n}\n\n#endif\n\n\n/* convert a 'Rand64' to a 'lua_Unsigned' */\nstatic lua_Unsigned I2UInt (Rand64 x) {\n  return (((lua_Unsigned)trim32(x.h) << 31) << 1) | (lua_Unsigned)trim32(x.l);\n}\n\n/* convert a 'lua_Unsigned' to a 'Rand64' */\nstatic Rand64 Int2I (lua_Unsigned n) {\n  return packI((lu_int32)((n >> 31) >> 1), (lu_int32)n);\n}\n\n#endif  /* } */\n\n\n/*\n** A state uses four 'Rand64' values.\n*/\ntypedef struct {\n  Rand64 s[4];\n} RanState;\n\n\n/*\n** Project the random integer 'ran' into the interval [0, n].\n** Because 'ran' has 2^B possible values, the projection can only be\n** uniform when the size of the interval is a power of 2 (exact\n** division). Otherwise, to get a uniform projection into [0, n], we\n** first compute 'lim', the smallest Mersenne number not smaller than\n** 'n'. We then project 'ran' into the interval [0, lim].  If the result\n** is inside [0, n], we are done. Otherwise, we try with another 'ran',\n** until we have a result inside the interval.\n*/\nstatic lua_Unsigned project (lua_Unsigned ran, lua_Unsigned n,\n                             RanState *state) {\n  if ((n & (n + 1)) == 0)  /* is 'n + 1' a power of 2? */\n    return ran & n;  /* no bias */\n  else {\n    lua_Unsigned lim = n;\n    /* compute the smallest (2^b - 1) not smaller than 'n' */\n    lim |= (lim >> 1);\n    lim |= (lim >> 2);\n    lim |= (lim >> 4);\n    lim |= (lim >> 8);\n    lim |= (lim >> 16);\n#if (LUA_MAXUNSIGNED >> 31) >= 3\n    lim |= (lim >> 32);  /* integer type has more than 32 bits */\n#endif\n    lua_assert((lim & (lim + 1)) == 0  /* 'lim + 1' is a power of 2, */\n      && lim >= n  /* not smaller than 'n', */\n      && (lim >> 1) < n);  /* and it is the smallest one */\n    while ((ran &= lim) > n)  /* project 'ran' into [0..lim] */\n      ran = I2UInt(nextrand(state->s));  /* not inside [0..n]? try again */\n    return ran;\n  }\n}\n\n\nstatic int math_random (lua_State *L) {\n  lua_Integer low, up;\n  lua_Unsigned p;\n  RanState *state = (RanState *)lua_touserdata(L, lua_upvalueindex(1));\n  Rand64 rv = nextrand(state->s);  /* next pseudo-random value */\n  switch (lua_gettop(L)) {  /* check number of arguments */\n    case 0: {  /* no arguments */\n      lua_pushnumber(L, I2d(rv));  /* float between 0 and 1 */\n      return 1;\n    }\n    case 1: {  /* only upper limit */\n      low = 1;\n      up = luaL_checkinteger(L, 1);\n      if (up == 0) {  /* single 0 as argument? */\n        lua_pushinteger(L, I2UInt(rv));  /* full random integer */\n        return 1;\n      }\n      break;\n    }\n    case 2: {  /* lower and upper limits */\n      low = luaL_checkinteger(L, 1);\n      up = luaL_checkinteger(L, 2);\n      break;\n    }\n    default: return luaL_error(L, \"wrong number of arguments\");\n  }\n  /* random integer in the interval [low, up] */\n  luaL_argcheck(L, low <= up, 1, \"interval is empty\");\n  /* project random integer into the interval [0, up - low] */\n  p = project(I2UInt(rv), (lua_Unsigned)up - (lua_Unsigned)low, state);\n  lua_pushinteger(L, p + (lua_Unsigned)low);\n  return 1;\n}\n\n\nstatic void setseed (lua_State *L, Rand64 *state,\n                     lua_Unsigned n1, lua_Unsigned n2) {\n  int i;\n  state[0] = Int2I(n1);\n  state[1] = Int2I(0xff);  /* avoid a zero state */\n  state[2] = Int2I(n2);\n  state[3] = Int2I(0);\n  for (i = 0; i < 16; i++)\n    nextrand(state);  /* discard initial values to \"spread\" seed */\n  lua_pushinteger(L, n1);\n  lua_pushinteger(L, n2);\n}\n\n\nstatic int math_randomseed (lua_State *L) {\n  RanState *state = (RanState *)lua_touserdata(L, lua_upvalueindex(1));\n  lua_Unsigned n1, n2;\n  if (lua_isnone(L, 1)) {\n    n1 = luaL_makeseed(L);  /* \"random\" seed */\n    n2 = I2UInt(nextrand(state->s));  /* in case seed is not that random... */\n  }\n  else {\n    n1 = luaL_checkinteger(L, 1);\n    n2 = luaL_optinteger(L, 2, 0);\n  }\n  setseed(L, state->s, n1, n2);\n  return 2;  /* return seeds */\n}\n\n\nstatic const luaL_Reg randfuncs[] = {\n  {\"random\", math_random},\n  {\"randomseed\", math_randomseed},\n  {NULL, NULL}\n};\n\n\n/*\n** Register the random functions and initialize their state.\n*/\nstatic void setrandfunc (lua_State *L) {\n  RanState *state = (RanState *)lua_newuserdatauv(L, sizeof(RanState), 0);\n  setseed(L, state->s, luaL_makeseed(L), 0);  /* initialize with random seed */\n  lua_pop(L, 2);  /* remove pushed seeds */\n  luaL_setfuncs(L, randfuncs, 1);\n}\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Deprecated functions (for compatibility only)\n** ===================================================================\n*/\n#if defined(LUA_COMPAT_MATHLIB)\n\nstatic int math_cosh (lua_State *L) {\n  lua_pushnumber(L, l_mathop(cosh)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_sinh (lua_State *L) {\n  lua_pushnumber(L, l_mathop(sinh)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_tanh (lua_State *L) {\n  lua_pushnumber(L, l_mathop(tanh)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_pow (lua_State *L) {\n  lua_Number x = luaL_checknumber(L, 1);\n  lua_Number y = luaL_checknumber(L, 2);\n  lua_pushnumber(L, l_mathop(pow)(x, y));\n  return 1;\n}\n\nstatic int math_frexp (lua_State *L) {\n  int e;\n  lua_pushnumber(L, l_mathop(frexp)(luaL_checknumber(L, 1), &e));\n  lua_pushinteger(L, e);\n  return 2;\n}\n\nstatic int math_ldexp (lua_State *L) {\n  lua_Number x = luaL_checknumber(L, 1);\n  int ep = (int)luaL_checkinteger(L, 2);\n  lua_pushnumber(L, l_mathop(ldexp)(x, ep));\n  return 1;\n}\n\nstatic int math_log10 (lua_State *L) {\n  lua_pushnumber(L, l_mathop(log10)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\n#endif\n/* }================================================================== */\n\n\n\nstatic const luaL_Reg mathlib[] = {\n  {\"abs\",   math_abs},\n  {\"acos\",  math_acos},\n  {\"asin\",  math_asin},\n  {\"atan\",  math_atan},\n  {\"ceil\",  math_ceil},\n  {\"cos\",   math_cos},\n  {\"deg\",   math_deg},\n  {\"exp\",   math_exp},\n  {\"tointeger\", math_toint},\n  {\"floor\", math_floor},\n  {\"fmod\",   math_fmod},\n  {\"ult\",   math_ult},\n  {\"log\",   math_log},\n  {\"max\",   math_max},\n  {\"min\",   math_min},\n  {\"modf\",   math_modf},\n  {\"rad\",   math_rad},\n  {\"sin\",   math_sin},\n  {\"sqrt\",  math_sqrt},\n  {\"tan\",   math_tan},\n  {\"type\", math_type},\n#if defined(LUA_COMPAT_MATHLIB)\n  {\"atan2\", math_atan},\n  {\"cosh\",   math_cosh},\n  {\"sinh\",   math_sinh},\n  {\"tanh\",   math_tanh},\n  {\"pow\",   math_pow},\n  {\"frexp\", math_frexp},\n  {\"ldexp\", math_ldexp},\n  {\"log10\", math_log10},\n#endif\n  /* placeholders */\n  {\"random\", NULL},\n  {\"randomseed\", NULL},\n  {\"pi\", NULL},\n  {\"huge\", NULL},\n  {\"maxinteger\", NULL},\n  {\"mininteger\", NULL},\n  {NULL, NULL}\n};\n\n\n/*\n** Open math library\n*/\nLUAMOD_API int luaopen_math (lua_State *L) {\n  luaL_newlib(L, mathlib);\n  lua_pushnumber(L, PI);\n  lua_setfield(L, -2, \"pi\");\n  lua_pushnumber(L, (lua_Number)HUGE_VAL);\n  lua_setfield(L, -2, \"huge\");\n  lua_pushinteger(L, LUA_MAXINTEGER);\n  lua_setfield(L, -2, \"maxinteger\");\n  lua_pushinteger(L, LUA_MININTEGER);\n  lua_setfield(L, -2, \"mininteger\");\n  setrandfunc(L);\n  return 1;\n}\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lmem.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: lmem.c $\n** Interface to Memory Manager\n** See Copyright Notice in lua.h\n*/\n\n#define lmem_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <stddef.h>\n\n#include \"lua.h\"\n\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n\n\n\n/*\n** About the realloc function:\n** void *frealloc (void *ud, void *ptr, size_t osize, size_t nsize);\n** ('osize' is the old size, 'nsize' is the new size)\n**\n** - frealloc(ud, p, x, 0) frees the block 'p' and returns NULL.\n** Particularly, frealloc(ud, NULL, 0, 0) does nothing,\n** which is equivalent to free(NULL) in ISO C.\n**\n** - frealloc(ud, NULL, x, s) creates a new block of size 's'\n** (no matter 'x'). Returns NULL if it cannot create the new block.\n**\n** - otherwise, frealloc(ud, b, x, y) reallocates the block 'b' from\n** size 'x' to size 'y'. Returns NULL if it cannot reallocate the\n** block to the new size.\n*/\n\n\n/*\n** Macro to call the allocation function.\n*/\n#define callfrealloc(g,block,os,ns)    ((*g->frealloc)(g->ud, block, os, ns))\n\n\n/*\n** When an allocation fails, it will try again after an emergency\n** collection, except when it cannot run a collection.  The GC should\n** not be called while the state is not fully built, as the collector\n** is not yet fully initialized. Also, it should not be called when\n** 'gcstopem' is true, because then the interpreter is in the middle of\n** a collection step.\n*/\n#define cantryagain(g)\t(completestate(g) && !g->gcstopem)\n\n\n\n\n#if defined(EMERGENCYGCTESTS)\n/*\n** First allocation will fail except when freeing a block (frees never\n** fail) and when it cannot try again; this fail will trigger 'tryagain'\n** and a full GC cycle at every allocation.\n*/\nstatic void *firsttry (global_State *g, void *block, size_t os, size_t ns) {\n  if (ns > 0 && cantryagain(g))\n    return NULL;  /* fail */\n  else  /* normal allocation */\n    return callfrealloc(g, block, os, ns);\n}\n#else\n#define firsttry(g,block,os,ns)    callfrealloc(g, block, os, ns)\n#endif\n\n\n\n\n\n/*\n** {==================================================================\n** Functions to allocate/deallocate arrays for the Parser\n** ===================================================================\n*/\n\n/*\n** Minimum size for arrays during parsing, to avoid overhead of\n** reallocating to size 1, then 2, and then 4. All these arrays\n** will be reallocated to exact sizes or erased when parsing ends.\n*/\n#define MINSIZEARRAY\t4\n\n\nvoid *luaM_growaux_ (lua_State *L, void *block, int nelems, int *psize,\n                     int size_elems, int limit, const char *what) {\n  void *newblock;\n  int size = *psize;\n  if (nelems + 1 <= size)  /* does one extra element still fit? */\n    return block;  /* nothing to be done */\n  if (size >= limit / 2) {  /* cannot double it? */\n    if (l_unlikely(size >= limit))  /* cannot grow even a little? */\n      luaG_runerror(L, \"too many %s (limit is %d)\", what, limit);\n    size = limit;  /* still have at least one free place */\n  }\n  else {\n    size *= 2;\n    if (size < MINSIZEARRAY)\n      size = MINSIZEARRAY;  /* minimum size */\n  }\n  lua_assert(nelems + 1 <= size && size <= limit);\n  /* 'limit' ensures that multiplication will not overflow */\n  newblock = luaM_saferealloc_(L, block, cast_sizet(*psize) * size_elems,\n                                         cast_sizet(size) * size_elems);\n  *psize = size;  /* update only when everything else is OK */\n  return newblock;\n}\n\n\n/*\n** In prototypes, the size of the array is also its number of\n** elements (to save memory). So, if it cannot shrink an array\n** to its number of elements, the only option is to raise an\n** error.\n*/\nvoid *luaM_shrinkvector_ (lua_State *L, void *block, int *size,\n                          int final_n, int size_elem) {\n  void *newblock;\n  size_t oldsize = cast_sizet((*size) * size_elem);\n  size_t newsize = cast_sizet(final_n * size_elem);\n  lua_assert(newsize <= oldsize);\n  newblock = luaM_saferealloc_(L, block, oldsize, newsize);\n  *size = final_n;\n  return newblock;\n}\n\n/* }================================================================== */\n\n\nl_noret luaM_toobig (lua_State *L) {\n  luaG_runerror(L, \"memory allocation private_lua_error: block too big\");\n}\n\n\n/*\n** Free memory\n*/\nvoid luaM_free_ (lua_State *L, void *block, size_t osize) {\n  global_State *g = G(L);\n  lua_assert((osize == 0) == (block == NULL));\n  callfrealloc(g, block, osize, 0);\n  g->totalbytes -= osize;\n}\n\n\n/*\n** In case of allocation fail, this function will do an emergency\n** collection to free some memory and then try the allocation again.\n*/\nstatic void *tryagain (lua_State *L, void *block,\n                       size_t osize, size_t nsize) {\n  global_State *g = G(L);\n  if (cantryagain(g)) {\n    luaC_fullgc(L, 1);  /* try to free some memory... */\n    return callfrealloc(g, block, osize, nsize);  /* try again */\n  }\n  else return NULL;  /* cannot run an emergency collection */\n}\n\n\n/*\n** Generic allocation routine.\n*/\nvoid *luaM_realloc_ (lua_State *L, void *block, size_t osize, size_t nsize) {\n  void *newblock;\n  global_State *g = G(L);\n  lua_assert((osize == 0) == (block == NULL));\n  newblock = firsttry(g, block, osize, nsize);\n  if (l_unlikely(newblock == NULL && nsize > 0)) {\n    newblock = tryagain(L, block, osize, nsize);\n    if (newblock == NULL)  /* still no memory? */\n      return NULL;  /* do not update 'totalbytes' */\n  }\n  lua_assert((nsize == 0) == (newblock == NULL));\n  g->totalbytes += nsize - osize;\n  return newblock;\n}\n\n\nvoid *luaM_saferealloc_ (lua_State *L, void *block, size_t osize,\n                                                    size_t nsize) {\n  void *newblock = luaM_realloc_(L, block, osize, nsize);\n  if (l_unlikely(newblock == NULL && nsize > 0))  /* allocation failed? */\n    luaM_error(L);\n  return newblock;\n}\n\n\nvoid *luaM_malloc_ (lua_State *L, size_t size, int tag) {\n  if (size == 0)\n    return NULL;  /* that's all */\n  else {\n    global_State *g = G(L);\n    void *newblock = firsttry(g, NULL, tag, size);\n    if (l_unlikely(newblock == NULL)) {\n      newblock = tryagain(L, NULL, tag, size);\n      if (newblock == NULL)\n        luaM_error(L);\n    }\n    g->totalbytes += size;\n    return newblock;\n  }\n}\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lmem.h",
		"is_binary":	false,
		"content":	"/*\n** $Id: lmem.h $\n** Interface to Memory Manager\n** See Copyright Notice in lua.h\n*/\n\n#ifndef lmem_h\n#define lmem_h\n\n\n#include <stddef.h>\n\n#include \"llimits.h\"\n#include \"lua.h\"\n\n\n#define luaM_error(L)\tluaD_throw(L, LUA_ERRMEM)\n\n\n/*\n** This macro tests whether it is safe to multiply 'n' by the size of\n** type 't' without overflows. Because 'e' is always constant, it avoids\n** the runtime division MAX_SIZET/(e).\n** (The macro is somewhat complex to avoid warnings:  The 'sizeof'\n** comparison avoids a runtime comparison when overflow cannot occur.\n** The compiler should be able to optimize the real test by itself, but\n** when it does it, it may give a warning about \"comparison is always\n** false due to limited range of data type\"; the +1 tricks the compiler,\n** avoiding this warning but also this optimization.)\n*/\n#define luaM_testsize(n,e)  \\\n\t(sizeof(n) >= sizeof(size_t) && cast_sizet((n)) + 1 > MAX_SIZET/(e))\n\n#define luaM_checksize(L,n,e)  \\\n\t(luaM_testsize(n,e) ? luaM_toobig(L) : cast_void(0))\n\n\n/*\n** Computes the minimum between 'n' and 'MAX_SIZET/sizeof(t)', so that\n** the result is not larger than 'n' and cannot overflow a 'size_t'\n** when multiplied by the size of type 't'. (Assumes that 'n' is an\n** 'int' or 'unsigned int' and that 'int' is not larger than 'size_t'.)\n*/\n#define luaM_limitN(n,t)  \\\n  ((cast_sizet(n) <= MAX_SIZET/sizeof(t)) ? (n) :  \\\n     cast_uint((MAX_SIZET/sizeof(t))))\n\n\n/*\n** Arrays of chars do not need any test\n*/\n#define luaM_reallocvchar(L,b,on,n)  \\\n  cast_charp(luaM_saferealloc_(L, (b), (on)*sizeof(char), (n)*sizeof(char)))\n\n#define luaM_freemem(L, b, s)\tluaM_free_(L, (b), (s))\n#define luaM_free(L, b)\t\tluaM_free_(L, (b), sizeof(*(b)))\n#define luaM_freearray(L, b, n)   luaM_free_(L, (b), (n)*sizeof(*(b)))\n\n#define luaM_new(L,t)\t\tcast(t*, luaM_malloc_(L, sizeof(t), 0))\n#define luaM_newvector(L,n,t)\tcast(t*, luaM_malloc_(L, (n)*sizeof(t), 0))\n#define luaM_newvectorchecked(L,n,t) \\\n  (luaM_checksize(L,n,sizeof(t)), luaM_newvector(L,n,t))\n\n#define luaM_newobject(L,tag,s)\tluaM_malloc_(L, (s), tag)\n\n#define luaM_newblock(L, size)\tluaM_newvector(L, size, char)\n\n#define luaM_growvector(L,v,nelems,size,t,limit,e) \\\n\t((v)=cast(t *, luaM_growaux_(L,v,nelems,&(size),sizeof(t), \\\n                         luaM_limitN(limit,t),e)))\n\n#define luaM_reallocvector(L, v,oldn,n,t) \\\n   (cast(t *, luaM_realloc_(L, v, cast_sizet(oldn) * sizeof(t), \\\n                                  cast_sizet(n) * sizeof(t))))\n\n#define luaM_shrinkvector(L,v,size,fs,t) \\\n   ((v)=cast(t *, luaM_shrinkvector_(L, v, &(size), fs, sizeof(t))))\n\nLUAI_FUNC l_noret luaM_toobig (lua_State *L);\n\n/* not to be called directly */\nLUAI_FUNC void *luaM_realloc_ (lua_State *L, void *block, size_t oldsize,\n                                                          size_t size);\nLUAI_FUNC void *luaM_saferealloc_ (lua_State *L, void *block, size_t oldsize,\n                                                              size_t size);\nLUAI_FUNC void luaM_free_ (lua_State *L, void *block, size_t osize);\nLUAI_FUNC void *luaM_growaux_ (lua_State *L, void *block, int nelems,\n                               int *size, int size_elem, int limit,\n                               const char *what);\nLUAI_FUNC void *luaM_shrinkvector_ (lua_State *L, void *block, int *nelem,\n                                    int final_n, int size_elem);\nLUAI_FUNC void *luaM_malloc_ (lua_State *L, size_t size, int tag);\n\n#endif\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/loadlib.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: loadlib.c $\n** Dynamic library loader for Lua\n** See Copyright Notice in lua.h\n**\n** This module contains an implementation of loadlib for Unix systems\n** that have dlfcn, an implementation for Windows, and a stub for other\n** systems.\n*/\n\n#define loadlib_c\n#define LUA_LIB\n\n#include \"lprefix.h\"\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n\n\n/*\n** LUA_CSUBSEP is the character that replaces dots in submodule names\n** when searching for a C loader.\n** LUA_LSUBSEP is the character that replaces dots in submodule names\n** when searching for a Lua loader.\n*/\n#if !defined(LUA_CSUBSEP)\n#define LUA_CSUBSEP\t\tLUA_DIRSEP\n#endif\n\n#if !defined(LUA_LSUBSEP)\n#define LUA_LSUBSEP\t\tLUA_DIRSEP\n#endif\n\n\n/* prefix for open functions in C libraries */\n#define LUA_POF\t\t\"luaopen_\"\n\n/* separator for open functions in C libraries */\n#define LUA_OFSEP\t\"_\"\n\n\n/*\n** key for table in the registry that keeps handles\n** for all loaded C libraries\n*/\nstatic const char *const CLIBS = \"_CLIBS\";\n\n#define LIB_FAIL\t\"open\"\n\n\n#define setprogdir(L)           ((void)0)\n\n\n/*\n** Special type equivalent to '(void*)' for functions in gcc\n** (to suppress warnings when converting function pointers)\n*/\ntypedef void (*voidf)(void);\n\n\n/*\n** system-dependent functions\n*/\n\n/*\n** unload library 'lib'\n*/\nstatic void lsys_unloadlib (void *lib);\n\n/*\n** load C library in file 'path'. If 'seeglb', load with all names in\n** the library global.\n** Returns the library; in case of error, returns NULL plus an\n** error string in the stack.\n*/\nstatic void *lsys_load (lua_State *L, const char *path, int seeglb);\n\n/*\n** Try to find a function named 'sym' in library 'lib'.\n** Returns the function; in case of error, returns NULL plus an\n** error string in the stack.\n*/\nstatic lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym);\n\n\n\n\n#if defined(LUA_USE_DLOPEN)\t/* { */\n/*\n** {========================================================================\n** This is an implementation of loadlib based on the dlfcn interface.\n** The dlfcn interface is available in Linux, SunOS, Solaris, IRIX, FreeBSD,\n** NetBSD, AIX 4.2, HPUX 11, and  probably most other Unix flavors, at least\n** as an emulation layer on top of native functions.\n** =========================================================================\n*/\n\n#include <dlfcn.h>\n\n/*\n** Macro to convert pointer-to-void* to pointer-to-function. This cast\n** is undefined according to ISO C, but POSIX assumes that it works.\n** (The '__extension__' in gnu compilers is only to avoid warnings.)\n*/\n#if defined(__GNUC__)\n#define cast_func(p) (__extension__ (lua_CFunction)(p))\n#else\n#define cast_func(p) ((lua_CFunction)(p))\n#endif\n\n\nstatic void lsys_unloadlib (void *lib) {\n  dlclose(lib);\n}\n\n\nstatic void *lsys_load (lua_State *L, const char *path, int seeglb) {\n  void *lib = dlopen(path, RTLD_NOW | (seeglb ? RTLD_GLOBAL : RTLD_LOCAL));\n  if (l_unlikely(lib == NULL))\n    lua_pushstring(L, dlerror());\n  return lib;\n}\n\n\nstatic lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym) {\n  lua_CFunction f = cast_func(dlsym(lib, sym));\n  if (l_unlikely(f == NULL))\n    lua_pushstring(L, dlerror());\n  return f;\n}\n\n/* }====================================================== */\n\n\n\n#elif defined(LUA_DL_DLL)\t/* }{ */\n/*\n** {======================================================================\n** This is an implementation of loadlib for Windows using native functions.\n** =======================================================================\n*/\n\n#include <windows.h>\n\n\n/*\n** optional flags for LoadLibraryEx\n*/\n#if !defined(LUA_LLE_FLAGS)\n#define LUA_LLE_FLAGS\t0\n#endif\n\n\n#undef setprogdir\n\n\n/*\n** Replace in the path (on the top of the stack) any occurrence\n** of LUA_EXEC_DIR with the executable's path.\n*/\nstatic void setprogdir (lua_State *L) {\n  char buff[MAX_PATH + 1];\n  char *lb;\n  DWORD nsize = sizeof(buff)/sizeof(char);\n  DWORD n = GetModuleFileNameA(NULL, buff, nsize);  /* get exec. name */\n  if (n == 0 || n == nsize || (lb = strrchr(buff, '\\\\')) == NULL)\n    luaL_error(L, \"unable to get ModuleFileName\");\n  else {\n    *lb = '\\0';  /* cut name on the last '\\\\' to get the path */\n    luaL_gsub(L, lua_tostring(L, -1), LUA_EXEC_DIR, buff);\n    lua_remove(L, -2);  /* remove original string */\n  }\n}\n\n\n\n\nstatic void pusherror (lua_State *L) {\n  int error = GetLastError();\n  char buffer[128];\n  if (FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,\n      NULL, error, 0, buffer, sizeof(buffer)/sizeof(char), NULL))\n    lua_pushstring(L, buffer);\n  else\n    lua_pushfstring(L, \"system error %d\\n\", error);\n}\n\nstatic void lsys_unloadlib (void *lib) {\n  FreeLibrary((HMODULE)lib);\n}\n\n\nstatic void *lsys_load (lua_State *L, const char *path, int seeglb) {\n  HMODULE lib = LoadLibraryExA(path, NULL, LUA_LLE_FLAGS);\n  (void)(seeglb);  /* not used: symbols are 'global' by default */\n  if (lib == NULL) pusherror(L);\n  return lib;\n}\n\n\nstatic lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym) {\n  lua_CFunction f = (lua_CFunction)(voidf)GetProcAddress((HMODULE)lib, sym);\n  if (f == NULL) pusherror(L);\n  return f;\n}\n\n/* }====================================================== */\n\n\n#else\t\t\t\t/* }{ */\n/*\n** {======================================================\n** Fallback for other systems\n** =======================================================\n*/\n\n#undef LIB_FAIL\n#define LIB_FAIL\t\"absent\"\n\n\n#define DLMSG\t\"dynamic libraries not enabled; check your Lua installation\"\n\n\nstatic void lsys_unloadlib (void *lib) {\n  (void)(lib);  /* not used */\n}\n\n\nstatic void *lsys_load (lua_State *L, const char *path, int seeglb) {\n  (void)(path); (void)(seeglb);  /* not used */\n  lua_pushliteral(L, DLMSG);\n  return NULL;\n}\n\n\nstatic lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym) {\n  (void)(lib); (void)(sym);  /* not used */\n  lua_pushliteral(L, DLMSG);\n  return NULL;\n}\n\n/* }====================================================== */\n#endif\t\t\t\t/* } */\n\n\n/*\n** {==================================================================\n** Set Paths\n** ===================================================================\n*/\n\n/*\n** LUA_PATH_VAR and LUA_CPATH_VAR are the names of the environment\n** variables that Lua check to set its paths.\n*/\n#if !defined(LUA_PATH_VAR)\n#define LUA_PATH_VAR    \"LUA_PATH\"\n#endif\n\n#if !defined(LUA_CPATH_VAR)\n#define LUA_CPATH_VAR   \"LUA_CPATH\"\n#endif\n\n\n\n/*\n** return registry.LUA_NOENV as a boolean\n*/\nstatic int noenv (lua_State *L) {\n  int b;\n  lua_getfield(L, LUA_REGISTRYINDEX, \"LUA_NOENV\");\n  b = lua_toboolean(L, -1);\n  lua_pop(L, 1);  /* remove value */\n  return b;\n}\n\n\n/*\n** Set a path. (If using the default path, assume it is a string\n** literal in C and create it as an external string.)\n*/\nstatic void setpath (lua_State *L, const char *fieldname,\n                                   const char *envname,\n                                   const char *dft) {\n  const char *dftmark;\n  const char *nver = lua_pushfstring(L, \"%s%s\", envname, LUA_VERSUFFIX);\n  const char *path = getenv(nver);  /* try versioned name */\n  if (path == NULL)  /* no versioned environment variable? */\n    path = getenv(envname);  /* try unversioned name */\n  if (path == NULL || noenv(L))  /* no environment variable? */\n    lua_pushextlstring(L, dft, strlen(dft), NULL, NULL);  /* use default */\n  else if ((dftmark = strstr(path, LUA_PATH_SEP LUA_PATH_SEP)) == NULL)\n    lua_pushstring(L, path);  /* nothing to change */\n  else {  /* path contains a \";;\": insert default path in its place */\n    size_t len = strlen(path);\n    luaL_Buffer b;\n    luaL_buffinit(L, &b);\n    if (path < dftmark) {  /* is there a prefix before ';;'? */\n      luaL_addlstring(&b, path, dftmark - path);  /* add it */\n      luaL_addchar(&b, *LUA_PATH_SEP);\n    }\n    luaL_addstring(&b, dft);  /* add default */\n    if (dftmark < path + len - 2) {  /* is there a suffix after ';;'? */\n      luaL_addchar(&b, *LUA_PATH_SEP);\n      luaL_addlstring(&b, dftmark + 2, (path + len - 2) - dftmark);\n    }\n    luaL_pushresult(&b);\n  }\n  setprogdir(L);\n  lua_setfield(L, -3, fieldname);  /* package[fieldname] = path value */\n  lua_pop(L, 1);  /* pop versioned variable name ('nver') */\n}\n\n/* }================================================================== */\n\n\n/*\n** return registry.CLIBS[path]\n*/\nstatic void *checkclib (lua_State *L, const char *path) {\n  void *plib;\n  lua_getfield(L, LUA_REGISTRYINDEX, CLIBS);\n  lua_getfield(L, -1, path);\n  plib = lua_touserdata(L, -1);  /* plib = CLIBS[path] */\n  lua_pop(L, 2);  /* pop CLIBS table and 'plib' */\n  return plib;\n}\n\n\n/*\n** registry.CLIBS[path] = plib        -- for queries\n** registry.CLIBS[#CLIBS + 1] = plib  -- also keep a list of all libraries\n*/\nstatic void addtoclib (lua_State *L, const char *path, void *plib) {\n  lua_getfield(L, LUA_REGISTRYINDEX, CLIBS);\n  lua_pushlightuserdata(L, plib);\n  lua_pushvalue(L, -1);\n  lua_setfield(L, -3, path);  /* CLIBS[path] = plib */\n  lua_rawseti(L, -2, luaL_len(L, -2) + 1);  /* CLIBS[#CLIBS + 1] = plib */\n  lua_pop(L, 1);  /* pop CLIBS table */\n}\n\n\n/*\n** __gc tag method for CLIBS table: calls 'lsys_unloadlib' for all lib\n** handles in list CLIBS\n*/\nstatic int gctm (lua_State *L) {\n  lua_Integer n = luaL_len(L, 1);\n  for (; n >= 1; n--) {  /* for each handle, in reverse order */\n    lua_rawgeti(L, 1, n);  /* get handle CLIBS[n] */\n    lsys_unloadlib(lua_touserdata(L, -1));\n    lua_pop(L, 1);  /* pop handle */\n  }\n  return 0;\n}\n\n\n\n/* error codes for 'lookforfunc' */\n#define ERRLIB\t\t1\n#define ERRFUNC\t\t2\n\n/*\n** Look for a C function named 'sym' in a dynamically loaded library\n** 'path'.\n** First, check whether the library is already loaded; if not, try\n** to load it.\n** Then, if 'sym' is '*', return true (as library has been loaded).\n** Otherwise, look for symbol 'sym' in the library and push a\n** C function with that symbol.\n** Return 0 and 'true' or a function in the stack; in case of\n** errors, return an error code and an error message in the stack.\n*/\nstatic int lookforfunc (lua_State *L, const char *path, const char *sym) {\n  void *reg = checkclib(L, path);  /* check loaded C libraries */\n  if (reg == NULL) {  /* must load library? */\n    reg = lsys_load(L, path, *sym == '*');  /* global symbols if 'sym'=='*' */\n    if (reg == NULL) return ERRLIB;  /* unable to load library */\n    addtoclib(L, path, reg);\n  }\n  if (*sym == '*') {  /* loading only library (no function)? */\n    lua_pushboolean(L, 1);  /* return 'true' */\n    return 0;  /* no errors */\n  }\n  else {\n    lua_CFunction f = lsys_sym(L, reg, sym);\n    if (f == NULL)\n      return ERRFUNC;  /* unable to find function */\n    lua_pushcfunction(L, f);  /* else create new function */\n    return 0;  /* no errors */\n  }\n}\n\n\nstatic int ll_loadlib (lua_State *L) {\n  const char *path = luaL_checkstring(L, 1);\n  const char *init = luaL_checkstring(L, 2);\n  int stat = lookforfunc(L, path, init);\n  if (l_likely(stat == 0))  /* no errors? */\n    return 1;  /* return the loaded function */\n  else {  /* error; error message is on stack top */\n    luaL_pushfail(L);\n    lua_insert(L, -2);\n    lua_pushstring(L, (stat == ERRLIB) ?  LIB_FAIL : \"init\");\n    return 3;  /* return fail, error message, and where */\n  }\n}\n\n\n\n/*\n** {======================================================\n** 'require' function\n** =======================================================\n*/\n\n\nstatic int readable (const char *filename) {\n  FILE *f = fopen(filename, \"r\");  /* try to open file */\n  if (f == NULL) return 0;  /* open failed */\n  fclose(f);\n  return 1;\n}\n\n\n/*\n** Get the next name in '*path' = 'name1;name2;name3;...', changing\n** the ending ';' to '\\0' to create a zero-terminated string. Return\n** NULL when list ends.\n*/\nstatic const char *getnextfilename (char **path, char *end) {\n  char *sep;\n  char *name = *path;\n  if (name == end)\n    return NULL;  /* no more names */\n  else if (*name == '\\0') {  /* from previous iteration? */\n    *name = *LUA_PATH_SEP;  /* restore separator */\n    name++;  /* skip it */\n  }\n  sep = strchr(name, *LUA_PATH_SEP);  /* find next separator */\n  if (sep == NULL)  /* separator not found? */\n    sep = end;  /* name goes until the end */\n  *sep = '\\0';  /* finish file name */\n  *path = sep;  /* will start next search from here */\n  return name;\n}\n\n\n/*\n** Given a path such as \";blabla.so;blublu.so\", pushes the string\n**\n** no file 'blabla.so'\n**\tno file 'blublu.so'\n*/\nstatic void pusherrornotfound (lua_State *L, const char *path) {\n  luaL_Buffer b;\n  luaL_buffinit(L, &b);\n  luaL_addstring(&b, \"no file '\");\n  luaL_addgsub(&b, path, LUA_PATH_SEP, \"'\\n\\tno file '\");\n  luaL_addstring(&b, \"'\");\n  luaL_pushresult(&b);\n}\n\n\nstatic const char *searchpath (lua_State *L, const char *name,\n                                             const char *path,\n                                             const char *sep,\n                                             const char *dirsep) {\n  luaL_Buffer buff;\n  char *pathname;  /* path with name inserted */\n  char *endpathname;  /* its end */\n  const char *filename;\n  /* separator is non-empty and appears in 'name'? */\n  if (*sep != '\\0' && strchr(name, *sep) != NULL)\n    name = luaL_gsub(L, name, sep, dirsep);  /* replace it by 'dirsep' */\n  luaL_buffinit(L, &buff);\n  /* add path to the buffer, replacing marks ('?') with the file name */\n  luaL_addgsub(&buff, path, LUA_PATH_MARK, name);\n  luaL_addchar(&buff, '\\0');\n  pathname = luaL_buffaddr(&buff);  /* writable list of file names */\n  endpathname = pathname + luaL_bufflen(&buff) - 1;\n  while ((filename = getnextfilename(&pathname, endpathname)) != NULL) {\n    if (readable(filename))  /* does file exist and is readable? */\n      return lua_pushstring(L, filename);  /* save and return name */\n  }\n  luaL_pushresult(&buff);  /* push path to create error message */\n  pusherrornotfound(L, lua_tostring(L, -1));  /* create error message */\n  return NULL;  /* not found */\n}\n\n\nstatic int ll_searchpath (lua_State *L) {\n  const char *f = searchpath(L, luaL_checkstring(L, 1),\n                                luaL_checkstring(L, 2),\n                                luaL_optstring(L, 3, \".\"),\n                                luaL_optstring(L, 4, LUA_DIRSEP));\n  if (f != NULL) return 1;\n  else {  /* error message is on top of the stack */\n    luaL_pushfail(L);\n    lua_insert(L, -2);\n    return 2;  /* return fail + error message */\n  }\n}\n\n\nstatic const char *findfile (lua_State *L, const char *name,\n                                           const char *pname,\n                                           const char *dirsep) {\n  const char *path;\n  lua_getfield(L, lua_upvalueindex(1), pname);\n  path = lua_tostring(L, -1);\n  if (l_unlikely(path == NULL))\n    luaL_error(L, \"'package.%s' must be a string\", pname);\n  return searchpath(L, name, path, \".\", dirsep);\n}\n\n\nstatic int checkload (lua_State *L, int stat, const char *filename) {\n  if (l_likely(stat)) {  /* module loaded successfully? */\n    lua_pushstring(L, filename);  /* will be 2nd argument to module */\n    return 2;  /* return open function and file name */\n  }\n  else\n    return luaL_error(L, \"error loading module '%s' from file '%s':\\n\\t%s\",\n                          lua_tostring(L, 1), filename, lua_tostring(L, -1));\n}\n\n\nstatic int searcher_Lua (lua_State *L) {\n  const char *filename;\n  const char *name = luaL_checkstring(L, 1);\n  filename = findfile(L, name, \"path\", LUA_LSUBSEP);\n  if (filename == NULL) return 1;  /* module not found in this path */\n  return checkload(L, (luaL_loadfile(L, filename) == LUA_OK), filename);\n}\n\n\n/*\n** Try to find a load function for module 'modname' at file 'filename'.\n** First, change '.' to '_' in 'modname'; then, if 'modname' has\n** the form X-Y (that is, it has an \"ignore mark\"), build a function\n** name \"luaopen_X\" and look for it. (For compatibility, if that\n** fails, it also tries \"luaopen_Y\".) If there is no ignore mark,\n** look for a function named \"luaopen_modname\".\n*/\nstatic int loadfunc (lua_State *L, const char *filename, const char *modname) {\n  const char *openfunc;\n  const char *mark;\n  modname = luaL_gsub(L, modname, \".\", LUA_OFSEP);\n  mark = strchr(modname, *LUA_IGMARK);\n  if (mark) {\n    int stat;\n    openfunc = lua_pushlstring(L, modname, mark - modname);\n    openfunc = lua_pushfstring(L, LUA_POF\"%s\", openfunc);\n    stat = lookforfunc(L, filename, openfunc);\n    if (stat != ERRFUNC) return stat;\n    modname = mark + 1;  /* else go ahead and try old-style name */\n  }\n  openfunc = lua_pushfstring(L, LUA_POF\"%s\", modname);\n  return lookforfunc(L, filename, openfunc);\n}\n\n\nstatic int searcher_C (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  const char *filename = findfile(L, name, \"cpath\", LUA_CSUBSEP);\n  if (filename == NULL) return 1;  /* module not found in this path */\n  return checkload(L, (loadfunc(L, filename, name) == 0), filename);\n}\n\n\nstatic int searcher_Croot (lua_State *L) {\n  const char *filename;\n  const char *name = luaL_checkstring(L, 1);\n  const char *p = strchr(name, '.');\n  int stat;\n  if (p == NULL) return 0;  /* is root */\n  lua_pushlstring(L, name, p - name);\n  filename = findfile(L, lua_tostring(L, -1), \"cpath\", LUA_CSUBSEP);\n  if (filename == NULL) return 1;  /* root not found */\n  if ((stat = loadfunc(L, filename, name)) != 0) {\n    if (stat != ERRFUNC)\n      return checkload(L, 0, filename);  /* real error */\n    else {  /* open function not found */\n      lua_pushfstring(L, \"no module '%s' in file '%s'\", name, filename);\n      return 1;\n    }\n  }\n  lua_pushstring(L, filename);  /* will be 2nd argument to module */\n  return 2;\n}\n\n\nstatic int searcher_preload (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  lua_getfield(L, LUA_REGISTRYINDEX, LUA_PRELOAD_TABLE);\n  if (lua_getfield(L, -1, name) == LUA_TNIL) {  /* not found? */\n    lua_pushfstring(L, \"no field package.preload['%s']\", name);\n    return 1;\n  }\n  else {\n    lua_pushliteral(L, \":preload:\");\n    return 2;\n  }\n}\n\n\nstatic void findloader (lua_State *L, const char *name) {\n  int i;\n  luaL_Buffer msg;  /* to build error message */\n  /* push 'package.searchers' to index 3 in the stack */\n  if (l_unlikely(lua_getfield(L, lua_upvalueindex(1), \"searchers\")\n                 != LUA_TTABLE))\n    luaL_error(L, \"'package.searchers' must be a table\");\n  luaL_buffinit(L, &msg);\n  /*  iterate over available searchers to find a loader */\n  for (i = 1; ; i++) {\n    luaL_addstring(&msg, \"\\n\\t\");  /* error-message prefix */\n    if (l_unlikely(lua_rawgeti(L, 3, i) == LUA_TNIL)) {  /* no more searchers? */\n      lua_pop(L, 1);  /* remove nil */\n      luaL_buffsub(&msg, 2);  /* remove prefix */\n      luaL_pushresult(&msg);  /* create error message */\n      luaL_error(L, \"module '%s' not found:%s\", name, lua_tostring(L, -1));\n    }\n    lua_pushstring(L, name);\n    lua_call(L, 1, 2);  /* call it */\n    if (lua_isfunction(L, -2))  /* did it find a loader? */\n      return;  /* module loader found */\n    else if (lua_isstring(L, -2)) {  /* searcher returned error message? */\n      lua_pop(L, 1);  /* remove extra return */\n      luaL_addvalue(&msg);  /* concatenate error message */\n    }\n    else {  /* no error message */\n      lua_pop(L, 2);  /* remove both returns */\n      luaL_buffsub(&msg, 2);  /* remove prefix */\n    }\n  }\n}\n\n\nstatic int ll_require (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  lua_settop(L, 1);  /* LOADED table will be at index 2 */\n  lua_getfield(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);\n  lua_getfield(L, 2, name);  /* LOADED[name] */\n  if (lua_toboolean(L, -1))  /* is it there? */\n    return 1;  /* package is already loaded */\n  /* else must load package */\n  lua_pop(L, 1);  /* remove 'getfield' result */\n  findloader(L, name);\n  lua_rotate(L, -2, 1);  /* function <-> loader data */\n  lua_pushvalue(L, 1);  /* name is 1st argument to module loader */\n  lua_pushvalue(L, -3);  /* loader data is 2nd argument */\n  /* stack: ...; loader data; loader function; mod. name; loader data */\n  lua_call(L, 2, 1);  /* run loader to load module */\n  /* stack: ...; loader data; result from loader */\n  if (!lua_isnil(L, -1))  /* non-nil return? */\n    lua_setfield(L, 2, name);  /* LOADED[name] = returned value */\n  else\n    lua_pop(L, 1);  /* pop nil */\n  if (lua_getfield(L, 2, name) == LUA_TNIL) {   /* module set no value? */\n    lua_pushboolean(L, 1);  /* use true as result */\n    lua_copy(L, -1, -2);  /* replace loader result */\n    lua_setfield(L, 2, name);  /* LOADED[name] = true */\n  }\n  lua_rotate(L, -2, 1);  /* loader data <-> module result  */\n  return 2;  /* return module result and loader data */\n}\n\n/* }====================================================== */\n\n\n\n\nstatic const luaL_Reg pk_funcs[] = {\n  {\"loadlib\", ll_loadlib},\n  {\"searchpath\", ll_searchpath},\n  /* placeholders */\n  {\"preload\", NULL},\n  {\"cpath\", NULL},\n  {\"path\", NULL},\n  {\"searchers\", NULL},\n  {\"loaded\", NULL},\n  {NULL, NULL}\n};\n\n\nstatic const luaL_Reg ll_funcs[] = {\n  {\"require\", ll_require},\n  {NULL, NULL}\n};\n\n\nstatic void createsearcherstable (lua_State *L) {\n  static const lua_CFunction searchers[] = {\n    searcher_preload,\n    searcher_Lua,\n    searcher_C,\n    searcher_Croot,\n    NULL\n  };\n  int i;\n  /* create 'searchers' table */\n  lua_createtable(L, sizeof(searchers)/sizeof(searchers[0]) - 1, 0);\n  /* fill it with predefined searchers */\n  for (i=0; searchers[i] != NULL; i++) {\n    lua_pushvalue(L, -2);  /* set 'package' as upvalue for all searchers */\n    lua_pushcclosure(L, searchers[i], 1);\n    lua_rawseti(L, -2, i+1);\n  }\n  lua_setfield(L, -2, \"searchers\");  /* put it in field 'searchers' */\n}\n\n\n/*\n** create table CLIBS to keep track of loaded C libraries,\n** setting a finalizer to close all libraries when closing state.\n*/\nstatic void createclibstable (lua_State *L) {\n  luaL_getsubtable(L, LUA_REGISTRYINDEX, CLIBS);  /* create CLIBS table */\n  lua_createtable(L, 0, 1);  /* create metatable for CLIBS */\n  lua_pushcfunction(L, gctm);\n  lua_setfield(L, -2, \"__gc\");  /* set finalizer for CLIBS table */\n  lua_setmetatable(L, -2);\n}\n\n\nLUAMOD_API int luaopen_package (lua_State *L) {\n  createclibstable(L);\n  luaL_newlib(L, pk_funcs);  /* create 'package' table */\n  createsearcherstable(L);\n  /* set paths */\n  setpath(L, \"path\", LUA_PATH_VAR, LUA_PATH_DEFAULT);\n  setpath(L, \"cpath\", LUA_CPATH_VAR, LUA_CPATH_DEFAULT);\n  /* store config information */\n  lua_pushliteral(L, LUA_DIRSEP \"\\n\" LUA_PATH_SEP \"\\n\" LUA_PATH_MARK \"\\n\"\n                     LUA_EXEC_DIR \"\\n\" LUA_IGMARK \"\\n\");\n  lua_setfield(L, -2, \"config\");\n  /* set field 'loaded' */\n  luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);\n  lua_setfield(L, -2, \"loaded\");\n  /* set field 'preload' */\n  luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_PRELOAD_TABLE);\n  lua_setfield(L, -2, \"preload\");\n  lua_pushglobaltable(L);\n  lua_pushvalue(L, -2);  /* set 'package' as upvalue for next lib */\n  luaL_setfuncs(L, ll_funcs, 1);  /* open lib into global table */\n  lua_pop(L, 1);  /* pop global table */\n  return 1;  /* return 'package' table */\n}\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lobject.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: lobject.c $\n** Some generic functions over Lua objects\n** See Copyright Notice in lua.h\n*/\n\n#define lobject_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <locale.h>\n#include <math.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lctype.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"lvm.h\"\n\n\n/*\n** Computes ceil(log2(x))\n*/\nint luaO_ceillog2 (unsigned int x) {\n  static const lu_byte log_2[256] = {  /* log_2[i - 1] = ceil(log2(i)) */\n    0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8\n  };\n  int l = 0;\n  x--;\n  while (x >= 256) { l += 8; x >>= 8; }\n  return l + log_2[x];\n}\n\n/*\n** Encodes 'p'% as a floating-point byte, represented as (eeeexxxx).\n** The exponent is represented using excess-7. Mimicking IEEE 754, the\n** representation normalizes the number when possible, assuming an extra\n** 1 before the mantissa (xxxx) and adding one to the exponent (eeee)\n** to signal that. So, the real value is (1xxxx) * 2^(eeee - 7 - 1) if\n** eeee != 0, and (xxxx) * 2^-7 otherwise (subnormal numbers).\n*/\nunsigned int luaO_codeparam (unsigned int p) {\n  if (p >= (cast(lu_mem, 0x1F) << (0xF - 7 - 1)) * 100u)  /* overflow? */\n    return 0xFF;  /* return maximum value */\n  else {\n    p = (cast(l_uint32, p) * 128 + 99) / 100;  /* round up the division */\n    if (p < 0x10)  /* subnormal number? */\n      return p;  /* exponent bits are already zero; nothing else to do */\n    else {\n      int log = luaO_ceillog2(p + 1) - 5;  /* preserve 5 bits */\n      return ((p >> log) - 0x10) | ((log + 1) << 4);\n    }\n  }\n}\n\n\n/*\n** Computes 'p' times 'x', where 'p' is a floating-point byte. Roughly,\n** we have to multiply 'x' by the mantissa and then shift accordingly to\n** the exponent.  If the exponent is positive, both the multiplication\n** and the shift increase 'x', so we have to care only about overflows.\n** For negative exponents, however, multiplying before the shift keeps\n** more significant bits, as long as the multiplication does not\n** overflow, so we check which order is best.\n*/\nl_obj luaO_applyparam (unsigned int p, l_obj x) {\n  unsigned int m = p & 0xF;  /* mantissa */\n  int e = (p >> 4);  /* exponent */\n  if (e > 0) {  /* normalized? */\n    e--;  /* correct exponent */\n    m += 0x10;  /* correct mantissa; maximum value is 0x1F */\n  }\n  e -= 7;  /* correct excess-7 */\n  if (e >= 0) {\n    if (x < (MAX_LOBJ / 0x1F) >> e)  /* no overflow? */\n      return (x * m) << e;  /* order doesn't matter here */\n    else  /* real overflow */\n      return MAX_LOBJ;\n  }\n  else {  /* negative exponent */\n    e = -e;\n    if (x < MAX_LOBJ / 0x1F)  /* multiplication cannot overflow? */\n      return (x * m) >> e;  /* multiplying first gives more precision */\n    else if ((x >> e) <  MAX_LOBJ / 0x1F)  /* cannot overflow after shift? */\n      return (x >> e) * m;\n    else  /* real overflow */\n      return MAX_LOBJ;\n  }\n}\n\n\nstatic lua_Integer intarith (lua_State *L, int op, lua_Integer v1,\n                                                   lua_Integer v2) {\n  switch (op) {\n    case LUA_OPADD: return intop(+, v1, v2);\n    case LUA_OPSUB:return intop(-, v1, v2);\n    case LUA_OPMUL:return intop(*, v1, v2);\n    case LUA_OPMOD: return luaV_mod(L, v1, v2);\n    case LUA_OPIDIV: return luaV_idiv(L, v1, v2);\n    case LUA_OPBAND: return intop(&, v1, v2);\n    case LUA_OPBOR: return intop(|, v1, v2);\n    case LUA_OPBXOR: return intop(^, v1, v2);\n    case LUA_OPSHL: return luaV_shiftl(v1, v2);\n    case LUA_OPSHR: return luaV_shiftr(v1, v2);\n    case LUA_OPUNM: return intop(-, 0, v1);\n    case LUA_OPBNOT: return intop(^, ~l_castS2U(0), v1);\n    default: lua_assert(0); return 0;\n  }\n}\n\n\nstatic lua_Number numarith (lua_State *L, int op, lua_Number v1,\n                                                  lua_Number v2) {\n  switch (op) {\n    case LUA_OPADD: return luai_numadd(L, v1, v2);\n    case LUA_OPSUB: return luai_numsub(L, v1, v2);\n    case LUA_OPMUL: return luai_nummul(L, v1, v2);\n    case LUA_OPDIV: return luai_numdiv(L, v1, v2);\n    case LUA_OPPOW: return luai_numpow(L, v1, v2);\n    case LUA_OPIDIV: return luai_numidiv(L, v1, v2);\n    case LUA_OPUNM: return luai_numunm(L, v1);\n    case LUA_OPMOD: return luaV_modf(L, v1, v2);\n    default: lua_assert(0); return 0;\n  }\n}\n\n\nint luaO_rawarith (lua_State *L, int op, const TValue *p1, const TValue *p2,\n                   TValue *res) {\n  switch (op) {\n    case LUA_OPBAND: case LUA_OPBOR: case LUA_OPBXOR:\n    case LUA_OPSHL: case LUA_OPSHR:\n    case LUA_OPBNOT: {  /* operate only on integers */\n      lua_Integer i1; lua_Integer i2;\n      if (tointegerns(p1, &i1) && tointegerns(p2, &i2)) {\n        setivalue(res, intarith(L, op, i1, i2));\n        return 1;\n      }\n      else return 0;  /* fail */\n    }\n    case LUA_OPDIV: case LUA_OPPOW: {  /* operate only on floats */\n      lua_Number n1; lua_Number n2;\n      if (tonumberns(p1, n1) && tonumberns(p2, n2)) {\n        setfltvalue(res, numarith(L, op, n1, n2));\n        return 1;\n      }\n      else return 0;  /* fail */\n    }\n    default: {  /* other operations */\n      lua_Number n1; lua_Number n2;\n      if (ttisinteger(p1) && ttisinteger(p2)) {\n        setivalue(res, intarith(L, op, ivalue(p1), ivalue(p2)));\n        return 1;\n      }\n      else if (tonumberns(p1, n1) && tonumberns(p2, n2)) {\n        setfltvalue(res, numarith(L, op, n1, n2));\n        return 1;\n      }\n      else return 0;  /* fail */\n    }\n  }\n}\n\n\nvoid luaO_arith (lua_State *L, int op, const TValue *p1, const TValue *p2,\n                 StkId res) {\n  if (!luaO_rawarith(L, op, p1, p2, s2v(res))) {\n    /* could not perform raw operation; try metamethod */\n    luaT_trybinTM(L, p1, p2, res, cast(TMS, (op - LUA_OPADD) + TM_ADD));\n  }\n}\n\n\nint luaO_hexavalue (int c) {\n  if (lisdigit(c)) return c - '0';\n  else return (ltolower(c) - 'a') + 10;\n}\n\n\nstatic int isneg (const char **s) {\n  if (**s == '-') { (*s)++; return 1; }\n  else if (**s == '+') (*s)++;\n  return 0;\n}\n\n\n\n/*\n** {==================================================================\n** Lua's implementation for 'lua_strx2number'\n** ===================================================================\n*/\n\n#if !defined(lua_strx2number)\n\n/* maximum number of significant digits to read (to avoid overflows\n   even with single floats) */\n#define MAXSIGDIG\t30\n\n/*\n** convert a hexadecimal numeric string to a number, following\n** C99 specification for 'strtod'\n*/\nstatic lua_Number lua_strx2number (const char *s, char **endptr) {\n  int dot = lua_getlocaledecpoint();\n  lua_Number r = l_mathop(0.0);  /* result (accumulator) */\n  int sigdig = 0;  /* number of significant digits */\n  int nosigdig = 0;  /* number of non-significant digits */\n  int e = 0;  /* exponent correction */\n  int neg;  /* 1 if number is negative */\n  int hasdot = 0;  /* true after seen a dot */\n  *endptr = cast_charp(s);  /* nothing is valid yet */\n  while (lisspace(cast_uchar(*s))) s++;  /* skip initial spaces */\n  neg = isneg(&s);  /* check sign */\n  if (!(*s == '0' && (*(s + 1) == 'x' || *(s + 1) == 'X')))  /* check '0x' */\n    return l_mathop(0.0);  /* invalid format (no '0x') */\n  for (s += 2; ; s++) {  /* skip '0x' and read numeral */\n    if (*s == dot) {\n      if (hasdot) break;  /* second dot? stop loop */\n      else hasdot = 1;\n    }\n    else if (lisxdigit(cast_uchar(*s))) {\n      if (sigdig == 0 && *s == '0')  /* non-significant digit (zero)? */\n        nosigdig++;\n      else if (++sigdig <= MAXSIGDIG)  /* can read it without overflow? */\n          r = (r * l_mathop(16.0)) + luaO_hexavalue(*s);\n      else e++; /* too many digits; ignore, but still count for exponent */\n      if (hasdot) e--;  /* decimal digit? correct exponent */\n    }\n    else break;  /* neither a dot nor a digit */\n  }\n  if (nosigdig + sigdig == 0)  /* no digits? */\n    return l_mathop(0.0);  /* invalid format */\n  *endptr = cast_charp(s);  /* valid up to here */\n  e *= 4;  /* each digit multiplies/divides value by 2^4 */\n  if (*s == 'p' || *s == 'P') {  /* exponent part? */\n    int exp1 = 0;  /* exponent value */\n    int neg1;  /* exponent sign */\n    s++;  /* skip 'p' */\n    neg1 = isneg(&s);  /* sign */\n    if (!lisdigit(cast_uchar(*s)))\n      return l_mathop(0.0);  /* invalid; must have at least one digit */\n    while (lisdigit(cast_uchar(*s)))  /* read exponent */\n      exp1 = exp1 * 10 + *(s++) - '0';\n    if (neg1) exp1 = -exp1;\n    e += exp1;\n    *endptr = cast_charp(s);  /* valid up to here */\n  }\n  if (neg) r = -r;\n  return l_mathop(ldexp)(r, e);\n}\n\n#endif\n/* }====================================================== */\n\n\n/* maximum length of a numeral to be converted to a number */\n#if !defined (L_MAXLENNUM)\n#define L_MAXLENNUM\t200\n#endif\n\n/*\n** Convert string 's' to a Lua number (put in 'result'). Return NULL on\n** fail or the address of the ending '\\0' on success. ('mode' == 'x')\n** means a hexadecimal numeral.\n*/\nstatic const char *l_str2dloc (const char *s, lua_Number *result, int mode) {\n  char *endptr;\n  *result = (mode == 'x') ? lua_strx2number(s, &endptr)  /* try to convert */\n                          : lua_str2number(s, &endptr);\n  if (endptr == s) return NULL;  /* nothing recognized? */\n  while (lisspace(cast_uchar(*endptr))) endptr++;  /* skip trailing spaces */\n  return (*endptr == '\\0') ? endptr : NULL;  /* OK iff no trailing chars */\n}\n\n\n/*\n** Convert string 's' to a Lua number (put in 'result') handling the\n** current locale.\n** This function accepts both the current locale or a dot as the radix\n** mark. If the conversion fails, it may mean number has a dot but\n** locale accepts something else. In that case, the code copies 's'\n** to a buffer (because 's' is read-only), changes the dot to the\n** current locale radix mark, and tries to convert again.\n** The variable 'mode' checks for special characters in the string:\n** - 'n' means 'inf' or 'nan' (which should be rejected)\n** - 'x' means a hexadecimal numeral\n** - '.' just optimizes the search for the common case (no special chars)\n*/\nstatic const char *l_str2d (const char *s, lua_Number *result) {\n  const char *endptr;\n  const char *pmode = strpbrk(s, \".xXnN\");  /* look for special chars */\n  int mode = pmode ? ltolower(cast_uchar(*pmode)) : 0;\n  if (mode == 'n')  /* reject 'inf' and 'nan' */\n    return NULL;\n  endptr = l_str2dloc(s, result, mode);  /* try to convert */\n  if (endptr == NULL) {  /* failed? may be a different locale */\n    char buff[L_MAXLENNUM + 1];\n    const char *pdot = strchr(s, '.');\n    if (pdot == NULL || strlen(s) > L_MAXLENNUM)\n      return NULL;  /* string too long or no dot; fail */\n    strcpy(buff, s);  /* copy string to buffer */\n    buff[pdot - s] = lua_getlocaledecpoint();  /* correct decimal point */\n    endptr = l_str2dloc(buff, result, mode);  /* try again */\n    if (endptr != NULL)\n      endptr = s + (endptr - buff);  /* make relative to 's' */\n  }\n  return endptr;\n}\n\n\n#define MAXBY10\t\tcast(lua_Unsigned, LUA_MAXINTEGER / 10)\n#define MAXLASTD\tcast_int(LUA_MAXINTEGER % 10)\n\nstatic const char *l_str2int (const char *s, lua_Integer *result) {\n  lua_Unsigned a = 0;\n  int empty = 1;\n  int neg;\n  while (lisspace(cast_uchar(*s))) s++;  /* skip initial spaces */\n  neg = isneg(&s);\n  if (s[0] == '0' &&\n      (s[1] == 'x' || s[1] == 'X')) {  /* hex? */\n    s += 2;  /* skip '0x' */\n    for (; lisxdigit(cast_uchar(*s)); s++) {\n      a = a * 16 + luaO_hexavalue(*s);\n      empty = 0;\n    }\n  }\n  else {  /* decimal */\n    for (; lisdigit(cast_uchar(*s)); s++) {\n      int d = *s - '0';\n      if (a >= MAXBY10 && (a > MAXBY10 || d > MAXLASTD + neg))  /* overflow? */\n        return NULL;  /* do not accept it (as integer) */\n      a = a * 10 + d;\n      empty = 0;\n    }\n  }\n  while (lisspace(cast_uchar(*s))) s++;  /* skip trailing spaces */\n  if (empty || *s != '\\0') return NULL;  /* something wrong in the numeral */\n  else {\n    *result = l_castU2S((neg) ? 0u - a : a);\n    return s;\n  }\n}\n\n\nsize_t luaO_str2num (const char *s, TValue *o) {\n  lua_Integer i; lua_Number n;\n  const char *e;\n  if ((e = l_str2int(s, &i)) != NULL) {  /* try as an integer */\n    setivalue(o, i);\n  }\n  else if ((e = l_str2d(s, &n)) != NULL) {  /* else try as a float */\n    setfltvalue(o, n);\n  }\n  else\n    return 0;  /* conversion failed */\n  return (e - s) + 1;  /* success; return string size */\n}\n\n\nint luaO_utf8esc (char *buff, unsigned long x) {\n  int n = 1;  /* number of bytes put in buffer (backwards) */\n  lua_assert(x <= 0x7FFFFFFFu);\n  if (x < 0x80)  /* ascii? */\n    buff[UTF8BUFFSZ - 1] = cast_char(x);\n  else {  /* need continuation bytes */\n    unsigned int mfb = 0x3f;  /* maximum that fits in first byte */\n    do {  /* add continuation bytes */\n      buff[UTF8BUFFSZ - (n++)] = cast_char(0x80 | (x & 0x3f));\n      x >>= 6;  /* remove added bits */\n      mfb >>= 1;  /* now there is one less bit available in first byte */\n    } while (x > mfb);  /* still needs continuation byte? */\n    buff[UTF8BUFFSZ - n] = cast_char((~mfb << 1) | x);  /* add first byte */\n  }\n  return n;\n}\n\n\n/*\n** Maximum length of the conversion of a number to a string. Must be\n** enough to accommodate both LUA_INTEGER_FMT and LUA_NUMBER_FMT.\n** (For a long long int, this is 19 digits plus a sign and a final '\\0',\n** adding to 21. For a long double, it can go to a sign, 33 digits,\n** the dot, an exponent letter, an exponent sign, 5 exponent digits,\n** and a final '\\0', adding to 43.)\n*/\n#define MAXNUMBER2STR\t44\n\n\n/*\n** Convert a number object to a string, adding it to a buffer\n*/\nstatic int tostringbuff (TValue *obj, char *buff) {\n  int len;\n  lua_assert(ttisnumber(obj));\n  if (ttisinteger(obj))\n    len = lua_integer2str(buff, MAXNUMBER2STR, ivalue(obj));\n  else {\n    len = lua_number2str(buff, MAXNUMBER2STR, fltvalue(obj));\n    if (buff[strspn(buff, \"-0123456789\")] == '\\0') {  /* looks like an int? */\n      buff[len++] = lua_getlocaledecpoint();\n      buff[len++] = '0';  /* adds '.0' to result */\n    }\n  }\n  return len;\n}\n\n\n/*\n** Convert a number object to a Lua string, replacing the value at 'obj'\n*/\nvoid luaO_tostring (lua_State *L, TValue *obj) {\n  char buff[MAXNUMBER2STR];\n  int len = tostringbuff(obj, buff);\n  setsvalue(L, obj, luaS_newlstr(L, buff, len));\n}\n\n\n\n\n/*\n** {==================================================================\n** 'luaO_pushvfstring'\n** ===================================================================\n*/\n\n/*\n** Size for buffer space used by 'luaO_pushvfstring'. It should be\n** (LUA_IDSIZE + MAXNUMBER2STR) + a minimal space for basic messages,\n** so that 'luaG_addinfo' can work directly on the buffer.\n*/\n#define BUFVFS\t\t(LUA_IDSIZE + MAXNUMBER2STR + 95)\n\n/* buffer used by 'luaO_pushvfstring' */\ntypedef struct BuffFS {\n  lua_State *L;\n  int pushed;  /* true if there is a part of the result on the stack */\n  int blen;  /* length of partial string in 'space' */\n  char space[BUFVFS];  /* holds last part of the result */\n} BuffFS;\n\n\n/*\n** Push given string to the stack, as part of the result, and\n** join it to previous partial result if there is one.\n** It may call 'luaV_concat' while using one slot from EXTRA_STACK.\n** This call cannot invoke metamethods, as both operands must be\n** strings. It can, however, raise an error if the result is too\n** long. In that case, 'luaV_concat' frees the extra slot before\n** raising the error.\n*/\nstatic void pushstr (BuffFS *buff, const char *str, size_t lstr) {\n  lua_State *L = buff->L;\n  setsvalue2s(L, L->top.p, luaS_newlstr(L, str, lstr));\n  L->top.p++;  /* may use one slot from EXTRA_STACK */\n  if (!buff->pushed)  /* no previous string on the stack? */\n    buff->pushed = 1;  /* now there is one */\n  else  /* join previous string with new one */\n    luaV_concat(L, 2);\n}\n\n\n/*\n** empty the buffer space into the stack\n*/\nstatic void clearbuff (BuffFS *buff) {\n  pushstr(buff, buff->space, buff->blen);  /* push buffer contents */\n  buff->blen = 0;  /* space now is empty */\n}\n\n\n/*\n** Get a space of size 'sz' in the buffer. If buffer has not enough\n** space, empty it. 'sz' must fit in an empty buffer.\n*/\nstatic char *getbuff (BuffFS *buff, int sz) {\n  lua_assert(buff->blen <= BUFVFS); lua_assert(sz <= BUFVFS);\n  if (sz > BUFVFS - buff->blen)  /* not enough space? */\n    clearbuff(buff);\n  return buff->space + buff->blen;\n}\n\n\n#define addsize(b,sz)\t((b)->blen += (sz))\n\n\n/*\n** Add 'str' to the buffer. If string is larger than the buffer space,\n** push the string directly to the stack.\n*/\nstatic void addstr2buff (BuffFS *buff, const char *str, size_t slen) {\n  if (slen <= BUFVFS) {  /* does string fit into buffer? */\n    char *bf = getbuff(buff, cast_int(slen));\n    memcpy(bf, str, slen);  /* add string to buffer */\n    addsize(buff, cast_int(slen));\n  }\n  else {  /* string larger than buffer */\n    clearbuff(buff);  /* string comes after buffer's content */\n    pushstr(buff, str, slen);  /* push string */\n  }\n}\n\n\n/*\n** Add a numeral to the buffer.\n*/\nstatic void addnum2buff (BuffFS *buff, TValue *num) {\n  char *numbuff = getbuff(buff, MAXNUMBER2STR);\n  int len = tostringbuff(num, numbuff);  /* format number into 'numbuff' */\n  addsize(buff, len);\n}\n\n\n/*\n** this function handles only '%d', '%c', '%f', '%p', '%s', and '%%'\n   conventional formats, plus Lua-specific '%I' and '%U'\n*/\nconst char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp) {\n  BuffFS buff;  /* holds last part of the result */\n  const char *e;  /* points to next '%' */\n  buff.pushed = buff.blen = 0;\n  buff.L = L;\n  while ((e = strchr(fmt, '%')) != NULL) {\n    addstr2buff(&buff, fmt, e - fmt);  /* add 'fmt' up to '%' */\n    switch (*(e + 1)) {  /* conversion specifier */\n      case 's': {  /* zero-terminated string */\n        const char *s = va_arg(argp, char *);\n        if (s == NULL) s = \"(null)\";\n        addstr2buff(&buff, s, strlen(s));\n        break;\n      }\n      case 'c': {  /* an 'int' as a character */\n        char c = cast_uchar(va_arg(argp, int));\n        addstr2buff(&buff, &c, sizeof(char));\n        break;\n      }\n      case 'd': {  /* an 'int' */\n        TValue num;\n        setivalue(&num, va_arg(argp, int));\n        addnum2buff(&buff, &num);\n        break;\n      }\n      case 'I': {  /* a 'lua_Integer' */\n        TValue num;\n        setivalue(&num, cast(lua_Integer, va_arg(argp, l_uacInt)));\n        addnum2buff(&buff, &num);\n        break;\n      }\n      case 'f': {  /* a 'lua_Number' */\n        TValue num;\n        setfltvalue(&num, cast_num(va_arg(argp, l_uacNumber)));\n        addnum2buff(&buff, &num);\n        break;\n      }\n      case 'p': {  /* a pointer */\n        const int sz = 3 * sizeof(void*) + 8; /* enough space for '%p' */\n        char *bf = getbuff(&buff, sz);\n        void *p = va_arg(argp, void *);\n        int len = lua_pointer2str(bf, sz, p);\n        addsize(&buff, len);\n        break;\n      }\n      case 'U': {  /* a 'long' as a UTF-8 sequence */\n        char bf[UTF8BUFFSZ];\n        int len = luaO_utf8esc(bf, va_arg(argp, long));\n        addstr2buff(&buff, bf + UTF8BUFFSZ - len, len);\n        break;\n      }\n      case '%': {\n        addstr2buff(&buff, \"%\", 1);\n        break;\n      }\n      default: {\n        luaG_runerror(L, \"invalid option '%%%c' to 'lua_pushfstring'\",\n                         *(e + 1));\n      }\n    }\n    fmt = e + 2;  /* skip '%' and the specifier */\n  }\n  addstr2buff(&buff, fmt, strlen(fmt));  /* rest of 'fmt' */\n  clearbuff(&buff);  /* empty buffer into the stack */\n  lua_assert(buff.pushed == 1);\n  return getstr(tsvalue(s2v(L->top.p - 1)));\n}\n\n\nconst char *luaO_pushfstring (lua_State *L, const char *fmt, ...) {\n  const char *msg;\n  va_list argp;\n  va_start(argp, fmt);\n  msg = luaO_pushvfstring(L, fmt, argp);\n  va_end(argp);\n  return msg;\n}\n\n/* }================================================================== */\n\n\n#define RETS\t\"...\"\n#define PRE\t\"[string \\\"\"\n#define POS\t\"\\\"]\"\n\n#define addstr(a,b,l)\t( memcpy(a,b,(l) * sizeof(char)), a += (l) )\n\nvoid luaO_chunkid (char *out, const char *source, size_t srclen) {\n  size_t bufflen = LUA_IDSIZE;  /* free space in buffer */\n  if (*source == '=') {  /* 'literal' source */\n    if (srclen <= bufflen)  /* small enough? */\n      memcpy(out, source + 1, srclen * sizeof(char));\n    else {  /* truncate it */\n      addstr(out, source + 1, bufflen - 1);\n      *out = '\\0';\n    }\n  }\n  else if (*source == '@') {  /* file name */\n    if (srclen <= bufflen)  /* small enough? */\n      memcpy(out, source + 1, srclen * sizeof(char));\n    else {  /* add '...' before rest of name */\n      addstr(out, RETS, LL(RETS));\n      bufflen -= LL(RETS);\n      memcpy(out, source + 1 + srclen - bufflen, bufflen * sizeof(char));\n    }\n  }\n  else {  /* string; format as [string \"source\"] */\n    const char *nl = strchr(source, '\\n');  /* find first new line (if any) */\n    addstr(out, PRE, LL(PRE));  /* add prefix */\n    bufflen -= LL(PRE RETS POS) + 1;  /* save space for prefix+suffix+'\\0' */\n    if (srclen < bufflen && nl == NULL) {  /* small one-line source? */\n      addstr(out, source, srclen);  /* keep it */\n    }\n    else {\n      if (nl != NULL) srclen = nl - source;  /* stop at first newline */\n      if (srclen > bufflen) srclen = bufflen;\n      addstr(out, source, srclen);\n      addstr(out, RETS, LL(RETS));\n    }\n    memcpy(out, POS, (LL(POS) + 1) * sizeof(char));\n  }\n}\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lobject.h",
		"is_binary":	false,
		"content":	"/*\n** $Id: lobject.h $\n** Type definitions for Lua objects\n** See Copyright Notice in lua.h\n*/\n\n\n#ifndef lobject_h\n#define lobject_h\n\n\n#include <stdarg.h>\n\n\n#include \"llimits.h\"\n#include \"lua.h\"\n\n\n/*\n** Extra types for collectable non-values\n*/\n#define LUA_TUPVAL\tLUA_NUMTYPES  /* upvalues */\n#define LUA_TPROTO\t(LUA_NUMTYPES+1)  /* function prototypes */\n#define LUA_TDEADKEY\t(LUA_NUMTYPES+2)  /* removed keys in tables */\n\n\n\n/*\n** number of all possible types (including LUA_TNONE but excluding DEADKEY)\n*/\n#define LUA_TOTALTYPES\t\t(LUA_TPROTO + 2)\n\n\n/*\n** tags for Tagged Values have the following use of bits:\n** bits 0-3: actual tag (a LUA_T* constant)\n** bits 4-5: variant bits\n** bit 6: whether value is collectable\n*/\n\n/* add variant bits to a type */\n#define makevariant(t,v)\t((t) | ((v) << 4))\n\n\n\n/*\n** Union of all Lua values\n*/\ntypedef union Value {\n  struct GCObject *gc;    /* collectable objects */\n  void *p;         /* light userdata */\n  lua_CFunction f; /* light C functions */\n  lua_Integer i;   /* integer numbers */\n  lua_Number n;    /* float numbers */\n  /* not used, but may avoid warnings for uninitialized value */\n  lu_byte ub;\n} Value;\n\n\n/*\n** Tagged Values. This is the basic representation of values in Lua:\n** an actual value plus a tag with its type.\n*/\n\n#define TValuefields\tValue value_; lu_byte tt_\n\ntypedef struct TValue {\n  TValuefields;\n} TValue;\n\n\n#define val_(o)\t\t((o)->value_)\n#define valraw(o)\t(val_(o))\n\n\n/* raw type tag of a TValue */\n#define rawtt(o)\t((o)->tt_)\n\n/* tag with no variants (bits 0-3) */\n#define novariant(t)\t((t) & 0x0F)\n\n/* type tag of a TValue (bits 0-3 for tags + variant bits 4-5) */\n#define withvariant(t)\t((t) & 0x3F)\n#define ttypetag(o)\twithvariant(rawtt(o))\n\n/* type of a TValue */\n#define ttype(o)\t(novariant(rawtt(o)))\n\n\n/* Macros to test type */\n#define checktag(o,t)\t\t(rawtt(o) == (t))\n#define checktype(o,t)\t\t(ttype(o) == (t))\n\n\n/* Macros for internal tests */\n\n/* collectable object has the same tag as the original value */\n#define righttt(obj)\t\t(ttypetag(obj) == gcvalue(obj)->tt)\n\n/*\n** Any value being manipulated by the program either is non\n** collectable, or the collectable object has the right tag\n** and it is not dead. The option 'L == NULL' allows other\n** macros using this one to be used where L is not available.\n*/\n#define checkliveness(L,obj) \\\n\t((void)L, lua_longassert(!iscollectable(obj) || \\\n\t\t(righttt(obj) && (L == NULL || !isdead(G(L),gcvalue(obj))))))\n\n\n/* Macros to set values */\n\n/* set a value's tag */\n#define settt_(o,t)\t((o)->tt_=(t))\n\n\n/* main macro to copy values (from 'obj2' to 'obj1') */\n#define setobj(L,obj1,obj2) \\\n\t{ TValue *io1=(obj1); const TValue *io2=(obj2); \\\n          io1->value_ = io2->value_; settt_(io1, io2->tt_); \\\n\t  checkliveness(L,io1); lua_assert(!isnonstrictnil(io1)); }\n\n/*\n** Different types of assignments, according to source and destination.\n** (They are mostly equal now, but may be different in the future.)\n*/\n\n/* from stack to stack */\n#define setobjs2s(L,o1,o2)\tsetobj(L,s2v(o1),s2v(o2))\n/* to stack (not from same stack) */\n#define setobj2s(L,o1,o2)\tsetobj(L,s2v(o1),o2)\n/* from table to same table */\n#define setobjt2t\tsetobj\n/* to new object */\n#define setobj2n\tsetobj\n/* to table */\n#define setobj2t\tsetobj\n\n\n/*\n** Entries in a Lua stack. Field 'tbclist' forms a list of all\n** to-be-closed variables active in this stack. Dummy entries are\n** used when the distance between two tbc variables does not fit\n** in an unsigned short. They are represented by delta==0, and\n** their real delta is always the maximum value that fits in\n** that field.\n*/\ntypedef union StackValue {\n  TValue val;\n  struct {\n    TValuefields;\n    unsigned short delta;\n  } tbclist;\n} StackValue;\n\n\n/* index to stack elements */\ntypedef StackValue *StkId;\n\n\n/*\n** When reallocating the stack, change all pointers to the stack into\n** proper offsets.\n*/\ntypedef union {\n  StkId p;  /* actual pointer */\n  ptrdiff_t offset;  /* used while the stack is being reallocated */\n} StkIdRel;\n\n\n/* convert a 'StackValue' to a 'TValue' */\n#define s2v(o)\t(&(o)->val)\n\n\n\n/*\n** {==================================================================\n** Nil\n** ===================================================================\n*/\n\n/* Standard nil */\n#define LUA_VNIL\tmakevariant(LUA_TNIL, 0)\n\n/* Empty slot (which might be different from a slot containing nil) */\n#define LUA_VEMPTY\tmakevariant(LUA_TNIL, 1)\n\n/* Value returned for a key not found in a table (absent key) */\n#define LUA_VABSTKEY\tmakevariant(LUA_TNIL, 2)\n\n/* Special variant to signal that a fast get is accessing a non-table */\n#define LUA_VNOTABLE    makevariant(LUA_TNIL, 3)\n\n\n/* macro to test for (any kind of) nil */\n#define ttisnil(v)\t\tchecktype((v), LUA_TNIL)\n\n/*\n** Macro to test the result of a table access. Formally, it should\n** distinguish between LUA_VEMPTY/LUA_VABSTKEY/LUA_VNOTABLE and\n** other tags. As currently nil is equivalent to LUA_VEMPTY, it is\n** simpler to just test whether the value is nil.\n*/\n#define tagisempty(tag)\t\t(novariant(tag) == LUA_TNIL)\n\n\n/* macro to test for a standard nil */\n#define ttisstrictnil(o)\tchecktag((o), LUA_VNIL)\n\n\n#define setnilvalue(obj) settt_(obj, LUA_VNIL)\n\n\n#define isabstkey(v)\t\tchecktag((v), LUA_VABSTKEY)\n\n\n/*\n** macro to detect non-standard nils (used only in assertions)\n*/\n#define isnonstrictnil(v)\t(ttisnil(v) && !ttisstrictnil(v))\n\n\n/*\n** By default, entries with any kind of nil are considered empty.\n** (In any definition, values associated with absent keys must also\n** be accepted as empty.)\n*/\n#define isempty(v)\t\tttisnil(v)\n\n\n/* macro defining a value corresponding to an absent key */\n#define ABSTKEYCONSTANT\t\t{NULL}, LUA_VABSTKEY\n\n\n/* mark an entry as empty */\n#define setempty(v)\t\tsettt_(v, LUA_VEMPTY)\n\n\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Booleans\n** ===================================================================\n*/\n\n\n#define LUA_VFALSE\tmakevariant(LUA_TBOOLEAN, 0)\n#define LUA_VTRUE\tmakevariant(LUA_TBOOLEAN, 1)\n\n#define ttisboolean(o)\t\tchecktype((o), LUA_TBOOLEAN)\n#define ttisfalse(o)\t\tchecktag((o), LUA_VFALSE)\n#define ttistrue(o)\t\tchecktag((o), LUA_VTRUE)\n\n\n#define l_isfalse(o)\t(ttisfalse(o) || ttisnil(o))\n#define tagisfalse(t)\t((t) == LUA_VFALSE || novariant(t) == LUA_TNIL)\n\n\n\n#define setbfvalue(obj)\t\tsettt_(obj, LUA_VFALSE)\n#define setbtvalue(obj)\t\tsettt_(obj, LUA_VTRUE)\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Threads\n** ===================================================================\n*/\n\n#define LUA_VTHREAD\t\tmakevariant(LUA_TTHREAD, 0)\n\n#define ttisthread(o)\t\tchecktag((o), ctb(LUA_VTHREAD))\n\n#define thvalue(o)\tcheck_exp(ttisthread(o), gco2th(val_(o).gc))\n\n#define setthvalue(L,obj,x) \\\n  { TValue *io = (obj); lua_State *x_ = (x); \\\n    val_(io).gc = obj2gco(x_); settt_(io, ctb(LUA_VTHREAD)); \\\n    checkliveness(L,io); }\n\n#define setthvalue2s(L,o,t)\tsetthvalue(L,s2v(o),t)\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Collectable Objects\n** ===================================================================\n*/\n\n/*\n** Common Header for all collectable objects (in macro form, to be\n** included in other objects)\n*/\n#define CommonHeader\tstruct GCObject *next; lu_byte tt; lu_byte marked\n\n\n/* Common type for all collectable objects */\ntypedef struct GCObject {\n  CommonHeader;\n} GCObject;\n\n\n/* Bit mark for collectable types */\n#define BIT_ISCOLLECTABLE\t(1 << 6)\n\n#define iscollectable(o)\t(rawtt(o) & BIT_ISCOLLECTABLE)\n\n/* mark a tag as collectable */\n#define ctb(t)\t\t\t((t) | BIT_ISCOLLECTABLE)\n\n#define gcvalue(o)\tcheck_exp(iscollectable(o), val_(o).gc)\n\n#define gcvalueraw(v)\t((v).gc)\n\n#define setgcovalue(L,obj,x) \\\n  { TValue *io = (obj); GCObject *i_g=(x); \\\n    val_(io).gc = i_g; settt_(io, ctb(i_g->tt)); }\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Numbers\n** ===================================================================\n*/\n\n/* Variant tags for numbers */\n#define LUA_VNUMINT\tmakevariant(LUA_TNUMBER, 0)  /* integer numbers */\n#define LUA_VNUMFLT\tmakevariant(LUA_TNUMBER, 1)  /* float numbers */\n\n#define ttisnumber(o)\t\tchecktype((o), LUA_TNUMBER)\n#define ttisfloat(o)\t\tchecktag((o), LUA_VNUMFLT)\n#define ttisinteger(o)\t\tchecktag((o), LUA_VNUMINT)\n\n#define nvalue(o)\tcheck_exp(ttisnumber(o), \\\n\t(ttisinteger(o) ? cast_num(ivalue(o)) : fltvalue(o)))\n#define fltvalue(o)\tcheck_exp(ttisfloat(o), val_(o).n)\n#define ivalue(o)\tcheck_exp(ttisinteger(o), val_(o).i)\n\n#define fltvalueraw(v)\t((v).n)\n#define ivalueraw(v)\t((v).i)\n\n#define setfltvalue(obj,x) \\\n  { TValue *io=(obj); val_(io).n=(x); settt_(io, LUA_VNUMFLT); }\n\n#define chgfltvalue(obj,x) \\\n  { TValue *io=(obj); lua_assert(ttisfloat(io)); val_(io).n=(x); }\n\n#define setivalue(obj,x) \\\n  { TValue *io=(obj); val_(io).i=(x); settt_(io, LUA_VNUMINT); }\n\n#define chgivalue(obj,x) \\\n  { TValue *io=(obj); lua_assert(ttisinteger(io)); val_(io).i=(x); }\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Strings\n** ===================================================================\n*/\n\n/* Variant tags for strings */\n#define LUA_VSHRSTR\tmakevariant(LUA_TSTRING, 0)  /* short strings */\n#define LUA_VLNGSTR\tmakevariant(LUA_TSTRING, 1)  /* long strings */\n\n#define ttisstring(o)\t\tchecktype((o), LUA_TSTRING)\n#define ttisshrstring(o)\tchecktag((o), ctb(LUA_VSHRSTR))\n#define ttislngstring(o)\tchecktag((o), ctb(LUA_VLNGSTR))\n\n#define tsvalueraw(v)\t(gco2ts((v).gc))\n\n#define tsvalue(o)\tcheck_exp(ttisstring(o), gco2ts(val_(o).gc))\n\n#define setsvalue(L,obj,x) \\\n  { TValue *io = (obj); TString *x_ = (x); \\\n    val_(io).gc = obj2gco(x_); settt_(io, ctb(x_->tt)); \\\n    checkliveness(L,io); }\n\n/* set a string to the stack */\n#define setsvalue2s(L,o,s)\tsetsvalue(L,s2v(o),s)\n\n/* set a string to a new object */\n#define setsvalue2n\tsetsvalue\n\n\n/* Kinds of long strings (stored in 'shrlen') */\n#define LSTRREG\t\t-1  /* regular long string */\n#define LSTRFIX\t\t-2  /* fixed external long string */\n#define LSTRMEM\t\t-3  /* external long string with deallocation */\n\n\n/*\n** Header for a string value.\n*/\ntypedef struct TString {\n  CommonHeader;\n  lu_byte extra;  /* reserved words for short strings; \"has hash\" for longs */\n  ls_byte shrlen;  /* length for short strings, negative for long strings */\n  unsigned int hash;\n  union {\n    size_t lnglen;  /* length for long strings */\n    struct TString *hnext;  /* linked list for hash table */\n  } u;\n  char *contents;  /* pointer to content in long strings */\n  lua_Alloc falloc;  /* deallocation function for external strings */\n  void *ud;  /* user data for external strings */\n} TString;\n\n\n#define strisshr(ts)\t((ts)->shrlen >= 0)\n\n\n/*\n** Get the actual string (array of bytes) from a 'TString'. (Generic\n** version and specialized versions for long and short strings.)\n*/\n#define rawgetshrstr(ts)  (cast_charp(&(ts)->contents))\n#define getshrstr(ts)\tcheck_exp(strisshr(ts), rawgetshrstr(ts))\n#define getlngstr(ts)\tcheck_exp(!strisshr(ts), (ts)->contents)\n#define getstr(ts) \t(strisshr(ts) ? rawgetshrstr(ts) : (ts)->contents)\n\n\n/* get string length from 'TString *ts' */\n#define tsslen(ts)  \\\n\t(strisshr(ts) ? cast_uint((ts)->shrlen) : (ts)->u.lnglen)\n\n/*\n** Get string and length */\n#define getlstr(ts, len)  \\\n\t(strisshr(ts) \\\n\t? (cast_void((len) = (ts)->shrlen), rawgetshrstr(ts)) \\\n\t: (cast_void((len) = (ts)->u.lnglen), (ts)->contents))\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Userdata\n** ===================================================================\n*/\n\n\n/*\n** Light userdata should be a variant of userdata, but for compatibility\n** reasons they are also different types.\n*/\n#define LUA_VLIGHTUSERDATA\tmakevariant(LUA_TLIGHTUSERDATA, 0)\n\n#define LUA_VUSERDATA\t\tmakevariant(LUA_TUSERDATA, 0)\n\n#define ttislightuserdata(o)\tchecktag((o), LUA_VLIGHTUSERDATA)\n#define ttisfulluserdata(o)\tchecktag((o), ctb(LUA_VUSERDATA))\n\n#define pvalue(o)\tcheck_exp(ttislightuserdata(o), val_(o).p)\n#define uvalue(o)\tcheck_exp(ttisfulluserdata(o), gco2u(val_(o).gc))\n\n#define pvalueraw(v)\t((v).p)\n\n#define setpvalue(obj,x) \\\n  { TValue *io=(obj); val_(io).p=(x); settt_(io, LUA_VLIGHTUSERDATA); }\n\n#define setuvalue(L,obj,x) \\\n  { TValue *io = (obj); Udata *x_ = (x); \\\n    val_(io).gc = obj2gco(x_); settt_(io, ctb(LUA_VUSERDATA)); \\\n    checkliveness(L,io); }\n\n\n/* Ensures that addresses after this type are always fully aligned. */\ntypedef union UValue {\n  TValue uv;\n  LUAI_MAXALIGN;  /* ensures maximum alignment for udata bytes */\n} UValue;\n\n\n/*\n** Header for userdata with user values;\n** memory area follows the end of this structure.\n*/\ntypedef struct Udata {\n  CommonHeader;\n  unsigned short nuvalue;  /* number of user values */\n  size_t len;  /* number of bytes */\n  struct Table *metatable;\n  GCObject *gclist;\n  UValue uv[1];  /* user values */\n} Udata;\n\n\n/*\n** Header for userdata with no user values. These userdata do not need\n** to be gray during GC, and therefore do not need a 'gclist' field.\n** To simplify, the code always use 'Udata' for both kinds of userdata,\n** making sure it never accesses 'gclist' on userdata with no user values.\n** This structure here is used only to compute the correct size for\n** this representation. (The 'bindata' field in its end ensures correct\n** alignment for binary data following this header.)\n*/\ntypedef struct Udata0 {\n  CommonHeader;\n  unsigned short nuvalue;  /* number of user values */\n  size_t len;  /* number of bytes */\n  struct Table *metatable;\n  union {LUAI_MAXALIGN;} bindata;\n} Udata0;\n\n\n/* compute the offset of the memory area of a userdata */\n#define udatamemoffset(nuv) \\\n\t((nuv) == 0 ? offsetof(Udata0, bindata)  \\\n                    : offsetof(Udata, uv) + (sizeof(UValue) * (nuv)))\n\n/* get the address of the memory block inside 'Udata' */\n#define getudatamem(u)\t(cast_charp(u) + udatamemoffset((u)->nuvalue))\n\n/* compute the size of a userdata */\n#define sizeudata(nuv,nb)\t(udatamemoffset(nuv) + (nb))\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Prototypes\n** ===================================================================\n*/\n\n#define LUA_VPROTO\tmakevariant(LUA_TPROTO, 0)\n\n\n/*\n** Description of an upvalue for function prototypes\n*/\ntypedef struct Upvaldesc {\n  TString *name;  /* upvalue name (for debug information) */\n  lu_byte instack;  /* whether it is in stack (register) */\n  lu_byte idx;  /* index of upvalue (in stack or in outer function's list) */\n  lu_byte kind;  /* kind of corresponding variable */\n} Upvaldesc;\n\n\n/*\n** Description of a local variable for function prototypes\n** (used for debug information)\n*/\ntypedef struct LocVar {\n  TString *varname;\n  int startpc;  /* first point where variable is active */\n  int endpc;    /* first point where variable is dead */\n} LocVar;\n\n\n/*\n** Associates the absolute line source for a given instruction ('pc').\n** The array 'lineinfo' gives, for each instruction, the difference in\n** lines from the previous instruction. When that difference does not\n** fit into a byte, Lua saves the absolute line for that instruction.\n** (Lua also saves the absolute line periodically, to speed up the\n** computation of a line number: we can use binary search in the\n** absolute-line array, but we must traverse the 'lineinfo' array\n** linearly to compute a line.)\n*/\ntypedef struct AbsLineInfo {\n  int pc;\n  int line;\n} AbsLineInfo;\n\n\n/*\n** Flags in Prototypes\n*/\n#define PF_ISVARARG\t1\n#define PF_FIXED\t2  /* prototype has parts in fixed memory */\n\n\n/*\n** Function Prototypes\n*/\ntypedef struct Proto {\n  CommonHeader;\n  lu_byte numparams;  /* number of fixed (named) parameters */\n  lu_byte flag;\n  lu_byte maxstacksize;  /* number of registers needed by this function */\n  int sizeupvalues;  /* size of 'upvalues' */\n  int sizek;  /* size of 'k' */\n  int sizecode;\n  int sizelineinfo;\n  int sizep;  /* size of 'p' */\n  int sizelocvars;\n  int sizeabslineinfo;  /* size of 'abslineinfo' */\n  int linedefined;  /* debug information  */\n  int lastlinedefined;  /* debug information  */\n  TValue *k;  /* constants used by the function */\n  Instruction *code;  /* opcodes */\n  struct Proto **p;  /* functions defined inside the function */\n  Upvaldesc *upvalues;  /* upvalue information */\n  ls_byte *lineinfo;  /* information about source lines (debug information) */\n  AbsLineInfo *abslineinfo;  /* idem */\n  LocVar *locvars;  /* information about local variables (debug information) */\n  TString  *source;  /* used for debug information */\n  GCObject *gclist;\n} Proto;\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Functions\n** ===================================================================\n*/\n\n#define LUA_VUPVAL\tmakevariant(LUA_TUPVAL, 0)\n\n\n/* Variant tags for functions */\n#define LUA_VLCL\tmakevariant(LUA_TFUNCTION, 0)  /* Lua closure */\n#define LUA_VLCF\tmakevariant(LUA_TFUNCTION, 1)  /* light C function */\n#define LUA_VCCL\tmakevariant(LUA_TFUNCTION, 2)  /* C closure */\n\n#define ttisfunction(o)\t\tchecktype(o, LUA_TFUNCTION)\n#define ttisLclosure(o)\t\tchecktag((o), ctb(LUA_VLCL))\n#define ttislcf(o)\t\tchecktag((o), LUA_VLCF)\n#define ttisCclosure(o)\t\tchecktag((o), ctb(LUA_VCCL))\n#define ttisclosure(o)         (ttisLclosure(o) || ttisCclosure(o))\n\n\n#define isLfunction(o)\tttisLclosure(o)\n\n#define clvalue(o)\tcheck_exp(ttisclosure(o), gco2cl(val_(o).gc))\n#define clLvalue(o)\tcheck_exp(ttisLclosure(o), gco2lcl(val_(o).gc))\n#define fvalue(o)\tcheck_exp(ttislcf(o), val_(o).f)\n#define clCvalue(o)\tcheck_exp(ttisCclosure(o), gco2ccl(val_(o).gc))\n\n#define fvalueraw(v)\t((v).f)\n\n#define setclLvalue(L,obj,x) \\\n  { TValue *io = (obj); LClosure *x_ = (x); \\\n    val_(io).gc = obj2gco(x_); settt_(io, ctb(LUA_VLCL)); \\\n    checkliveness(L,io); }\n\n#define setclLvalue2s(L,o,cl)\tsetclLvalue(L,s2v(o),cl)\n\n#define setfvalue(obj,x) \\\n  { TValue *io=(obj); val_(io).f=(x); settt_(io, LUA_VLCF); }\n\n#define setclCvalue(L,obj,x) \\\n  { TValue *io = (obj); CClosure *x_ = (x); \\\n    val_(io).gc = obj2gco(x_); settt_(io, ctb(LUA_VCCL)); \\\n    checkliveness(L,io); }\n\n\n/*\n** Upvalues for Lua closures\n*/\ntypedef struct UpVal {\n  CommonHeader;\n  union {\n    TValue *p;  /* points to stack or to its own value */\n    ptrdiff_t offset;  /* used while the stack is being reallocated */\n  } v;\n  union {\n    struct {  /* (when open) */\n      struct UpVal *next;  /* linked list */\n      struct UpVal **previous;\n    } open;\n    TValue value;  /* the value (when closed) */\n  } u;\n} UpVal;\n\n\n\n#define ClosureHeader \\\n\tCommonHeader; lu_byte nupvalues; GCObject *gclist\n\ntypedef struct CClosure {\n  ClosureHeader;\n  lua_CFunction f;\n  TValue upvalue[1];  /* list of upvalues */\n} CClosure;\n\n\ntypedef struct LClosure {\n  ClosureHeader;\n  struct Proto *p;\n  UpVal *upvals[1];  /* list of upvalues */\n} LClosure;\n\n\ntypedef union Closure {\n  CClosure c;\n  LClosure l;\n} Closure;\n\n\n#define getproto(o)\t(clLvalue(o)->p)\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Tables\n** ===================================================================\n*/\n\n#define LUA_VTABLE\tmakevariant(LUA_TTABLE, 0)\n\n#define ttistable(o)\t\tchecktag((o), ctb(LUA_VTABLE))\n\n#define hvalue(o)\tcheck_exp(ttistable(o), gco2t(val_(o).gc))\n\n#define sethvalue(L,obj,x) \\\n  { TValue *io = (obj); Table *x_ = (x); \\\n    val_(io).gc = obj2gco(x_); settt_(io, ctb(LUA_VTABLE)); \\\n    checkliveness(L,io); }\n\n#define sethvalue2s(L,o,h)\tsethvalue(L,s2v(o),h)\n\n\n/*\n** Nodes for Hash tables: A pack of two TValue's (key-value pairs)\n** plus a 'next' field to link colliding entries. The distribution\n** of the key's fields ('key_tt' and 'key_val') not forming a proper\n** 'TValue' allows for a smaller size for 'Node' both in 4-byte\n** and 8-byte alignments.\n*/\ntypedef union Node {\n  struct NodeKey {\n    TValuefields;  /* fields for value */\n    lu_byte key_tt;  /* key type */\n    int next;  /* for chaining */\n    Value key_val;  /* key value */\n  } u;\n  TValue i_val;  /* direct access to node's value as a proper 'TValue' */\n} Node;\n\n\n/* copy a value into a key */\n#define setnodekey(L,node,obj) \\\n\t{ Node *n_=(node); const TValue *io_=(obj); \\\n\t  n_->u.key_val = io_->value_; n_->u.key_tt = io_->tt_; \\\n\t  checkliveness(L,io_); }\n\n\n/* copy a value from a key */\n#define getnodekey(L,obj,node) \\\n\t{ TValue *io_=(obj); const Node *n_=(node); \\\n\t  io_->value_ = n_->u.key_val; io_->tt_ = n_->u.key_tt; \\\n\t  checkliveness(L,io_); }\n\n\n/*\n** About 'alimit': if 'isrealasize(t)' is true, then 'alimit' is the\n** real size of 'array'. Otherwise, the real size of 'array' is the\n** smallest power of two not smaller than 'alimit' (or zero iff 'alimit'\n** is zero); 'alimit' is then used as a hint for #t.\n*/\n\n#define BITRAS\t\t(1 << 7)\n#define isrealasize(t)\t\t(!((t)->flags & BITRAS))\n#define setrealasize(t)\t\t((t)->flags &= cast_byte(~BITRAS))\n#define setnorealasize(t)\t((t)->flags |= BITRAS)\n\n\ntypedef struct ArrayCell ArrayCell;\n\n\ntypedef struct Table {\n  CommonHeader;\n  lu_byte flags;  /* 1<<p means tagmethod(p) is not present */\n  lu_byte lsizenode;  /* log2 of size of 'node' array */\n  unsigned int alimit;  /* \"limit\" of 'array' array */\n  ArrayCell *array;  /* array part */\n  Node *node;\n  struct Table *metatable;\n  GCObject *gclist;\n} Table;\n\n\n/*\n** Macros to manipulate keys inserted in nodes\n*/\n#define keytt(node)\t\t((node)->u.key_tt)\n#define keyval(node)\t\t((node)->u.key_val)\n\n#define keyisnil(node)\t\t(keytt(node) == LUA_TNIL)\n#define keyisinteger(node)\t(keytt(node) == LUA_VNUMINT)\n#define keyival(node)\t\t(keyval(node).i)\n#define keyisshrstr(node)\t(keytt(node) == ctb(LUA_VSHRSTR))\n#define keystrval(node)\t\t(gco2ts(keyval(node).gc))\n\n#define setnilkey(node)\t\t(keytt(node) = LUA_TNIL)\n\n#define keyiscollectable(n)\t(keytt(n) & BIT_ISCOLLECTABLE)\n\n#define gckey(n)\t(keyval(n).gc)\n#define gckeyN(n)\t(keyiscollectable(n) ? gckey(n) : NULL)\n\n\n/*\n** Dead keys in tables have the tag DEADKEY but keep their original\n** gcvalue. This distinguishes them from regular keys but allows them to\n** be found when searched in a special way. ('next' needs that to find\n** keys removed from a table during a traversal.)\n*/\n#define setdeadkey(node)\t(keytt(node) = LUA_TDEADKEY)\n#define keyisdead(node)\t\t(keytt(node) == LUA_TDEADKEY)\n\n/* }================================================================== */\n\n\n\n/*\n** 'module' operation for hashing (size is always a power of 2)\n*/\n#define lmod(s,size) \\\n\t(check_exp((size&(size-1))==0, (cast_int((s) & ((size)-1)))))\n\n\n#define twoto(x)\t(1<<(x))\n#define sizenode(t)\t(twoto((t)->lsizenode))\n\n\n/* size of buffer for 'luaO_utf8esc' function */\n#define UTF8BUFFSZ\t8\n\nLUAI_FUNC int luaO_utf8esc (char *buff, unsigned long x);\nLUAI_FUNC int luaO_ceillog2 (unsigned int x);\nLUAI_FUNC unsigned int luaO_codeparam (unsigned int p);\nLUAI_FUNC l_obj luaO_applyparam (unsigned int p, l_obj x);\n\nLUAI_FUNC int luaO_rawarith (lua_State *L, int op, const TValue *p1,\n                             const TValue *p2, TValue *res);\nLUAI_FUNC void luaO_arith (lua_State *L, int op, const TValue *p1,\n                           const TValue *p2, StkId res);\nLUAI_FUNC size_t luaO_str2num (const char *s, TValue *o);\nLUAI_FUNC int luaO_hexavalue (int c);\nLUAI_FUNC void luaO_tostring (lua_State *L, TValue *obj);\nLUAI_FUNC const char *luaO_pushvfstring (lua_State *L, const char *fmt,\n                                                       va_list argp);\nLUAI_FUNC const char *luaO_pushfstring (lua_State *L, const char *fmt, ...);\nLUAI_FUNC void luaO_chunkid (char *out, const char *source, size_t srclen);\n\n\n#endif\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lopcodes.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: lopcodes.c $\n** Opcodes for Lua virtual machine\n** See Copyright Notice in lua.h\n*/\n\n#define lopcodes_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include \"lopcodes.h\"\n\n\n/* ORDER OP */\n\nLUAI_DDEF const lu_byte luaP_opmodes[NUM_OPCODES] = {\n/*       MM OT IT T  A  mode\t\t   opcode  */\n  opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_MOVE */\n ,opmode(0, 0, 0, 0, 1, iAsBx)\t\t/* OP_LOADI */\n ,opmode(0, 0, 0, 0, 1, iAsBx)\t\t/* OP_LOADF */\n ,opmode(0, 0, 0, 0, 1, iABx)\t\t/* OP_LOADK */\n ,opmode(0, 0, 0, 0, 1, iABx)\t\t/* OP_LOADKX */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_LOADFALSE */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_LFALSESKIP */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_LOADTRUE */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_LOADNIL */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_GETUPVAL */\n ,opmode(0, 0, 0, 0, 0, iABC)\t\t/* OP_SETUPVAL */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_GETTABUP */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_GETTABLE */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_GETI */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_GETFIELD */\n ,opmode(0, 0, 0, 0, 0, iABC)\t\t/* OP_SETTABUP */\n ,opmode(0, 0, 0, 0, 0, iABC)\t\t/* OP_SETTABLE */\n ,opmode(0, 0, 0, 0, 0, iABC)\t\t/* OP_SETI */\n ,opmode(0, 0, 0, 0, 0, iABC)\t\t/* OP_SETFIELD */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_NEWTABLE */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_SELF */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_ADDI */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_ADDK */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_SUBK */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_MULK */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_MODK */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_POWK */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_DIVK */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_IDIVK */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_BANDK */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_BORK */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_BXORK */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_SHRI */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_SHLI */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_ADD */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_SUB */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_MUL */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_MOD */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_POW */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_DIV */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_IDIV */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_BAND */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_BOR */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_BXOR */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_SHL */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_SHR */\n ,opmode(1, 0, 0, 0, 0, iABC)\t\t/* OP_MMBIN */\n ,opmode(1, 0, 0, 0, 0, iABC)\t\t/* OP_MMBINI*/\n ,opmode(1, 0, 0, 0, 0, iABC)\t\t/* OP_MMBINK*/\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_UNM */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_BNOT */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_NOT */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_LEN */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_CONCAT */\n ,opmode(0, 0, 0, 0, 0, iABC)\t\t/* OP_CLOSE */\n ,opmode(0, 0, 0, 0, 0, iABC)\t\t/* OP_TBC */\n ,opmode(0, 0, 0, 0, 0, isJ)\t\t/* OP_JMP */\n ,opmode(0, 0, 0, 1, 0, iABC)\t\t/* OP_EQ */\n ,opmode(0, 0, 0, 1, 0, iABC)\t\t/* OP_LT */\n ,opmode(0, 0, 0, 1, 0, iABC)\t\t/* OP_LE */\n ,opmode(0, 0, 0, 1, 0, iABC)\t\t/* OP_EQK */\n ,opmode(0, 0, 0, 1, 0, iABC)\t\t/* OP_EQI */\n ,opmode(0, 0, 0, 1, 0, iABC)\t\t/* OP_LTI */\n ,opmode(0, 0, 0, 1, 0, iABC)\t\t/* OP_LEI */\n ,opmode(0, 0, 0, 1, 0, iABC)\t\t/* OP_GTI */\n ,opmode(0, 0, 0, 1, 0, iABC)\t\t/* OP_GEI */\n ,opmode(0, 0, 0, 1, 0, iABC)\t\t/* OP_TEST */\n ,opmode(0, 0, 0, 1, 1, iABC)\t\t/* OP_TESTSET */\n ,opmode(0, 1, 1, 0, 1, iABC)\t\t/* OP_CALL */\n ,opmode(0, 1, 1, 0, 1, iABC)\t\t/* OP_TAILCALL */\n ,opmode(0, 0, 1, 0, 0, iABC)\t\t/* OP_RETURN */\n ,opmode(0, 0, 0, 0, 0, iABC)\t\t/* OP_RETURN0 */\n ,opmode(0, 0, 0, 0, 0, iABC)\t\t/* OP_RETURN1 */\n ,opmode(0, 0, 0, 0, 1, iABx)\t\t/* OP_FORLOOP */\n ,opmode(0, 0, 0, 0, 1, iABx)\t\t/* OP_FORPREP */\n ,opmode(0, 0, 0, 0, 0, iABx)\t\t/* OP_TFORPREP */\n ,opmode(0, 0, 0, 0, 0, iABC)\t\t/* OP_TFORCALL */\n ,opmode(0, 0, 0, 0, 1, iABx)\t\t/* OP_TFORLOOP */\n ,opmode(0, 0, 1, 0, 0, iABC)\t\t/* OP_SETLIST */\n ,opmode(0, 0, 0, 0, 1, iABx)\t\t/* OP_CLOSURE */\n ,opmode(0, 1, 0, 0, 1, iABC)\t\t/* OP_VARARG */\n ,opmode(0, 0, 1, 0, 1, iABC)\t\t/* OP_VARARGPREP */\n ,opmode(0, 0, 0, 0, 0, iAx)\t\t/* OP_EXTRAARG */\n};\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lopcodes.h",
		"is_binary":	false,
		"content":	"/*\n** $Id: lopcodes.h $\n** Opcodes for Lua virtual machine\n** See Copyright Notice in lua.h\n*/\n\n#ifndef lopcodes_h\n#define lopcodes_h\n\n#include \"llimits.h\"\n\n\n/*===========================================================================\n  We assume that instructions are unsigned 32-bit integers.\n  All instructions have an opcode in the first 7 bits.\n  Instructions can have the following formats:\n\n        3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0\n        1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0\niABC          C(8)     |      B(8)     |k|     A(8)      |   Op(7)     |\niABx                Bx(17)               |     A(8)      |   Op(7)     |\niAsBx              sBx (signed)(17)      |     A(8)      |   Op(7)     |\niAx                           Ax(25)                     |   Op(7)     |\nisJ                           sJ (signed)(25)            |   Op(7)     |\n\n  A signed argument is represented in excess K: the represented value is\n  the written unsigned value minus K, where K is half the maximum for the\n  corresponding unsigned argument.\n===========================================================================*/\n\n\nenum OpMode {iABC, iABx, iAsBx, iAx, isJ};  /* basic instruction formats */\n\n\n/*\n** size and position of opcode arguments.\n*/\n#define SIZE_C\t\t8\n#define SIZE_B\t\t8\n#define SIZE_Bx\t\t(SIZE_C + SIZE_B + 1)\n#define SIZE_A\t\t8\n#define SIZE_Ax\t\t(SIZE_Bx + SIZE_A)\n#define SIZE_sJ\t\t(SIZE_Bx + SIZE_A)\n\n#define SIZE_OP\t\t7\n\n#define POS_OP\t\t0\n\n#define POS_A\t\t(POS_OP + SIZE_OP)\n#define POS_k\t\t(POS_A + SIZE_A)\n#define POS_B\t\t(POS_k + 1)\n#define POS_C\t\t(POS_B + SIZE_B)\n\n#define POS_Bx\t\tPOS_k\n\n#define POS_Ax\t\tPOS_A\n\n#define POS_sJ\t\tPOS_A\n\n\n/*\n** limits for opcode arguments.\n** we use (signed) 'int' to manipulate most arguments,\n** so they must fit in ints.\n*/\n\n/* Check whether type 'int' has at least 'b' bits ('b' < 32) */\n#define L_INTHASBITS(b)\t\t((UINT_MAX >> ((b) - 1)) >= 1)\n\n\n#if L_INTHASBITS(SIZE_Bx)\n#define MAXARG_Bx\t((1<<SIZE_Bx)-1)\n#else\n#define MAXARG_Bx\tMAX_INT\n#endif\n\n#define OFFSET_sBx\t(MAXARG_Bx>>1)         /* 'sBx' is signed */\n\n\n#if L_INTHASBITS(SIZE_Ax)\n#define MAXARG_Ax\t((1<<SIZE_Ax)-1)\n#else\n#define MAXARG_Ax\tMAX_INT\n#endif\n\n#if L_INTHASBITS(SIZE_sJ)\n#define MAXARG_sJ\t((1 << SIZE_sJ) - 1)\n#else\n#define MAXARG_sJ\tMAX_INT\n#endif\n\n#define OFFSET_sJ\t(MAXARG_sJ >> 1)\n\n\n#define MAXARG_A\t((1<<SIZE_A)-1)\n#define MAXARG_B\t((1<<SIZE_B)-1)\n#define MAXARG_C\t((1<<SIZE_C)-1)\n#define OFFSET_sC\t(MAXARG_C >> 1)\n\n#define int2sC(i)\t((i) + OFFSET_sC)\n#define sC2int(i)\t((i) - OFFSET_sC)\n\n\n/* creates a mask with 'n' 1 bits at position 'p' */\n#define MASK1(n,p)\t((~((~(Instruction)0)<<(n)))<<(p))\n\n/* creates a mask with 'n' 0 bits at position 'p' */\n#define MASK0(n,p)\t(~MASK1(n,p))\n\n/*\n** the following macros help to manipulate instructions\n*/\n\n#define GET_OPCODE(i)\t(cast(OpCode, ((i)>>POS_OP) & MASK1(SIZE_OP,0)))\n#define SET_OPCODE(i,o)\t((i) = (((i)&MASK0(SIZE_OP,POS_OP)) | \\\n\t\t((cast(Instruction, o)<<POS_OP)&MASK1(SIZE_OP,POS_OP))))\n\n#define checkopm(i,m)\t(getOpMode(GET_OPCODE(i)) == m)\n\n\n#define getarg(i,pos,size)\t(cast_int(((i)>>(pos)) & MASK1(size,0)))\n#define setarg(i,v,pos,size)\t((i) = (((i)&MASK0(size,pos)) | \\\n                ((cast(Instruction, v)<<pos)&MASK1(size,pos))))\n\n#define GETARG_A(i)\tgetarg(i, POS_A, SIZE_A)\n#define SETARG_A(i,v)\tsetarg(i, v, POS_A, SIZE_A)\n\n#define GETARG_B(i)\tcheck_exp(checkopm(i, iABC), getarg(i, POS_B, SIZE_B))\n#define GETARG_sB(i)\tsC2int(GETARG_B(i))\n#define SETARG_B(i,v)\tsetarg(i, v, POS_B, SIZE_B)\n\n#define GETARG_C(i)\tcheck_exp(checkopm(i, iABC), getarg(i, POS_C, SIZE_C))\n#define GETARG_sC(i)\tsC2int(GETARG_C(i))\n#define SETARG_C(i,v)\tsetarg(i, v, POS_C, SIZE_C)\n\n#define TESTARG_k(i)\tcheck_exp(checkopm(i, iABC), (cast_int(((i) & (1u << POS_k)))))\n#define GETARG_k(i)\tcheck_exp(checkopm(i, iABC), getarg(i, POS_k, 1))\n#define SETARG_k(i,v)\tsetarg(i, v, POS_k, 1)\n\n#define GETARG_Bx(i)\tcheck_exp(checkopm(i, iABx), getarg(i, POS_Bx, SIZE_Bx))\n#define SETARG_Bx(i,v)\tsetarg(i, v, POS_Bx, SIZE_Bx)\n\n#define GETARG_Ax(i)\tcheck_exp(checkopm(i, iAx), getarg(i, POS_Ax, SIZE_Ax))\n#define SETARG_Ax(i,v)\tsetarg(i, v, POS_Ax, SIZE_Ax)\n\n#define GETARG_sBx(i)  \\\n\tcheck_exp(checkopm(i, iAsBx), getarg(i, POS_Bx, SIZE_Bx) - OFFSET_sBx)\n#define SETARG_sBx(i,b)\tSETARG_Bx((i),cast_uint((b)+OFFSET_sBx))\n\n#define GETARG_sJ(i)  \\\n\tcheck_exp(checkopm(i, isJ), getarg(i, POS_sJ, SIZE_sJ) - OFFSET_sJ)\n#define SETARG_sJ(i,j) \\\n\tsetarg(i, cast_uint((j)+OFFSET_sJ), POS_sJ, SIZE_sJ)\n\n\n#define CREATE_ABCk(o,a,b,c,k)\t((cast(Instruction, o)<<POS_OP) \\\n\t\t\t| (cast(Instruction, a)<<POS_A) \\\n\t\t\t| (cast(Instruction, b)<<POS_B) \\\n\t\t\t| (cast(Instruction, c)<<POS_C) \\\n\t\t\t| (cast(Instruction, k)<<POS_k))\n\n#define CREATE_ABx(o,a,bc)\t((cast(Instruction, o)<<POS_OP) \\\n\t\t\t| (cast(Instruction, a)<<POS_A) \\\n\t\t\t| (cast(Instruction, bc)<<POS_Bx))\n\n#define CREATE_Ax(o,a)\t\t((cast(Instruction, o)<<POS_OP) \\\n\t\t\t| (cast(Instruction, a)<<POS_Ax))\n\n#define CREATE_sJ(o,j,k)\t((cast(Instruction, o) << POS_OP) \\\n\t\t\t| (cast(Instruction, j) << POS_sJ) \\\n\t\t\t| (cast(Instruction, k) << POS_k))\n\n\n#if !defined(MAXINDEXRK)  /* (for debugging only) */\n#define MAXINDEXRK\tMAXARG_B\n#endif\n\n\n/*\n** invalid register that fits in 8 bits\n*/\n#define NO_REG\t\tMAXARG_A\n\n\n/*\n** R[x] - register\n** K[x] - constant (in constant table)\n** RK(x) == if k(i) then K[x] else R[x]\n*/\n\n\n/*\n** Grep \"ORDER OP\" if you change these enums. Opcodes marked with a (*)\n** has extra descriptions in the notes after the enumeration.\n*/\n\ntypedef enum {\n/*----------------------------------------------------------------------\n  name\t\targs\tdescription\n------------------------------------------------------------------------*/\nOP_MOVE,/*\tA B\tR[A] := R[B]\t\t\t\t\t*/\nOP_LOADI,/*\tA sBx\tR[A] := sBx\t\t\t\t\t*/\nOP_LOADF,/*\tA sBx\tR[A] := (lua_Number)sBx\t\t\t\t*/\nOP_LOADK,/*\tA Bx\tR[A] := K[Bx]\t\t\t\t\t*/\nOP_LOADKX,/*\tA\tR[A] := K[extra arg]\t\t\t\t*/\nOP_LOADFALSE,/*\tA\tR[A] := false\t\t\t\t\t*/\nOP_LFALSESKIP,/*A\tR[A] := false; pc++\t(*)\t\t\t*/\nOP_LOADTRUE,/*\tA\tR[A] := true\t\t\t\t\t*/\nOP_LOADNIL,/*\tA B\tR[A], R[A+1], ..., R[A+B] := nil\t\t*/\nOP_GETUPVAL,/*\tA B\tR[A] := UpValue[B]\t\t\t\t*/\nOP_SETUPVAL,/*\tA B\tUpValue[B] := R[A]\t\t\t\t*/\n\nOP_GETTABUP,/*\tA B C\tR[A] := UpValue[B][K[C]:shortstring]\t\t*/\nOP_GETTABLE,/*\tA B C\tR[A] := R[B][R[C]]\t\t\t\t*/\nOP_GETI,/*\tA B C\tR[A] := R[B][C]\t\t\t\t\t*/\nOP_GETFIELD,/*\tA B C\tR[A] := R[B][K[C]:shortstring]\t\t\t*/\n\nOP_SETTABUP,/*\tA B C\tUpValue[A][K[B]:shortstring] := RK(C)\t\t*/\nOP_SETTABLE,/*\tA B C\tR[A][R[B]] := RK(C)\t\t\t\t*/\nOP_SETI,/*\tA B C\tR[A][B] := RK(C)\t\t\t\t*/\nOP_SETFIELD,/*\tA B C\tR[A][K[B]:shortstring] := RK(C)\t\t\t*/\n\nOP_NEWTABLE,/*\tA B C k\tR[A] := {}\t\t\t\t\t*/\n\nOP_SELF,/*\tA B C\tR[A+1] := R[B]; R[A] := R[B][RK(C):string]\t*/\n\nOP_ADDI,/*\tA B sC\tR[A] := R[B] + sC\t\t\t\t*/\n\nOP_ADDK,/*\tA B C\tR[A] := R[B] + K[C]:number\t\t\t*/\nOP_SUBK,/*\tA B C\tR[A] := R[B] - K[C]:number\t\t\t*/\nOP_MULK,/*\tA B C\tR[A] := R[B] * K[C]:number\t\t\t*/\nOP_MODK,/*\tA B C\tR[A] := R[B] % K[C]:number\t\t\t*/\nOP_POWK,/*\tA B C\tR[A] := R[B] ^ K[C]:number\t\t\t*/\nOP_DIVK,/*\tA B C\tR[A] := R[B] / K[C]:number\t\t\t*/\nOP_IDIVK,/*\tA B C\tR[A] := R[B] // K[C]:number\t\t\t*/\n\nOP_BANDK,/*\tA B C\tR[A] := R[B] & K[C]:integer\t\t\t*/\nOP_BORK,/*\tA B C\tR[A] := R[B] | K[C]:integer\t\t\t*/\nOP_BXORK,/*\tA B C\tR[A] := R[B] ~ K[C]:integer\t\t\t*/\n\nOP_SHRI,/*\tA B sC\tR[A] := R[B] >> sC\t\t\t\t*/\nOP_SHLI,/*\tA B sC\tR[A] := sC << R[B]\t\t\t\t*/\n\nOP_ADD,/*\tA B C\tR[A] := R[B] + R[C]\t\t\t\t*/\nOP_SUB,/*\tA B C\tR[A] := R[B] - R[C]\t\t\t\t*/\nOP_MUL,/*\tA B C\tR[A] := R[B] * R[C]\t\t\t\t*/\nOP_MOD,/*\tA B C\tR[A] := R[B] % R[C]\t\t\t\t*/\nOP_POW,/*\tA B C\tR[A] := R[B] ^ R[C]\t\t\t\t*/\nOP_DIV,/*\tA B C\tR[A] := R[B] / R[C]\t\t\t\t*/\nOP_IDIV,/*\tA B C\tR[A] := R[B] // R[C]\t\t\t\t*/\n\nOP_BAND,/*\tA B C\tR[A] := R[B] & R[C]\t\t\t\t*/\nOP_BOR,/*\tA B C\tR[A] := R[B] | R[C]\t\t\t\t*/\nOP_BXOR,/*\tA B C\tR[A] := R[B] ~ R[C]\t\t\t\t*/\nOP_SHL,/*\tA B C\tR[A] := R[B] << R[C]\t\t\t\t*/\nOP_SHR,/*\tA B C\tR[A] := R[B] >> R[C]\t\t\t\t*/\n\nOP_MMBIN,/*\tA B C\tcall C metamethod over R[A] and R[B]\t(*)\t*/\nOP_MMBINI,/*\tA sB C k\tcall C metamethod over R[A] and sB\t*/\nOP_MMBINK,/*\tA B C k\t\tcall C metamethod over R[A] and K[B]\t*/\n\nOP_UNM,/*\tA B\tR[A] := -R[B]\t\t\t\t\t*/\nOP_BNOT,/*\tA B\tR[A] := ~R[B]\t\t\t\t\t*/\nOP_NOT,/*\tA B\tR[A] := not R[B]\t\t\t\t*/\nOP_LEN,/*\tA B\tR[A] := #R[B] (length operator)\t\t\t*/\n\nOP_CONCAT,/*\tA B\tR[A] := R[A].. ... ..R[A + B - 1]\t\t*/\n\nOP_CLOSE,/*\tA\tclose all upvalues >= R[A]\t\t\t*/\nOP_TBC,/*\tA\tmark variable A \"to be closed\"\t\t\t*/\nOP_JMP,/*\tsJ\tpc += sJ\t\t\t\t\t*/\nOP_EQ,/*\tA B k\tif ((R[A] == R[B]) ~= k) then pc++\t\t*/\nOP_LT,/*\tA B k\tif ((R[A] <  R[B]) ~= k) then pc++\t\t*/\nOP_LE,/*\tA B k\tif ((R[A] <= R[B]) ~= k) then pc++\t\t*/\n\nOP_EQK,/*\tA B k\tif ((R[A] == K[B]) ~= k) then pc++\t\t*/\nOP_EQI,/*\tA sB k\tif ((R[A] == sB) ~= k) then pc++\t\t*/\nOP_LTI,/*\tA sB k\tif ((R[A] < sB) ~= k) then pc++\t\t\t*/\nOP_LEI,/*\tA sB k\tif ((R[A] <= sB) ~= k) then pc++\t\t*/\nOP_GTI,/*\tA sB k\tif ((R[A] > sB) ~= k) then pc++\t\t\t*/\nOP_GEI,/*\tA sB k\tif ((R[A] >= sB) ~= k) then pc++\t\t*/\n\nOP_TEST,/*\tA k\tif (not R[A] == k) then pc++\t\t\t*/\nOP_TESTSET,/*\tA B k\tif (not R[B] == k) then pc++ else R[A] := R[B] (*) */\n\nOP_CALL,/*\tA B C\tR[A], ... ,R[A+C-2] := R[A](R[A+1], ... ,R[A+B-1]) */\nOP_TAILCALL,/*\tA B C k\treturn R[A](R[A+1], ... ,R[A+B-1])\t\t*/\n\nOP_RETURN,/*\tA B C k\treturn R[A], ... ,R[A+B-2]\t(see note)\t*/\nOP_RETURN0,/*\t\treturn\t\t\t\t\t\t*/\nOP_RETURN1,/*\tA\treturn R[A]\t\t\t\t\t*/\n\nOP_FORLOOP,/*\tA Bx\tupdate counters; if loop continues then pc-=Bx; */\nOP_FORPREP,/*\tA Bx\t<check values and prepare counters>;\n                        if not to run then pc+=Bx+1;\t\t\t*/\n\nOP_TFORPREP,/*\tA Bx\tcreate upvalue for R[A + 3]; pc+=Bx\t\t*/\nOP_TFORCALL,/*\tA C\tR[A+4], ... ,R[A+3+C] := R[A](R[A+1], R[A+2]);\t*/\nOP_TFORLOOP,/*\tA Bx\tif R[A+2] ~= nil then { R[A]=R[A+2]; pc -= Bx }\t*/\n\nOP_SETLIST,/*\tA B C k\tR[A][C+i] := R[A+i], 1 <= i <= B\t\t*/\n\nOP_CLOSURE,/*\tA Bx\tR[A] := closure(KPROTO[Bx])\t\t\t*/\n\nOP_VARARG,/*\tA C\tR[A], R[A+1], ..., R[A+C-2] = vararg\t\t*/\n\nOP_VARARGPREP,/*A\t(adjust vararg parameters)\t\t\t*/\n\nOP_EXTRAARG/*\tAx\textra (larger) argument for previous opcode\t*/\n} OpCode;\n\n\n#define NUM_OPCODES\t((int)(OP_EXTRAARG) + 1)\n\n\n\n/*===========================================================================\n  Notes:\n\n  (*) Opcode OP_LFALSESKIP is used to convert a condition to a boolean\n  value, in a code equivalent to (not cond ? false : true).  (It\n  produces false and skips the next instruction producing true.)\n\n  (*) Opcodes OP_MMBIN and variants follow each arithmetic and\n  bitwise opcode. If the operation succeeds, it skips this next\n  opcode. Otherwise, this opcode calls the corresponding metamethod.\n\n  (*) Opcode OP_TESTSET is used in short-circuit expressions that need\n  both to jump and to produce a value, such as (a = b or c).\n\n  (*) In OP_CALL, if (B == 0) then B = top - A. If (C == 0), then\n  'top' is set to last_result+1, so next open instruction (OP_CALL,\n  OP_RETURN*, OP_SETLIST) may use 'top'.\n\n  (*) In OP_VARARG, if (C == 0) then use actual number of varargs and\n  set top (like in OP_CALL with C == 0).\n\n  (*) In OP_RETURN, if (B == 0) then return up to 'top'.\n\n  (*) In OP_LOADKX and OP_NEWTABLE, the next instruction is always\n  OP_EXTRAARG.\n\n  (*) In OP_SETLIST, if (B == 0) then real B = 'top'; if k, then\n  real C = EXTRAARG _ C (the bits of EXTRAARG concatenated with the\n  bits of C).\n\n  (*) In OP_NEWTABLE, B is log2 of the hash size (which is always a\n  power of 2) plus 1, or zero for size zero. If not k, the array size\n  is C. Otherwise, the array size is EXTRAARG _ C.\n\n  (*) For comparisons, k specifies what condition the test should accept\n  (true or false).\n\n  (*) In OP_MMBINI/OP_MMBINK, k means the arguments were flipped\n   (the constant is the first operand).\n\n  (*) All 'skips' (pc++) assume that next instruction is a jump.\n\n  (*) In instructions OP_RETURN/OP_TAILCALL, 'k' specifies that the\n  function builds upvalues, which may need to be closed. C > 0 means\n  the function is vararg, so that its 'func' must be corrected before\n  returning; in this case, (C - 1) is its number of fixed parameters.\n\n  (*) In comparisons with an immediate operand, C signals whether the\n  original operand was a float. (It must be corrected in case of\n  metamethods.)\n\n===========================================================================*/\n\n\n/*\n** masks for instruction properties. The format is:\n** bits 0-2: op mode\n** bit 3: instruction set register A\n** bit 4: operator is a test (next instruction must be a jump)\n** bit 5: instruction uses 'L->top' set by previous instruction (when B == 0)\n** bit 6: instruction sets 'L->top' for next instruction (when C == 0)\n** bit 7: instruction is an MM instruction (call a metamethod)\n*/\n\nLUAI_DDEC(const lu_byte luaP_opmodes[NUM_OPCODES];)\n\n#define getOpMode(m)\t(cast(enum OpMode, luaP_opmodes[m] & 7))\n#define testAMode(m)\t(luaP_opmodes[m] & (1 << 3))\n#define testTMode(m)\t(luaP_opmodes[m] & (1 << 4))\n#define testITMode(m)\t(luaP_opmodes[m] & (1 << 5))\n#define testOTMode(m)\t(luaP_opmodes[m] & (1 << 6))\n#define testMMMode(m)\t(luaP_opmodes[m] & (1 << 7))\n\n/* \"out top\" (set top for next instruction) */\n#define isOT(i)  \\\n\t((testOTMode(GET_OPCODE(i)) && GETARG_C(i) == 0) || \\\n          GET_OPCODE(i) == OP_TAILCALL)\n\n/* \"in top\" (uses top from previous instruction) */\n#define isIT(i)\t\t(testITMode(GET_OPCODE(i)) && GETARG_B(i) == 0)\n\n#define opmode(mm,ot,it,t,a,m)  \\\n    (((mm) << 7) | ((ot) << 6) | ((it) << 5) | ((t) << 4) | ((a) << 3) | (m))\n\n\n/* number of list items to accumulate before a SETLIST instruction */\n#define LFIELDS_PER_FLUSH\t50\n\n#endif\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lopnames.h",
		"is_binary":	false,
		"content":	"/*\n** $Id: lopnames.h $\n** Opcode names\n** See Copyright Notice in lua.h\n*/\n\n#if !defined(lopnames_h)\n#define lopnames_h\n\n#include <stddef.h>\n\n\n/* ORDER OP */\n\nstatic const char *const opnames[] = {\n  \"MOVE\",\n  \"LOADI\",\n  \"LOADF\",\n  \"LOADK\",\n  \"LOADKX\",\n  \"LOADFALSE\",\n  \"LFALSESKIP\",\n  \"LOADTRUE\",\n  \"LOADNIL\",\n  \"GETUPVAL\",\n  \"SETUPVAL\",\n  \"GETTABUP\",\n  \"GETTABLE\",\n  \"GETI\",\n  \"GETFIELD\",\n  \"SETTABUP\",\n  \"SETTABLE\",\n  \"SETI\",\n  \"SETFIELD\",\n  \"NEWTABLE\",\n  \"SELF\",\n  \"ADDI\",\n  \"ADDK\",\n  \"SUBK\",\n  \"MULK\",\n  \"MODK\",\n  \"POWK\",\n  \"DIVK\",\n  \"IDIVK\",\n  \"BANDK\",\n  \"BORK\",\n  \"BXORK\",\n  \"SHRI\",\n  \"SHLI\",\n  \"ADD\",\n  \"SUB\",\n  \"MUL\",\n  \"MOD\",\n  \"POW\",\n  \"DIV\",\n  \"IDIV\",\n  \"BAND\",\n  \"BOR\",\n  \"BXOR\",\n  \"SHL\",\n  \"SHR\",\n  \"MMBIN\",\n  \"MMBINI\",\n  \"MMBINK\",\n  \"UNM\",\n  \"BNOT\",\n  \"NOT\",\n  \"LEN\",\n  \"CONCAT\",\n  \"CLOSE\",\n  \"TBC\",\n  \"JMP\",\n  \"EQ\",\n  \"LT\",\n  \"LE\",\n  \"EQK\",\n  \"EQI\",\n  \"LTI\",\n  \"LEI\",\n  \"GTI\",\n  \"GEI\",\n  \"TEST\",\n  \"TESTSET\",\n  \"CALL\",\n  \"TAILCALL\",\n  \"RETURN\",\n  \"RETURN0\",\n  \"RETURN1\",\n  \"FORLOOP\",\n  \"FORPREP\",\n  \"TFORPREP\",\n  \"TFORCALL\",\n  \"TFORLOOP\",\n  \"SETLIST\",\n  \"CLOSURE\",\n  \"VARARG\",\n  \"VARARGPREP\",\n  \"EXTRAARG\",\n  NULL\n};\n\n#endif\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/loslib.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: loslib.c $\n** Standard Operating System library\n** See Copyright Notice in lua.h\n*/\n\n#define loslib_c\n#define LUA_LIB\n\n#include \"lprefix.h\"\n\n\n#include <errno.h>\n#include <locale.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n\n\n/*\n** {==================================================================\n** List of valid conversion specifiers for the 'strftime' function;\n** options are grouped by length; group of length 2 start with '||'.\n** ===================================================================\n*/\n#if !defined(LUA_STRFTIMEOPTIONS)\t/* { */\n\n#if defined(LUA_USE_WINDOWS)\n#define LUA_STRFTIMEOPTIONS  \"aAbBcdHIjmMpSUwWxXyYzZ%\" \\\n    \"||\" \"#c#x#d#H#I#j#m#M#S#U#w#W#y#Y\"  /* two-char options */\n#elif defined(LUA_USE_C89)  /* ANSI C 89 (only 1-char options) */\n#define LUA_STRFTIMEOPTIONS  \"aAbBcdHIjmMpSUwWxXyYZ%\"\n#else  /* C99 specification */\n#define LUA_STRFTIMEOPTIONS  \"aAbBcCdDeFgGhHIjmMnprRStTuUVwWxXyYzZ%\" \\\n    \"||\" \"EcECExEXEyEY\" \"OdOeOHOIOmOMOSOuOUOVOwOWOy\"  /* two-char options */\n#endif\n\n#endif\t\t\t\t\t/* } */\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Configuration for time-related stuff\n** ===================================================================\n*/\n\n/*\n** type to represent time_t in Lua\n*/\n#if !defined(LUA_NUMTIME)\t/* { */\n\n#define l_timet\t\t\tlua_Integer\n#define l_pushtime(L,t)\t\tlua_pushinteger(L,(lua_Integer)(t))\n#define l_gettime(L,arg)\tluaL_checkinteger(L, arg)\n\n#else\t\t\t\t/* }{ */\n\n#define l_timet\t\t\tlua_Number\n#define l_pushtime(L,t)\t\tlua_pushnumber(L,(lua_Number)(t))\n#define l_gettime(L,arg)\tluaL_checknumber(L, arg)\n\n#endif\t\t\t\t/* } */\n\n\n#if !defined(l_gmtime)\t\t/* { */\n/*\n** By default, Lua uses gmtime/localtime, except when POSIX is available,\n** where it uses gmtime_r/localtime_r\n*/\n\n#if defined(LUA_USE_POSIX)\t/* { */\n\n#define l_gmtime(t,r)\t\tgmtime_r(t,r)\n#define l_localtime(t,r)\tlocaltime_r(t,r)\n\n#else\t\t\t\t/* }{ */\n\n/* ISO C definitions */\n#define l_gmtime(t,r)\t\t((void)(r)->tm_sec, gmtime(t))\n#define l_localtime(t,r)\t((void)(r)->tm_sec, localtime(t))\n\n#endif\t\t\t\t/* } */\n\n#endif\t\t\t\t/* } */\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Configuration for 'tmpnam':\n** By default, Lua uses tmpnam except when POSIX is available, where\n** it uses mkstemp.\n** ===================================================================\n*/\n#if !defined(lua_tmpnam)\t/* { */\n\n#if defined(LUA_USE_POSIX)\t/* { */\n\n#include <unistd.h>\n\n#define LUA_TMPNAMBUFSIZE\t32\n\n#if !defined(LUA_TMPNAMTEMPLATE)\n#define LUA_TMPNAMTEMPLATE\t\"/tmp/lua_XXXXXX\"\n#endif\n\n#define lua_tmpnam(b,e) { \\\n        strcpy(b, LUA_TMPNAMTEMPLATE); \\\n        e = mkstemp(b); \\\n        if (e != -1) close(e); \\\n        e = (e == -1); }\n\n#else\t\t\t\t/* }{ */\n\n/* ISO C definitions */\n#define LUA_TMPNAMBUFSIZE\tL_tmpnam\n#define lua_tmpnam(b,e)\t\t{ e = (tmpnam(b) == NULL); }\n\n#endif\t\t\t\t/* } */\n\n#endif\t\t\t\t/* } */\n/* }================================================================== */\n\n\n#if !defined(l_system)\n#if defined(LUA_USE_IOS)\n/* Despite claiming to be ISO C, iOS does not implement 'system'. */\n#define l_system(cmd) ((cmd) == NULL ? 0 : -1)\n#else\n#define l_system(cmd)\tsystem(cmd)  /* default definition */\n#endif\n#endif\n\n\nstatic int os_execute (lua_State *L) {\n  const char *cmd = luaL_optstring(L, 1, NULL);\n  int stat;\n  errno = 0;\n  stat = l_system(cmd);\n  if (cmd != NULL)\n    return luaL_execresult(L, stat);\n  else {\n    lua_pushboolean(L, stat);  /* true if there is a shell */\n    return 1;\n  }\n}\n\n\nstatic int os_remove (lua_State *L) {\n  const char *filename = luaL_checkstring(L, 1);\n  return luaL_fileresult(L, remove(filename) == 0, filename);\n}\n\n\nstatic int os_rename (lua_State *L) {\n  const char *fromname = luaL_checkstring(L, 1);\n  const char *toname = luaL_checkstring(L, 2);\n  return luaL_fileresult(L, rename(fromname, toname) == 0, NULL);\n}\n\n\nstatic int os_tmpname (lua_State *L) {\n  char buff[LUA_TMPNAMBUFSIZE];\n  int err;\n  lua_tmpnam(buff, err);\n  if (l_unlikely(err))\n    return luaL_error(L, \"unable to generate a unique filename\");\n  lua_pushstring(L, buff);\n  return 1;\n}\n\n\nstatic int os_getenv (lua_State *L) {\n  lua_pushstring(L, getenv(luaL_checkstring(L, 1)));  /* if NULL push nil */\n  return 1;\n}\n\n\nstatic int os_clock (lua_State *L) {\n  lua_pushnumber(L, ((lua_Number)clock())/(lua_Number)CLOCKS_PER_SEC);\n  return 1;\n}\n\n\n/*\n** {======================================================\n** Time/Date operations\n** { year=%Y, month=%m, day=%d, hour=%H, min=%M, sec=%S,\n**   wday=%w+1, yday=%j, isdst=? }\n** =======================================================\n*/\n\n/*\n** About the overflow check: an overflow cannot occur when time\n** is represented by a lua_Integer, because either lua_Integer is\n** large enough to represent all int fields or it is not large enough\n** to represent a time that cause a field to overflow.  However, if\n** times are represented as doubles and lua_Integer is int, then the\n** time 0x1.e1853b0d184f6p+55 would cause an overflow when adding 1900\n** to compute the year.\n*/\nstatic void setfield (lua_State *L, const char *key, int value, int delta) {\n  #if (defined(LUA_NUMTIME) && LUA_MAXINTEGER <= INT_MAX)\n    if (l_unlikely(value > LUA_MAXINTEGER - delta))\n      luaL_error(L, \"field '%s' is out-of-bound\", key);\n  #endif\n  lua_pushinteger(L, (lua_Integer)value + delta);\n  lua_setfield(L, -2, key);\n}\n\n\nstatic void setboolfield (lua_State *L, const char *key, int value) {\n  if (value < 0)  /* undefined? */\n    return;  /* does not set field */\n  lua_pushboolean(L, value);\n  lua_setfield(L, -2, key);\n}\n\n\n/*\n** Set all fields from structure 'tm' in the table on top of the stack\n*/\nstatic void setallfields (lua_State *L, struct tm *stm) {\n  setfield(L, \"year\", stm->tm_year, 1900);\n  setfield(L, \"month\", stm->tm_mon, 1);\n  setfield(L, \"day\", stm->tm_mday, 0);\n  setfield(L, \"hour\", stm->tm_hour, 0);\n  setfield(L, \"min\", stm->tm_min, 0);\n  setfield(L, \"sec\", stm->tm_sec, 0);\n  setfield(L, \"yday\", stm->tm_yday, 1);\n  setfield(L, \"wday\", stm->tm_wday, 1);\n  setboolfield(L, \"isdst\", stm->tm_isdst);\n}\n\n\nstatic int getboolfield (lua_State *L, const char *key) {\n  int res;\n  res = (lua_getfield(L, -1, key) == LUA_TNIL) ? -1 : lua_toboolean(L, -1);\n  lua_pop(L, 1);\n  return res;\n}\n\n\nstatic int getfield (lua_State *L, const char *key, int d, int delta) {\n  int isnum;\n  int t = lua_getfield(L, -1, key);  /* get field and its type */\n  lua_Integer res = lua_tointegerx(L, -1, &isnum);\n  if (!isnum) {  /* field is not an integer? */\n    if (l_unlikely(t != LUA_TNIL))  /* some other value? */\n      return luaL_error(L, \"field '%s' is not an integer\", key);\n    else if (l_unlikely(d < 0))  /* absent field; no default? */\n      return luaL_error(L, \"field '%s' missing in date table\", key);\n    res = d;\n  }\n  else {\n    if (!(res >= 0 ? res - delta <= INT_MAX : INT_MIN + delta <= res))\n      return luaL_error(L, \"field '%s' is out-of-bound\", key);\n    res -= delta;\n  }\n  lua_pop(L, 1);\n  return (int)res;\n}\n\n\nstatic const char *checkoption (lua_State *L, const char *conv,\n                                ptrdiff_t convlen, char *buff) {\n  const char *option = LUA_STRFTIMEOPTIONS;\n  int oplen = 1;  /* length of options being checked */\n  for (; *option != '\\0' && oplen <= convlen; option += oplen) {\n    if (*option == '|')  /* next block? */\n      oplen++;  /* will check options with next length (+1) */\n    else if (memcmp(conv, option, oplen) == 0) {  /* match? */\n      memcpy(buff, conv, oplen);  /* copy valid option to buffer */\n      buff[oplen] = '\\0';\n      return conv + oplen;  /* return next item */\n    }\n  }\n  luaL_argerror(L, 1,\n    lua_pushfstring(L, \"invalid conversion specifier '%%%s'\", conv));\n  return conv;  /* to avoid warnings */\n}\n\n\nstatic time_t l_checktime (lua_State *L, int arg) {\n  l_timet t = l_gettime(L, arg);\n  luaL_argcheck(L, (time_t)t == t, arg, \"time out-of-bounds\");\n  return (time_t)t;\n}\n\n\n/* maximum size for an individual 'strftime' item */\n#define SIZETIMEFMT\t250\n\n\nstatic int os_date (lua_State *L) {\n  size_t slen;\n  const char *s = luaL_optlstring(L, 1, \"%c\", &slen);\n  time_t t = luaL_opt(L, l_checktime, 2, time(NULL));\n  const char *se = s + slen;  /* 's' end */\n  struct tm tmr, *stm;\n  if (*s == '!') {  /* UTC? */\n    stm = l_gmtime(&t, &tmr);\n    s++;  /* skip '!' */\n  }\n  else\n    stm = l_localtime(&t, &tmr);\n  if (stm == NULL)  /* invalid date? */\n    return luaL_error(L,\n                 \"date result cannot be represented in this installation\");\n  if (strcmp(s, \"*t\") == 0) {\n    lua_createtable(L, 0, 9);  /* 9 = number of fields */\n    setallfields(L, stm);\n  }\n  else {\n    char cc[4];  /* buffer for individual conversion specifiers */\n    luaL_Buffer b;\n    cc[0] = '%';\n    luaL_buffinit(L, &b);\n    while (s < se) {\n      if (*s != '%')  /* not a conversion specifier? */\n        luaL_addchar(&b, *s++);\n      else {\n        size_t reslen;\n        char *buff = luaL_prepbuffsize(&b, SIZETIMEFMT);\n        s++;  /* skip '%' */\n        s = checkoption(L, s, se - s, cc + 1);  /* copy specifier to 'cc' */\n        reslen = strftime(buff, SIZETIMEFMT, cc, stm);\n        luaL_addsize(&b, reslen);\n      }\n    }\n    luaL_pushresult(&b);\n  }\n  return 1;\n}\n\n\nstatic int os_time (lua_State *L) {\n  time_t t;\n  if (lua_isnoneornil(L, 1))  /* called without args? */\n    t = time(NULL);  /* get current time */\n  else {\n    struct tm ts;\n    luaL_checktype(L, 1, LUA_TTABLE);\n    lua_settop(L, 1);  /* make sure table is at the top */\n    ts.tm_year = getfield(L, \"year\", -1, 1900);\n    ts.tm_mon = getfield(L, \"month\", -1, 1);\n    ts.tm_mday = getfield(L, \"day\", -1, 0);\n    ts.tm_hour = getfield(L, \"hour\", 12, 0);\n    ts.tm_min = getfield(L, \"min\", 0, 0);\n    ts.tm_sec = getfield(L, \"sec\", 0, 0);\n    ts.tm_isdst = getboolfield(L, \"isdst\");\n    t = mktime(&ts);\n    setallfields(L, &ts);  /* update fields with normalized values */\n  }\n  if (t != (time_t)(l_timet)t || t == (time_t)(-1))\n    return luaL_error(L,\n                  \"time result cannot be represented in this installation\");\n  l_pushtime(L, t);\n  return 1;\n}\n\n\nstatic int os_difftime (lua_State *L) {\n  time_t t1 = l_checktime(L, 1);\n  time_t t2 = l_checktime(L, 2);\n  lua_pushnumber(L, (lua_Number)difftime(t1, t2));\n  return 1;\n}\n\n/* }====================================================== */\n\n\nstatic int os_setlocale (lua_State *L) {\n  static const int cat[] = {LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY,\n                      LC_NUMERIC, LC_TIME};\n  static const char *const catnames[] = {\"all\", \"collate\", \"ctype\", \"monetary\",\n     \"numeric\", \"time\", NULL};\n  const char *l = luaL_optstring(L, 1, NULL);\n  int op = luaL_checkoption(L, 2, \"all\", catnames);\n  lua_pushstring(L, setlocale(cat[op], l));\n  return 1;\n}\n\n\nstatic int os_exit (lua_State *L) {\n  int status;\n  if (lua_isboolean(L, 1))\n    status = (lua_toboolean(L, 1) ? EXIT_SUCCESS : EXIT_FAILURE);\n  else\n    status = (int)luaL_optinteger(L, 1, EXIT_SUCCESS);\n  if (lua_toboolean(L, 2))\n    lua_close(L);\n  if (L) exit(status);  /* 'if' to avoid warnings for unreachable 'return' */\n  return 0;\n}\n\n\nstatic const luaL_Reg syslib[] = {\n  {\"clock\",     os_clock},\n  {\"date\",      os_date},\n  {\"difftime\",  os_difftime},\n  {\"execute\",   os_execute},\n  {\"exit\",      os_exit},\n  {\"getenv\",    os_getenv},\n  {\"remove\",    os_remove},\n  {\"rename\",    os_rename},\n  {\"setlocale\", os_setlocale},\n  {\"time\",      os_time},\n  {\"tmpname\",   os_tmpname},\n  {NULL, NULL}\n};\n\n/* }====================================================== */\n\n\n\nLUAMOD_API int luaopen_os (lua_State *L) {\n  luaL_newlib(L, syslib);\n  return 1;\n}\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lparser.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: lparser.c $\n** Lua Parser\n** See Copyright Notice in lua.h\n*/\n\n#define lparser_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <limits.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lcode.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"llex.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lparser.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n\n\n\n/* maximum number of local variables per function (must be smaller\n   than 250, due to the bytecode format) */\n#define MAXVARS\t\t200\n\n\n#define hasmultret(k)\t\t((k) == VCALL || (k) == VVARARG)\n\n\n/* because all strings are unified by the scanner, the parser\n   can use pointer equality for string equality */\n#define eqstr(a,b)\t((a) == (b))\n\n\n/*\n** nodes for block list (list of active blocks)\n*/\ntypedef struct BlockCnt {\n  struct BlockCnt *previous;  /* chain */\n  int firstlabel;  /* index of first label in this block */\n  int firstgoto;  /* index of first pending goto in this block */\n  lu_byte nactvar;  /* # active locals outside the block */\n  lu_byte upval;  /* true if some variable in the block is an upvalue */\n  lu_byte isloop;  /* true if 'block' is a loop */\n  lu_byte insidetbc;  /* true if inside the scope of a to-be-closed var. */\n} BlockCnt;\n\n\n\n/*\n** prototypes for recursive non-terminal functions\n*/\nstatic void statement (LexState *ls);\nstatic void expr (LexState *ls, expdesc *v);\n\n\nstatic l_noret error_expected (LexState *ls, int token) {\n  luaX_syntaxerror(ls,\n      luaO_pushfstring(ls->L, \"%s expected\", luaX_token2str(ls, token)));\n}\n\n\nstatic l_noret errorlimit (FuncState *fs, int limit, const char *what) {\n  lua_State *L = fs->ls->L;\n  const char *msg;\n  int line = fs->f->linedefined;\n  const char *where = (line == 0)\n                      ? \"main function\"\n                      : luaO_pushfstring(L, \"function at line %d\", line);\n  msg = luaO_pushfstring(L, \"too many %s (limit is %d) in %s\",\n                             what, limit, where);\n  luaX_syntaxerror(fs->ls, msg);\n}\n\n\nstatic void checklimit (FuncState *fs, int v, int l, const char *what) {\n  if (v > l) errorlimit(fs, l, what);\n}\n\n\n/*\n** Test whether next token is 'c'; if so, skip it.\n*/\nstatic int testnext (LexState *ls, int c) {\n  if (ls->t.token == c) {\n    luaX_next(ls);\n    return 1;\n  }\n  else return 0;\n}\n\n\n/*\n** Check that next token is 'c'.\n*/\nstatic void check (LexState *ls, int c) {\n  if (ls->t.token != c)\n    error_expected(ls, c);\n}\n\n\n/*\n** Check that next token is 'c' and skip it.\n*/\nstatic void checknext (LexState *ls, int c) {\n  check(ls, c);\n  luaX_next(ls);\n}\n\n\n#define check_condition(ls,c,msg)\t{ if (!(c)) luaX_syntaxerror(ls, msg); }\n\n\n/*\n** Check that next token is 'what' and skip it. In case of error,\n** raise an error that the expected 'what' should match a 'who'\n** in line 'where' (if that is not the current line).\n*/\nstatic void check_match (LexState *ls, int what, int who, int where) {\n  if (l_unlikely(!testnext(ls, what))) {\n    if (where == ls->linenumber)  /* all in the same line? */\n      error_expected(ls, what);  /* do not need a complex message */\n    else {\n      luaX_syntaxerror(ls, luaO_pushfstring(ls->L,\n             \"%s expected (to close %s at line %d)\",\n              luaX_token2str(ls, what), luaX_token2str(ls, who), where));\n    }\n  }\n}\n\n\nstatic TString *str_checkname (LexState *ls) {\n  TString *ts;\n  check(ls, TK_NAME);\n  ts = ls->t.seminfo.ts;\n  luaX_next(ls);\n  return ts;\n}\n\n\nstatic void init_exp (expdesc *e, expkind k, int i) {\n  e->f = e->t = NO_JUMP;\n  e->k = k;\n  e->u.info = i;\n}\n\n\nstatic void codestring (expdesc *e, TString *s) {\n  e->f = e->t = NO_JUMP;\n  e->k = VKSTR;\n  e->u.strval = s;\n}\n\n\nstatic void codename (LexState *ls, expdesc *e) {\n  codestring(e, str_checkname(ls));\n}\n\n\n/*\n** Register a new local variable in the active 'Proto' (for debug\n** information).\n*/\nstatic int registerlocalvar (LexState *ls, FuncState *fs, TString *varname) {\n  Proto *f = fs->f;\n  int oldsize = f->sizelocvars;\n  luaM_growvector(ls->L, f->locvars, fs->ndebugvars, f->sizelocvars,\n                  LocVar, SHRT_MAX, \"local variables\");\n  while (oldsize < f->sizelocvars)\n    f->locvars[oldsize++].varname = NULL;\n  f->locvars[fs->ndebugvars].varname = varname;\n  f->locvars[fs->ndebugvars].startpc = fs->pc;\n  luaC_objbarrier(ls->L, f, varname);\n  return fs->ndebugvars++;\n}\n\n\n/*\n** Create a new local variable with the given 'name' and given 'kind'.\n** Return its index in the function.\n*/\nstatic int new_localvarkind (LexState *ls, TString *name, int kind) {\n  lua_State *L = ls->L;\n  FuncState *fs = ls->fs;\n  Dyndata *dyd = ls->dyd;\n  Vardesc *var;\n  checklimit(fs, dyd->actvar.n + 1 - fs->firstlocal,\n                 MAXVARS, \"local variables\");\n  luaM_growvector(L, dyd->actvar.arr, dyd->actvar.n + 1,\n                  dyd->actvar.size, Vardesc, USHRT_MAX, \"local variables\");\n  var = &dyd->actvar.arr[dyd->actvar.n++];\n  var->vd.kind = kind;  /* default */\n  var->vd.name = name;\n  return dyd->actvar.n - 1 - fs->firstlocal;\n}\n\n\n/*\n** Create a new local variable with the given 'name' and regular kind.\n*/\nstatic int new_localvar (LexState *ls, TString *name) {\n  return new_localvarkind(ls, name, VDKREG);\n}\n\n#define new_localvarliteral(ls,v) \\\n    new_localvar(ls,  \\\n      luaX_newstring(ls, \"\" v, (sizeof(v)/sizeof(char)) - 1));\n\n\n\n/*\n** Return the \"variable description\" (Vardesc) of a given variable.\n** (Unless noted otherwise, all variables are referred to by their\n** compiler indices.)\n*/\nstatic Vardesc *getlocalvardesc (FuncState *fs, int vidx) {\n  return &fs->ls->dyd->actvar.arr[fs->firstlocal + vidx];\n}\n\n\n/*\n** Convert 'nvar', a compiler index level, to its corresponding\n** register. For that, search for the highest variable below that level\n** that is in a register and uses its register index ('ridx') plus one.\n*/\nstatic int reglevel (FuncState *fs, int nvar) {\n  while (nvar-- > 0) {\n    Vardesc *vd = getlocalvardesc(fs, nvar);  /* get previous variable */\n    if (vd->vd.kind != RDKCTC)  /* is in a register? */\n      return vd->vd.ridx + 1;\n  }\n  return 0;  /* no variables in registers */\n}\n\n\n/*\n** Return the number of variables in the register stack for the given\n** function.\n*/\nint luaY_nvarstack (FuncState *fs) {\n  return reglevel(fs, fs->nactvar);\n}\n\n\n/*\n** Get the debug-information entry for current variable 'vidx'.\n*/\nstatic LocVar *localdebuginfo (FuncState *fs, int vidx) {\n  Vardesc *vd = getlocalvardesc(fs,  vidx);\n  if (vd->vd.kind == RDKCTC)\n    return NULL;  /* no debug info. for constants */\n  else {\n    int idx = vd->vd.pidx;\n    lua_assert(idx < fs->ndebugvars);\n    return &fs->f->locvars[idx];\n  }\n}\n\n\n/*\n** Create an expression representing variable 'vidx'\n*/\nstatic void init_var (FuncState *fs, expdesc *e, int vidx) {\n  e->f = e->t = NO_JUMP;\n  e->k = VLOCAL;\n  e->u.var.vidx = vidx;\n  e->u.var.ridx = getlocalvardesc(fs, vidx)->vd.ridx;\n}\n\n\n/*\n** Raises an error if variable described by 'e' is read only\n*/\nstatic void check_readonly (LexState *ls, expdesc *e) {\n  FuncState *fs = ls->fs;\n  TString *varname = NULL;  /* to be set if variable is const */\n  switch (e->k) {\n    case VCONST: {\n      varname = ls->dyd->actvar.arr[e->u.info].vd.name;\n      break;\n    }\n    case VLOCAL: {\n      Vardesc *vardesc = getlocalvardesc(fs, e->u.var.vidx);\n      if (vardesc->vd.kind != VDKREG)  /* not a regular variable? */\n        varname = vardesc->vd.name;\n      break;\n    }\n    case VUPVAL: {\n      Upvaldesc *up = &fs->f->upvalues[e->u.info];\n      if (up->kind != VDKREG)\n        varname = up->name;\n      break;\n    }\n    default:\n      return;  /* other cases cannot be read-only */\n  }\n  if (varname) {\n    const char *msg = luaO_pushfstring(ls->L,\n       \"attempt to assign to const variable '%s'\", getstr(varname));\n    luaK_semerror(ls, msg);  /* error */\n  }\n}\n\n\n/*\n** Start the scope for the last 'nvars' created variables.\n*/\nstatic void adjustlocalvars (LexState *ls, int nvars) {\n  FuncState *fs = ls->fs;\n  int reglevel = luaY_nvarstack(fs);\n  int i;\n  for (i = 0; i < nvars; i++) {\n    int vidx = fs->nactvar++;\n    Vardesc *var = getlocalvardesc(fs, vidx);\n    var->vd.ridx = reglevel++;\n    var->vd.pidx = registerlocalvar(ls, fs, var->vd.name);\n  }\n}\n\n\n/*\n** Close the scope for all variables up to level 'tolevel'.\n** (debug info.)\n*/\nstatic void removevars (FuncState *fs, int tolevel) {\n  fs->ls->dyd->actvar.n -= (fs->nactvar - tolevel);\n  while (fs->nactvar > tolevel) {\n    LocVar *var = localdebuginfo(fs, --fs->nactvar);\n    if (var)  /* does it have debug information? */\n      var->endpc = fs->pc;\n  }\n}\n\n\n/*\n** Search the upvalues of the function 'fs' for one\n** with the given 'name'.\n*/\nstatic int searchupvalue (FuncState *fs, TString *name) {\n  int i;\n  Upvaldesc *up = fs->f->upvalues;\n  for (i = 0; i < fs->nups; i++) {\n    if (eqstr(up[i].name, name)) return i;\n  }\n  return -1;  /* not found */\n}\n\n\nstatic Upvaldesc *allocupvalue (FuncState *fs) {\n  Proto *f = fs->f;\n  int oldsize = f->sizeupvalues;\n  checklimit(fs, fs->nups + 1, MAXUPVAL, \"upvalues\");\n  luaM_growvector(fs->ls->L, f->upvalues, fs->nups, f->sizeupvalues,\n                  Upvaldesc, MAXUPVAL, \"upvalues\");\n  while (oldsize < f->sizeupvalues)\n    f->upvalues[oldsize++].name = NULL;\n  return &f->upvalues[fs->nups++];\n}\n\n\nstatic int newupvalue (FuncState *fs, TString *name, expdesc *v) {\n  Upvaldesc *up = allocupvalue(fs);\n  FuncState *prev = fs->prev;\n  if (v->k == VLOCAL) {\n    up->instack = 1;\n    up->idx = v->u.var.ridx;\n    up->kind = getlocalvardesc(prev, v->u.var.vidx)->vd.kind;\n    lua_assert(eqstr(name, getlocalvardesc(prev, v->u.var.vidx)->vd.name));\n  }\n  else {\n    up->instack = 0;\n    up->idx = cast_byte(v->u.info);\n    up->kind = prev->f->upvalues[v->u.info].kind;\n    lua_assert(eqstr(name, prev->f->upvalues[v->u.info].name));\n  }\n  up->name = name;\n  luaC_objbarrier(fs->ls->L, fs->f, name);\n  return fs->nups - 1;\n}\n\n\n/*\n** Look for an active local variable with the name 'n' in the\n** function 'fs'. If found, initialize 'var' with it and return\n** its expression kind; otherwise return -1.\n*/\nstatic int searchvar (FuncState *fs, TString *n, expdesc *var) {\n  int i;\n  for (i = cast_int(fs->nactvar) - 1; i >= 0; i--) {\n    Vardesc *vd = getlocalvardesc(fs, i);\n    if (eqstr(n, vd->vd.name)) {  /* found? */\n      if (vd->vd.kind == RDKCTC)  /* compile-time constant? */\n        init_exp(var, VCONST, fs->firstlocal + i);\n      else  /* real variable */\n        init_var(fs, var, i);\n      return var->k;\n    }\n  }\n  return -1;  /* not found */\n}\n\n\n/*\n** Mark block where variable at given level was defined\n** (to emit close instructions later).\n*/\nstatic void markupval (FuncState *fs, int level) {\n  BlockCnt *bl = fs->bl;\n  while (bl->nactvar > level)\n    bl = bl->previous;\n  bl->upval = 1;\n  fs->needclose = 1;\n}\n\n\n/*\n** Mark that current block has a to-be-closed variable.\n*/\nstatic void marktobeclosed (FuncState *fs) {\n  BlockCnt *bl = fs->bl;\n  bl->upval = 1;\n  bl->insidetbc = 1;\n  fs->needclose = 1;\n}\n\n\n/*\n** Find a variable with the given name 'n'. If it is an upvalue, add\n** this upvalue into all intermediate functions. If it is a global, set\n** 'var' as 'void' as a flag.\n*/\nstatic void singlevaraux (FuncState *fs, TString *n, expdesc *var, int base) {\n  if (fs == NULL)  /* no more levels? */\n    init_exp(var, VVOID, 0);  /* default is global */\n  else {\n    int v = searchvar(fs, n, var);  /* look up locals at current level */\n    if (v >= 0) {  /* found? */\n      if (v == VLOCAL && !base)\n        markupval(fs, var->u.var.vidx);  /* local will be used as an upval */\n    }\n    else {  /* not found as local at current level; try upvalues */\n      int idx = searchupvalue(fs, n);  /* try existing upvalues */\n      if (idx < 0) {  /* not found? */\n        singlevaraux(fs->prev, n, var, 0);  /* try upper levels */\n        if (var->k == VLOCAL || var->k == VUPVAL)  /* local or upvalue? */\n          idx  = newupvalue(fs, n, var);  /* will be a new upvalue */\n        else  /* it is a global or a constant */\n          return;  /* don't need to do anything at this level */\n      }\n      init_exp(var, VUPVAL, idx);  /* new or old upvalue */\n    }\n  }\n}\n\n\n/*\n** Find a variable with the given name 'n', handling global variables\n** too.\n*/\nstatic void singlevar (LexState *ls, expdesc *var) {\n  TString *varname = str_checkname(ls);\n  FuncState *fs = ls->fs;\n  singlevaraux(fs, varname, var, 1);\n  if (var->k == VVOID) {  /* global name? */\n    expdesc key;\n    singlevaraux(fs, ls->envn, var, 1);  /* get environment variable */\n    lua_assert(var->k != VVOID);  /* this one must exist */\n    luaK_exp2anyregup(fs, var);  /* but could be a constant */\n    codestring(&key, varname);  /* key is variable name */\n    luaK_indexed(fs, var, &key);  /* env[varname] */\n  }\n}\n\n\n/*\n** Adjust the number of results from an expression list 'e' with 'nexps'\n** expressions to 'nvars' values.\n*/\nstatic void adjust_assign (LexState *ls, int nvars, int nexps, expdesc *e) {\n  FuncState *fs = ls->fs;\n  int needed = nvars - nexps;  /* extra values needed */\n  if (hasmultret(e->k)) {  /* last expression has multiple returns? */\n    int extra = needed + 1;  /* discount last expression itself */\n    if (extra < 0)\n      extra = 0;\n    luaK_setreturns(fs, e, extra);  /* last exp. provides the difference */\n  }\n  else {\n    if (e->k != VVOID)  /* at least one expression? */\n      luaK_exp2nextreg(fs, e);  /* close last expression */\n    if (needed > 0)  /* missing values? */\n      luaK_nil(fs, fs->freereg, needed);  /* complete with nils */\n  }\n  if (needed > 0)\n    luaK_reserveregs(fs, needed);  /* registers for extra values */\n  else  /* adding 'needed' is actually a subtraction */\n    fs->freereg += needed;  /* remove extra values */\n}\n\n\n#define enterlevel(ls)\tluaE_incCstack(ls->L)\n\n\n#define leavelevel(ls) ((ls)->L->nCcalls--)\n\n\n/*\n** Generates an error that a goto jumps into the scope of some\n** local variable.\n*/\nstatic l_noret jumpscopeerror (LexState *ls, Labeldesc *gt) {\n  TString *tsname = getlocalvardesc(ls->fs, gt->nactvar)->vd.name;\n  const char *varname = getstr(tsname);\n  const char *msg = \"<goto %s> at line %d jumps into the scope of local '%s'\";\n  msg = luaO_pushfstring(ls->L, msg, getstr(gt->name), gt->line, varname);\n  luaK_semerror(ls, msg);  /* raise the error */\n}\n\n\n/*\n** Solves the goto at index 'g' to given 'label' and removes it\n** from the list of pending gotos.\n** If it jumps into the scope of some variable, raises an error.\n*/\nstatic void solvegoto (LexState *ls, int g, Labeldesc *label) {\n  int i;\n  Labellist *gl = &ls->dyd->gt;  /* list of gotos */\n  Labeldesc *gt = &gl->arr[g];  /* goto to be resolved */\n  lua_assert(eqstr(gt->name, label->name));\n  if (l_unlikely(gt->nactvar < label->nactvar))  /* enter some scope? */\n    jumpscopeerror(ls, gt);\n  luaK_patchlist(ls->fs, gt->pc, label->pc);\n  for (i = g; i < gl->n - 1; i++)  /* remove goto from pending list */\n    gl->arr[i] = gl->arr[i + 1];\n  gl->n--;\n}\n\n\n/*\n** Search for an active label with the given name.\n*/\nstatic Labeldesc *findlabel (LexState *ls, TString *name) {\n  int i;\n  Dyndata *dyd = ls->dyd;\n  /* check labels in current function for a match */\n  for (i = ls->fs->firstlabel; i < dyd->label.n; i++) {\n    Labeldesc *lb = &dyd->label.arr[i];\n    if (eqstr(lb->name, name))  /* correct label? */\n      return lb;\n  }\n  return NULL;  /* label not found */\n}\n\n\n/*\n** Adds a new label/goto in the corresponding list.\n*/\nstatic int newlabelentry (LexState *ls, Labellist *l, TString *name,\n                          int line, int pc) {\n  int n = l->n;\n  luaM_growvector(ls->L, l->arr, n, l->size,\n                  Labeldesc, SHRT_MAX, \"labels/gotos\");\n  l->arr[n].name = name;\n  l->arr[n].line = line;\n  l->arr[n].nactvar = ls->fs->nactvar;\n  l->arr[n].close = 0;\n  l->arr[n].pc = pc;\n  l->n = n + 1;\n  return n;\n}\n\n\nstatic int newgotoentry (LexState *ls, TString *name, int line, int pc) {\n  return newlabelentry(ls, &ls->dyd->gt, name, line, pc);\n}\n\n\n/*\n** Solves forward jumps. Check whether new label 'lb' matches any\n** pending gotos in current block and solves them. Return true\n** if any of the gotos need to close upvalues.\n*/\nstatic int solvegotos (LexState *ls, Labeldesc *lb) {\n  Labellist *gl = &ls->dyd->gt;\n  int i = ls->fs->bl->firstgoto;\n  int needsclose = 0;\n  while (i < gl->n) {\n    if (eqstr(gl->arr[i].name, lb->name)) {\n      needsclose |= gl->arr[i].close;\n      solvegoto(ls, i, lb);  /* will remove 'i' from the list */\n    }\n    else\n      i++;\n  }\n  return needsclose;\n}\n\n\n/*\n** Create a new label with the given 'name' at the given 'line'.\n** 'last' tells whether label is the last non-op statement in its\n** block. Solves all pending gotos to this new label and adds\n** a close instruction if necessary.\n** Returns true iff it added a close instruction.\n*/\nstatic int createlabel (LexState *ls, TString *name, int line,\n                        int last) {\n  FuncState *fs = ls->fs;\n  Labellist *ll = &ls->dyd->label;\n  int l = newlabelentry(ls, ll, name, line, luaK_getlabel(fs));\n  if (last) {  /* label is last no-op statement in the block? */\n    /* assume that locals are already out of scope */\n    ll->arr[l].nactvar = fs->bl->nactvar;\n  }\n  if (solvegotos(ls, &ll->arr[l])) {  /* need close? */\n    luaK_codeABC(fs, OP_CLOSE, luaY_nvarstack(fs), 0, 0);\n    return 1;\n  }\n  return 0;\n}\n\n\n/*\n** Adjust pending gotos to outer level of a block.\n*/\nstatic void movegotosout (FuncState *fs, BlockCnt *bl) {\n  int i;\n  Labellist *gl = &fs->ls->dyd->gt;\n  /* correct pending gotos to current block */\n  for (i = bl->firstgoto; i < gl->n; i++) {  /* for each pending goto */\n    Labeldesc *gt = &gl->arr[i];\n    /* leaving a variable scope? */\n    if (reglevel(fs, gt->nactvar) > reglevel(fs, bl->nactvar))\n      gt->close |= bl->upval;  /* jump may need a close */\n    gt->nactvar = bl->nactvar;  /* update goto level */\n  }\n}\n\n\nstatic void enterblock (FuncState *fs, BlockCnt *bl, lu_byte isloop) {\n  bl->isloop = isloop;\n  bl->nactvar = fs->nactvar;\n  bl->firstlabel = fs->ls->dyd->label.n;\n  bl->firstgoto = fs->ls->dyd->gt.n;\n  bl->upval = 0;\n  bl->insidetbc = (fs->bl != NULL && fs->bl->insidetbc);\n  bl->previous = fs->bl;\n  fs->bl = bl;\n  lua_assert(fs->freereg == luaY_nvarstack(fs));\n}\n\n\n/*\n** generates an error for an undefined 'goto'.\n*/\nstatic l_noret undefgoto (LexState *ls, Labeldesc *gt) {\n  const char *msg;\n  if (eqstr(gt->name, luaS_newliteral(ls->L, \"break\"))) {\n    msg = \"break outside loop at line %d\";\n    msg = luaO_pushfstring(ls->L, msg, gt->line);\n  }\n  else {\n    msg = \"no visible label '%s' for <goto> at line %d\";\n    msg = luaO_pushfstring(ls->L, msg, getstr(gt->name), gt->line);\n  }\n  luaK_semerror(ls, msg);\n}\n\n\nstatic void leaveblock (FuncState *fs) {\n  BlockCnt *bl = fs->bl;\n  LexState *ls = fs->ls;\n  int hasclose = 0;\n  int stklevel = reglevel(fs, bl->nactvar);  /* level outside the block */\n  removevars(fs, bl->nactvar);  /* remove block locals */\n  lua_assert(bl->nactvar == fs->nactvar);  /* back to level on entry */\n  if (bl->isloop)  /* has to fix pending breaks? */\n    hasclose = createlabel(ls, luaS_newliteral(ls->L, \"break\"), 0, 0);\n  if (!hasclose && bl->previous && bl->upval)  /* still need a 'close'? */\n    luaK_codeABC(fs, OP_CLOSE, stklevel, 0, 0);\n  fs->freereg = stklevel;  /* free registers */\n  ls->dyd->label.n = bl->firstlabel;  /* remove local labels */\n  fs->bl = bl->previous;  /* current block now is previous one */\n  if (bl->previous)  /* was it a nested block? */\n    movegotosout(fs, bl);  /* update pending gotos to enclosing block */\n  else {\n    if (bl->firstgoto < ls->dyd->gt.n)  /* still pending gotos? */\n      undefgoto(ls, &ls->dyd->gt.arr[bl->firstgoto]);  /* error */\n  }\n}\n\n\n/*\n** adds a new prototype into list of prototypes\n*/\nstatic Proto *addprototype (LexState *ls) {\n  Proto *clp;\n  lua_State *L = ls->L;\n  FuncState *fs = ls->fs;\n  Proto *f = fs->f;  /* prototype of current function */\n  if (fs->np >= f->sizep) {\n    int oldsize = f->sizep;\n    luaM_growvector(L, f->p, fs->np, f->sizep, Proto *, MAXARG_Bx, \"functions\");\n    while (oldsize < f->sizep)\n      f->p[oldsize++] = NULL;\n  }\n  f->p[fs->np++] = clp = luaF_newproto(L);\n  luaC_objbarrier(L, f, clp);\n  return clp;\n}\n\n\n/*\n** codes instruction to create new closure in parent function.\n** The OP_CLOSURE instruction uses the last available register,\n** so that, if it invokes the GC, the GC knows which registers\n** are in use at that time.\n\n*/\nstatic void codeclosure (LexState *ls, expdesc *v) {\n  FuncState *fs = ls->fs->prev;\n  init_exp(v, VRELOC, luaK_codeABx(fs, OP_CLOSURE, 0, fs->np - 1));\n  luaK_exp2nextreg(fs, v);  /* fix it at the last register */\n}\n\n\nstatic void open_func (LexState *ls, FuncState *fs, BlockCnt *bl) {\n  Proto *f = fs->f;\n  fs->prev = ls->fs;  /* linked list of funcstates */\n  fs->ls = ls;\n  ls->fs = fs;\n  fs->pc = 0;\n  fs->previousline = f->linedefined;\n  fs->iwthabs = 0;\n  fs->lasttarget = 0;\n  fs->freereg = 0;\n  fs->nk = 0;\n  fs->nabslineinfo = 0;\n  fs->np = 0;\n  fs->nups = 0;\n  fs->ndebugvars = 0;\n  fs->nactvar = 0;\n  fs->needclose = 0;\n  fs->firstlocal = ls->dyd->actvar.n;\n  fs->firstlabel = ls->dyd->label.n;\n  fs->bl = NULL;\n  f->source = ls->source;\n  luaC_objbarrier(ls->L, f, f->source);\n  f->maxstacksize = 2;  /* registers 0/1 are always valid */\n  enterblock(fs, bl, 0);\n}\n\n\nstatic void close_func (LexState *ls) {\n  lua_State *L = ls->L;\n  FuncState *fs = ls->fs;\n  Proto *f = fs->f;\n  luaK_ret(fs, luaY_nvarstack(fs), 0);  /* final return */\n  leaveblock(fs);\n  lua_assert(fs->bl == NULL);\n  luaK_finish(fs);\n  luaM_shrinkvector(L, f->code, f->sizecode, fs->pc, Instruction);\n  luaM_shrinkvector(L, f->lineinfo, f->sizelineinfo, fs->pc, ls_byte);\n  luaM_shrinkvector(L, f->abslineinfo, f->sizeabslineinfo,\n                       fs->nabslineinfo, AbsLineInfo);\n  luaM_shrinkvector(L, f->k, f->sizek, fs->nk, TValue);\n  luaM_shrinkvector(L, f->p, f->sizep, fs->np, Proto *);\n  luaM_shrinkvector(L, f->locvars, f->sizelocvars, fs->ndebugvars, LocVar);\n  luaM_shrinkvector(L, f->upvalues, f->sizeupvalues, fs->nups, Upvaldesc);\n  ls->fs = fs->prev;\n  luaC_checkGC(L);\n}\n\n\n\n/*============================================================*/\n/* GRAMMAR RULES */\n/*============================================================*/\n\n\n/*\n** check whether current token is in the follow set of a block.\n** 'until' closes syntactical blocks, but do not close scope,\n** so it is handled in separate.\n*/\nstatic int block_follow (LexState *ls, int withuntil) {\n  switch (ls->t.token) {\n    case TK_ELSE: case TK_ELSEIF:\n    case TK_END: case TK_EOS:\n      return 1;\n    case TK_UNTIL: return withuntil;\n    default: return 0;\n  }\n}\n\n\nstatic void statlist (LexState *ls) {\n  /* statlist -> { stat [';'] } */\n  while (!block_follow(ls, 1)) {\n    if (ls->t.token == TK_RETURN) {\n      statement(ls);\n      return;  /* 'return' must be last statement */\n    }\n    statement(ls);\n  }\n}\n\n\nstatic void fieldsel (LexState *ls, expdesc *v) {\n  /* fieldsel -> ['.' | ':'] NAME */\n  FuncState *fs = ls->fs;\n  expdesc key;\n  luaK_exp2anyregup(fs, v);\n  luaX_next(ls);  /* skip the dot or colon */\n  codename(ls, &key);\n  luaK_indexed(fs, v, &key);\n}\n\n\nstatic void yindex (LexState *ls, expdesc *v) {\n  /* index -> '[' expr ']' */\n  luaX_next(ls);  /* skip the '[' */\n  expr(ls, v);\n  luaK_exp2val(ls->fs, v);\n  checknext(ls, ']');\n}\n\n\n/*\n** {======================================================================\n** Rules for Constructors\n** =======================================================================\n*/\n\n\ntypedef struct ConsControl {\n  expdesc v;  /* last list item read */\n  expdesc *t;  /* table descriptor */\n  int nh;  /* total number of 'record' elements */\n  int na;  /* number of array elements already stored */\n  int tostore;  /* number of array elements pending to be stored */\n} ConsControl;\n\n\nstatic void recfield (LexState *ls, ConsControl *cc) {\n  /* recfield -> (NAME | '['exp']') = exp */\n  FuncState *fs = ls->fs;\n  int reg = ls->fs->freereg;\n  expdesc tab, key, val;\n  if (ls->t.token == TK_NAME) {\n    checklimit(fs, cc->nh, MAX_INT, \"items in a constructor\");\n    codename(ls, &key);\n  }\n  else  /* ls->t.token == '[' */\n    yindex(ls, &key);\n  cc->nh++;\n  checknext(ls, '=');\n  tab = *cc->t;\n  luaK_indexed(fs, &tab, &key);\n  expr(ls, &val);\n  luaK_storevar(fs, &tab, &val);\n  fs->freereg = reg;  /* free registers */\n}\n\n\nstatic void closelistfield (FuncState *fs, ConsControl *cc) {\n  if (cc->v.k == VVOID) return;  /* there is no list item */\n  luaK_exp2nextreg(fs, &cc->v);\n  cc->v.k = VVOID;\n  if (cc->tostore == LFIELDS_PER_FLUSH) {\n    luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);  /* flush */\n    cc->na += cc->tostore;\n    cc->tostore = 0;  /* no more items pending */\n  }\n}\n\n\nstatic void lastlistfield (FuncState *fs, ConsControl *cc) {\n  if (cc->tostore == 0) return;\n  if (hasmultret(cc->v.k)) {\n    luaK_setmultret(fs, &cc->v);\n    luaK_setlist(fs, cc->t->u.info, cc->na, LUA_MULTRET);\n    cc->na--;  /* do not count last expression (unknown number of elements) */\n  }\n  else {\n    if (cc->v.k != VVOID)\n      luaK_exp2nextreg(fs, &cc->v);\n    luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);\n  }\n  cc->na += cc->tostore;\n}\n\n\nstatic void listfield (LexState *ls, ConsControl *cc) {\n  /* listfield -> exp */\n  expr(ls, &cc->v);\n  cc->tostore++;\n}\n\n\nstatic void field (LexState *ls, ConsControl *cc) {\n  /* field -> listfield | recfield */\n  switch(ls->t.token) {\n    case TK_NAME: {  /* may be 'listfield' or 'recfield' */\n      if (luaX_lookahead(ls) != '=')  /* expression? */\n        listfield(ls, cc);\n      else\n        recfield(ls, cc);\n      break;\n    }\n    case '[': {\n      recfield(ls, cc);\n      break;\n    }\n    default: {\n      listfield(ls, cc);\n      break;\n    }\n  }\n}\n\n\nstatic void constructor (LexState *ls, expdesc *t) {\n  /* constructor -> '{' [ field { sep field } [sep] ] '}'\n     sep -> ',' | ';' */\n  FuncState *fs = ls->fs;\n  int line = ls->linenumber;\n  int pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0);\n  ConsControl cc;\n  luaK_code(fs, 0);  /* space for extra arg. */\n  cc.na = cc.nh = cc.tostore = 0;\n  cc.t = t;\n  init_exp(t, VNONRELOC, fs->freereg);  /* table will be at stack top */\n  luaK_reserveregs(fs, 1);\n  init_exp(&cc.v, VVOID, 0);  /* no value (yet) */\n  checknext(ls, '{');\n  do {\n    lua_assert(cc.v.k == VVOID || cc.tostore > 0);\n    if (ls->t.token == '}') break;\n    closelistfield(fs, &cc);\n    field(ls, &cc);\n  } while (testnext(ls, ',') || testnext(ls, ';'));\n  check_match(ls, '}', '{', line);\n  lastlistfield(fs, &cc);\n  luaK_settablesize(fs, pc, t->u.info, cc.na, cc.nh);\n}\n\n/* }====================================================================== */\n\n\nstatic void setvararg (FuncState *fs, int nparams) {\n  fs->f->flag |= PF_ISVARARG;\n  luaK_codeABC(fs, OP_VARARGPREP, nparams, 0, 0);\n}\n\n\nstatic void parlist (LexState *ls) {\n  /* parlist -> [ {NAME ','} (NAME | '...') ] */\n  FuncState *fs = ls->fs;\n  Proto *f = fs->f;\n  int nparams = 0;\n  int isvararg = 0;\n  if (ls->t.token != ')') {  /* is 'parlist' not empty? */\n    do {\n      switch (ls->t.token) {\n        case TK_NAME: {\n          new_localvar(ls, str_checkname(ls));\n          nparams++;\n          break;\n        }\n        case TK_DOTS: {\n          luaX_next(ls);\n          isvararg = 1;\n          break;\n        }\n        default: luaX_syntaxerror(ls, \"<name> or '...' expected\");\n      }\n    } while (!isvararg && testnext(ls, ','));\n  }\n  adjustlocalvars(ls, nparams);\n  f->numparams = cast_byte(fs->nactvar);\n  if (isvararg)\n    setvararg(fs, f->numparams);  /* declared vararg */\n  luaK_reserveregs(fs, fs->nactvar);  /* reserve registers for parameters */\n}\n\n\nstatic void body (LexState *ls, expdesc *e, int ismethod, int line) {\n  /* body ->  '(' parlist ')' block END */\n  FuncState new_fs;\n  BlockCnt bl;\n  new_fs.f = addprototype(ls);\n  new_fs.f->linedefined = line;\n  open_func(ls, &new_fs, &bl);\n  checknext(ls, '(');\n  if (ismethod) {\n    new_localvarliteral(ls, \"self\");  /* create 'self' parameter */\n    adjustlocalvars(ls, 1);\n  }\n  parlist(ls);\n  checknext(ls, ')');\n  statlist(ls);\n  new_fs.f->lastlinedefined = ls->linenumber;\n  check_match(ls, TK_END, TK_FUNCTION, line);\n  codeclosure(ls, e);\n  close_func(ls);\n}\n\n\nstatic int explist (LexState *ls, expdesc *v) {\n  /* explist -> expr { ',' expr } */\n  int n = 1;  /* at least one expression */\n  expr(ls, v);\n  while (testnext(ls, ',')) {\n    luaK_exp2nextreg(ls->fs, v);\n    expr(ls, v);\n    n++;\n  }\n  return n;\n}\n\n\nstatic void funcargs (LexState *ls, expdesc *f) {\n  FuncState *fs = ls->fs;\n  expdesc args;\n  int base, nparams;\n  int line = ls->linenumber;\n  switch (ls->t.token) {\n    case '(': {  /* funcargs -> '(' [ explist ] ')' */\n      luaX_next(ls);\n      if (ls->t.token == ')')  /* arg list is empty? */\n        args.k = VVOID;\n      else {\n        explist(ls, &args);\n        if (hasmultret(args.k))\n          luaK_setmultret(fs, &args);\n      }\n      check_match(ls, ')', '(', line);\n      break;\n    }\n    case '{': {  /* funcargs -> constructor */\n      constructor(ls, &args);\n      break;\n    }\n    case TK_STRING: {  /* funcargs -> STRING */\n      codestring(&args, ls->t.seminfo.ts);\n      luaX_next(ls);  /* must use 'seminfo' before 'next' */\n      break;\n    }\n    default: {\n      luaX_syntaxerror(ls, \"function arguments expected\");\n    }\n  }\n  lua_assert(f->k == VNONRELOC);\n  base = f->u.info;  /* base register for call */\n  if (hasmultret(args.k))\n    nparams = LUA_MULTRET;  /* open call */\n  else {\n    if (args.k != VVOID)\n      luaK_exp2nextreg(fs, &args);  /* close last argument */\n    nparams = fs->freereg - (base+1);\n  }\n  init_exp(f, VCALL, luaK_codeABC(fs, OP_CALL, base, nparams+1, 2));\n  luaK_fixline(fs, line);\n  fs->freereg = base+1;  /* call removes function and arguments and leaves\n                            one result (unless changed later) */\n}\n\n\n\n\n/*\n** {======================================================================\n** Expression parsing\n** =======================================================================\n*/\n\n\nstatic void primaryexp (LexState *ls, expdesc *v) {\n  /* primaryexp -> NAME | '(' expr ')' */\n  switch (ls->t.token) {\n    case '(': {\n      int line = ls->linenumber;\n      luaX_next(ls);\n      expr(ls, v);\n      check_match(ls, ')', '(', line);\n      luaK_dischargevars(ls->fs, v);\n      return;\n    }\n    case TK_NAME: {\n      singlevar(ls, v);\n      return;\n    }\n    default: {\n      luaX_syntaxerror(ls, \"unexpected symbol\");\n    }\n  }\n}\n\n\nstatic void suffixedexp (LexState *ls, expdesc *v) {\n  /* suffixedexp ->\n       primaryexp { '.' NAME | '[' exp ']' | ':' NAME funcargs | funcargs } */\n  FuncState *fs = ls->fs;\n  primaryexp(ls, v);\n  for (;;) {\n    switch (ls->t.token) {\n      case '.': {  /* fieldsel */\n        fieldsel(ls, v);\n        break;\n      }\n      case '[': {  /* '[' exp ']' */\n        expdesc key;\n        luaK_exp2anyregup(fs, v);\n        yindex(ls, &key);\n        luaK_indexed(fs, v, &key);\n        break;\n      }\n      case ':': {  /* ':' NAME funcargs */\n        expdesc key;\n        luaX_next(ls);\n        codename(ls, &key);\n        luaK_self(fs, v, &key);\n        funcargs(ls, v);\n        break;\n      }\n      case '(': case TK_STRING: case '{': {  /* funcargs */\n        luaK_exp2nextreg(fs, v);\n        funcargs(ls, v);\n        break;\n      }\n      default: return;\n    }\n  }\n}\n\n\nstatic void simpleexp (LexState *ls, expdesc *v) {\n  /* simpleexp -> FLT | INT | STRING | NIL | TRUE | FALSE | ... |\n                  constructor | FUNCTION body | suffixedexp */\n  switch (ls->t.token) {\n    case TK_FLT: {\n      init_exp(v, VKFLT, 0);\n      v->u.nval = ls->t.seminfo.r;\n      break;\n    }\n    case TK_INT: {\n      init_exp(v, VKINT, 0);\n      v->u.ival = ls->t.seminfo.i;\n      break;\n    }\n    case TK_STRING: {\n      codestring(v, ls->t.seminfo.ts);\n      break;\n    }\n    case TK_NIL: {\n      init_exp(v, VNIL, 0);\n      break;\n    }\n    case TK_TRUE: {\n      init_exp(v, VTRUE, 0);\n      break;\n    }\n    case TK_FALSE: {\n      init_exp(v, VFALSE, 0);\n      break;\n    }\n    case TK_DOTS: {  /* vararg */\n      FuncState *fs = ls->fs;\n      check_condition(ls, fs->f->flag & PF_ISVARARG,\n                      \"cannot use '...' outside a vararg function\");\n      init_exp(v, VVARARG, luaK_codeABC(fs, OP_VARARG, 0, 0, 1));\n      break;\n    }\n    case '{': {  /* constructor */\n      constructor(ls, v);\n      return;\n    }\n    case TK_FUNCTION: {\n      luaX_next(ls);\n      body(ls, v, 0, ls->linenumber);\n      return;\n    }\n    default: {\n      suffixedexp(ls, v);\n      return;\n    }\n  }\n  luaX_next(ls);\n}\n\n\nstatic UnOpr getunopr (int op) {\n  switch (op) {\n    case TK_NOT: return OPR_NOT;\n    case '-': return OPR_MINUS;\n    case '~': return OPR_BNOT;\n    case '#': return OPR_LEN;\n    default: return OPR_NOUNOPR;\n  }\n}\n\n\nstatic BinOpr getbinopr (int op) {\n  switch (op) {\n    case '+': return OPR_ADD;\n    case '-': return OPR_SUB;\n    case '*': return OPR_MUL;\n    case '%': return OPR_MOD;\n    case '^': return OPR_POW;\n    case '/': return OPR_DIV;\n    case TK_IDIV: return OPR_IDIV;\n    case '&': return OPR_BAND;\n    case '|': return OPR_BOR;\n    case '~': return OPR_BXOR;\n    case TK_SHL: return OPR_SHL;\n    case TK_SHR: return OPR_SHR;\n    case TK_CONCAT: return OPR_CONCAT;\n    case TK_NE: return OPR_NE;\n    case TK_EQ: return OPR_EQ;\n    case '<': return OPR_LT;\n    case TK_LE: return OPR_LE;\n    case '>': return OPR_GT;\n    case TK_GE: return OPR_GE;\n    case TK_AND: return OPR_AND;\n    case TK_OR: return OPR_OR;\n    default: return OPR_NOBINOPR;\n  }\n}\n\n\n/*\n** Priority table for binary operators.\n*/\nstatic const struct {\n  lu_byte left;  /* left priority for each binary operator */\n  lu_byte right; /* right priority */\n} priority[] = {  /* ORDER OPR */\n   {10, 10}, {10, 10},           /* '+' '-' */\n   {11, 11}, {11, 11},           /* '*' '%' */\n   {14, 13},                  /* '^' (right associative) */\n   {11, 11}, {11, 11},           /* '/' '//' */\n   {6, 6}, {4, 4}, {5, 5},   /* '&' '|' '~' */\n   {7, 7}, {7, 7},           /* '<<' '>>' */\n   {9, 8},                   /* '..' (right associative) */\n   {3, 3}, {3, 3}, {3, 3},   /* ==, <, <= */\n   {3, 3}, {3, 3}, {3, 3},   /* ~=, >, >= */\n   {2, 2}, {1, 1}            /* and, or */\n};\n\n#define UNARY_PRIORITY\t12  /* priority for unary operators */\n\n\n/*\n** subexpr -> (simpleexp | unop subexpr) { binop subexpr }\n** where 'binop' is any binary operator with a priority higher than 'limit'\n*/\nstatic BinOpr subexpr (LexState *ls, expdesc *v, int limit) {\n  BinOpr op;\n  UnOpr uop;\n  enterlevel(ls);\n  uop = getunopr(ls->t.token);\n  if (uop != OPR_NOUNOPR) {  /* prefix (unary) operator? */\n    int line = ls->linenumber;\n    luaX_next(ls);  /* skip operator */\n    subexpr(ls, v, UNARY_PRIORITY);\n    luaK_prefix(ls->fs, uop, v, line);\n  }\n  else simpleexp(ls, v);\n  /* expand while operators have priorities higher than 'limit' */\n  op = getbinopr(ls->t.token);\n  while (op != OPR_NOBINOPR && priority[op].left > limit) {\n    expdesc v2;\n    BinOpr nextop;\n    int line = ls->linenumber;\n    luaX_next(ls);  /* skip operator */\n    luaK_infix(ls->fs, op, v);\n    /* read sub-expression with higher priority */\n    nextop = subexpr(ls, &v2, priority[op].right);\n    luaK_posfix(ls->fs, op, v, &v2, line);\n    op = nextop;\n  }\n  leavelevel(ls);\n  return op;  /* return first untreated operator */\n}\n\n\nstatic void expr (LexState *ls, expdesc *v) {\n  subexpr(ls, v, 0);\n}\n\n/* }==================================================================== */\n\n\n\n/*\n** {======================================================================\n** Rules for Statements\n** =======================================================================\n*/\n\n\nstatic void block (LexState *ls) {\n  /* block -> statlist */\n  FuncState *fs = ls->fs;\n  BlockCnt bl;\n  enterblock(fs, &bl, 0);\n  statlist(ls);\n  leaveblock(fs);\n}\n\n\n/*\n** structure to chain all variables in the left-hand side of an\n** assignment\n*/\nstruct LHS_assign {\n  struct LHS_assign *prev;\n  expdesc v;  /* variable (global, local, upvalue, or indexed) */\n};\n\n\n/*\n** check whether, in an assignment to an upvalue/local variable, the\n** upvalue/local variable is begin used in a previous assignment to a\n** table. If so, save original upvalue/local value in a safe place and\n** use this safe copy in the previous assignment.\n*/\nstatic void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v) {\n  FuncState *fs = ls->fs;\n  int extra = fs->freereg;  /* eventual position to save local variable */\n  int conflict = 0;\n  for (; lh; lh = lh->prev) {  /* check all previous assignments */\n    if (vkisindexed(lh->v.k)) {  /* assignment to table field? */\n      if (lh->v.k == VINDEXUP) {  /* is table an upvalue? */\n        if (v->k == VUPVAL && lh->v.u.ind.t == v->u.info) {\n          conflict = 1;  /* table is the upvalue being assigned now */\n          lh->v.k = VINDEXSTR;\n          lh->v.u.ind.t = extra;  /* assignment will use safe copy */\n        }\n      }\n      else {  /* table is a register */\n        if (v->k == VLOCAL && lh->v.u.ind.t == v->u.var.ridx) {\n          conflict = 1;  /* table is the local being assigned now */\n          lh->v.u.ind.t = extra;  /* assignment will use safe copy */\n        }\n        /* is index the local being assigned? */\n        if (lh->v.k == VINDEXED && v->k == VLOCAL &&\n            lh->v.u.ind.idx == v->u.var.ridx) {\n          conflict = 1;\n          lh->v.u.ind.idx = extra;  /* previous assignment will use safe copy */\n        }\n      }\n    }\n  }\n  if (conflict) {\n    /* copy upvalue/local value to a temporary (in position 'extra') */\n    if (v->k == VLOCAL)\n      luaK_codeABC(fs, OP_MOVE, extra, v->u.var.ridx, 0);\n    else\n      luaK_codeABC(fs, OP_GETUPVAL, extra, v->u.info, 0);\n    luaK_reserveregs(fs, 1);\n  }\n}\n\n/*\n** Parse and compile a multiple assignment. The first \"variable\"\n** (a 'suffixedexp') was already read by the caller.\n**\n** assignment -> suffixedexp restassign\n** restassign -> ',' suffixedexp restassign | '=' explist\n*/\nstatic void restassign (LexState *ls, struct LHS_assign *lh, int nvars) {\n  expdesc e;\n  check_condition(ls, vkisvar(lh->v.k), \"syntax private_lua_error\");\n  check_readonly(ls, &lh->v);\n  if (testnext(ls, ',')) {  /* restassign -> ',' suffixedexp restassign */\n    struct LHS_assign nv;\n    nv.prev = lh;\n    suffixedexp(ls, &nv.v);\n    if (!vkisindexed(nv.v.k))\n      check_conflict(ls, lh, &nv.v);\n    enterlevel(ls);  /* control recursion depth */\n    restassign(ls, &nv, nvars+1);\n    leavelevel(ls);\n  }\n  else {  /* restassign -> '=' explist */\n    int nexps;\n    checknext(ls, '=');\n    nexps = explist(ls, &e);\n    if (nexps != nvars)\n      adjust_assign(ls, nvars, nexps, &e);\n    else {\n      luaK_setoneret(ls->fs, &e);  /* close last expression */\n      luaK_storevar(ls->fs, &lh->v, &e);\n      return;  /* avoid default */\n    }\n  }\n  init_exp(&e, VNONRELOC, ls->fs->freereg-1);  /* default assignment */\n  luaK_storevar(ls->fs, &lh->v, &e);\n}\n\n\nstatic int cond (LexState *ls) {\n  /* cond -> exp */\n  expdesc v;\n  expr(ls, &v);  /* read condition */\n  if (v.k == VNIL) v.k = VFALSE;  /* 'falses' are all equal here */\n  luaK_goiftrue(ls->fs, &v);\n  return v.f;\n}\n\n\nstatic void gotostat (LexState *ls) {\n  FuncState *fs = ls->fs;\n  int line = ls->linenumber;\n  TString *name = str_checkname(ls);  /* label's name */\n  Labeldesc *lb = findlabel(ls, name);\n  if (lb == NULL)  /* no label? */\n    /* forward jump; will be resolved when the label is declared */\n    newgotoentry(ls, name, line, luaK_jump(fs));\n  else {  /* found a label */\n    /* backward jump; will be resolved here */\n    int lblevel = reglevel(fs, lb->nactvar);  /* label level */\n    if (luaY_nvarstack(fs) > lblevel)  /* leaving the scope of a variable? */\n      luaK_codeABC(fs, OP_CLOSE, lblevel, 0, 0);\n    /* create jump and link it to the label */\n    luaK_patchlist(fs, luaK_jump(fs), lb->pc);\n  }\n}\n\n\n/*\n** Break statement. Semantically equivalent to \"goto break\".\n*/\nstatic void breakstat (LexState *ls) {\n  int line = ls->linenumber;\n  luaX_next(ls);  /* skip break */\n  newgotoentry(ls, luaS_newliteral(ls->L, \"break\"), line, luaK_jump(ls->fs));\n}\n\n\n/*\n** Check whether there is already a label with the given 'name'.\n*/\nstatic void checkrepeated (LexState *ls, TString *name) {\n  Labeldesc *lb = findlabel(ls, name);\n  if (l_unlikely(lb != NULL)) {  /* already defined? */\n    const char *msg = \"label '%s' already defined on line %d\";\n    msg = luaO_pushfstring(ls->L, msg, getstr(name), lb->line);\n    luaK_semerror(ls, msg);  /* error */\n  }\n}\n\n\nstatic void labelstat (LexState *ls, TString *name, int line) {\n  /* label -> '::' NAME '::' */\n  checknext(ls, TK_DBCOLON);  /* skip double colon */\n  while (ls->t.token == ';' || ls->t.token == TK_DBCOLON)\n    statement(ls);  /* skip other no-op statements */\n  checkrepeated(ls, name);  /* check for repeated labels */\n  createlabel(ls, name, line, block_follow(ls, 0));\n}\n\n\nstatic void whilestat (LexState *ls, int line) {\n  /* whilestat -> WHILE cond DO block END */\n  FuncState *fs = ls->fs;\n  int whileinit;\n  int condexit;\n  BlockCnt bl;\n  luaX_next(ls);  /* skip WHILE */\n  whileinit = luaK_getlabel(fs);\n  condexit = cond(ls);\n  enterblock(fs, &bl, 1);\n  checknext(ls, TK_DO);\n  block(ls);\n  luaK_jumpto(fs, whileinit);\n  check_match(ls, TK_END, TK_WHILE, line);\n  leaveblock(fs);\n  luaK_patchtohere(fs, condexit);  /* false conditions finish the loop */\n}\n\n\nstatic void repeatstat (LexState *ls, int line) {\n  /* repeatstat -> REPEAT block UNTIL cond */\n  int condexit;\n  FuncState *fs = ls->fs;\n  int repeat_init = luaK_getlabel(fs);\n  BlockCnt bl1, bl2;\n  enterblock(fs, &bl1, 1);  /* loop block */\n  enterblock(fs, &bl2, 0);  /* scope block */\n  luaX_next(ls);  /* skip REPEAT */\n  statlist(ls);\n  check_match(ls, TK_UNTIL, TK_REPEAT, line);\n  condexit = cond(ls);  /* read condition (inside scope block) */\n  leaveblock(fs);  /* finish scope */\n  if (bl2.upval) {  /* upvalues? */\n    int exit = luaK_jump(fs);  /* normal exit must jump over fix */\n    luaK_patchtohere(fs, condexit);  /* repetition must close upvalues */\n    luaK_codeABC(fs, OP_CLOSE, reglevel(fs, bl2.nactvar), 0, 0);\n    condexit = luaK_jump(fs);  /* repeat after closing upvalues */\n    luaK_patchtohere(fs, exit);  /* normal exit comes to here */\n  }\n  luaK_patchlist(fs, condexit, repeat_init);  /* close the loop */\n  leaveblock(fs);  /* finish loop */\n}\n\n\n/*\n** Read an expression and generate code to put its results in next\n** stack slot.\n**\n*/\nstatic void exp1 (LexState *ls) {\n  expdesc e;\n  expr(ls, &e);\n  luaK_exp2nextreg(ls->fs, &e);\n  lua_assert(e.k == VNONRELOC);\n}\n\n\n/*\n** Fix for instruction at position 'pc' to jump to 'dest'.\n** (Jump addresses are relative in Lua). 'back' true means\n** a back jump.\n*/\nstatic void fixforjump (FuncState *fs, int pc, int dest, int back) {\n  Instruction *jmp = &fs->f->code[pc];\n  int offset = dest - (pc + 1);\n  if (back)\n    offset = -offset;\n  if (l_unlikely(offset > MAXARG_Bx))\n    luaX_syntaxerror(fs->ls, \"control structure too long\");\n  SETARG_Bx(*jmp, offset);\n}\n\n\n/*\n** Generate code for a 'for' loop.\n*/\nstatic void forbody (LexState *ls, int base, int line, int nvars, int isgen) {\n  /* forbody -> DO block */\n  static const OpCode forprep[2] = {OP_FORPREP, OP_TFORPREP};\n  static const OpCode forloop[2] = {OP_FORLOOP, OP_TFORLOOP};\n  BlockCnt bl;\n  FuncState *fs = ls->fs;\n  int prep, endfor;\n  checknext(ls, TK_DO);\n  prep = luaK_codeABx(fs, forprep[isgen], base, 0);\n  fs->freereg--;  /* both 'forprep' remove one register from the stack */\n  enterblock(fs, &bl, 0);  /* scope for declared variables */\n  adjustlocalvars(ls, nvars);\n  luaK_reserveregs(fs, nvars);\n  block(ls);\n  leaveblock(fs);  /* end of scope for declared variables */\n  fixforjump(fs, prep, luaK_getlabel(fs), 0);\n  if (isgen) {  /* generic for? */\n    luaK_codeABC(fs, OP_TFORCALL, base, 0, nvars);\n    luaK_fixline(fs, line);\n  }\n  endfor = luaK_codeABx(fs, forloop[isgen], base, 0);\n  fixforjump(fs, endfor, prep + 1, 1);\n  luaK_fixline(fs, line);\n}\n\n\nstatic void fornum (LexState *ls, TString *varname, int line) {\n  /* fornum -> NAME = exp,exp[,exp] forbody */\n  FuncState *fs = ls->fs;\n  int base = fs->freereg;\n  new_localvarliteral(ls, \"(for state)\");\n  new_localvarliteral(ls, \"(for state)\");\n  new_localvarkind(ls, varname, RDKCONST);  /* control variable */\n  checknext(ls, '=');\n  exp1(ls);  /* initial value */\n  checknext(ls, ',');\n  exp1(ls);  /* limit */\n  if (testnext(ls, ','))\n    exp1(ls);  /* optional step */\n  else {  /* default step = 1 */\n    luaK_int(fs, fs->freereg, 1);\n    luaK_reserveregs(fs, 1);\n  }\n  adjustlocalvars(ls, 2);  /* start scope for internal variables */\n  forbody(ls, base, line, 1, 0);\n}\n\n\nstatic void forlist (LexState *ls, TString *indexname) {\n  /* forlist -> NAME {,NAME} IN explist forbody */\n  FuncState *fs = ls->fs;\n  expdesc e;\n  int nvars = 4;  /* function, state, closing, control */\n  int line;\n  int base = fs->freereg;\n  /* create internal variables */\n  new_localvarliteral(ls, \"(for state)\");  /* iterator function */\n  new_localvarliteral(ls, \"(for state)\");  /* state */\n  new_localvarliteral(ls, \"(for state)\");  /* closing var. (after swap) */\n  new_localvarkind(ls, indexname, RDKCONST);  /* control variable */\n  /* other declared variables */\n  while (testnext(ls, ',')) {\n    new_localvar(ls, str_checkname(ls));\n    nvars++;\n  }\n  checknext(ls, TK_IN);\n  line = ls->linenumber;\n  adjust_assign(ls, 4, explist(ls, &e), &e);\n  adjustlocalvars(ls, 3);  /* start scope for internal variables */\n  marktobeclosed(fs);  /* last internal var. must be closed */\n  luaK_checkstack(fs, 2);  /* extra space to call iterator */\n  forbody(ls, base, line, nvars - 3, 1);\n}\n\n\nstatic void forstat (LexState *ls, int line) {\n  /* forstat -> FOR (fornum | forlist) END */\n  FuncState *fs = ls->fs;\n  TString *varname;\n  BlockCnt bl;\n  enterblock(fs, &bl, 1);  /* scope for loop and control variables */\n  luaX_next(ls);  /* skip 'for' */\n  varname = str_checkname(ls);  /* first variable name */\n  switch (ls->t.token) {\n    case '=': fornum(ls, varname, line); break;\n    case ',': case TK_IN: forlist(ls, varname); break;\n    default: luaX_syntaxerror(ls, \"'=' or 'in' expected\");\n  }\n  check_match(ls, TK_END, TK_FOR, line);\n  leaveblock(fs);  /* loop scope ('break' jumps to this point) */\n}\n\n\nstatic void test_then_block (LexState *ls, int *escapelist) {\n  /* test_then_block -> [IF | ELSEIF] cond THEN block */\n  BlockCnt bl;\n  FuncState *fs = ls->fs;\n  expdesc v;\n  int jf;  /* instruction to skip 'then' code (if condition is false) */\n  luaX_next(ls);  /* skip IF or ELSEIF */\n  expr(ls, &v);  /* read condition */\n  checknext(ls, TK_THEN);\n  if (ls->t.token == TK_BREAK) {  /* 'if x then break' ? */\n    int line = ls->linenumber;\n    luaK_goiffalse(ls->fs, &v);  /* will jump if condition is true */\n    luaX_next(ls);  /* skip 'break' */\n    enterblock(fs, &bl, 0);  /* must enter block before 'goto' */\n    newgotoentry(ls, luaS_newliteral(ls->L, \"break\"), line, v.t);\n    while (testnext(ls, ';')) {}  /* skip semicolons */\n    if (block_follow(ls, 0)) {  /* jump is the entire block? */\n      leaveblock(fs);\n      return;  /* and that is it */\n    }\n    else  /* must skip over 'then' part if condition is false */\n      jf = luaK_jump(fs);\n  }\n  else {  /* regular case (not a break) */\n    luaK_goiftrue(ls->fs, &v);  /* skip over block if condition is false */\n    enterblock(fs, &bl, 0);\n    jf = v.f;\n  }\n  statlist(ls);  /* 'then' part */\n  leaveblock(fs);\n  if (ls->t.token == TK_ELSE ||\n      ls->t.token == TK_ELSEIF)  /* followed by 'else'/'elseif'? */\n    luaK_concat(fs, escapelist, luaK_jump(fs));  /* must jump over it */\n  luaK_patchtohere(fs, jf);\n}\n\n\nstatic void ifstat (LexState *ls, int line) {\n  /* ifstat -> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */\n  FuncState *fs = ls->fs;\n  int escapelist = NO_JUMP;  /* exit list for finished parts */\n  test_then_block(ls, &escapelist);  /* IF cond THEN block */\n  while (ls->t.token == TK_ELSEIF)\n    test_then_block(ls, &escapelist);  /* ELSEIF cond THEN block */\n  if (testnext(ls, TK_ELSE))\n    block(ls);  /* 'else' part */\n  check_match(ls, TK_END, TK_IF, line);\n  luaK_patchtohere(fs, escapelist);  /* patch escape list to 'if' end */\n}\n\n\nstatic void localfunc (LexState *ls) {\n  expdesc b;\n  FuncState *fs = ls->fs;\n  int fvar = fs->nactvar;  /* function's variable index */\n  new_localvar(ls, str_checkname(ls));  /* new local variable */\n  adjustlocalvars(ls, 1);  /* enter its scope */\n  body(ls, &b, 0, ls->linenumber);  /* function created in next register */\n  /* debug information will only see the variable after this point! */\n  localdebuginfo(fs, fvar)->startpc = fs->pc;\n}\n\n\nstatic int getlocalattribute (LexState *ls) {\n  /* ATTRIB -> ['<' Name '>'] */\n  if (testnext(ls, '<')) {\n    TString *ts = str_checkname(ls);\n    const char *attr = getstr(ts);\n    checknext(ls, '>');\n    if (strcmp(attr, \"const\") == 0)\n      return RDKCONST;  /* read-only variable */\n    else if (strcmp(attr, \"close\") == 0)\n      return RDKTOCLOSE;  /* to-be-closed variable */\n    else\n      luaK_semerror(ls,\n        luaO_pushfstring(ls->L, \"unknown attribute '%s'\", attr));\n  }\n  return VDKREG;  /* regular variable */\n}\n\n\nstatic void checktoclose (FuncState *fs, int level) {\n  if (level != -1) {  /* is there a to-be-closed variable? */\n    marktobeclosed(fs);\n    luaK_codeABC(fs, OP_TBC, reglevel(fs, level), 0, 0);\n  }\n}\n\n\nstatic void localstat (LexState *ls) {\n  /* stat -> LOCAL NAME ATTRIB { ',' NAME ATTRIB } ['=' explist] */\n  FuncState *fs = ls->fs;\n  int toclose = -1;  /* index of to-be-closed variable (if any) */\n  Vardesc *var;  /* last variable */\n  int vidx;  /* index of last variable */\n  int nvars = 0;\n  int nexps;\n  expdesc e;\n  do {\n    TString *vname = str_checkname(ls);\n    int kind = getlocalattribute(ls);\n    vidx = new_localvarkind(ls, vname, kind);\n    if (kind == RDKTOCLOSE) {  /* to-be-closed? */\n      if (toclose != -1)  /* one already present? */\n        luaK_semerror(ls, \"multiple to-be-closed variables in local list\");\n      toclose = fs->nactvar + nvars;\n    }\n    nvars++;\n  } while (testnext(ls, ','));\n  if (testnext(ls, '='))\n    nexps = explist(ls, &e);\n  else {\n    e.k = VVOID;\n    nexps = 0;\n  }\n  var = getlocalvardesc(fs, vidx);  /* get last variable */\n  if (nvars == nexps &&  /* no adjustments? */\n      var->vd.kind == RDKCONST &&  /* last variable is const? */\n      luaK_exp2const(fs, &e, &var->k)) {  /* compile-time constant? */\n    var->vd.kind = RDKCTC;  /* variable is a compile-time constant */\n    adjustlocalvars(ls, nvars - 1);  /* exclude last variable */\n    fs->nactvar++;  /* but count it */\n  }\n  else {\n    adjust_assign(ls, nvars, nexps, &e);\n    adjustlocalvars(ls, nvars);\n  }\n  checktoclose(fs, toclose);\n}\n\n\nstatic int funcname (LexState *ls, expdesc *v) {\n  /* funcname -> NAME {fieldsel} [':' NAME] */\n  int ismethod = 0;\n  singlevar(ls, v);\n  while (ls->t.token == '.')\n    fieldsel(ls, v);\n  if (ls->t.token == ':') {\n    ismethod = 1;\n    fieldsel(ls, v);\n  }\n  return ismethod;\n}\n\n\nstatic void funcstat (LexState *ls, int line) {\n  /* funcstat -> FUNCTION funcname body */\n  int ismethod;\n  expdesc v, b;\n  luaX_next(ls);  /* skip FUNCTION */\n  ismethod = funcname(ls, &v);\n  body(ls, &b, ismethod, line);\n  check_readonly(ls, &v);\n  luaK_storevar(ls->fs, &v, &b);\n  luaK_fixline(ls->fs, line);  /* definition \"happens\" in the first line */\n}\n\n\nstatic void exprstat (LexState *ls) {\n  /* stat -> func | assignment */\n  FuncState *fs = ls->fs;\n  struct LHS_assign v;\n  suffixedexp(ls, &v.v);\n  if (ls->t.token == '=' || ls->t.token == ',') { /* stat -> assignment ? */\n    v.prev = NULL;\n    restassign(ls, &v, 1);\n  }\n  else {  /* stat -> func */\n    Instruction *inst;\n    check_condition(ls, v.v.k == VCALL, \"syntax private_lua_error\");\n    inst = &getinstruction(fs, &v.v);\n    SETARG_C(*inst, 1);  /* call statement uses no results */\n  }\n}\n\n\nstatic void retstat (LexState *ls) {\n  /* stat -> RETURN [explist] [';'] */\n  FuncState *fs = ls->fs;\n  expdesc e;\n  int nret;  /* number of values being returned */\n  int first = luaY_nvarstack(fs);  /* first slot to be returned */\n  if (block_follow(ls, 1) || ls->t.token == ';')\n    nret = 0;  /* return no values */\n  else {\n    nret = explist(ls, &e);  /* optional return values */\n    if (hasmultret(e.k)) {\n      luaK_setmultret(fs, &e);\n      if (e.k == VCALL && nret == 1 && !fs->bl->insidetbc) {  /* tail call? */\n        SET_OPCODE(getinstruction(fs,&e), OP_TAILCALL);\n        lua_assert(GETARG_A(getinstruction(fs,&e)) == luaY_nvarstack(fs));\n      }\n      nret = LUA_MULTRET;  /* return all values */\n    }\n    else {\n      if (nret == 1)  /* only one single value? */\n        first = luaK_exp2anyreg(fs, &e);  /* can use original slot */\n      else {  /* values must go to the top of the stack */\n        luaK_exp2nextreg(fs, &e);\n        lua_assert(nret == fs->freereg - first);\n      }\n    }\n  }\n  luaK_ret(fs, first, nret);\n  testnext(ls, ';');  /* skip optional semicolon */\n}\n\n\nstatic void statement (LexState *ls) {\n  int line = ls->linenumber;  /* may be needed for error messages */\n  enterlevel(ls);\n  switch (ls->t.token) {\n    case ';': {  /* stat -> ';' (empty statement) */\n      luaX_next(ls);  /* skip ';' */\n      break;\n    }\n    case TK_IF: {  /* stat -> ifstat */\n      ifstat(ls, line);\n      break;\n    }\n    case TK_WHILE: {  /* stat -> whilestat */\n      whilestat(ls, line);\n      break;\n    }\n    case TK_DO: {  /* stat -> DO block END */\n      luaX_next(ls);  /* skip DO */\n      block(ls);\n      check_match(ls, TK_END, TK_DO, line);\n      break;\n    }\n    case TK_FOR: {  /* stat -> forstat */\n      forstat(ls, line);\n      break;\n    }\n    case TK_REPEAT: {  /* stat -> repeatstat */\n      repeatstat(ls, line);\n      break;\n    }\n    case TK_FUNCTION: {  /* stat -> funcstat */\n      funcstat(ls, line);\n      break;\n    }\n    case TK_LOCAL: {  /* stat -> localstat */\n      luaX_next(ls);  /* skip LOCAL */\n      if (testnext(ls, TK_FUNCTION))  /* local function? */\n        localfunc(ls);\n      else\n        localstat(ls);\n      break;\n    }\n    case TK_DBCOLON: {  /* stat -> label */\n      luaX_next(ls);  /* skip double colon */\n      labelstat(ls, str_checkname(ls), line);\n      break;\n    }\n    case TK_RETURN: {  /* stat -> retstat */\n      luaX_next(ls);  /* skip RETURN */\n      retstat(ls);\n      break;\n    }\n    case TK_BREAK: {  /* stat -> breakstat */\n      breakstat(ls);\n      break;\n    }\n    case TK_GOTO: {  /* stat -> 'goto' NAME */\n      luaX_next(ls);  /* skip 'goto' */\n      gotostat(ls);\n      break;\n    }\n    default: {  /* stat -> func | assignment */\n      exprstat(ls);\n      break;\n    }\n  }\n  lua_assert(ls->fs->f->maxstacksize >= ls->fs->freereg &&\n             ls->fs->freereg >= luaY_nvarstack(ls->fs));\n  ls->fs->freereg = luaY_nvarstack(ls->fs);  /* free registers */\n  leavelevel(ls);\n}\n\n/* }====================================================================== */\n\n\n/*\n** compiles the main function, which is a regular vararg function with an\n** upvalue named LUA_ENV\n*/\nstatic void mainfunc (LexState *ls, FuncState *fs) {\n  BlockCnt bl;\n  Upvaldesc *env;\n  open_func(ls, fs, &bl);\n  setvararg(fs, 0);  /* main function is always declared vararg */\n  env = allocupvalue(fs);  /* ...set environment upvalue */\n  env->instack = 1;\n  env->idx = 0;\n  env->kind = VDKREG;\n  env->name = ls->envn;\n  luaC_objbarrier(ls->L, fs->f, env->name);\n  luaX_next(ls);  /* read first token */\n  statlist(ls);  /* parse main body */\n  check(ls, TK_EOS);\n  close_func(ls);\n}\n\n\nLClosure *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff,\n                       Dyndata *dyd, const char *name, int firstchar) {\n  LexState lexstate;\n  FuncState funcstate;\n  LClosure *cl = luaF_newLclosure(L, 1);  /* create main closure */\n  setclLvalue2s(L, L->top.p, cl);  /* anchor it (to avoid being collected) */\n  luaD_inctop(L);\n  lexstate.h = luaH_new(L);  /* create table for scanner */\n  sethvalue2s(L, L->top.p, lexstate.h);  /* anchor it */\n  luaD_inctop(L);\n  funcstate.f = cl->p = luaF_newproto(L);\n  luaC_objbarrier(L, cl, cl->p);\n  funcstate.f->source = luaS_new(L, name);  /* create and anchor TString */\n  luaC_objbarrier(L, funcstate.f, funcstate.f->source);\n  lexstate.buff = buff;\n  lexstate.dyd = dyd;\n  dyd->actvar.n = dyd->gt.n = dyd->label.n = 0;\n  luaX_setinput(L, &lexstate, z, funcstate.f->source, firstchar);\n  mainfunc(&lexstate, &funcstate);\n  lua_assert(!funcstate.prev && funcstate.nups == 1 && !lexstate.fs);\n  /* all scopes should be correctly finished */\n  lua_assert(dyd->actvar.n == 0 && dyd->gt.n == 0 && dyd->label.n == 0);\n  L->top.p--;  /* remove scanner's table */\n  return cl;  /* closure is on the stack, too */\n}\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lparser.h",
		"is_binary":	false,
		"content":	"/*\n** $Id: lparser.h $\n** Lua Parser\n** See Copyright Notice in lua.h\n*/\n\n#ifndef lparser_h\n#define lparser_h\n\n#include \"llimits.h\"\n#include \"lobject.h\"\n#include \"lzio.h\"\n\n\n/*\n** Expression and variable descriptor.\n** Code generation for variables and expressions can be delayed to allow\n** optimizations; An 'expdesc' structure describes a potentially-delayed\n** variable/expression. It has a description of its \"main\" value plus a\n** list of conditional jumps that can also produce its value (generated\n** by short-circuit operators 'and'/'or').\n*/\n\n/* kinds of variables/expressions */\ntypedef enum {\n  VVOID,  /* when 'expdesc' describes the last expression of a list,\n             this kind means an empty list (so, no expression) */\n  VNIL,  /* constant nil */\n  VTRUE,  /* constant true */\n  VFALSE,  /* constant false */\n  VK,  /* constant in 'k'; info = index of constant in 'k' */\n  VKFLT,  /* floating constant; nval = numerical float value */\n  VKINT,  /* integer constant; ival = numerical integer value */\n  VKSTR,  /* string constant; strval = TString address;\n             (string is fixed by the lexer) */\n  VNONRELOC,  /* expression has its value in a fixed register;\n                 info = result register */\n  VLOCAL,  /* local variable; var.ridx = register index;\n              var.vidx = relative index in 'actvar.arr'  */\n  VUPVAL,  /* upvalue variable; info = index of upvalue in 'upvalues' */\n  VCONST,  /* compile-time <const> variable;\n              info = absolute index in 'actvar.arr'  */\n  VINDEXED,  /* indexed variable;\n                ind.t = table register;\n                ind.idx = key's R index */\n  VINDEXUP,  /* indexed upvalue;\n                ind.t = table upvalue;\n                ind.idx = key's K index */\n  VINDEXI, /* indexed variable with constant integer;\n                ind.t = table register;\n                ind.idx = key's value */\n  VINDEXSTR, /* indexed variable with literal string;\n                ind.t = table register;\n                ind.idx = key's K index */\n  VJMP,  /* expression is a test/comparison;\n            info = pc of corresponding jump instruction */\n  VRELOC,  /* expression can put result in any register;\n              info = instruction pc */\n  VCALL,  /* expression is a function call; info = instruction pc */\n  VVARARG  /* vararg expression; info = instruction pc */\n} expkind;\n\n\n#define vkisvar(k)\t(VLOCAL <= (k) && (k) <= VINDEXSTR)\n#define vkisindexed(k)\t(VINDEXED <= (k) && (k) <= VINDEXSTR)\n\n\ntypedef struct expdesc {\n  expkind k;\n  union {\n    lua_Integer ival;    /* for VKINT */\n    lua_Number nval;  /* for VKFLT */\n    TString *strval;  /* for VKSTR */\n    int info;  /* for generic use */\n    struct {  /* for indexed variables */\n      short idx;  /* index (R or \"long\" K) */\n      lu_byte t;  /* table (register or upvalue) */\n    } ind;\n    struct {  /* for local variables */\n      lu_byte ridx;  /* register holding the variable */\n      unsigned short vidx;  /* compiler index (in 'actvar.arr')  */\n    } var;\n  } u;\n  int t;  /* patch list of 'exit when true' */\n  int f;  /* patch list of 'exit when false' */\n} expdesc;\n\n\n/* kinds of variables */\n#define VDKREG\t\t0   /* regular */\n#define RDKCONST\t1   /* constant */\n#define RDKTOCLOSE\t2   /* to-be-closed */\n#define RDKCTC\t\t3   /* compile-time constant */\n\n/* description of an active local variable */\ntypedef union Vardesc {\n  struct {\n    TValuefields;  /* constant value (if it is a compile-time constant) */\n    lu_byte kind;\n    lu_byte ridx;  /* register holding the variable */\n    short pidx;  /* index of the variable in the Proto's 'locvars' array */\n    TString *name;  /* variable name */\n  } vd;\n  TValue k;  /* constant value (if any) */\n} Vardesc;\n\n\n\n/* description of pending goto statements and label statements */\ntypedef struct Labeldesc {\n  TString *name;  /* label identifier */\n  int pc;  /* position in code */\n  int line;  /* line where it appeared */\n  lu_byte nactvar;  /* number of active variables in that position */\n  lu_byte close;  /* goto that escapes upvalues */\n} Labeldesc;\n\n\n/* list of labels or gotos */\ntypedef struct Labellist {\n  Labeldesc *arr;  /* array */\n  int n;  /* number of entries in use */\n  int size;  /* array size */\n} Labellist;\n\n\n/* dynamic structures used by the parser */\ntypedef struct Dyndata {\n  struct {  /* list of all active local variables */\n    Vardesc *arr;\n    int n;\n    int size;\n  } actvar;\n  Labellist gt;  /* list of pending gotos */\n  Labellist label;   /* list of active labels */\n} Dyndata;\n\n\n/* control of blocks */\nstruct BlockCnt;  /* defined in lparser.c */\n\n\n/* state needed to generate code for a given function */\ntypedef struct FuncState {\n  Proto *f;  /* current function header */\n  struct FuncState *prev;  /* enclosing function */\n  struct LexState *ls;  /* lexical state */\n  struct BlockCnt *bl;  /* chain of current blocks */\n  int pc;  /* next position to code (equivalent to 'ncode') */\n  int lasttarget;   /* 'label' of last 'jump label' */\n  int previousline;  /* last line that was saved in 'lineinfo' */\n  int nk;  /* number of elements in 'k' */\n  int np;  /* number of elements in 'p' */\n  int nabslineinfo;  /* number of elements in 'abslineinfo' */\n  int firstlocal;  /* index of first local var (in Dyndata array) */\n  int firstlabel;  /* index of first label (in 'dyd->label->arr') */\n  short ndebugvars;  /* number of elements in 'f->locvars' */\n  lu_byte nactvar;  /* number of active local variables */\n  lu_byte nups;  /* number of upvalues */\n  lu_byte freereg;  /* first free register */\n  lu_byte iwthabs;  /* instructions issued since last absolute line info */\n  lu_byte needclose;  /* function needs to close upvalues when returning */\n} FuncState;\n\n\nLUAI_FUNC int luaY_nvarstack (FuncState *fs);\nLUAI_FUNC LClosure *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff,\n                                 Dyndata *dyd, const char *name, int firstchar);\n\n\n#endif\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lprefix.h",
		"is_binary":	false,
		"content":	"/*\n** $Id: lprefix.h $\n** Definitions for Lua code that must come before any other header file\n** See Copyright Notice in lua.h\n*/\n\n#ifndef lprefix_h\n#define lprefix_h\n\n\n/*\n** Allows POSIX/XSI stuff\n*/\n#if !defined(LUA_USE_C89)\t/* { */\n\n#if !defined(_XOPEN_SOURCE)\n#define _XOPEN_SOURCE           600\n#elif _XOPEN_SOURCE == 0\n#undef _XOPEN_SOURCE  /* use -D_XOPEN_SOURCE=0 to undefine it */\n#endif\n\n/*\n** Allows manipulation of large files in gcc and some other compilers\n*/\n#if !defined(LUA_32BITS) && !defined(_FILE_OFFSET_BITS)\n#define _LARGEFILE_SOURCE       1\n#define _FILE_OFFSET_BITS       64\n#endif\n\n#endif\t\t\t\t/* } */\n\n\n/*\n** Windows stuff\n*/\n#if defined(_WIN32)\t/* { */\n\n#if !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS  /* avoid warnings about ISO C functions */\n#endif\n\n#endif\t\t\t/* } */\n\n#endif\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lstate.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: lstate.c $\n** Global State\n** See Copyright Notice in lua.h\n*/\n\n#define lstate_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <stddef.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lapi.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"llex.h\"\n#include \"lmem.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n\n\n\n/*\n** thread state + extra space\n*/\ntypedef struct LX {\n  lu_byte extra_[LUA_EXTRASPACE];\n  lua_State l;\n} LX;\n\n\n/*\n** Main thread combines a thread state and the global state\n*/\ntypedef struct LG {\n  LX l;\n  global_State g;\n} LG;\n\n\n\n#define fromstate(L)\t(cast(LX *, cast(lu_byte *, (L)) - offsetof(LX, l)))\n\n\n/*\n** set GCdebt to a new value keeping the real number of allocated\n** objects (totalobjs - GCdebt) invariant and avoiding overflows in\n** 'totalobjs'.\n*/\nvoid luaE_setdebt (global_State *g, l_obj debt) {\n  l_obj tb = gettotalobjs(g);\n  lua_assert(tb > 0);\n  if (debt > MAX_LOBJ - tb)\n    debt = MAX_LOBJ - tb;  /* will make 'totalobjs == MAX_LMEM' */\n  g->totalobjs = tb + debt;\n  g->GCdebt = debt;\n}\n\n\nCallInfo *luaE_extendCI (lua_State *L) {\n  CallInfo *ci;\n  lua_assert(L->ci->next == NULL);\n  ci = luaM_new(L, CallInfo);\n  lua_assert(L->ci->next == NULL);\n  L->ci->next = ci;\n  ci->previous = L->ci;\n  ci->next = NULL;\n  ci->u.l.trap = 0;\n  L->nci++;\n  return ci;\n}\n\n\n/*\n** free all CallInfo structures not in use by a thread\n*/\nstatic void freeCI (lua_State *L) {\n  CallInfo *ci = L->ci;\n  CallInfo *next = ci->next;\n  ci->next = NULL;\n  while ((ci = next) != NULL) {\n    next = ci->next;\n    luaM_free(L, ci);\n    L->nci--;\n  }\n}\n\n\n/*\n** free half of the CallInfo structures not in use by a thread,\n** keeping the first one.\n*/\nvoid luaE_shrinkCI (lua_State *L) {\n  CallInfo *ci = L->ci->next;  /* first free CallInfo */\n  CallInfo *next;\n  if (ci == NULL)\n    return;  /* no extra elements */\n  while ((next = ci->next) != NULL) {  /* two extra elements? */\n    CallInfo *next2 = next->next;  /* next's next */\n    ci->next = next2;  /* remove next from the list */\n    L->nci--;\n    luaM_free(L, next);  /* free next */\n    if (next2 == NULL)\n      break;  /* no more elements */\n    else {\n      next2->previous = ci;\n      ci = next2;  /* continue */\n    }\n  }\n}\n\n\n/*\n** Called when 'getCcalls(L)' larger or equal to LUAI_MAXCCALLS.\n** If equal, raises an overflow error. If value is larger than\n** LUAI_MAXCCALLS (which means it is handling an overflow) but\n** not much larger, does not report an error (to allow overflow\n** handling to work).\n*/\nvoid luaE_checkcstack (lua_State *L) {\n  if (getCcalls(L) == LUAI_MAXCCALLS)\n    luaG_runerror(L, \"C stack overflow\");\n  else if (getCcalls(L) >= (LUAI_MAXCCALLS / 10 * 11))\n    luaD_throw(L, LUA_ERRERR);  /* error while handling stack error */\n}\n\n\nLUAI_FUNC void luaE_incCstack (lua_State *L) {\n  L->nCcalls++;\n  if (l_unlikely(getCcalls(L) >= LUAI_MAXCCALLS))\n    luaE_checkcstack(L);\n}\n\n\nstatic void stack_init (lua_State *L1, lua_State *L) {\n  int i; CallInfo *ci;\n  /* initialize stack array */\n  L1->stack.p = luaM_newvector(L, BASIC_STACK_SIZE + EXTRA_STACK, StackValue);\n  L1->tbclist.p = L1->stack.p;\n  for (i = 0; i < BASIC_STACK_SIZE + EXTRA_STACK; i++)\n    setnilvalue(s2v(L1->stack.p + i));  /* erase new stack */\n  L1->top.p = L1->stack.p;\n  L1->stack_last.p = L1->stack.p + BASIC_STACK_SIZE;\n  /* initialize first ci */\n  ci = &L1->base_ci;\n  ci->next = ci->previous = NULL;\n  ci->callstatus = CIST_C;\n  ci->func.p = L1->top.p;\n  ci->u.c.k = NULL;\n  ci->nresults = 0;\n  setnilvalue(s2v(L1->top.p));  /* 'function' entry for this 'ci' */\n  L1->top.p++;\n  ci->top.p = L1->top.p + LUA_MINSTACK;\n  L1->ci = ci;\n}\n\n\nstatic void freestack (lua_State *L) {\n  if (L->stack.p == NULL)\n    return;  /* stack not completely built yet */\n  L->ci = &L->base_ci;  /* free the entire 'ci' list */\n  freeCI(L);\n  lua_assert(L->nci == 0);\n  luaM_freearray(L, L->stack.p, stacksize(L) + EXTRA_STACK);  /* free stack */\n}\n\n\n/*\n** Create registry table and its predefined values\n*/\nstatic void init_registry (lua_State *L, global_State *g) {\n  /* create registry */\n  TValue aux;\n  Table *registry = luaH_new(L);\n  sethvalue(L, &g->l_registry, registry);\n  luaH_resize(L, registry, LUA_RIDX_LAST, 0);\n  /* registry[1] = false */\n  setbfvalue(&aux);\n  luaH_setint(L, registry, 1, &aux);\n  /* registry[LUA_RIDX_MAINTHREAD] = L */\n  setthvalue(L, &aux, L);\n  luaH_setint(L, registry, LUA_RIDX_MAINTHREAD, &aux);\n  /* registry[LUA_RIDX_GLOBALS] = new table (table of globals) */\n  sethvalue(L, &aux, luaH_new(L));\n  luaH_setint(L, registry, LUA_RIDX_GLOBALS, &aux);\n}\n\n\n/*\n** open parts of the state that may cause memory-allocation errors.\n*/\nstatic void f_luaopen (lua_State *L, void *ud) {\n  global_State *g = G(L);\n  UNUSED(ud);\n  stack_init(L, L);  /* init stack */\n  init_registry(L, g);\n  luaS_init(L);\n  luaT_init(L);\n  luaX_init(L);\n  g->gcstp = 0;  /* allow gc */\n  setnilvalue(&g->nilvalue);  /* now state is complete */\n  luai_userstateopen(L);\n}\n\n\n/*\n** preinitialize a thread with consistent values without allocating\n** any memory (to avoid errors)\n*/\nstatic void preinit_thread (lua_State *L, global_State *g) {\n  G(L) = g;\n  L->stack.p = NULL;\n  L->ci = NULL;\n  L->nci = 0;\n  L->twups = L;  /* thread has no upvalues */\n  L->nCcalls = 0;\n  L->errorJmp = NULL;\n  L->hook = NULL;\n  L->hookmask = 0;\n  L->basehookcount = 0;\n  L->allowhook = 1;\n  resethookcount(L);\n  L->openupval = NULL;\n  L->status = LUA_OK;\n  L->errfunc = 0;\n  L->oldpc = 0;\n}\n\n\nstatic void close_state (lua_State *L) {\n  global_State *g = G(L);\n  if (!completestate(g))  /* closing a partially built state? */\n    luaC_freeallobjects(L);  /* just collect its objects */\n  else {  /* closing a fully built state */\n    L->ci = &L->base_ci;  /* unwind CallInfo list */\n    luaD_closeprotected(L, 1, LUA_OK);  /* close all upvalues */\n    luaC_freeallobjects(L);  /* collect all objects */\n    luai_userstateclose(L);\n  }\n  luaM_freearray(L, G(L)->strt.hash, G(L)->strt.size);\n  freestack(L);\n  lua_assert(g->totalbytes == sizeof(LG));\n  lua_assert(gettotalobjs(g) == 1);\n  (*g->frealloc)(g->ud, fromstate(L), sizeof(LG), 0);  /* free main block */\n}\n\n\nLUA_API lua_State *lua_newthread (lua_State *L) {\n  global_State *g = G(L);\n  GCObject *o;\n  lua_State *L1;\n  lua_lock(L);\n  luaC_checkGC(L);\n  /* create new thread */\n  o = luaC_newobjdt(L, LUA_TTHREAD, sizeof(LX), offsetof(LX, l));\n  L1 = gco2th(o);\n  /* anchor it on L stack */\n  setthvalue2s(L, L->top.p, L1);\n  api_incr_top(L);\n  preinit_thread(L1, g);\n  L1->hookmask = L->hookmask;\n  L1->basehookcount = L->basehookcount;\n  L1->hook = L->hook;\n  resethookcount(L1);\n  /* initialize L1 extra space */\n  memcpy(lua_getextraspace(L1), lua_getextraspace(g->mainthread),\n         LUA_EXTRASPACE);\n  luai_userstatethread(L, L1);\n  stack_init(L1, L);  /* init stack */\n  lua_unlock(L);\n  return L1;\n}\n\n\nvoid luaE_freethread (lua_State *L, lua_State *L1) {\n  LX *l = fromstate(L1);\n  luaF_closeupval(L1, L1->stack.p);  /* close all upvalues */\n  lua_assert(L1->openupval == NULL);\n  luai_userstatefree(L, L1);\n  freestack(L1);\n  luaM_free(L, l);\n}\n\n\nint luaE_resetthread (lua_State *L, int status) {\n  CallInfo *ci = L->ci = &L->base_ci;  /* unwind CallInfo list */\n  setnilvalue(s2v(L->stack.p));  /* 'function' entry for basic 'ci' */\n  ci->func.p = L->stack.p;\n  ci->callstatus = CIST_C;\n  if (status == LUA_YIELD)\n    status = LUA_OK;\n  L->status = LUA_OK;  /* so it can run __close metamethods */\n  status = luaD_closeprotected(L, 1, status);\n  if (status != LUA_OK)  /* errors? */\n    luaD_seterrorobj(L, status, L->stack.p + 1);\n  else\n    L->top.p = L->stack.p + 1;\n  ci->top.p = L->top.p + LUA_MINSTACK;\n  luaD_reallocstack(L, cast_int(ci->top.p - L->stack.p), 0);\n  return status;\n}\n\n\nLUA_API int lua_closethread (lua_State *L, lua_State *from) {\n  int status;\n  lua_lock(L);\n  L->nCcalls = (from) ? getCcalls(from) : 0;\n  status = luaE_resetthread(L, L->status);\n  lua_unlock(L);\n  return status;\n}\n\n\nLUA_API lua_State *lua_newstate (lua_Alloc f, void *ud, unsigned seed) {\n  int i;\n  lua_State *L;\n  global_State *g;\n  LG *l = cast(LG *, (*f)(ud, NULL, LUA_TTHREAD, sizeof(LG)));\n  if (l == NULL) return NULL;\n  L = &l->l.l;\n  g = &l->g;\n  L->tt = LUA_VTHREAD;\n  g->currentwhite = bitmask(WHITE0BIT);\n  L->marked = luaC_white(g);\n  preinit_thread(L, g);\n  g->allgc = obj2gco(L);  /* by now, only object is the main thread */\n  L->next = NULL;\n  incnny(L);  /* main thread is always non yieldable */\n  g->frealloc = f;\n  g->ud = ud;\n  g->warnf = NULL;\n  g->ud_warn = NULL;\n  g->mainthread = L;\n  g->seed = seed;\n  g->gcstp = GCSTPGC;  /* no GC while building state */\n  g->strt.size = g->strt.nuse = 0;\n  g->strt.hash = NULL;\n  setnilvalue(&g->l_registry);\n  g->panic = NULL;\n  g->gcstate = GCSpause;\n  g->gckind = KGC_INC;\n  g->gcstopem = 0;\n  g->gcemergency = 0;\n  g->finobj = g->tobefnz = g->fixedgc = NULL;\n  g->firstold1 = g->survival = g->old1 = g->reallyold = NULL;\n  g->finobjsur = g->finobjold1 = g->finobjrold = NULL;\n  g->sweepgc = NULL;\n  g->gray = g->grayagain = NULL;\n  g->weak = g->ephemeron = g->allweak = NULL;\n  g->twups = NULL;\n  g->totalbytes = sizeof(LG);\n  g->totalobjs = 1;\n  g->marked = 0;\n  g->GCdebt = 0;\n  setivalue(&g->nilvalue, 0);  /* to signal that state is not yet built */\n  setgcparam(g, PAUSE, LUAI_GCPAUSE);\n  setgcparam(g, STEPMUL, LUAI_GCMUL);\n  setgcparam(g, STEPSIZE, LUAI_GCSTEPSIZE);\n  setgcparam(g, MINORMUL, LUAI_GENMINORMUL);\n  setgcparam(g, MINORMAJOR, LUAI_MINORMAJOR);\n  setgcparam(g, MAJORMINOR, LUAI_MAJORMINOR);\n  for (i=0; i < LUA_NUMTYPES; i++) g->mt[i] = NULL;\n  if (luaD_rawrunprotected(L, f_luaopen, NULL) != LUA_OK) {\n    /* memory allocation error: free partial state */\n    close_state(L);\n    L = NULL;\n  }\n  return L;\n}\n\n\nLUA_API void lua_close (lua_State *L) {\n  lua_lock(L);\n  L = G(L)->mainthread;  /* only the main thread can be closed */\n  close_state(L);\n}\n\n\nvoid luaE_warning (lua_State *L, const char *msg, int tocont) {\n  lua_WarnFunction wf = G(L)->warnf;\n  if (wf != NULL)\n    wf(G(L)->ud_warn, msg, tocont);\n}\n\n\n/*\n** Generate a warning from an error message\n*/\nvoid luaE_warnerror (lua_State *L, const char *where) {\n  TValue *errobj = s2v(L->top.p - 1);  /* error object */\n  const char *msg = (ttisstring(errobj))\n                  ? getstr(tsvalue(errobj))\n                  : \"private_lua_error object is not a string\";\n  /* produce warning \"error in %s (%s)\" (where, msg) */\n  luaE_warning(L, \"private_lua_error in \", 1);\n  luaE_warning(L, where, 1);\n  luaE_warning(L, \" (\", 1);\n  luaE_warning(L, msg, 1);\n  luaE_warning(L, \")\", 0);\n}\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lstate.h",
		"is_binary":	false,
		"content":	"/*\n** $Id: lstate.h $\n** Global State\n** See Copyright Notice in lua.h\n*/\n\n#ifndef lstate_h\n#define lstate_h\n\n#include \"lua.h\"\n\n\n/* Some header files included here need this definition */\ntypedef struct CallInfo CallInfo;\n\n\n#include \"lobject.h\"\n#include \"ltm.h\"\n#include \"lzio.h\"\n\n\n/*\n** Some notes about garbage-collected objects: All objects in Lua must\n** be kept somehow accessible until being freed, so all objects always\n** belong to one (and only one) of these lists, using field 'next' of\n** the 'CommonHeader' for the link:\n**\n** 'allgc': all objects not marked for finalization;\n** 'finobj': all objects marked for finalization;\n** 'tobefnz': all objects ready to be finalized;\n** 'fixedgc': all objects that are not to be collected (currently\n** only small strings, such as reserved words).\n**\n** For the generational collector, some of these lists have marks for\n** generations. Each mark points to the first element in the list for\n** that particular generation; that generation goes until the next mark.\n**\n** 'allgc' -> 'survival': new objects;\n** 'survival' -> 'old': objects that survived one collection;\n** 'old1' -> 'reallyold': objects that became old in last collection;\n** 'reallyold' -> NULL: objects old for more than one cycle.\n**\n** 'finobj' -> 'finobjsur': new objects marked for finalization;\n** 'finobjsur' -> 'finobjold1': survived   \"\"\"\";\n** 'finobjold1' -> 'finobjrold': just old  \"\"\"\";\n** 'finobjrold' -> NULL: really old       \"\"\"\".\n**\n** All lists can contain elements older than their main ages, due\n** to 'luaC_checkfinalizer' and 'udata2finalize', which move\n** objects between the normal lists and the \"marked for finalization\"\n** lists. Moreover, barriers can age young objects in young lists as\n** OLD0, which then become OLD1. However, a list never contains\n** elements younger than their main ages.\n**\n** The generational collector also uses a pointer 'firstold1', which\n** points to the first OLD1 object in the list. It is used to optimize\n** 'markold'. (Potentially OLD1 objects can be anywhere between 'allgc'\n** and 'reallyold', but often the list has no OLD1 objects or they are\n** after 'old1'.) Note the difference between it and 'old1':\n** 'firstold1': no OLD1 objects before this point; there can be all\n**   ages after it.\n** 'old1': no objects younger than OLD1 after this point.\n*/\n\n/*\n** Moreover, there is another set of lists that control gray objects.\n** These lists are linked by fields 'gclist'. (All objects that\n** can become gray have such a field. The field is not the same\n** in all objects, but it always has this name.)  Any gray object\n** must belong to one of these lists, and all objects in these lists\n** must be gray (with two exceptions explained below):\n**\n** 'gray': regular gray objects, still waiting to be visited.\n** 'grayagain': objects that must be revisited at the atomic phase.\n**   That includes\n**   - black objects got in a write barrier;\n**   - all kinds of weak tables during propagation phase;\n**   - all threads.\n** 'weak': tables with weak values to be cleared;\n** 'ephemeron': ephemeron tables with white->white entries;\n** 'allweak': tables with weak keys and/or weak values to be cleared.\n**\n** The exceptions to that \"gray rule\" are:\n** - TOUCHED2 objects in generational mode stay in a gray list (because\n** they must be visited again at the end of the cycle), but they are\n** marked black because assignments to them must activate barriers (to\n** move them back to TOUCHED1).\n** - Open upvales are kept gray to avoid barriers, but they stay out\n** of gray lists. (They don't even have a 'gclist' field.)\n*/\n\n\n\n/*\n** About 'nCcalls':  This count has two parts: the lower 16 bits counts\n** the number of recursive invocations in the C stack; the higher\n** 16 bits counts the number of non-yieldable calls in the stack.\n** (They are together so that we can change and save both with one\n** instruction.)\n*/\n\n\n/* true if this thread does not have non-yieldable calls in the stack */\n#define yieldable(L)\t\t(((L)->nCcalls & 0xffff0000) == 0)\n\n/* real number of C calls */\n#define getCcalls(L)\t((L)->nCcalls & 0xffff)\n\n\n/* Increment the number of non-yieldable calls */\n#define incnny(L)\t((L)->nCcalls += 0x10000)\n\n/* Decrement the number of non-yieldable calls */\n#define decnny(L)\t((L)->nCcalls -= 0x10000)\n\n/* Non-yieldable call increment */\n#define nyci\t(0x10000 | 1)\n\n\n\n\nstruct lua_longjmp;  /* defined in ldo.c */\n\n\n/*\n** Atomic type (relative to signals) to better ensure that 'lua_sethook'\n** is thread safe\n*/\n#if !defined(l_signalT)\n#include <signal.h>\n#define l_signalT\tsig_atomic_t\n#endif\n\n\n/*\n** Extra stack space to handle TM calls and some other extras. This\n** space is not included in 'stack_last'. It is used only to avoid stack\n** checks, either because the element will be promptly popped or because\n** there will be a stack check soon after the push. Function frames\n** never use this extra space, so it does not need to be kept clean.\n*/\n#define EXTRA_STACK   5\n\n\n#define BASIC_STACK_SIZE        (2*LUA_MINSTACK)\n\n#define stacksize(th)\tcast_int((th)->stack_last.p - (th)->stack.p)\n\n\n/* kinds of Garbage Collection */\n#define KGC_INC\t\t0\t/* incremental gc */\n#define KGC_GENMINOR\t1\t/* generational gc in minor (regular) mode */\n#define KGC_GENMAJOR\t2\t/* generational in major mode */\n\n\ntypedef struct stringtable {\n  TString **hash;  /* array of buckets (linked lists of strings) */\n  int nuse;  /* number of elements */\n  int size;  /* number of buckets */\n} stringtable;\n\n\n/*\n** Information about a call.\n** About union 'u':\n** - field 'l' is used only for Lua functions;\n** - field 'c' is used only for C functions.\n** About union 'u2':\n** - field 'funcidx' is used only by C functions while doing a\n** protected call;\n** - field 'nyield' is used only while a function is \"doing\" an\n** yield (from the yield until the next resume);\n** - field 'nres' is used only while closing tbc variables when\n** returning from a function;\n** - field 'transferinfo' is used only during call/returnhooks,\n** before the function starts or after it ends.\n*/\nstruct CallInfo {\n  StkIdRel func;  /* function index in the stack */\n  StkIdRel\ttop;  /* top for this function */\n  struct CallInfo *previous, *next;  /* dynamic call link */\n  union {\n    struct {  /* only for Lua functions */\n      const Instruction *savedpc;\n      volatile l_signalT trap;  /* function is tracing lines/counts */\n      int nextraargs;  /* # of extra arguments in vararg functions */\n    } l;\n    struct {  /* only for C functions */\n      lua_KFunction k;  /* continuation in case of yields */\n      ptrdiff_t old_errfunc;\n      lua_KContext ctx;  /* context info. in case of yields */\n    } c;\n  } u;\n  union {\n    int funcidx;  /* called-function index */\n    int nyield;  /* number of values yielded */\n    int nres;  /* number of values returned */\n    struct {  /* info about transferred values (for call/return hooks) */\n      unsigned short ftransfer;  /* offset of first value transferred */\n      unsigned short ntransfer;  /* number of values transferred */\n    } transferinfo;\n  } u2;\n  short nresults;  /* expected number of results from this function */\n  unsigned short callstatus;\n};\n\n\n/*\n** Bits in CallInfo status\n*/\n#define CIST_OAH\t(1<<0)\t/* original value of 'allowhook' */\n#define CIST_C\t\t(1<<1)\t/* call is running a C function */\n#define CIST_FRESH\t(1<<2)\t/* call is on a fresh \"luaV_execute\" frame */\n#define CIST_HOOKED\t(1<<3)\t/* call is running a debug hook */\n#define CIST_YPCALL\t(1<<4)\t/* doing a yieldable protected call */\n#define CIST_TAIL\t(1<<5)\t/* call was tail called */\n#define CIST_HOOKYIELD\t(1<<6)\t/* last hook called yielded */\n#define CIST_FIN\t(1<<7)\t/* function \"called\" a finalizer */\n#define CIST_TRAN\t(1<<8)\t/* 'ci' has transfer information */\n#define CIST_CLSRET\t(1<<9)  /* function is closing tbc variables */\n/* Bits 10-12 are used for CIST_RECST (see below) */\n#define CIST_RECST\t10\n#if defined(LUA_COMPAT_LT_LE)\n#define CIST_LEQ\t(1<<13)  /* using __lt for __le */\n#endif\n\n\n/*\n** Field CIST_RECST stores the \"recover status\", used to keep the error\n** status while closing to-be-closed variables in coroutines, so that\n** Lua can correctly resume after an yield from a __close method called\n** because of an error.  (Three bits are enough for error status.)\n*/\n#define getcistrecst(ci)     (((ci)->callstatus >> CIST_RECST) & 7)\n#define setcistrecst(ci,st)  \\\n  check_exp(((st) & 7) == (st),   /* status must fit in three bits */  \\\n            ((ci)->callstatus = ((ci)->callstatus & ~(7 << CIST_RECST))  \\\n                                                  | ((st) << CIST_RECST)))\n\n\n/* active function is a Lua function */\n#define isLua(ci)\t(!((ci)->callstatus & CIST_C))\n\n/* call is running Lua code (not a hook) */\n#define isLuacode(ci)\t(!((ci)->callstatus & (CIST_C | CIST_HOOKED)))\n\n/* assume that CIST_OAH has offset 0 and that 'v' is strictly 0/1 */\n#define setoah(st,v)\t((st) = ((st) & ~CIST_OAH) | (v))\n#define getoah(st)\t((st) & CIST_OAH)\n\n\n/*\n** 'global state', shared by all threads of this state\n*/\ntypedef struct global_State {\n  lua_Alloc frealloc;  /* function to reallocate memory */\n  void *ud;         /* auxiliary data to 'frealloc' */\n  lu_mem totalbytes;  /* number of bytes currently allocated */\n  l_obj totalobjs;  /* total number of objects allocated + GCdebt */\n  l_obj GCdebt;  /* objects counted but not yet allocated */\n  l_obj marked;  /* number of objects marked in a GC cycle */\n  l_obj GCmajorminor;  /* auxiliar counter to control major-minor shifts */\n  stringtable strt;  /* hash table for strings */\n  TValue l_registry;\n  TValue nilvalue;  /* a nil value */\n  unsigned int seed;  /* randomized seed for hashes */\n  lu_byte gcparams[LUA_GCPN];\n  lu_byte currentwhite;\n  lu_byte gcstate;  /* state of garbage collector */\n  lu_byte gckind;  /* kind of GC running */\n  lu_byte gcstopem;  /* stops emergency collections */\n  lu_byte gcstp;  /* control whether GC is running */\n  lu_byte gcemergency;  /* true if this is an emergency collection */\n  GCObject *allgc;  /* list of all collectable objects */\n  GCObject **sweepgc;  /* current position of sweep in list */\n  GCObject *finobj;  /* list of collectable objects with finalizers */\n  GCObject *gray;  /* list of gray objects */\n  GCObject *grayagain;  /* list of objects to be traversed atomically */\n  GCObject *weak;  /* list of tables with weak values */\n  GCObject *ephemeron;  /* list of ephemeron tables (weak keys) */\n  GCObject *allweak;  /* list of all-weak tables */\n  GCObject *tobefnz;  /* list of userdata to be GC */\n  GCObject *fixedgc;  /* list of objects not to be collected */\n  /* fields for generational collector */\n  GCObject *survival;  /* start of objects that survived one GC cycle */\n  GCObject *old1;  /* start of old1 objects */\n  GCObject *reallyold;  /* objects more than one cycle old (\"really old\") */\n  GCObject *firstold1;  /* first OLD1 object in the list (if any) */\n  GCObject *finobjsur;  /* list of survival objects with finalizers */\n  GCObject *finobjold1;  /* list of old1 objects with finalizers */\n  GCObject *finobjrold;  /* list of really old objects with finalizers */\n  struct lua_State *twups;  /* list of threads with open upvalues */\n  lua_CFunction panic;  /* to be called in unprotected errors */\n  struct lua_State *mainthread;\n  TString *memerrmsg;  /* message for memory-allocation errors */\n  TString *tmname[TM_N];  /* array with tag-method names */\n  struct Table *mt[LUA_NUMTYPES];  /* metatables for basic types */\n  TString *strcache[STRCACHE_N][STRCACHE_M];  /* cache for strings in API */\n  lua_WarnFunction warnf;  /* warning function */\n  void *ud_warn;         /* auxiliary data to 'warnf' */\n} global_State;\n\n\n/*\n** 'per thread' state\n*/\nstruct lua_State {\n  CommonHeader;\n  lu_byte status;\n  lu_byte allowhook;\n  unsigned short nci;  /* number of items in 'ci' list */\n  StkIdRel top;  /* first free slot in the stack */\n  global_State *l_G;\n  CallInfo *ci;  /* call info for current function */\n  StkIdRel stack_last;  /* end of stack (last element + 1) */\n  StkIdRel stack;  /* stack base */\n  UpVal *openupval;  /* list of open upvalues in this stack */\n  StkIdRel tbclist;  /* list of to-be-closed variables */\n  GCObject *gclist;\n  struct lua_State *twups;  /* list of threads with open upvalues */\n  struct lua_longjmp *errorJmp;  /* current error recover point */\n  CallInfo base_ci;  /* CallInfo for first level (C calling Lua) */\n  volatile lua_Hook hook;\n  ptrdiff_t errfunc;  /* current error handling function (stack index) */\n  l_uint32 nCcalls;  /* number of nested (non-yieldable | C)  calls */\n  int oldpc;  /* last pc traced */\n  int basehookcount;\n  int hookcount;\n  volatile l_signalT hookmask;\n};\n\n\n#define G(L)\t(L->l_G)\n\n/*\n** 'g->nilvalue' being a nil value flags that the state was completely\n** build.\n*/\n#define completestate(g)\tttisnil(&g->nilvalue)\n\n\n/*\n** Union of all collectable objects (only for conversions)\n** ISO C99, 6.5.2.3 p.5:\n** \"if a union contains several structures that share a common initial\n** sequence [...], and if the union object currently contains one\n** of these structures, it is permitted to inspect the common initial\n** part of any of them anywhere that a declaration of the complete type\n** of the union is visible.\"\n*/\nunion GCUnion {\n  GCObject gc;  /* common header */\n  struct TString ts;\n  struct Udata u;\n  union Closure cl;\n  struct Table h;\n  struct Proto p;\n  struct lua_State th;  /* thread */\n  struct UpVal upv;\n};\n\n\n/*\n** ISO C99, 6.7.2.1 p.14:\n** \"A pointer to a union object, suitably converted, points to each of\n** its members [...], and vice versa.\"\n*/\n#define cast_u(o)\tcast(union GCUnion *, (o))\n\n/* macros to convert a GCObject into a specific value */\n#define gco2ts(o)  \\\n\tcheck_exp(novariant((o)->tt) == LUA_TSTRING, &((cast_u(o))->ts))\n#define gco2u(o)  check_exp((o)->tt == LUA_VUSERDATA, &((cast_u(o))->u))\n#define gco2lcl(o)  check_exp((o)->tt == LUA_VLCL, &((cast_u(o))->cl.l))\n#define gco2ccl(o)  check_exp((o)->tt == LUA_VCCL, &((cast_u(o))->cl.c))\n#define gco2cl(o)  \\\n\tcheck_exp(novariant((o)->tt) == LUA_TFUNCTION, &((cast_u(o))->cl))\n#define gco2t(o)  check_exp((o)->tt == LUA_VTABLE, &((cast_u(o))->h))\n#define gco2p(o)  check_exp((o)->tt == LUA_VPROTO, &((cast_u(o))->p))\n#define gco2th(o)  check_exp((o)->tt == LUA_VTHREAD, &((cast_u(o))->th))\n#define gco2upv(o)\tcheck_exp((o)->tt == LUA_VUPVAL, &((cast_u(o))->upv))\n\n\n/*\n** macro to convert a Lua object into a GCObject\n** (The access to 'tt' tries to ensure that 'v' is actually a Lua object.)\n*/\n#define obj2gco(v)\tcheck_exp((v)->tt >= LUA_TSTRING, &(cast_u(v)->gc))\n\n\n/* actual number of total objects allocated */\n#define gettotalobjs(g)\t((g)->totalobjs - (g)->GCdebt)\n\n\nLUAI_FUNC void luaE_setdebt (global_State *g, l_obj debt);\nLUAI_FUNC void luaE_freethread (lua_State *L, lua_State *L1);\nLUAI_FUNC CallInfo *luaE_extendCI (lua_State *L);\nLUAI_FUNC void luaE_shrinkCI (lua_State *L);\nLUAI_FUNC void luaE_checkcstack (lua_State *L);\nLUAI_FUNC void luaE_incCstack (lua_State *L);\nLUAI_FUNC void luaE_warning (lua_State *L, const char *msg, int tocont);\nLUAI_FUNC void luaE_warnerror (lua_State *L, const char *where);\nLUAI_FUNC int luaE_resetthread (lua_State *L, int status);\n\n\n#endif\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lstring.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: lstring.c $\n** String table (keeps all strings handled by Lua)\n** See Copyright Notice in lua.h\n*/\n\n#define lstring_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n\n\n/*\n** Maximum size for string table.\n*/\n#define MAXSTRTB\tcast_int(luaM_limitN(MAX_INT, TString*))\n\n\n/*\n** equality for long strings\n*/\nint luaS_eqlngstr (TString *a, TString *b) {\n  size_t len = a->u.lnglen;\n  lua_assert(a->tt == LUA_VLNGSTR && b->tt == LUA_VLNGSTR);\n  return (a == b) ||  /* same instance or... */\n    ((len == b->u.lnglen) &&  /* equal length and ... */\n     (memcmp(getlngstr(a), getlngstr(b), len) == 0));  /* equal contents */\n}\n\n\nunsigned luaS_hash (const char *str, size_t l, unsigned seed) {\n  unsigned int h = seed ^ cast_uint(l);\n  for (; l > 0; l--)\n    h ^= ((h<<5) + (h>>2) + cast_byte(str[l - 1]));\n  return h;\n}\n\n\nunsigned luaS_hashlongstr (TString *ts) {\n  lua_assert(ts->tt == LUA_VLNGSTR);\n  if (ts->extra == 0) {  /* no hash? */\n    size_t len = ts->u.lnglen;\n    ts->hash = luaS_hash(getlngstr(ts), len, ts->hash);\n    ts->extra = 1;  /* now it has its hash */\n  }\n  return ts->hash;\n}\n\n\nstatic void tablerehash (TString **vect, int osize, int nsize) {\n  int i;\n  for (i = osize; i < nsize; i++)  /* clear new elements */\n    vect[i] = NULL;\n  for (i = 0; i < osize; i++) {  /* rehash old part of the array */\n    TString *p = vect[i];\n    vect[i] = NULL;\n    while (p) {  /* for each string in the list */\n      TString *hnext = p->u.hnext;  /* save next */\n      unsigned int h = lmod(p->hash, nsize);  /* new position */\n      p->u.hnext = vect[h];  /* chain it into array */\n      vect[h] = p;\n      p = hnext;\n    }\n  }\n}\n\n\n/*\n** Resize the string table. If allocation fails, keep the current size.\n** (This can degrade performance, but any non-zero size should work\n** correctly.)\n*/\nvoid luaS_resize (lua_State *L, int nsize) {\n  stringtable *tb = &G(L)->strt;\n  int osize = tb->size;\n  TString **newvect;\n  if (nsize < osize)  /* shrinking table? */\n    tablerehash(tb->hash, osize, nsize);  /* depopulate shrinking part */\n  newvect = luaM_reallocvector(L, tb->hash, osize, nsize, TString*);\n  if (l_unlikely(newvect == NULL)) {  /* reallocation failed? */\n    if (nsize < osize)  /* was it shrinking table? */\n      tablerehash(tb->hash, nsize, osize);  /* restore to original size */\n    /* leave table as it was */\n  }\n  else {  /* allocation succeeded */\n    tb->hash = newvect;\n    tb->size = nsize;\n    if (nsize > osize)\n      tablerehash(newvect, osize, nsize);  /* rehash for new size */\n  }\n}\n\n\n/*\n** Clear API string cache. (Entries cannot be empty, so fill them with\n** a non-collectable string.)\n*/\nvoid luaS_clearcache (global_State *g) {\n  int i, j;\n  for (i = 0; i < STRCACHE_N; i++)\n    for (j = 0; j < STRCACHE_M; j++) {\n      if (iswhite(g->strcache[i][j]))  /* will entry be collected? */\n        g->strcache[i][j] = g->memerrmsg;  /* replace it with something fixed */\n    }\n}\n\n\n/*\n** Initialize the string table and the string cache\n*/\nvoid luaS_init (lua_State *L) {\n  global_State *g = G(L);\n  int i, j;\n  stringtable *tb = &G(L)->strt;\n  tb->hash = luaM_newvector(L, MINSTRTABSIZE, TString*);\n  tablerehash(tb->hash, 0, MINSTRTABSIZE);  /* clear array */\n  tb->size = MINSTRTABSIZE;\n  /* pre-create memory-error message */\n  g->memerrmsg = luaS_newliteral(L, MEMERRMSG);\n  luaC_fix(L, obj2gco(g->memerrmsg));  /* it should never be collected */\n  for (i = 0; i < STRCACHE_N; i++)  /* fill cache with valid strings */\n    for (j = 0; j < STRCACHE_M; j++)\n      g->strcache[i][j] = g->memerrmsg;\n}\n\n\nsize_t luaS_sizelngstr (size_t len, int kind) {\n  switch (kind) {\n    case LSTRREG:  /* regular long string */\n      /* don't need 'falloc'/'ud', but need space for content */\n      return offsetof(TString, falloc) + (len + 1) * sizeof(char);\n    case LSTRFIX:  /* fixed external long string */\n      /* don't need 'falloc'/'ud' */\n      return offsetof(TString, falloc);\n    default:  /* external long string with deallocation */\n      lua_assert(kind == LSTRMEM);\n      return sizeof(TString);\n  }\n}\n\n\n/*\n** creates a new string object\n*/\nstatic TString *createstrobj (lua_State *L, size_t totalsize, int tag,\n                              unsigned h) {\n  TString *ts;\n  GCObject *o;\n  o = luaC_newobj(L, tag, totalsize);\n  ts = gco2ts(o);\n  ts->hash = h;\n  ts->extra = 0;\n  return ts;\n}\n\n\nTString *luaS_createlngstrobj (lua_State *L, size_t l) {\n  size_t totalsize = luaS_sizelngstr(l, LSTRREG);\n  TString *ts = createstrobj(L, totalsize, LUA_VLNGSTR, G(L)->seed);\n  ts->u.lnglen = l;\n  ts->shrlen = LSTRREG;  /* signals that it is a regular long string */\n  ts->contents = cast_charp(ts) + offsetof(TString, falloc);\n  ts->contents[l] = '\\0';  /* ending 0 */\n  return ts;\n}\n\n\nvoid luaS_remove (lua_State *L, TString *ts) {\n  stringtable *tb = &G(L)->strt;\n  TString **p = &tb->hash[lmod(ts->hash, tb->size)];\n  while (*p != ts)  /* find previous element */\n    p = &(*p)->u.hnext;\n  *p = (*p)->u.hnext;  /* remove element from its list */\n  tb->nuse--;\n}\n\n\nstatic void growstrtab (lua_State *L, stringtable *tb) {\n  if (l_unlikely(tb->nuse == MAX_INT)) {  /* too many strings? */\n    luaC_fullgc(L, 1);  /* try to free some... */\n    if (tb->nuse == MAX_INT)  /* still too many? */\n      luaM_error(L);  /* cannot even create a message... */\n  }\n  if (tb->size <= MAXSTRTB / 2)  /* can grow string table? */\n    luaS_resize(L, tb->size * 2);\n}\n\n\n/*\n** Checks whether short string exists and reuses it or creates a new one.\n*/\nstatic TString *internshrstr (lua_State *L, const char *str, size_t l) {\n  TString *ts;\n  global_State *g = G(L);\n  stringtable *tb = &g->strt;\n  unsigned int h = luaS_hash(str, l, g->seed);\n  TString **list = &tb->hash[lmod(h, tb->size)];\n  lua_assert(str != NULL);  /* otherwise 'memcmp'/'memcpy' are undefined */\n  for (ts = *list; ts != NULL; ts = ts->u.hnext) {\n    if (l == cast_uint(ts->shrlen) &&\n        (memcmp(str, getshrstr(ts), l * sizeof(char)) == 0)) {\n      /* found! */\n      if (isdead(g, ts))  /* dead (but not collected yet)? */\n        changewhite(ts);  /* resurrect it */\n      return ts;\n    }\n  }\n  /* else must create a new string */\n  if (tb->nuse >= tb->size) {  /* need to grow string table? */\n    growstrtab(L, tb);\n    list = &tb->hash[lmod(h, tb->size)];  /* rehash with new size */\n  }\n  ts = createstrobj(L, sizestrshr(l), LUA_VSHRSTR, h);\n  ts->shrlen = cast_byte(l);\n  getshrstr(ts)[l] = '\\0';  /* ending 0 */\n  memcpy(getshrstr(ts), str, l * sizeof(char));\n  ts->u.hnext = *list;\n  *list = ts;\n  tb->nuse++;\n  return ts;\n}\n\n\n/*\n** new string (with explicit length)\n*/\nTString *luaS_newlstr (lua_State *L, const char *str, size_t l) {\n  if (l <= LUAI_MAXSHORTLEN)  /* short string? */\n    return internshrstr(L, str, l);\n  else {\n    TString *ts;\n    if (l_unlikely(l * sizeof(char) >= (MAX_SIZE - sizeof(TString))))\n      luaM_toobig(L);\n    ts = luaS_createlngstrobj(L, l);\n    memcpy(getlngstr(ts), str, l * sizeof(char));\n    return ts;\n  }\n}\n\n\n/*\n** Create or reuse a zero-terminated string, first checking in the\n** cache (using the string address as a key). The cache can contain\n** only zero-terminated strings, so it is safe to use 'strcmp' to\n** check hits.\n*/\nTString *luaS_new (lua_State *L, const char *str) {\n  unsigned int i = point2uint(str) % STRCACHE_N;  /* hash */\n  int j;\n  TString **p = G(L)->strcache[i];\n  for (j = 0; j < STRCACHE_M; j++) {\n    if (strcmp(str, getstr(p[j])) == 0)  /* hit? */\n      return p[j];  /* that is it */\n  }\n  /* normal route */\n  for (j = STRCACHE_M - 1; j > 0; j--)\n    p[j] = p[j - 1];  /* move out last element */\n  /* new element is first in the list */\n  p[0] = luaS_newlstr(L, str, strlen(str));\n  return p[0];\n}\n\n\nUdata *luaS_newudata (lua_State *L, size_t s, int nuvalue) {\n  Udata *u;\n  int i;\n  GCObject *o;\n  if (l_unlikely(s > MAX_SIZE - udatamemoffset(nuvalue)))\n    luaM_toobig(L);\n  o = luaC_newobj(L, LUA_VUSERDATA, sizeudata(nuvalue, s));\n  u = gco2u(o);\n  u->len = s;\n  u->nuvalue = nuvalue;\n  u->metatable = NULL;\n  for (i = 0; i < nuvalue; i++)\n    setnilvalue(&u->uv[i].uv);\n  return u;\n}\n\n\nstruct NewExt {\n  int kind;\n  const char *s;\n   size_t len;\n  TString *ts;  /* output */\n};\n\n\nstatic void f_newext (lua_State *L, void *ud) {\n  struct NewExt *ne = cast(struct NewExt *, ud);\n  size_t size = luaS_sizelngstr(0, ne->kind);\n  ne->ts = createstrobj(L, size, LUA_VLNGSTR, G(L)->seed);\n}\n\n\nstatic void f_pintern (lua_State *L, void *ud) {\n  struct NewExt *ne = cast(struct NewExt *, ud);\n  ne->ts = internshrstr(L, ne->s, ne->len);\n}\n\n\nTString *luaS_newextlstr (lua_State *L,\n\t          const char *s, size_t len, lua_Alloc falloc, void *ud) {\n  struct NewExt ne;\n  if (len <= LUAI_MAXSHORTLEN) {  /* short string? */\n    ne.s = s; ne.len = len;\n    if (!falloc)\n      f_pintern(L, &ne);  /* just internalize string */\n    else {\n      int status = luaD_rawrunprotected(L, f_pintern, &ne);\n      (*falloc)(ud, cast_voidp(s), len + 1, 0);  /* free external string */\n      if (status != LUA_OK)  /* memory error? */\n        luaM_error(L);  /* re-raise memory error */\n    }\n    return ne.ts;\n  }\n  /* \"normal\" case: long strings */\n  if (!falloc) {\n    ne.kind = LSTRFIX;\n    f_newext(L, &ne);  /* just create header */\n  }\n  else {\n    ne.kind = LSTRMEM;\n    if (luaD_rawrunprotected(L, f_newext, &ne) != LUA_OK) {  /* mem. error? */\n      (*falloc)(ud, cast_voidp(s), len + 1, 0);  /* free external string */\n      luaM_error(L);  /* re-raise memory error */\n    }\n    ne.ts->falloc = falloc;\n    ne.ts->ud = ud;\n  }\n  ne.ts->shrlen = ne.kind;\n  ne.ts->u.lnglen = len;\n  ne.ts->contents = cast_charp(s);\n  return ne.ts;\n}\n\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lstring.h",
		"is_binary":	false,
		"content":	"/*\n** $Id: lstring.h $\n** String table (keep all strings handled by Lua)\n** See Copyright Notice in lua.h\n*/\n\n#ifndef lstring_h\n#define lstring_h\n\n#include \"lgc.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n\n\n/*\n** Memory-allocation error message must be preallocated (it cannot\n** be created after memory is exhausted)\n*/\n#define MEMERRMSG       \"not enough memory\"\n\n\n/*\n** Size of a short TString: Size of the header plus space for the string\n** itself (including final '\\0').\n*/\n#define sizestrshr(l)  \\\n\t(offsetof(TString, contents) + ((l) + 1) * sizeof(char))\n\n\n#define luaS_newliteral(L, s)\t(luaS_newlstr(L, \"\" s, \\\n                                 (sizeof(s)/sizeof(char))-1))\n\n\n/*\n** test whether a string is a reserved word\n*/\n#define isreserved(s)\t((s)->tt == LUA_VSHRSTR && (s)->extra > 0)\n\n\n/*\n** equality for short strings, which are always internalized\n*/\n#define eqshrstr(a,b)\tcheck_exp((a)->tt == LUA_VSHRSTR, (a) == (b))\n\n\nLUAI_FUNC unsigned luaS_hash (const char *str, size_t l, unsigned seed);\nLUAI_FUNC unsigned luaS_hashlongstr (TString *ts);\nLUAI_FUNC int luaS_eqlngstr (TString *a, TString *b);\nLUAI_FUNC void luaS_resize (lua_State *L, int newsize);\nLUAI_FUNC void luaS_clearcache (global_State *g);\nLUAI_FUNC void luaS_init (lua_State *L);\nLUAI_FUNC void luaS_remove (lua_State *L, TString *ts);\nLUAI_FUNC Udata *luaS_newudata (lua_State *L, size_t s, int nuvalue);\nLUAI_FUNC TString *luaS_newlstr (lua_State *L, const char *str, size_t l);\nLUAI_FUNC TString *luaS_new (lua_State *L, const char *str);\nLUAI_FUNC TString *luaS_createlngstrobj (lua_State *L, size_t l);\nLUAI_FUNC TString *luaS_newextlstr (lua_State *L,\n\t\tconst char *s, size_t len, lua_Alloc falloc, void *ud);\nLUAI_FUNC size_t luaS_sizelngstr (size_t len, int kind);\n\n#endif\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lstrlib.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: lstrlib.c $\n** Standard library for string operations and pattern-matching\n** See Copyright Notice in lua.h\n*/\n\n#define lstrlib_c\n#define LUA_LIB\n\n#include \"lprefix.h\"\n\n\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <locale.h>\n#include <math.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n\n\n/*\n** maximum number of captures that a pattern can do during\n** pattern-matching. This limit is arbitrary, but must fit in\n** an unsigned char.\n*/\n#if !defined(LUA_MAXCAPTURES)\n#define LUA_MAXCAPTURES\t\t32\n#endif\n\n\n/* macro to 'unsign' a character */\n#define uchar(c)\t((unsigned char)(c))\n\n\n/*\n** Some sizes are better limited to fit in 'int', but must also fit in\n** 'size_t'. (We assume that 'lua_Integer' cannot be smaller than 'int'.)\n*/\n#define MAX_SIZET\t((size_t)(~(size_t)0))\n\n#define MAXSIZE  \\\n\t(sizeof(size_t) < sizeof(int) ? MAX_SIZET : (size_t)(INT_MAX))\n\n\n\n\nstatic int str_len (lua_State *L) {\n  size_t l;\n  luaL_checklstring(L, 1, &l);\n  lua_pushinteger(L, (lua_Integer)l);\n  return 1;\n}\n\n\n/*\n** translate a relative initial string position\n** (negative means back from end): clip result to [1, inf).\n** The length of any string in Lua must fit in a lua_Integer,\n** so there are no overflows in the casts.\n** The inverted comparison avoids a possible overflow\n** computing '-pos'.\n*/\nstatic size_t posrelatI (lua_Integer pos, size_t len) {\n  if (pos > 0)\n    return (size_t)pos;\n  else if (pos == 0)\n    return 1;\n  else if (pos < -(lua_Integer)len)  /* inverted comparison */\n    return 1;  /* clip to 1 */\n  else return len + (size_t)pos + 1;\n}\n\n\n/*\n** Gets an optional ending string position from argument 'arg',\n** with default value 'def'.\n** Negative means back from end: clip result to [0, len]\n*/\nstatic size_t getendpos (lua_State *L, int arg, lua_Integer def,\n                         size_t len) {\n  lua_Integer pos = luaL_optinteger(L, arg, def);\n  if (pos > (lua_Integer)len)\n    return len;\n  else if (pos >= 0)\n    return (size_t)pos;\n  else if (pos < -(lua_Integer)len)\n    return 0;\n  else return len + (size_t)pos + 1;\n}\n\n\nstatic int str_sub (lua_State *L) {\n  size_t l;\n  const char *s = luaL_checklstring(L, 1, &l);\n  size_t start = posrelatI(luaL_checkinteger(L, 2), l);\n  size_t end = getendpos(L, 3, -1, l);\n  if (start <= end)\n    lua_pushlstring(L, s + start - 1, (end - start) + 1);\n  else lua_pushliteral(L, \"\");\n  return 1;\n}\n\n\nstatic int str_reverse (lua_State *L) {\n  size_t l, i;\n  luaL_Buffer b;\n  const char *s = luaL_checklstring(L, 1, &l);\n  char *p = luaL_buffinitsize(L, &b, l);\n  for (i = 0; i < l; i++)\n    p[i] = s[l - i - 1];\n  luaL_pushresultsize(&b, l);\n  return 1;\n}\n\n\nstatic int str_lower (lua_State *L) {\n  size_t l;\n  size_t i;\n  luaL_Buffer b;\n  const char *s = luaL_checklstring(L, 1, &l);\n  char *p = luaL_buffinitsize(L, &b, l);\n  for (i=0; i<l; i++)\n    p[i] = tolower(uchar(s[i]));\n  luaL_pushresultsize(&b, l);\n  return 1;\n}\n\n\nstatic int str_upper (lua_State *L) {\n  size_t l;\n  size_t i;\n  luaL_Buffer b;\n  const char *s = luaL_checklstring(L, 1, &l);\n  char *p = luaL_buffinitsize(L, &b, l);\n  for (i=0; i<l; i++)\n    p[i] = toupper(uchar(s[i]));\n  luaL_pushresultsize(&b, l);\n  return 1;\n}\n\n\nstatic int str_rep (lua_State *L) {\n  size_t l, lsep;\n  const char *s = luaL_checklstring(L, 1, &l);\n  lua_Integer n = luaL_checkinteger(L, 2);\n  const char *sep = luaL_optlstring(L, 3, \"\", &lsep);\n  if (n <= 0)\n    lua_pushliteral(L, \"\");\n  else if (l_unlikely(l + lsep < l || l + lsep > MAXSIZE / n))\n    return luaL_error(L, \"resulting string too large\");\n  else {\n    size_t totallen = (size_t)n * l + (size_t)(n - 1) * lsep;\n    luaL_Buffer b;\n    char *p = luaL_buffinitsize(L, &b, totallen);\n    while (n-- > 1) {  /* first n-1 copies (followed by separator) */\n      memcpy(p, s, l * sizeof(char)); p += l;\n      if (lsep > 0) {  /* empty 'memcpy' is not that cheap */\n        memcpy(p, sep, lsep * sizeof(char));\n        p += lsep;\n      }\n    }\n    memcpy(p, s, l * sizeof(char));  /* last copy (not followed by separator) */\n    luaL_pushresultsize(&b, totallen);\n  }\n  return 1;\n}\n\n\nstatic int str_byte (lua_State *L) {\n  size_t l;\n  const char *s = luaL_checklstring(L, 1, &l);\n  lua_Integer pi = luaL_optinteger(L, 2, 1);\n  size_t posi = posrelatI(pi, l);\n  size_t pose = getendpos(L, 3, pi, l);\n  int n, i;\n  if (posi > pose) return 0;  /* empty interval; return no values */\n  if (l_unlikely(pose - posi >= (size_t)INT_MAX))  /* arithmetic overflow? */\n    return luaL_error(L, \"string slice too long\");\n  n = (int)(pose -  posi) + 1;\n  luaL_checkstack(L, n, \"string slice too long\");\n  for (i=0; i<n; i++)\n    lua_pushinteger(L, uchar(s[posi+i-1]));\n  return n;\n}\n\n\nstatic int str_char (lua_State *L) {\n  int n = lua_gettop(L);  /* number of arguments */\n  int i;\n  luaL_Buffer b;\n  char *p = luaL_buffinitsize(L, &b, n);\n  for (i=1; i<=n; i++) {\n    lua_Unsigned c = (lua_Unsigned)luaL_checkinteger(L, i);\n    luaL_argcheck(L, c <= (lua_Unsigned)UCHAR_MAX, i, \"value out of range\");\n    p[i - 1] = uchar(c);\n  }\n  luaL_pushresultsize(&b, n);\n  return 1;\n}\n\n\n/*\n** Buffer to store the result of 'string.dump'. It must be initialized\n** after the call to 'lua_dump', to ensure that the function is on the\n** top of the stack when 'lua_dump' is called. ('luaL_buffinit' might\n** push stuff.)\n*/\nstruct str_Writer {\n  int init;  /* true iff buffer has been initialized */\n  luaL_Buffer B;\n};\n\n\nstatic int writer (lua_State *L, const void *b, size_t size, void *ud) {\n  struct str_Writer *state = (struct str_Writer *)ud;\n  if (!state->init) {\n    state->init = 1;\n    luaL_buffinit(L, &state->B);\n  }\n  if (b == NULL) {  /* finishing dump? */\n    luaL_pushresult(&state->B);  /* push result */\n    lua_replace(L, 1);  /* move it to reserved slot */\n  }\n  else\n    luaL_addlstring(&state->B, (const char *)b, size);\n  return 0;\n}\n\n\nstatic int str_dump (lua_State *L) {\n  struct str_Writer state;\n  int strip = lua_toboolean(L, 2);\n  luaL_argcheck(L, lua_type(L, 1) == LUA_TFUNCTION && !lua_iscfunction(L, 1),\n                   1, \"Lua function expected\");\n  /* ensure function is on the top of the stack and vacate slot 1 */\n  lua_pushvalue(L, 1);\n  state.init = 0;\n  lua_dump(L, writer, &state, strip);\n  lua_settop(L, 1);  /* leave final result on top */\n  return 1;\n}\n\n\n\n/*\n** {======================================================\n** METAMETHODS\n** =======================================================\n*/\n\n#if defined(LUA_NOCVTS2N)\t/* { */\n\n/* no coercion from strings to numbers */\n\nstatic const luaL_Reg stringmetamethods[] = {\n  {\"__index\", NULL},  /* placeholder */\n  {NULL, NULL}\n};\n\n#else\t\t/* }{ */\n\nstatic int tonum (lua_State *L, int arg) {\n  if (lua_type(L, arg) == LUA_TNUMBER) {  /* already a number? */\n    lua_pushvalue(L, arg);\n    return 1;\n  }\n  else {  /* check whether it is a numerical string */\n    size_t len;\n    const char *s = lua_tolstring(L, arg, &len);\n    return (s != NULL && lua_stringtonumber(L, s) == len + 1);\n  }\n}\n\n\nstatic void trymt (lua_State *L, const char *mtname) {\n  lua_settop(L, 2);  /* back to the original arguments */\n  if (l_unlikely(lua_type(L, 2) == LUA_TSTRING ||\n                 !luaL_getmetafield(L, 2, mtname)))\n    luaL_error(L, \"attempt to %s a '%s' with a '%s'\", mtname + 2,\n                  luaL_typename(L, -2), luaL_typename(L, -1));\n  lua_insert(L, -3);  /* put metamethod before arguments */\n  lua_call(L, 2, 1);  /* call metamethod */\n}\n\n\nstatic int arith (lua_State *L, int op, const char *mtname) {\n  if (tonum(L, 1) && tonum(L, 2))\n    lua_arith(L, op);  /* result will be on the top */\n  else\n    trymt(L, mtname);\n  return 1;\n}\n\n\nstatic int arith_add (lua_State *L) {\n  return arith(L, LUA_OPADD, \"__add\");\n}\n\nstatic int arith_sub (lua_State *L) {\n  return arith(L, LUA_OPSUB, \"__sub\");\n}\n\nstatic int arith_mul (lua_State *L) {\n  return arith(L, LUA_OPMUL, \"__mul\");\n}\n\nstatic int arith_mod (lua_State *L) {\n  return arith(L, LUA_OPMOD, \"__mod\");\n}\n\nstatic int arith_pow (lua_State *L) {\n  return arith(L, LUA_OPPOW, \"__pow\");\n}\n\nstatic int arith_div (lua_State *L) {\n  return arith(L, LUA_OPDIV, \"__div\");\n}\n\nstatic int arith_idiv (lua_State *L) {\n  return arith(L, LUA_OPIDIV, \"__idiv\");\n}\n\nstatic int arith_unm (lua_State *L) {\n  return arith(L, LUA_OPUNM, \"__unm\");\n}\n\n\nstatic const luaL_Reg stringmetamethods[] = {\n  {\"__add\", arith_add},\n  {\"__sub\", arith_sub},\n  {\"__mul\", arith_mul},\n  {\"__mod\", arith_mod},\n  {\"__pow\", arith_pow},\n  {\"__div\", arith_div},\n  {\"__idiv\", arith_idiv},\n  {\"__unm\", arith_unm},\n  {\"__index\", NULL},  /* placeholder */\n  {NULL, NULL}\n};\n\n#endif\t\t/* } */\n\n/* }====================================================== */\n\n/*\n** {======================================================\n** PATTERN MATCHING\n** =======================================================\n*/\n\n\n#define CAP_UNFINISHED\t(-1)\n#define CAP_POSITION\t(-2)\n\n\ntypedef struct MatchState {\n  const char *src_init;  /* init of source string */\n  const char *src_end;  /* end ('\\0') of source string */\n  const char *p_end;  /* end ('\\0') of pattern */\n  lua_State *L;\n  int matchdepth;  /* control for recursive depth (to avoid C stack overflow) */\n  unsigned char level;  /* total number of captures (finished or unfinished) */\n  struct {\n    const char *init;\n    ptrdiff_t len;\n  } capture[LUA_MAXCAPTURES];\n} MatchState;\n\n\n/* recursive function */\nstatic const char *match (MatchState *ms, const char *s, const char *p);\n\n\n/* maximum recursion depth for 'match' */\n#if !defined(MAXCCALLS)\n#define MAXCCALLS\t200\n#endif\n\n\n#define L_ESC\t\t'%'\n#define SPECIALS\t\"^$*+?.([%-\"\n\n\nstatic int check_capture (MatchState *ms, int l) {\n  l -= '1';\n  if (l_unlikely(l < 0 || l >= ms->level ||\n                 ms->capture[l].len == CAP_UNFINISHED))\n    return luaL_error(ms->L, \"invalid capture index %%%d\", l + 1);\n  return l;\n}\n\n\nstatic int capture_to_close (MatchState *ms) {\n  int level = ms->level;\n  for (level--; level>=0; level--)\n    if (ms->capture[level].len == CAP_UNFINISHED) return level;\n  return luaL_error(ms->L, \"invalid pattern capture\");\n}\n\n\nstatic const char *classend (MatchState *ms, const char *p) {\n  switch (*p++) {\n    case L_ESC: {\n      if (l_unlikely(p == ms->p_end))\n        luaL_error(ms->L, \"malformed pattern (ends with '%%')\");\n      return p+1;\n    }\n    case '[': {\n      if (*p == '^') p++;\n      do {  /* look for a ']' */\n        if (l_unlikely(p == ms->p_end))\n          luaL_error(ms->L, \"malformed pattern (missing ']')\");\n        if (*(p++) == L_ESC && p < ms->p_end)\n          p++;  /* skip escapes (e.g. '%]') */\n      } while (*p != ']');\n      return p+1;\n    }\n    default: {\n      return p;\n    }\n  }\n}\n\n\nstatic int match_class (int c, int cl) {\n  int res;\n  switch (tolower(cl)) {\n    case 'a' : res = isalpha(c); break;\n    case 'c' : res = iscntrl(c); break;\n    case 'd' : res = isdigit(c); break;\n    case 'g' : res = isgraph(c); break;\n    case 'l' : res = islower(c); break;\n    case 'p' : res = ispunct(c); break;\n    case 's' : res = isspace(c); break;\n    case 'u' : res = isupper(c); break;\n    case 'w' : res = isalnum(c); break;\n    case 'x' : res = isxdigit(c); break;\n    case 'z' : res = (c == 0); break;  /* deprecated option */\n    default: return (cl == c);\n  }\n  return (islower(cl) ? res : !res);\n}\n\n\nstatic int matchbracketclass (int c, const char *p, const char *ec) {\n  int sig = 1;\n  if (*(p+1) == '^') {\n    sig = 0;\n    p++;  /* skip the '^' */\n  }\n  while (++p < ec) {\n    if (*p == L_ESC) {\n      p++;\n      if (match_class(c, uchar(*p)))\n        return sig;\n    }\n    else if ((*(p+1) == '-') && (p+2 < ec)) {\n      p+=2;\n      if (uchar(*(p-2)) <= c && c <= uchar(*p))\n        return sig;\n    }\n    else if (uchar(*p) == c) return sig;\n  }\n  return !sig;\n}\n\n\nstatic int singlematch (MatchState *ms, const char *s, const char *p,\n                        const char *ep) {\n  if (s >= ms->src_end)\n    return 0;\n  else {\n    int c = uchar(*s);\n    switch (*p) {\n      case '.': return 1;  /* matches any char */\n      case L_ESC: return match_class(c, uchar(*(p+1)));\n      case '[': return matchbracketclass(c, p, ep-1);\n      default:  return (uchar(*p) == c);\n    }\n  }\n}\n\n\nstatic const char *matchbalance (MatchState *ms, const char *s,\n                                   const char *p) {\n  if (l_unlikely(p >= ms->p_end - 1))\n    luaL_error(ms->L, \"malformed pattern (missing arguments to '%%b')\");\n  if (*s != *p) return NULL;\n  else {\n    int b = *p;\n    int e = *(p+1);\n    int cont = 1;\n    while (++s < ms->src_end) {\n      if (*s == e) {\n        if (--cont == 0) return s+1;\n      }\n      else if (*s == b) cont++;\n    }\n  }\n  return NULL;  /* string ends out of balance */\n}\n\n\nstatic const char *max_expand (MatchState *ms, const char *s,\n                                 const char *p, const char *ep) {\n  ptrdiff_t i = 0;  /* counts maximum expand for item */\n  while (singlematch(ms, s + i, p, ep))\n    i++;\n  /* keeps trying to match with the maximum repetitions */\n  while (i>=0) {\n    const char *res = match(ms, (s+i), ep+1);\n    if (res) return res;\n    i--;  /* else didn't match; reduce 1 repetition to try again */\n  }\n  return NULL;\n}\n\n\nstatic const char *min_expand (MatchState *ms, const char *s,\n                                 const char *p, const char *ep) {\n  for (;;) {\n    const char *res = match(ms, s, ep+1);\n    if (res != NULL)\n      return res;\n    else if (singlematch(ms, s, p, ep))\n      s++;  /* try with one more repetition */\n    else return NULL;\n  }\n}\n\n\nstatic const char *start_capture (MatchState *ms, const char *s,\n                                    const char *p, int what) {\n  const char *res;\n  int level = ms->level;\n  if (level >= LUA_MAXCAPTURES) luaL_error(ms->L, \"too many captures\");\n  ms->capture[level].init = s;\n  ms->capture[level].len = what;\n  ms->level = level+1;\n  if ((res=match(ms, s, p)) == NULL)  /* match failed? */\n    ms->level--;  /* undo capture */\n  return res;\n}\n\n\nstatic const char *end_capture (MatchState *ms, const char *s,\n                                  const char *p) {\n  int l = capture_to_close(ms);\n  const char *res;\n  ms->capture[l].len = s - ms->capture[l].init;  /* close capture */\n  if ((res = match(ms, s, p)) == NULL)  /* match failed? */\n    ms->capture[l].len = CAP_UNFINISHED;  /* undo capture */\n  return res;\n}\n\n\nstatic const char *match_capture (MatchState *ms, const char *s, int l) {\n  size_t len;\n  l = check_capture(ms, l);\n  len = ms->capture[l].len;\n  if ((size_t)(ms->src_end-s) >= len &&\n      memcmp(ms->capture[l].init, s, len) == 0)\n    return s+len;\n  else return NULL;\n}\n\n\nstatic const char *match (MatchState *ms, const char *s, const char *p) {\n  if (l_unlikely(ms->matchdepth-- == 0))\n    luaL_error(ms->L, \"pattern too complex\");\n  init: /* using goto to optimize tail recursion */\n  if (p != ms->p_end) {  /* end of pattern? */\n    switch (*p) {\n      case '(': {  /* start capture */\n        if (*(p + 1) == ')')  /* position capture? */\n          s = start_capture(ms, s, p + 2, CAP_POSITION);\n        else\n          s = start_capture(ms, s, p + 1, CAP_UNFINISHED);\n        break;\n      }\n      case ')': {  /* end capture */\n        s = end_capture(ms, s, p + 1);\n        break;\n      }\n      case '$': {\n        if ((p + 1) != ms->p_end)  /* is the '$' the last char in pattern? */\n          goto dflt;  /* no; go to default */\n        s = (s == ms->src_end) ? s : NULL;  /* check end of string */\n        break;\n      }\n      case L_ESC: {  /* escaped sequences not in the format class[*+?-]? */\n        switch (*(p + 1)) {\n          case 'b': {  /* balanced string? */\n            s = matchbalance(ms, s, p + 2);\n            if (s != NULL) {\n              p += 4; goto init;  /* return match(ms, s, p + 4); */\n            }  /* else fail (s == NULL) */\n            break;\n          }\n          case 'f': {  /* frontier? */\n            const char *ep; char previous;\n            p += 2;\n            if (l_unlikely(*p != '['))\n              luaL_error(ms->L, \"missing '[' after '%%f' in pattern\");\n            ep = classend(ms, p);  /* points to what is next */\n            previous = (s == ms->src_init) ? '\\0' : *(s - 1);\n            if (!matchbracketclass(uchar(previous), p, ep - 1) &&\n               matchbracketclass(uchar(*s), p, ep - 1)) {\n              p = ep; goto init;  /* return match(ms, s, ep); */\n            }\n            s = NULL;  /* match failed */\n            break;\n          }\n          case '0': case '1': case '2': case '3':\n          case '4': case '5': case '6': case '7':\n          case '8': case '9': {  /* capture results (%0-%9)? */\n            s = match_capture(ms, s, uchar(*(p + 1)));\n            if (s != NULL) {\n              p += 2; goto init;  /* return match(ms, s, p + 2) */\n            }\n            break;\n          }\n          default: goto dflt;\n        }\n        break;\n      }\n      default: dflt: {  /* pattern class plus optional suffix */\n        const char *ep = classend(ms, p);  /* points to optional suffix */\n        /* does not match at least once? */\n        if (!singlematch(ms, s, p, ep)) {\n          if (*ep == '*' || *ep == '?' || *ep == '-') {  /* accept empty? */\n            p = ep + 1; goto init;  /* return match(ms, s, ep + 1); */\n          }\n          else  /* '+' or no suffix */\n            s = NULL;  /* fail */\n        }\n        else {  /* matched once */\n          switch (*ep) {  /* handle optional suffix */\n            case '?': {  /* optional */\n              const char *res;\n              if ((res = match(ms, s + 1, ep + 1)) != NULL)\n                s = res;\n              else {\n                p = ep + 1; goto init;  /* else return match(ms, s, ep + 1); */\n              }\n              break;\n            }\n            case '+':  /* 1 or more repetitions */\n              s++;  /* 1 match already done */\n              /* FALLTHROUGH */\n            case '*':  /* 0 or more repetitions */\n              s = max_expand(ms, s, p, ep);\n              break;\n            case '-':  /* 0 or more repetitions (minimum) */\n              s = min_expand(ms, s, p, ep);\n              break;\n            default:  /* no suffix */\n              s++; p = ep; goto init;  /* return match(ms, s + 1, ep); */\n          }\n        }\n        break;\n      }\n    }\n  }\n  ms->matchdepth++;\n  return s;\n}\n\n\n\nstatic const char *lmemfind (const char *s1, size_t l1,\n                               const char *s2, size_t l2) {\n  if (l2 == 0) return s1;  /* empty strings are everywhere */\n  else if (l2 > l1) return NULL;  /* avoids a negative 'l1' */\n  else {\n    const char *init;  /* to search for a '*s2' inside 's1' */\n    l2--;  /* 1st char will be checked by 'memchr' */\n    l1 = l1-l2;  /* 's2' cannot be found after that */\n    while (l1 > 0 && (init = (const char *)memchr(s1, *s2, l1)) != NULL) {\n      init++;   /* 1st char is already checked */\n      if (memcmp(init, s2+1, l2) == 0)\n        return init-1;\n      else {  /* correct 'l1' and 's1' to try again */\n        l1 -= init-s1;\n        s1 = init;\n      }\n    }\n    return NULL;  /* not found */\n  }\n}\n\n\n/*\n** get information about the i-th capture. If there are no captures\n** and 'i==0', return information about the whole match, which\n** is the range 's'..'e'. If the capture is a string, return\n** its length and put its address in '*cap'. If it is an integer\n** (a position), push it on the stack and return CAP_POSITION.\n*/\nstatic size_t get_onecapture (MatchState *ms, int i, const char *s,\n                              const char *e, const char **cap) {\n  if (i >= ms->level) {\n    if (l_unlikely(i != 0))\n      luaL_error(ms->L, \"invalid capture index %%%d\", i + 1);\n    *cap = s;\n    return e - s;\n  }\n  else {\n    ptrdiff_t capl = ms->capture[i].len;\n    *cap = ms->capture[i].init;\n    if (l_unlikely(capl == CAP_UNFINISHED))\n      luaL_error(ms->L, \"unfinished capture\");\n    else if (capl == CAP_POSITION)\n      lua_pushinteger(ms->L, (ms->capture[i].init - ms->src_init) + 1);\n    return capl;\n  }\n}\n\n\n/*\n** Push the i-th capture on the stack.\n*/\nstatic void push_onecapture (MatchState *ms, int i, const char *s,\n                                                    const char *e) {\n  const char *cap;\n  ptrdiff_t l = get_onecapture(ms, i, s, e, &cap);\n  if (l != CAP_POSITION)\n    lua_pushlstring(ms->L, cap, l);\n  /* else position was already pushed */\n}\n\n\nstatic int push_captures (MatchState *ms, const char *s, const char *e) {\n  int i;\n  int nlevels = (ms->level == 0 && s) ? 1 : ms->level;\n  luaL_checkstack(ms->L, nlevels, \"too many captures\");\n  for (i = 0; i < nlevels; i++)\n    push_onecapture(ms, i, s, e);\n  return nlevels;  /* number of strings pushed */\n}\n\n\n/* check whether pattern has no special characters */\nstatic int nospecials (const char *p, size_t l) {\n  size_t upto = 0;\n  do {\n    if (strpbrk(p + upto, SPECIALS))\n      return 0;  /* pattern has a special character */\n    upto += strlen(p + upto) + 1;  /* may have more after \\0 */\n  } while (upto <= l);\n  return 1;  /* no special chars found */\n}\n\n\nstatic void prepstate (MatchState *ms, lua_State *L,\n                       const char *s, size_t ls, const char *p, size_t lp) {\n  ms->L = L;\n  ms->matchdepth = MAXCCALLS;\n  ms->src_init = s;\n  ms->src_end = s + ls;\n  ms->p_end = p + lp;\n}\n\n\nstatic void reprepstate (MatchState *ms) {\n  ms->level = 0;\n  lua_assert(ms->matchdepth == MAXCCALLS);\n}\n\n\nstatic int str_find_aux (lua_State *L, int find) {\n  size_t ls, lp;\n  const char *s = luaL_checklstring(L, 1, &ls);\n  const char *p = luaL_checklstring(L, 2, &lp);\n  size_t init = posrelatI(luaL_optinteger(L, 3, 1), ls) - 1;\n  if (init > ls) {  /* start after string's end? */\n    luaL_pushfail(L);  /* cannot find anything */\n    return 1;\n  }\n  /* explicit request or no special characters? */\n  if (find && (lua_toboolean(L, 4) || nospecials(p, lp))) {\n    /* do a plain search */\n    const char *s2 = lmemfind(s + init, ls - init, p, lp);\n    if (s2) {\n      lua_pushinteger(L, (s2 - s) + 1);\n      lua_pushinteger(L, (s2 - s) + lp);\n      return 2;\n    }\n  }\n  else {\n    MatchState ms;\n    const char *s1 = s + init;\n    int anchor = (*p == '^');\n    if (anchor) {\n      p++; lp--;  /* skip anchor character */\n    }\n    prepstate(&ms, L, s, ls, p, lp);\n    do {\n      const char *res;\n      reprepstate(&ms);\n      if ((res=match(&ms, s1, p)) != NULL) {\n        if (find) {\n          lua_pushinteger(L, (s1 - s) + 1);  /* start */\n          lua_pushinteger(L, res - s);   /* end */\n          return push_captures(&ms, NULL, 0) + 2;\n        }\n        else\n          return push_captures(&ms, s1, res);\n      }\n    } while (s1++ < ms.src_end && !anchor);\n  }\n  luaL_pushfail(L);  /* not found */\n  return 1;\n}\n\n\nstatic int str_find (lua_State *L) {\n  return str_find_aux(L, 1);\n}\n\n\nstatic int str_match (lua_State *L) {\n  return str_find_aux(L, 0);\n}\n\n\n/* state for 'gmatch' */\ntypedef struct GMatchState {\n  const char *src;  /* current position */\n  const char *p;  /* pattern */\n  const char *lastmatch;  /* end of last match */\n  MatchState ms;  /* match state */\n} GMatchState;\n\n\nstatic int gmatch_aux (lua_State *L) {\n  GMatchState *gm = (GMatchState *)lua_touserdata(L, lua_upvalueindex(3));\n  const char *src;\n  gm->ms.L = L;\n  for (src = gm->src; src <= gm->ms.src_end; src++) {\n    const char *e;\n    reprepstate(&gm->ms);\n    if ((e = match(&gm->ms, src, gm->p)) != NULL && e != gm->lastmatch) {\n      gm->src = gm->lastmatch = e;\n      return push_captures(&gm->ms, src, e);\n    }\n  }\n  return 0;  /* not found */\n}\n\n\nstatic int gmatch (lua_State *L) {\n  size_t ls, lp;\n  const char *s = luaL_checklstring(L, 1, &ls);\n  const char *p = luaL_checklstring(L, 2, &lp);\n  size_t init = posrelatI(luaL_optinteger(L, 3, 1), ls) - 1;\n  GMatchState *gm;\n  lua_settop(L, 2);  /* keep strings on closure to avoid being collected */\n  gm = (GMatchState *)lua_newuserdatauv(L, sizeof(GMatchState), 0);\n  if (init > ls)  /* start after string's end? */\n    init = ls + 1;  /* avoid overflows in 's + init' */\n  prepstate(&gm->ms, L, s, ls, p, lp);\n  gm->src = s + init; gm->p = p; gm->lastmatch = NULL;\n  lua_pushcclosure(L, gmatch_aux, 3);\n  return 1;\n}\n\n\nstatic void add_s (MatchState *ms, luaL_Buffer *b, const char *s,\n                                                   const char *e) {\n  size_t l;\n  lua_State *L = ms->L;\n  const char *news = lua_tolstring(L, 3, &l);\n  const char *p;\n  while ((p = (char *)memchr(news, L_ESC, l)) != NULL) {\n    luaL_addlstring(b, news, p - news);\n    p++;  /* skip ESC */\n    if (*p == L_ESC)  /* '%%' */\n      luaL_addchar(b, *p);\n    else if (*p == '0')  /* '%0' */\n        luaL_addlstring(b, s, e - s);\n    else if (isdigit(uchar(*p))) {  /* '%n' */\n      const char *cap;\n      ptrdiff_t resl = get_onecapture(ms, *p - '1', s, e, &cap);\n      if (resl == CAP_POSITION)\n        luaL_addvalue(b);  /* add position to accumulated result */\n      else\n        luaL_addlstring(b, cap, resl);\n    }\n    else\n      luaL_error(L, \"invalid use of '%c' in replacement string\", L_ESC);\n    l -= p + 1 - news;\n    news = p + 1;\n  }\n  luaL_addlstring(b, news, l);\n}\n\n\n/*\n** Add the replacement value to the string buffer 'b'.\n** Return true if the original string was changed. (Function calls and\n** table indexing resulting in nil or false do not change the subject.)\n*/\nstatic int add_value (MatchState *ms, luaL_Buffer *b, const char *s,\n                                      const char *e, int tr) {\n  lua_State *L = ms->L;\n  switch (tr) {\n    case LUA_TFUNCTION: {  /* call the function */\n      int n;\n      lua_pushvalue(L, 3);  /* push the function */\n      n = push_captures(ms, s, e);  /* all captures as arguments */\n      lua_call(L, n, 1);  /* call it */\n      break;\n    }\n    case LUA_TTABLE: {  /* index the table */\n      push_onecapture(ms, 0, s, e);  /* first capture is the index */\n      lua_gettable(L, 3);\n      break;\n    }\n    default: {  /* LUA_TNUMBER or LUA_TSTRING */\n      add_s(ms, b, s, e);  /* add value to the buffer */\n      return 1;  /* something changed */\n    }\n  }\n  if (!lua_toboolean(L, -1)) {  /* nil or false? */\n    lua_pop(L, 1);  /* remove value */\n    luaL_addlstring(b, s, e - s);  /* keep original text */\n    return 0;  /* no changes */\n  }\n  else if (l_unlikely(!lua_isstring(L, -1)))\n    return luaL_error(L, \"invalid replacement value (a %s)\",\n                         luaL_typename(L, -1));\n  else {\n    luaL_addvalue(b);  /* add result to accumulator */\n    return 1;  /* something changed */\n  }\n}\n\n\nstatic int str_gsub (lua_State *L) {\n  size_t srcl, lp;\n  const char *src = luaL_checklstring(L, 1, &srcl);  /* subject */\n  const char *p = luaL_checklstring(L, 2, &lp);  /* pattern */\n  const char *lastmatch = NULL;  /* end of last match */\n  int tr = lua_type(L, 3);  /* replacement type */\n  lua_Integer max_s = luaL_optinteger(L, 4, srcl + 1);  /* max replacements */\n  int anchor = (*p == '^');\n  lua_Integer n = 0;  /* replacement count */\n  int changed = 0;  /* change flag */\n  MatchState ms;\n  luaL_Buffer b;\n  luaL_argexpected(L, tr == LUA_TNUMBER || tr == LUA_TSTRING ||\n                   tr == LUA_TFUNCTION || tr == LUA_TTABLE, 3,\n                      \"string/function/table\");\n  luaL_buffinit(L, &b);\n  if (anchor) {\n    p++; lp--;  /* skip anchor character */\n  }\n  prepstate(&ms, L, src, srcl, p, lp);\n  while (n < max_s) {\n    const char *e;\n    reprepstate(&ms);  /* (re)prepare state for new match */\n    if ((e = match(&ms, src, p)) != NULL && e != lastmatch) {  /* match? */\n      n++;\n      changed = add_value(&ms, &b, src, e, tr) | changed;\n      src = lastmatch = e;\n    }\n    else if (src < ms.src_end)  /* otherwise, skip one character */\n      luaL_addchar(&b, *src++);\n    else break;  /* end of subject */\n    if (anchor) break;\n  }\n  if (!changed)  /* no changes? */\n    lua_pushvalue(L, 1);  /* return original string */\n  else {  /* something changed */\n    luaL_addlstring(&b, src, ms.src_end-src);\n    luaL_pushresult(&b);  /* create and return new string */\n  }\n  lua_pushinteger(L, n);  /* number of substitutions */\n  return 2;\n}\n\n/* }====================================================== */\n\n\n\n/*\n** {======================================================\n** STRING FORMAT\n** =======================================================\n*/\n\n#if !defined(lua_number2strx)\t/* { */\n\n/*\n** Hexadecimal floating-point formatter\n*/\n\n#define SIZELENMOD\t(sizeof(LUA_NUMBER_FRMLEN)/sizeof(char))\n\n\n/*\n** Number of bits that goes into the first digit. It can be any value\n** between 1 and 4; the following definition tries to align the number\n** to nibble boundaries by making what is left after that first digit a\n** multiple of 4.\n*/\n#define L_NBFD\t\t((l_floatatt(MANT_DIG) - 1)%4 + 1)\n\n\n/*\n** Add integer part of 'x' to buffer and return new 'x'\n*/\nstatic lua_Number adddigit (char *buff, int n, lua_Number x) {\n  lua_Number dd = l_mathop(floor)(x);  /* get integer part from 'x' */\n  int d = (int)dd;\n  buff[n] = (d < 10 ? d + '0' : d - 10 + 'a');  /* add to buffer */\n  return x - dd;  /* return what is left */\n}\n\n\nstatic int num2straux (char *buff, int sz, lua_Number x) {\n  /* if 'inf' or 'NaN', format it like '%g' */\n  if (x != x || x == (lua_Number)HUGE_VAL || x == -(lua_Number)HUGE_VAL)\n    return l_sprintf(buff, sz, LUA_NUMBER_FMT, (LUAI_UACNUMBER)x);\n  else if (x == 0) {  /* can be -0... */\n    /* create \"0\" or \"-0\" followed by exponent */\n    return l_sprintf(buff, sz, LUA_NUMBER_FMT \"x0p+0\", (LUAI_UACNUMBER)x);\n  }\n  else {\n    int e;\n    lua_Number m = l_mathop(frexp)(x, &e);  /* 'x' fraction and exponent */\n    int n = 0;  /* character count */\n    if (m < 0) {  /* is number negative? */\n      buff[n++] = '-';  /* add sign */\n      m = -m;  /* make it positive */\n    }\n    buff[n++] = '0'; buff[n++] = 'x';  /* add \"0x\" */\n    m = adddigit(buff, n++, m * (1 << L_NBFD));  /* add first digit */\n    e -= L_NBFD;  /* this digit goes before the radix point */\n    if (m > 0) {  /* more digits? */\n      buff[n++] = lua_getlocaledecpoint();  /* add radix point */\n      do {  /* add as many digits as needed */\n        m = adddigit(buff, n++, m * 16);\n      } while (m > 0);\n    }\n    n += l_sprintf(buff + n, sz - n, \"p%+d\", e);  /* add exponent */\n    lua_assert(n < sz);\n    return n;\n  }\n}\n\n\nstatic int lua_number2strx (lua_State *L, char *buff, int sz,\n                            const char *fmt, lua_Number x) {\n  int n = num2straux(buff, sz, x);\n  if (fmt[SIZELENMOD] == 'A') {\n    int i;\n    for (i = 0; i < n; i++)\n      buff[i] = toupper(uchar(buff[i]));\n  }\n  else if (l_unlikely(fmt[SIZELENMOD] != 'a'))\n    return luaL_error(L, \"modifiers for format '%%a'/'%%A' not implemented\");\n  return n;\n}\n\n#endif\t\t\t\t/* } */\n\n\n/*\n** Maximum size for items formatted with '%f'. This size is produced\n** by format('%.99f', -maxfloat), and is equal to 99 + 3 ('-', '.',\n** and '\\0') + number of decimal digits to represent maxfloat (which\n** is maximum exponent + 1). (99+3+1, adding some extra, 110)\n*/\n#define MAX_ITEMF\t(110 + l_floatatt(MAX_10_EXP))\n\n\n/*\n** All formats except '%f' do not need that large limit.  The other\n** float formats use exponents, so that they fit in the 99 limit for\n** significant digits; 's' for large strings and 'q' add items directly\n** to the buffer; all integer formats also fit in the 99 limit.  The\n** worst case are floats: they may need 99 significant digits, plus\n** '0x', '-', '.', 'e+XXXX', and '\\0'. Adding some extra, 120.\n*/\n#define MAX_ITEM\t120\n\n\n/* valid flags in a format specification */\n#if !defined(L_FMTFLAGSF)\n\n/* valid flags for a, A, e, E, f, F, g, and G conversions */\n#define L_FMTFLAGSF\t\"-+#0 \"\n\n/* valid flags for o, x, and X conversions */\n#define L_FMTFLAGSX\t\"-#0\"\n\n/* valid flags for d and i conversions */\n#define L_FMTFLAGSI\t\"-+0 \"\n\n/* valid flags for u conversions */\n#define L_FMTFLAGSU\t\"-0\"\n\n/* valid flags for c, p, and s conversions */\n#define L_FMTFLAGSC\t\"-\"\n\n#endif\n\n\n/*\n** Maximum size of each format specification (such as \"%-099.99d\"):\n** Initial '%', flags (up to 5), width (2), period, precision (2),\n** length modifier (8), conversion specifier, and final '\\0', plus some\n** extra.\n*/\n#define MAX_FORMAT\t32\n\n\nstatic void addquoted (luaL_Buffer *b, const char *s, size_t len) {\n  luaL_addchar(b, '\"');\n  while (len--) {\n    if (*s == '\"' || *s == '\\\\' || *s == '\\n') {\n      luaL_addchar(b, '\\\\');\n      luaL_addchar(b, *s);\n    }\n    else if (iscntrl(uchar(*s))) {\n      char buff[10];\n      if (!isdigit(uchar(*(s+1))))\n        l_sprintf(buff, sizeof(buff), \"\\\\%d\", (int)uchar(*s));\n      else\n        l_sprintf(buff, sizeof(buff), \"\\\\%03d\", (int)uchar(*s));\n      luaL_addstring(b, buff);\n    }\n    else\n      luaL_addchar(b, *s);\n    s++;\n  }\n  luaL_addchar(b, '\"');\n}\n\n\n/*\n** Serialize a floating-point number in such a way that it can be\n** scanned back by Lua. Use hexadecimal format for \"common\" numbers\n** (to preserve precision); inf, -inf, and NaN are handled separately.\n** (NaN cannot be expressed as a numeral, so we write '(0/0)' for it.)\n*/\nstatic int quotefloat (lua_State *L, char *buff, lua_Number n) {\n  const char *s;  /* for the fixed representations */\n  if (n == (lua_Number)HUGE_VAL)  /* inf? */\n    s = \"1e9999\";\n  else if (n == -(lua_Number)HUGE_VAL)  /* -inf? */\n    s = \"-1e9999\";\n  else if (n != n)  /* NaN? */\n    s = \"(0/0)\";\n  else {  /* format number as hexadecimal */\n    int  nb = lua_number2strx(L, buff, MAX_ITEM,\n                                 \"%\" LUA_NUMBER_FRMLEN \"a\", n);\n    /* ensures that 'buff' string uses a dot as the radix character */\n    if (memchr(buff, '.', nb) == NULL) {  /* no dot? */\n      char point = lua_getlocaledecpoint();  /* try locale point */\n      char *ppoint = (char *)memchr(buff, point, nb);\n      if (ppoint) *ppoint = '.';  /* change it to a dot */\n    }\n    return nb;\n  }\n  /* for the fixed representations */\n  return l_sprintf(buff, MAX_ITEM, \"%s\", s);\n}\n\n\nstatic void addliteral (lua_State *L, luaL_Buffer *b, int arg) {\n  switch (lua_type(L, arg)) {\n    case LUA_TSTRING: {\n      size_t len;\n      const char *s = lua_tolstring(L, arg, &len);\n      addquoted(b, s, len);\n      break;\n    }\n    case LUA_TNUMBER: {\n      char *buff = luaL_prepbuffsize(b, MAX_ITEM);\n      int nb;\n      if (!lua_isinteger(L, arg))  /* float? */\n        nb = quotefloat(L, buff, lua_tonumber(L, arg));\n      else {  /* integers */\n        lua_Integer n = lua_tointeger(L, arg);\n        const char *format = (n == LUA_MININTEGER)  /* corner case? */\n                           ? \"0x%\" LUA_INTEGER_FRMLEN \"x\"  /* use hex */\n                           : LUA_INTEGER_FMT;  /* else use default format */\n        nb = l_sprintf(buff, MAX_ITEM, format, (LUAI_UACINT)n);\n      }\n      luaL_addsize(b, nb);\n      break;\n    }\n    case LUA_TNIL: case LUA_TBOOLEAN: {\n      luaL_tolstring(L, arg, NULL);\n      luaL_addvalue(b);\n      break;\n    }\n    default: {\n      luaL_argerror(L, arg, \"value has no literal form\");\n    }\n  }\n}\n\n\nstatic const char *get2digits (const char *s) {\n  if (isdigit(uchar(*s))) {\n    s++;\n    if (isdigit(uchar(*s))) s++;  /* (2 digits at most) */\n  }\n  return s;\n}\n\n\n/*\n** Check whether a conversion specification is valid. When called,\n** first character in 'form' must be '%' and last character must\n** be a valid conversion specifier. 'flags' are the accepted flags;\n** 'precision' signals whether to accept a precision.\n*/\nstatic void checkformat (lua_State *L, const char *form, const char *flags,\n                                       int precision) {\n  const char *spec = form + 1;  /* skip '%' */\n  spec += strspn(spec, flags);  /* skip flags */\n  if (*spec != '0') {  /* a width cannot start with '0' */\n    spec = get2digits(spec);  /* skip width */\n    if (*spec == '.' && precision) {\n      spec++;\n      spec = get2digits(spec);  /* skip precision */\n    }\n  }\n  if (!isalpha(uchar(*spec)))  /* did not go to the end? */\n    luaL_error(L, \"invalid conversion specification: '%s'\", form);\n}\n\n\n/*\n** Get a conversion specification and copy it to 'form'.\n** Return the address of its last character.\n*/\nstatic const char *getformat (lua_State *L, const char *strfrmt,\n                                            char *form) {\n  /* spans flags, width, and precision ('0' is included as a flag) */\n  size_t len = strspn(strfrmt, L_FMTFLAGSF \"123456789.\");\n  len++;  /* adds following character (should be the specifier) */\n  /* still needs space for '%', '\\0', plus a length modifier */\n  if (len >= MAX_FORMAT - 10)\n    luaL_error(L, \"invalid format (too long)\");\n  *(form++) = '%';\n  memcpy(form, strfrmt, len * sizeof(char));\n  *(form + len) = '\\0';\n  return strfrmt + len - 1;\n}\n\n\n/*\n** add length modifier into formats\n*/\nstatic void addlenmod (char *form, const char *lenmod) {\n  size_t l = strlen(form);\n  size_t lm = strlen(lenmod);\n  char spec = form[l - 1];\n  strcpy(form + l - 1, lenmod);\n  form[l + lm - 1] = spec;\n  form[l + lm] = '\\0';\n}\n\n\nstatic int str_format (lua_State *L) {\n  int top = lua_gettop(L);\n  int arg = 1;\n  size_t sfl;\n  const char *strfrmt = luaL_checklstring(L, arg, &sfl);\n  const char *strfrmt_end = strfrmt+sfl;\n  const char *flags;\n  luaL_Buffer b;\n  luaL_buffinit(L, &b);\n  while (strfrmt < strfrmt_end) {\n    if (*strfrmt != L_ESC)\n      luaL_addchar(&b, *strfrmt++);\n    else if (*++strfrmt == L_ESC)\n      luaL_addchar(&b, *strfrmt++);  /* %% */\n    else { /* format item */\n      char form[MAX_FORMAT];  /* to store the format ('%...') */\n      int maxitem = MAX_ITEM;  /* maximum length for the result */\n      char *buff = luaL_prepbuffsize(&b, maxitem);  /* to put result */\n      int nb = 0;  /* number of bytes in result */\n      if (++arg > top)\n        return luaL_argerror(L, arg, \"no value\");\n      strfrmt = getformat(L, strfrmt, form);\n      switch (*strfrmt++) {\n        case 'c': {\n          checkformat(L, form, L_FMTFLAGSC, 0);\n          nb = l_sprintf(buff, maxitem, form, (int)luaL_checkinteger(L, arg));\n          break;\n        }\n        case 'd': case 'i':\n          flags = L_FMTFLAGSI;\n          goto intcase;\n        case 'u':\n          flags = L_FMTFLAGSU;\n          goto intcase;\n        case 'o': case 'x': case 'X':\n          flags = L_FMTFLAGSX;\n         intcase: {\n          lua_Integer n = luaL_checkinteger(L, arg);\n          checkformat(L, form, flags, 1);\n          addlenmod(form, LUA_INTEGER_FRMLEN);\n          nb = l_sprintf(buff, maxitem, form, (LUAI_UACINT)n);\n          break;\n        }\n        case 'a': case 'A':\n          checkformat(L, form, L_FMTFLAGSF, 1);\n          addlenmod(form, LUA_NUMBER_FRMLEN);\n          nb = lua_number2strx(L, buff, maxitem, form,\n                                  luaL_checknumber(L, arg));\n          break;\n        case 'f':\n          maxitem = MAX_ITEMF;  /* extra space for '%f' */\n          buff = luaL_prepbuffsize(&b, maxitem);\n          /* FALLTHROUGH */\n        case 'e': case 'E': case 'g': case 'G': {\n          lua_Number n = luaL_checknumber(L, arg);\n          checkformat(L, form, L_FMTFLAGSF, 1);\n          addlenmod(form, LUA_NUMBER_FRMLEN);\n          nb = l_sprintf(buff, maxitem, form, (LUAI_UACNUMBER)n);\n          break;\n        }\n        case 'p': {\n          const void *p = lua_topointer(L, arg);\n          checkformat(L, form, L_FMTFLAGSC, 0);\n          if (p == NULL) {  /* avoid calling 'printf' with argument NULL */\n            p = \"(null)\";  /* result */\n            form[strlen(form) - 1] = 's';  /* format it as a string */\n          }\n          nb = l_sprintf(buff, maxitem, form, p);\n          break;\n        }\n        case 'q': {\n          if (form[2] != '\\0')  /* modifiers? */\n            return luaL_error(L, \"specifier '%%q' cannot have modifiers\");\n          addliteral(L, &b, arg);\n          break;\n        }\n        case 's': {\n          size_t l;\n          const char *s = luaL_tolstring(L, arg, &l);\n          if (form[2] == '\\0')  /* no modifiers? */\n            luaL_addvalue(&b);  /* keep entire string */\n          else {\n            luaL_argcheck(L, l == strlen(s), arg, \"string contains zeros\");\n            checkformat(L, form, L_FMTFLAGSC, 1);\n            if (strchr(form, '.') == NULL && l >= 100) {\n              /* no precision and string is too long to be formatted */\n              luaL_addvalue(&b);  /* keep entire string */\n            }\n            else {  /* format the string into 'buff' */\n              nb = l_sprintf(buff, maxitem, form, s);\n              lua_pop(L, 1);  /* remove result from 'luaL_tolstring' */\n            }\n          }\n          break;\n        }\n        default: {  /* also treat cases 'pnLlh' */\n          return luaL_error(L, \"invalid conversion '%s' to 'format'\", form);\n        }\n      }\n      lua_assert(nb < maxitem);\n      luaL_addsize(&b, nb);\n    }\n  }\n  luaL_pushresult(&b);\n  return 1;\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** PACK/UNPACK\n** =======================================================\n*/\n\n\n/* value used for padding */\n#if !defined(LUAL_PACKPADBYTE)\n#define LUAL_PACKPADBYTE\t\t0x00\n#endif\n\n/* maximum size for the binary representation of an integer */\n#define MAXINTSIZE\t16\n\n/* number of bits in a character */\n#define NB\tCHAR_BIT\n\n/* mask for one character (NB 1's) */\n#define MC\t((1 << NB) - 1)\n\n/* size of a lua_Integer */\n#define SZINT\t((int)sizeof(lua_Integer))\n\n\n/* dummy union to get native endianness */\nstatic const union {\n  int dummy;\n  char little;  /* true iff machine is little endian */\n} nativeendian = {1};\n\n\n/*\n** information to pack/unpack stuff\n*/\ntypedef struct Header {\n  lua_State *L;\n  int islittle;\n  int maxalign;\n} Header;\n\n\n/*\n** options for pack/unpack\n*/\ntypedef enum KOption {\n  Kint,\t\t/* signed integers */\n  Kuint,\t/* unsigned integers */\n  Kfloat,\t/* single-precision floating-point numbers */\n  Knumber,\t/* Lua \"native\" floating-point numbers */\n  Kdouble,\t/* double-precision floating-point numbers */\n  Kchar,\t/* fixed-length strings */\n  Kstring,\t/* strings with prefixed length */\n  Kzstr,\t/* zero-terminated strings */\n  Kpadding,\t/* padding */\n  Kpaddalign,\t/* padding for alignment */\n  Knop\t\t/* no-op (configuration or spaces) */\n} KOption;\n\n\n/*\n** Read an integer numeral from string 'fmt' or return 'df' if\n** there is no numeral\n*/\nstatic int digit (int c) { return '0' <= c && c <= '9'; }\n\nstatic int getnum (const char **fmt, int df) {\n  if (!digit(**fmt))  /* no number? */\n    return df;  /* return default value */\n  else {\n    int a = 0;\n    do {\n      a = a*10 + (*((*fmt)++) - '0');\n    } while (digit(**fmt) && a <= ((int)MAXSIZE - 9)/10);\n    return a;\n  }\n}\n\n\n/*\n** Read an integer numeral and raises an error if it is larger\n** than the maximum size for integers.\n*/\nstatic int getnumlimit (Header *h, const char **fmt, int df) {\n  int sz = getnum(fmt, df);\n  if (l_unlikely(sz > MAXINTSIZE || sz <= 0))\n    return luaL_error(h->L, \"integral size (%d) out of limits [1,%d]\",\n                            sz, MAXINTSIZE);\n  return sz;\n}\n\n\n/*\n** Initialize Header\n*/\nstatic void initheader (lua_State *L, Header *h) {\n  h->L = L;\n  h->islittle = nativeendian.little;\n  h->maxalign = 1;\n}\n\n\n/*\n** Read and classify next option. 'size' is filled with option's size.\n*/\nstatic KOption getoption (Header *h, const char **fmt, int *size) {\n  /* dummy structure to get native alignment requirements */\n  struct cD { char c; union { LUAI_MAXALIGN; } u; };\n  int opt = *((*fmt)++);\n  *size = 0;  /* default */\n  switch (opt) {\n    case 'b': *size = sizeof(char); return Kint;\n    case 'B': *size = sizeof(char); return Kuint;\n    case 'h': *size = sizeof(short); return Kint;\n    case 'H': *size = sizeof(short); return Kuint;\n    case 'l': *size = sizeof(long); return Kint;\n    case 'L': *size = sizeof(long); return Kuint;\n    case 'j': *size = sizeof(lua_Integer); return Kint;\n    case 'J': *size = sizeof(lua_Integer); return Kuint;\n    case 'T': *size = sizeof(size_t); return Kuint;\n    case 'f': *size = sizeof(float); return Kfloat;\n    case 'n': *size = sizeof(lua_Number); return Knumber;\n    case 'd': *size = sizeof(double); return Kdouble;\n    case 'i': *size = getnumlimit(h, fmt, sizeof(int)); return Kint;\n    case 'I': *size = getnumlimit(h, fmt, sizeof(int)); return Kuint;\n    case 's': *size = getnumlimit(h, fmt, sizeof(size_t)); return Kstring;\n    case 'c':\n      *size = getnum(fmt, -1);\n      if (l_unlikely(*size == -1))\n        luaL_error(h->L, \"missing size for format option 'c'\");\n      return Kchar;\n    case 'z': return Kzstr;\n    case 'x': *size = 1; return Kpadding;\n    case 'X': return Kpaddalign;\n    case ' ': break;\n    case '<': h->islittle = 1; break;\n    case '>': h->islittle = 0; break;\n    case '=': h->islittle = nativeendian.little; break;\n    case '!': {\n      const int maxalign = offsetof(struct cD, u);\n      h->maxalign = getnumlimit(h, fmt, maxalign);\n      break;\n    }\n    default: luaL_error(h->L, \"invalid format option '%c'\", opt);\n  }\n  return Knop;\n}\n\n\n/*\n** Read, classify, and fill other details about the next option.\n** 'psize' is filled with option's size, 'notoalign' with its\n** alignment requirements.\n** Local variable 'size' gets the size to be aligned. (Kpadal option\n** always gets its full alignment, other options are limited by\n** the maximum alignment ('maxalign'). Kchar option needs no alignment\n** despite its size.\n*/\nstatic KOption getdetails (Header *h, size_t totalsize,\n                           const char **fmt, int *psize, int *ntoalign) {\n  KOption opt = getoption(h, fmt, psize);\n  int align = *psize;  /* usually, alignment follows size */\n  if (opt == Kpaddalign) {  /* 'X' gets alignment from following option */\n    if (**fmt == '\\0' || getoption(h, fmt, &align) == Kchar || align == 0)\n      luaL_argerror(h->L, 1, \"invalid next option for option 'X'\");\n  }\n  if (align <= 1 || opt == Kchar)  /* need no alignment? */\n    *ntoalign = 0;\n  else {\n    if (align > h->maxalign)  /* enforce maximum alignment */\n      align = h->maxalign;\n    if (l_unlikely((align & (align - 1)) != 0))  /* not a power of 2? */\n      luaL_argerror(h->L, 1, \"format asks for alignment not power of 2\");\n    *ntoalign = (align - (int)(totalsize & (align - 1))) & (align - 1);\n  }\n  return opt;\n}\n\n\n/*\n** Pack integer 'n' with 'size' bytes and 'islittle' endianness.\n** The final 'if' handles the case when 'size' is larger than\n** the size of a Lua integer, correcting the extra sign-extension\n** bytes if necessary (by default they would be zeros).\n*/\nstatic void packint (luaL_Buffer *b, lua_Unsigned n,\n                     int islittle, int size, int neg) {\n  char *buff = luaL_prepbuffsize(b, size);\n  int i;\n  buff[islittle ? 0 : size - 1] = (char)(n & MC);  /* first byte */\n  for (i = 1; i < size; i++) {\n    n >>= NB;\n    buff[islittle ? i : size - 1 - i] = (char)(n & MC);\n  }\n  if (neg && size > SZINT) {  /* negative number need sign extension? */\n    for (i = SZINT; i < size; i++)  /* correct extra bytes */\n      buff[islittle ? i : size - 1 - i] = (char)MC;\n  }\n  luaL_addsize(b, size);  /* add result to buffer */\n}\n\n\n/*\n** Copy 'size' bytes from 'src' to 'dest', correcting endianness if\n** given 'islittle' is different from native endianness.\n*/\nstatic void copywithendian (char *dest, const char *src,\n                            int size, int islittle) {\n  if (islittle == nativeendian.little)\n    memcpy(dest, src, size);\n  else {\n    dest += size - 1;\n    while (size-- != 0)\n      *(dest--) = *(src++);\n  }\n}\n\n\nstatic int str_pack (lua_State *L) {\n  luaL_Buffer b;\n  Header h;\n  const char *fmt = luaL_checkstring(L, 1);  /* format string */\n  int arg = 1;  /* current argument to pack */\n  size_t totalsize = 0;  /* accumulate total size of result */\n  initheader(L, &h);\n  lua_pushnil(L);  /* mark to separate arguments from string buffer */\n  luaL_buffinit(L, &b);\n  while (*fmt != '\\0') {\n    int size, ntoalign;\n    KOption opt = getdetails(&h, totalsize, &fmt, &size, &ntoalign);\n    totalsize += ntoalign + size;\n    while (ntoalign-- > 0)\n     luaL_addchar(&b, LUAL_PACKPADBYTE);  /* fill alignment */\n    arg++;\n    switch (opt) {\n      case Kint: {  /* signed integers */\n        lua_Integer n = luaL_checkinteger(L, arg);\n        if (size < SZINT) {  /* need overflow check? */\n          lua_Integer lim = (lua_Integer)1 << ((size * NB) - 1);\n          luaL_argcheck(L, -lim <= n && n < lim, arg, \"integer overflow\");\n        }\n        packint(&b, (lua_Unsigned)n, h.islittle, size, (n < 0));\n        break;\n      }\n      case Kuint: {  /* unsigned integers */\n        lua_Integer n = luaL_checkinteger(L, arg);\n        if (size < SZINT)  /* need overflow check? */\n          luaL_argcheck(L, (lua_Unsigned)n < ((lua_Unsigned)1 << (size * NB)),\n                           arg, \"unsigned overflow\");\n        packint(&b, (lua_Unsigned)n, h.islittle, size, 0);\n        break;\n      }\n      case Kfloat: {  /* C float */\n        float f = (float)luaL_checknumber(L, arg);  /* get argument */\n        char *buff = luaL_prepbuffsize(&b, sizeof(f));\n        /* move 'f' to final result, correcting endianness if needed */\n        copywithendian(buff, (char *)&f, sizeof(f), h.islittle);\n        luaL_addsize(&b, size);\n        break;\n      }\n      case Knumber: {  /* Lua float */\n        lua_Number f = luaL_checknumber(L, arg);  /* get argument */\n        char *buff = luaL_prepbuffsize(&b, sizeof(f));\n        /* move 'f' to final result, correcting endianness if needed */\n        copywithendian(buff, (char *)&f, sizeof(f), h.islittle);\n        luaL_addsize(&b, size);\n        break;\n      }\n      case Kdouble: {  /* C double */\n        double f = (double)luaL_checknumber(L, arg);  /* get argument */\n        char *buff = luaL_prepbuffsize(&b, sizeof(f));\n        /* move 'f' to final result, correcting endianness if needed */\n        copywithendian(buff, (char *)&f, sizeof(f), h.islittle);\n        luaL_addsize(&b, size);\n        break;\n      }\n      case Kchar: {  /* fixed-size string */\n        size_t len;\n        const char *s = luaL_checklstring(L, arg, &len);\n        luaL_argcheck(L, len <= (size_t)size, arg,\n                         \"string longer than given size\");\n        luaL_addlstring(&b, s, len);  /* add string */\n        while (len++ < (size_t)size)  /* pad extra space */\n          luaL_addchar(&b, LUAL_PACKPADBYTE);\n        break;\n      }\n      case Kstring: {  /* strings with length count */\n        size_t len;\n        const char *s = luaL_checklstring(L, arg, &len);\n        luaL_argcheck(L, size >= (int)sizeof(size_t) ||\n                         len < ((size_t)1 << (size * NB)),\n                         arg, \"string length does not fit in given size\");\n        packint(&b, (lua_Unsigned)len, h.islittle, size, 0);  /* pack length */\n        luaL_addlstring(&b, s, len);\n        totalsize += len;\n        break;\n      }\n      case Kzstr: {  /* zero-terminated string */\n        size_t len;\n        const char *s = luaL_checklstring(L, arg, &len);\n        luaL_argcheck(L, strlen(s) == len, arg, \"string contains zeros\");\n        luaL_addlstring(&b, s, len);\n        luaL_addchar(&b, '\\0');  /* add zero at the end */\n        totalsize += len + 1;\n        break;\n      }\n      case Kpadding: luaL_addchar(&b, LUAL_PACKPADBYTE);  /* FALLTHROUGH */\n      case Kpaddalign: case Knop:\n        arg--;  /* undo increment */\n        break;\n    }\n  }\n  luaL_pushresult(&b);\n  return 1;\n}\n\n\nstatic int str_packsize (lua_State *L) {\n  Header h;\n  const char *fmt = luaL_checkstring(L, 1);  /* format string */\n  size_t totalsize = 0;  /* accumulate total size of result */\n  initheader(L, &h);\n  while (*fmt != '\\0') {\n    int size, ntoalign;\n    KOption opt = getdetails(&h, totalsize, &fmt, &size, &ntoalign);\n    luaL_argcheck(L, opt != Kstring && opt != Kzstr, 1,\n                     \"variable-length format\");\n    size += ntoalign;  /* total space used by option */\n    luaL_argcheck(L, totalsize <= MAXSIZE - size, 1,\n                     \"format result too large\");\n    totalsize += size;\n  }\n  lua_pushinteger(L, (lua_Integer)totalsize);\n  return 1;\n}\n\n\n/*\n** Unpack an integer with 'size' bytes and 'islittle' endianness.\n** If size is smaller than the size of a Lua integer and integer\n** is signed, must do sign extension (propagating the sign to the\n** higher bits); if size is larger than the size of a Lua integer,\n** it must check the unread bytes to see whether they do not cause an\n** overflow.\n*/\nstatic lua_Integer unpackint (lua_State *L, const char *str,\n                              int islittle, int size, int issigned) {\n  lua_Unsigned res = 0;\n  int i;\n  int limit = (size  <= SZINT) ? size : SZINT;\n  for (i = limit - 1; i >= 0; i--) {\n    res <<= NB;\n    res |= (lua_Unsigned)(unsigned char)str[islittle ? i : size - 1 - i];\n  }\n  if (size < SZINT) {  /* real size smaller than lua_Integer? */\n    if (issigned) {  /* needs sign extension? */\n      lua_Unsigned mask = (lua_Unsigned)1 << (size*NB - 1);\n      res = ((res ^ mask) - mask);  /* do sign extension */\n    }\n  }\n  else if (size > SZINT) {  /* must check unread bytes */\n    int mask = (!issigned || (lua_Integer)res >= 0) ? 0 : MC;\n    for (i = limit; i < size; i++) {\n      if (l_unlikely((unsigned char)str[islittle ? i : size - 1 - i] != mask))\n        luaL_error(L, \"%d-byte integer does not fit into Lua Integer\", size);\n    }\n  }\n  return (lua_Integer)res;\n}\n\n\nstatic int str_unpack (lua_State *L) {\n  Header h;\n  const char *fmt = luaL_checkstring(L, 1);\n  size_t ld;\n  const char *data = luaL_checklstring(L, 2, &ld);\n  size_t pos = posrelatI(luaL_optinteger(L, 3, 1), ld) - 1;\n  int n = 0;  /* number of results */\n  luaL_argcheck(L, pos <= ld, 3, \"initial position out of string\");\n  initheader(L, &h);\n  while (*fmt != '\\0') {\n    int size, ntoalign;\n    KOption opt = getdetails(&h, pos, &fmt, &size, &ntoalign);\n    luaL_argcheck(L, (size_t)ntoalign + size <= ld - pos, 2,\n                    \"data string too short\");\n    pos += ntoalign;  /* skip alignment */\n    /* stack space for item + next position */\n    luaL_checkstack(L, 2, \"too many results\");\n    n++;\n    switch (opt) {\n      case Kint:\n      case Kuint: {\n        lua_Integer res = unpackint(L, data + pos, h.islittle, size,\n                                       (opt == Kint));\n        lua_pushinteger(L, res);\n        break;\n      }\n      case Kfloat: {\n        float f;\n        copywithendian((char *)&f, data + pos, sizeof(f), h.islittle);\n        lua_pushnumber(L, (lua_Number)f);\n        break;\n      }\n      case Knumber: {\n        lua_Number f;\n        copywithendian((char *)&f, data + pos, sizeof(f), h.islittle);\n        lua_pushnumber(L, f);\n        break;\n      }\n      case Kdouble: {\n        double f;\n        copywithendian((char *)&f, data + pos, sizeof(f), h.islittle);\n        lua_pushnumber(L, (lua_Number)f);\n        break;\n      }\n      case Kchar: {\n        lua_pushlstring(L, data + pos, size);\n        break;\n      }\n      case Kstring: {\n        size_t len = (size_t)unpackint(L, data + pos, h.islittle, size, 0);\n        luaL_argcheck(L, len <= ld - pos - size, 2, \"data string too short\");\n        lua_pushlstring(L, data + pos + size, len);\n        pos += len;  /* skip string */\n        break;\n      }\n      case Kzstr: {\n        size_t len = strlen(data + pos);\n        luaL_argcheck(L, pos + len < ld, 2,\n                         \"unfinished string for format 'z'\");\n        lua_pushlstring(L, data + pos, len);\n        pos += len + 1;  /* skip string plus final '\\0' */\n        break;\n      }\n      case Kpaddalign: case Kpadding: case Knop:\n        n--;  /* undo increment */\n        break;\n    }\n    pos += size;\n  }\n  lua_pushinteger(L, pos + 1);  /* next position */\n  return n + 1;\n}\n\n/* }====================================================== */\n\n\nstatic const luaL_Reg strlib[] = {\n  {\"byte\", str_byte},\n  {\"char\", str_char},\n  {\"dump\", str_dump},\n  {\"find\", str_find},\n  {\"format\", str_format},\n  {\"gmatch\", gmatch},\n  {\"gsub\", str_gsub},\n  {\"len\", str_len},\n  {\"lower\", str_lower},\n  {\"match\", str_match},\n  {\"rep\", str_rep},\n  {\"reverse\", str_reverse},\n  {\"sub\", str_sub},\n  {\"upper\", str_upper},\n  {\"pack\", str_pack},\n  {\"packsize\", str_packsize},\n  {\"unpack\", str_unpack},\n  {NULL, NULL}\n};\n\n\nstatic void createmetatable (lua_State *L) {\n  /* table to be metatable for strings */\n  luaL_newlibtable(L, stringmetamethods);\n  luaL_setfuncs(L, stringmetamethods, 0);\n  lua_pushliteral(L, \"\");  /* dummy string */\n  lua_pushvalue(L, -2);  /* copy table */\n  lua_setmetatable(L, -2);  /* set table as metatable for strings */\n  lua_pop(L, 1);  /* pop dummy string */\n  lua_pushvalue(L, -2);  /* get string library */\n  lua_setfield(L, -2, \"__index\");  /* metatable.__index = string */\n  lua_pop(L, 1);  /* pop metatable */\n}\n\n\n/*\n** Open string library\n*/\nLUAMOD_API int luaopen_string (lua_State *L) {\n  luaL_newlib(L, strlib);\n  createmetatable(L);\n  return 1;\n}\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/ltable.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: ltable.c $\n** Lua tables (hash)\n** See Copyright Notice in lua.h\n*/\n\n#define ltable_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n/*\n** Implementation of tables (aka arrays, objects, or hash tables).\n** Tables keep its elements in two parts: an array part and a hash part.\n** Non-negative integer keys are all candidates to be kept in the array\n** part. The actual size of the array is the largest 'n' such that\n** more than half the slots between 1 and n are in use.\n** Hash uses a mix of chained scatter table with Brent's variation.\n** A main invariant of these tables is that, if an element is not\n** in its main position (i.e. the 'original' position that its hash gives\n** to it), then the colliding element is in its own main position.\n** Hence even when the load factor reaches 100%, performance remains good.\n*/\n\n#include <math.h>\n#include <limits.h>\n\n#include \"lua.h\"\n\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"lvm.h\"\n\n\n/*\n** Only tables with hash parts larger than 2^LIMFORLAST has a 'lastfree'\n** field that optimizes finding a free slot. That field is stored just\n** before the array of nodes, in the same block. Smaller tables do a\n** complete search when looking for a free slot.\n*/\n#define LIMFORLAST    2  /* log2 of real limit */\n\n/*\n** The union 'Limbox' stores 'lastfree' and ensures that what follows it\n** is properly aligned to store a Node.\n*/\ntypedef struct { Node *dummy; Node follows_pNode; } Limbox_aux;\n\ntypedef union {\n  Node *lastfree;\n  char padding[offsetof(Limbox_aux, follows_pNode)];\n} Limbox;\n\n#define haslastfree(t)     ((t)->lsizenode > LIMFORLAST)\n#define getlastfree(t)     ((cast(Limbox *, (t)->node) - 1)->lastfree)\n\n\n/*\n** MAXABITS is the largest integer such that 2^MAXABITS fits in an\n** unsigned int.\n*/\n#define MAXABITS\tcast_int(sizeof(int) * CHAR_BIT - 1)\n\n\n/*\n** MAXASIZEB is the maximum number of elements in the array part such\n** that the size of the array fits in 'size_t'.\n*/\n#define MAXASIZEB\t((MAX_SIZET/sizeof(ArrayCell)) * NM)\n\n\n/*\n** MAXASIZE is the maximum size of the array part. It is the minimum\n** between 2^MAXABITS and MAXASIZEB.\n*/\n#define MAXASIZE  \\\n    (((1u << MAXABITS) < MAXASIZEB) ? (1u << MAXABITS) : cast_uint(MAXASIZEB))\n\n/*\n** MAXHBITS is the largest integer such that 2^MAXHBITS fits in a\n** signed int.\n*/\n#define MAXHBITS\t(MAXABITS - 1)\n\n\n/*\n** MAXHSIZE is the maximum size of the hash part. It is the minimum\n** between 2^MAXHBITS and the maximum size such that, measured in bytes,\n** it fits in a 'size_t'.\n*/\n#define MAXHSIZE\tluaM_limitN(1u << MAXHBITS, Node)\n\n\n/*\n** When the original hash value is good, hashing by a power of 2\n** avoids the cost of '%'.\n*/\n#define hashpow2(t,n)\t\t(gnode(t, lmod((n), sizenode(t))))\n\n/*\n** for other types, it is better to avoid modulo by power of 2, as\n** they can have many 2 factors.\n*/\n#define hashmod(t,n)\t(gnode(t, ((n) % ((sizenode(t)-1)|1))))\n\n\n#define hashstr(t,str)\t\thashpow2(t, (str)->hash)\n#define hashboolean(t,p)\thashpow2(t, p)\n\n\n#define hashpointer(t,p)\thashmod(t, point2uint(p))\n\n\n#define dummynode\t\t(&dummynode_)\n\nstatic const Node dummynode_ = {\n  {{NULL}, LUA_VEMPTY,  /* value's value and type */\n   LUA_VNIL, 0, {NULL}}  /* key type, next, and key value */\n};\n\n\nstatic const TValue absentkey = {ABSTKEYCONSTANT};\n\n\n/*\n** Hash for integers. To allow a good hash, use the remainder operator\n** ('%'). If integer fits as a non-negative int, compute an int\n** remainder, which is faster. Otherwise, use an unsigned-integer\n** remainder, which uses all bits and ensures a non-negative result.\n*/\nstatic Node *hashint (const Table *t, lua_Integer i) {\n  lua_Unsigned ui = l_castS2U(i);\n  if (ui <= cast_uint(INT_MAX))\n    return hashmod(t, cast_int(ui));\n  else\n    return hashmod(t, ui);\n}\n\n\n/*\n** Hash for floating-point numbers.\n** The main computation should be just\n**     n = frexp(n, &i); return (n * INT_MAX) + i\n** but there are some numerical subtleties.\n** In a two-complement representation, INT_MAX does not has an exact\n** representation as a float, but INT_MIN does; because the absolute\n** value of 'frexp' is smaller than 1 (unless 'n' is inf/NaN), the\n** absolute value of the product 'frexp * -INT_MIN' is smaller or equal\n** to INT_MAX. Next, the use of 'unsigned int' avoids overflows when\n** adding 'i'; the use of '~u' (instead of '-u') avoids problems with\n** INT_MIN.\n*/\n#if !defined(l_hashfloat)\nstatic int l_hashfloat (lua_Number n) {\n  int i;\n  lua_Integer ni;\n  n = l_mathop(frexp)(n, &i) * -cast_num(INT_MIN);\n  if (!lua_numbertointeger(n, &ni)) {  /* is 'n' inf/-inf/NaN? */\n    lua_assert(luai_numisnan(n) || l_mathop(fabs)(n) == cast_num(HUGE_VAL));\n    return 0;\n  }\n  else {  /* normal case */\n    unsigned int u = cast_uint(i) + cast_uint(ni);\n    return cast_int(u <= cast_uint(INT_MAX) ? u : ~u);\n  }\n}\n#endif\n\n\n/*\n** returns the 'main' position of an element in a table (that is,\n** the index of its hash value).\n*/\nstatic Node *mainpositionTV (const Table *t, const TValue *key) {\n  switch (ttypetag(key)) {\n    case LUA_VNUMINT: {\n      lua_Integer i = ivalue(key);\n      return hashint(t, i);\n    }\n    case LUA_VNUMFLT: {\n      lua_Number n = fltvalue(key);\n      return hashmod(t, l_hashfloat(n));\n    }\n    case LUA_VSHRSTR: {\n      TString *ts = tsvalue(key);\n      return hashstr(t, ts);\n    }\n    case LUA_VLNGSTR: {\n      TString *ts = tsvalue(key);\n      return hashpow2(t, luaS_hashlongstr(ts));\n    }\n    case LUA_VFALSE:\n      return hashboolean(t, 0);\n    case LUA_VTRUE:\n      return hashboolean(t, 1);\n    case LUA_VLIGHTUSERDATA: {\n      void *p = pvalue(key);\n      return hashpointer(t, p);\n    }\n    case LUA_VLCF: {\n      lua_CFunction f = fvalue(key);\n      return hashpointer(t, f);\n    }\n    default: {\n      GCObject *o = gcvalue(key);\n      return hashpointer(t, o);\n    }\n  }\n}\n\n\nl_sinline Node *mainpositionfromnode (const Table *t, Node *nd) {\n  TValue key;\n  getnodekey(cast(lua_State *, NULL), &key, nd);\n  return mainpositionTV(t, &key);\n}\n\n\n/*\n** Check whether key 'k1' is equal to the key in node 'n2'. This\n** equality is raw, so there are no metamethods. Floats with integer\n** values have been normalized, so integers cannot be equal to\n** floats. It is assumed that 'eqshrstr' is simply pointer equality, so\n** that short strings are handled in the default case.\n** A true 'deadok' means to accept dead keys as equal to their original\n** values. All dead keys are compared in the default case, by pointer\n** identity. (Only collectable objects can produce dead keys.) Note that\n** dead long strings are also compared by identity.\n** Once a key is dead, its corresponding value may be collected, and\n** then another value can be created with the same address. If this\n** other value is given to 'next', 'equalkey' will signal a false\n** positive. In a regular traversal, this situation should never happen,\n** as all keys given to 'next' came from the table itself, and therefore\n** could not have been collected. Outside a regular traversal, we\n** have garbage in, garbage out. What is relevant is that this false\n** positive does not break anything.  (In particular, 'next' will return\n** some other valid item on the table or nil.)\n*/\nstatic int equalkey (const TValue *k1, const Node *n2, int deadok) {\n  if ((rawtt(k1) != keytt(n2)) &&  /* not the same variants? */\n       !(deadok && keyisdead(n2) && iscollectable(k1)))\n   return 0;  /* cannot be same key */\n  switch (keytt(n2)) {\n    case LUA_VNIL: case LUA_VFALSE: case LUA_VTRUE:\n      return 1;\n    case LUA_VNUMINT:\n      return (ivalue(k1) == keyival(n2));\n    case LUA_VNUMFLT:\n      return luai_numeq(fltvalue(k1), fltvalueraw(keyval(n2)));\n    case LUA_VLIGHTUSERDATA:\n      return pvalue(k1) == pvalueraw(keyval(n2));\n    case LUA_VLCF:\n      return fvalue(k1) == fvalueraw(keyval(n2));\n    case ctb(LUA_VLNGSTR):\n      return luaS_eqlngstr(tsvalue(k1), keystrval(n2));\n    default:\n      return gcvalue(k1) == gcvalueraw(keyval(n2));\n  }\n}\n\n\n/*\n** True if value of 'alimit' is equal to the real size of the array\n** part of table 't'. (Otherwise, the array part must be larger than\n** 'alimit'.)\n*/\n#define limitequalsasize(t)\t(isrealasize(t) || ispow2((t)->alimit))\n\n\n/*\n** Returns the real size of the 'array' array\n*/\nLUAI_FUNC unsigned int luaH_realasize (const Table *t) {\n  if (limitequalsasize(t))\n    return t->alimit;  /* this is the size */\n  else {\n    unsigned int size = t->alimit;\n    /* compute the smallest power of 2 not smaller than 'size' */\n    size |= (size >> 1);\n    size |= (size >> 2);\n    size |= (size >> 4);\n    size |= (size >> 8);\n#if (UINT_MAX >> 14) > 3  /* unsigned int has more than 16 bits */\n    size |= (size >> 16);\n#if (UINT_MAX >> 30) > 3\n    size |= (size >> 32);  /* unsigned int has more than 32 bits */\n#endif\n#endif\n    size++;\n    lua_assert(ispow2(size) && size/2 < t->alimit && t->alimit < size);\n    return size;\n  }\n}\n\n\n/*\n** Check whether real size of the array is a power of 2.\n** (If it is not, 'alimit' cannot be changed to any other value\n** without changing the real size.)\n*/\nstatic int ispow2realasize (const Table *t) {\n  return (!isrealasize(t) || ispow2(t->alimit));\n}\n\n\nstatic unsigned int setlimittosize (Table *t) {\n  t->alimit = luaH_realasize(t);\n  setrealasize(t);\n  return t->alimit;\n}\n\n\n#define limitasasize(t)\tcheck_exp(isrealasize(t), t->alimit)\n\n\n\n/*\n** \"Generic\" get version. (Not that generic: not valid for integers,\n** which may be in array part, nor for floats with integral values.)\n** See explanation about 'deadok' in function 'equalkey'.\n*/\nstatic const TValue *getgeneric (Table *t, const TValue *key, int deadok) {\n  Node *n = mainpositionTV(t, key);\n  for (;;) {  /* check whether 'key' is somewhere in the chain */\n    if (equalkey(key, n, deadok))\n      return gval(n);  /* that's it */\n    else {\n      int nx = gnext(n);\n      if (nx == 0)\n        return &absentkey;  /* not found */\n      n += nx;\n    }\n  }\n}\n\n\n/*\n** returns the index for 'k' if 'k' is an appropriate key to live in\n** the array part of a table, 0 otherwise.\n*/\nstatic unsigned int arrayindex (lua_Integer k) {\n  if (l_castS2U(k) - 1u < MAXASIZE)  /* 'k' in [1, MAXASIZE]? */\n    return cast_uint(k);  /* 'key' is an appropriate array index */\n  else\n    return 0;\n}\n\n\n/*\n** returns the index of a 'key' for table traversals. First goes all\n** elements in the array part, then elements in the hash part. The\n** beginning of a traversal is signaled by 0.\n*/\nstatic unsigned findindex (lua_State *L, Table *t, TValue *key,\n                               unsigned asize) {\n  unsigned int i;\n  if (ttisnil(key)) return 0;  /* first iteration */\n  i = ttisinteger(key) ? arrayindex(ivalue(key)) : 0;\n  if (i - 1u < asize)  /* is 'key' inside array part? */\n    return i;  /* yes; that's the index */\n  else {\n    const TValue *n = getgeneric(t, key, 1);\n    if (l_unlikely(isabstkey(n)))\n      luaG_runerror(L, \"invalid key to 'next'\");  /* key not found */\n    i = cast_int(nodefromval(n) - gnode(t, 0));  /* key index in hash table */\n    /* hash elements are numbered after array ones */\n    return (i + 1) + asize;\n  }\n}\n\n\nint luaH_next (lua_State *L, Table *t, StkId key) {\n  unsigned int asize = luaH_realasize(t);\n  unsigned int i = findindex(L, t, s2v(key), asize);  /* find original key */\n  for (; i < asize; i++) {  /* try first array part */\n    int tag = *getArrTag(t, i);\n    if (!tagisempty(tag)) {  /* a non-empty entry? */\n      setivalue(s2v(key), i + 1);\n      farr2val(t, i + 1, tag, s2v(key + 1));\n      return 1;\n    }\n  }\n  for (i -= asize; cast_int(i) < sizenode(t); i++) {  /* hash part */\n    if (!isempty(gval(gnode(t, i)))) {  /* a non-empty entry? */\n      Node *n = gnode(t, i);\n      getnodekey(L, s2v(key), n);\n      setobj2s(L, key + 1, gval(n));\n      return 1;\n    }\n  }\n  return 0;  /* no more elements */\n}\n\n\nstatic void freehash (lua_State *L, Table *t) {\n  if (!isdummy(t)) {\n    size_t bsize = sizenode(t) * sizeof(Node);  /* 'node' size in bytes */\n    char *arr = cast_charp(t->node);\n    if (haslastfree(t)) {\n      bsize += sizeof(Limbox);\n      arr -= sizeof(Limbox);\n    }\n    luaM_freearray(L, arr, bsize);\n  }\n}\n\n\n/*\n** Check whether an integer key is in the array part. If 'alimit' is\n** not the real size of the array, the key still can be in the array\n** part.  In this case, do the \"Xmilia trick\" to check whether 'key-1'\n** is smaller than the real size.\n** The trick works as follow: let 'p' be the integer such that\n** '2^(p+1) >= alimit > 2^p', or '2^(p+1) > alimit-1 >= 2^p'.  That is,\n** 'p' is the highest 1-bit in 'alimit-1', and 2^(p+1) is the real size\n** of the array. What we have to check becomes 'key-1 < 2^(p+1)'.  We\n** compute '(key-1) & ~(alimit-1)', which we call 'res'; it will have\n** the 'p' bit cleared. (It may also clear other bits smaller than 'p',\n** but no bit higher than 'p'.) If the key is outside the array, that\n** is, 'key-1 >= 2^(p+1)', then 'res' will have some 1-bit higher than\n** 'p', therefore it will be larger or equal to 'alimit', and the check\n** will fail. If 'key-1 < 2^(p+1)', then 'res' has no 1-bit higher than\n** 'p', and as the bit 'p' itself was cleared, 'res' will be smaller\n** than 2^p, therefore smaller than 'alimit', and the check succeeds.\n** As special cases, when 'alimit' is 0 the condition is trivially false,\n** and when 'alimit' is 1 the condition simplifies to 'key-1 < alimit'.\n** If key is 0 or negative, 'res' will have its higher bit on, so that\n** it cannot be smaller than 'alimit'.\n*/\nstatic int keyinarray (Table *t, lua_Integer key) {\n  lua_Unsigned alimit = t->alimit;\n  if (l_castS2U(key) - 1u < alimit)  /* 'key' in [1, t->alimit]? */\n    return 1;\n  else if (!isrealasize(t) &&  /* key still may be in the array part? */\n           (((l_castS2U(key) - 1u) & ~(alimit - 1u)) < alimit)) {\n    t->alimit = cast_uint(key);  /* probably '#t' is here now */\n    return 1;\n  }\n  else\n    return 0;\n}\n\n\n/*\n** {=============================================================\n** Rehash\n** ==============================================================\n*/\n\n/*\n** Compute the optimal size for the array part of table 't'. 'nums' is a\n** \"count array\" where 'nums[i]' is the number of integers in the table\n** between 2^(i - 1) + 1 and 2^i. 'pna' enters with the total number of\n** integer keys in the table and leaves with the number of keys that\n** will go to the array part; return the optimal size.  (The condition\n** 'twotoi > 0' in the for loop stops the loop if 'twotoi' overflows.)\n*/\nstatic unsigned computesizes (unsigned nums[], unsigned *pna) {\n  int i;\n  unsigned int twotoi;  /* 2^i (candidate for optimal size) */\n  unsigned int a = 0;  /* number of elements smaller than 2^i */\n  unsigned int na = 0;  /* number of elements to go to array part */\n  unsigned int optimal = 0;  /* optimal size for array part */\n  /* loop while keys can fill more than half of total size */\n  for (i = 0, twotoi = 1;\n       twotoi > 0 && *pna > twotoi / 2;\n       i++, twotoi *= 2) {\n    a += nums[i];\n    if (a > twotoi/2) {  /* more than half elements present? */\n      optimal = twotoi;  /* optimal size (till now) */\n      na = a;  /* all elements up to 'optimal' will go to array part */\n    }\n  }\n  lua_assert((optimal == 0 || optimal / 2 < na) && na <= optimal);\n  *pna = na;\n  return optimal;\n}\n\n\nstatic int countint (lua_Integer key, unsigned int *nums) {\n  unsigned int k = arrayindex(key);\n  if (k != 0) {  /* is 'key' an appropriate array index? */\n    nums[luaO_ceillog2(k)]++;  /* count as such */\n    return 1;\n  }\n  else\n    return 0;\n}\n\n\nl_sinline int arraykeyisempty (const Table *t, lua_Integer key) {\n  int tag = *getArrTag(t, key - 1);\n  return tagisempty(tag);\n}\n\n\n/*\n** Count keys in array part of table 't': Fill 'nums[i]' with\n** number of keys that will go into corresponding slice and return\n** total number of non-nil keys.\n*/\nstatic unsigned numusearray (const Table *t, unsigned *nums) {\n  int lg;\n  unsigned int ttlg;  /* 2^lg */\n  unsigned int ause = 0;  /* summation of 'nums' */\n  unsigned int i = 1;  /* count to traverse all array keys */\n  unsigned int asize = limitasasize(t);  /* real array size */\n  /* traverse each slice */\n  for (lg = 0, ttlg = 1; lg <= MAXABITS; lg++, ttlg *= 2) {\n    unsigned int lc = 0;  /* counter */\n    unsigned int lim = ttlg;\n    if (lim > asize) {\n      lim = asize;  /* adjust upper limit */\n      if (i > lim)\n        break;  /* no more elements to count */\n    }\n    /* count elements in range (2^(lg - 1), 2^lg] */\n    for (; i <= lim; i++) {\n      if (!arraykeyisempty(t, i))\n        lc++;\n    }\n    nums[lg] += lc;\n    ause += lc;\n  }\n  return ause;\n}\n\n\nstatic int numusehash (const Table *t, unsigned *nums, unsigned *pna) {\n  int totaluse = 0;  /* total number of elements */\n  int ause = 0;  /* elements added to 'nums' (can go to array part) */\n  int i = sizenode(t);\n  while (i--) {\n    Node *n = &t->node[i];\n    if (!isempty(gval(n))) {\n      if (keyisinteger(n))\n        ause += countint(keyival(n), nums);\n      totaluse++;\n    }\n  }\n  *pna += ause;\n  return totaluse;\n}\n\n\n/*\n** Convert an \"abstract size\" (number of slots in an array) to\n** \"concrete size\" (number of bytes in the array).\n** If the abstract size is not a multiple of NM, the last cell is\n** incomplete, so we don't need to allocate memory for the whole cell.\n** 'extra' computes how many values are not needed in that last cell.\n** It will be zero when 'size' is a multiple of NM, and from there it\n** increases as 'size' decreases, up to (NM - 1).\n*/\nstatic size_t concretesize (unsigned int size) {\n  unsigned int numcells = (size + NM - 1) / NM;   /* (size / NM) rounded up */\n  unsigned int extra = NM - 1 - ((size + NM - 1) % NM);\n  return numcells * sizeof(ArrayCell) - extra * sizeof(Value);\n}\n\n\nstatic ArrayCell *resizearray (lua_State *L , Table *t,\n                               unsigned oldasize,\n                               unsigned newasize) {\n  size_t oldasizeb = concretesize(oldasize);\n  size_t newasizeb = concretesize(newasize);\n  void *a = luaM_reallocvector(L, t->array, oldasizeb, newasizeb, lu_byte);\n  return cast(ArrayCell*, a);\n}\n\n\n/*\n** Creates an array for the hash part of a table with the given\n** size, or reuses the dummy node if size is zero.\n** The computation for size overflow is in two steps: the first\n** comparison ensures that the shift in the second one does not\n** overflow.\n*/\nstatic void setnodevector (lua_State *L, Table *t, unsigned size) {\n  if (size == 0) {  /* no elements to hash part? */\n    t->node = cast(Node *, dummynode);  /* use common 'dummynode' */\n    t->lsizenode = 0;\n    setdummy(t);  /* signal that it is using dummy node */\n  }\n  else {\n    int i;\n    int lsize = luaO_ceillog2(size);\n    if (lsize > MAXHBITS || (1u << lsize) > MAXHSIZE)\n      luaG_runerror(L, \"table overflow\");\n    size = twoto(lsize);\n    if (lsize <= LIMFORLAST)  /* no 'lastfree' field? */\n      t->node = luaM_newvector(L, size, Node);\n    else {\n      size_t bsize = size * sizeof(Node) + sizeof(Limbox);\n      char *node = luaM_newblock(L, bsize);\n      t->node = cast(Node *, node + sizeof(Limbox));\n      getlastfree(t) = gnode(t, size);  /* all positions are free */\n    }\n    t->lsizenode = cast_byte(lsize);\n    setnodummy(t);\n    for (i = 0; i < cast_int(size); i++) {\n      Node *n = gnode(t, i);\n      gnext(n) = 0;\n      setnilkey(n);\n      setempty(gval(n));\n    }\n  }\n}\n\n\n/*\n** (Re)insert all elements from the hash part of 'ot' into table 't'.\n*/\nstatic void reinsert (lua_State *L, Table *ot, Table *t) {\n  int j;\n  int size = sizenode(ot);\n  for (j = 0; j < size; j++) {\n    Node *old = gnode(ot, j);\n    if (!isempty(gval(old))) {\n      /* doesn't need barrier/invalidate cache, as entry was\n         already present in the table */\n      TValue k;\n      getnodekey(L, &k, old);\n      luaH_set(L, t, &k, gval(old));\n    }\n  }\n}\n\n\n/*\n** Exchange the hash part of 't1' and 't2'. (In 'flags', only the\n** dummy bit must be exchanged: The 'isrealasize' is not related\n** to the hash part, and the metamethod bits do not change during\n** a resize, so the \"real\" table can keep their values.)\n*/\nstatic void exchangehashpart (Table *t1, Table *t2) {\n  lu_byte lsizenode = t1->lsizenode;\n  Node *node = t1->node;\n  int bitdummy1 = t1->flags & BITDUMMY;\n  t1->lsizenode = t2->lsizenode;\n  t1->node = t2->node;\n  t1->flags = (t1->flags & NOTBITDUMMY) | (t2->flags & BITDUMMY);\n  t2->lsizenode = lsizenode;\n  t2->node = node;\n  t2->flags = (t2->flags & NOTBITDUMMY) | bitdummy1;\n}\n\n\n/*\n** Re-insert into the new hash part of a table the elements from the\n** vanishing slice of the array part.\n*/\nstatic void reinsertOldSlice (lua_State *L, Table *t, unsigned oldasize,\n                                            unsigned newasize) {\n  unsigned i;\n  t->alimit = newasize;  /* pretend array has new size... */\n  for (i = newasize; i < oldasize; i++) {  /* traverse vanishing slice */\n    int tag = *getArrTag(t, i);\n    if (!tagisempty(tag)) {  /* a non-empty entry? */\n      TValue aux;\n      farr2val(t, i + 1, tag, &aux);  /* copy entry into 'aux' */\n      luaH_setint(L, t, i + 1, &aux);  /* re-insert it into the table */\n    }\n  }\n  t->alimit = oldasize;  /* restore current size... */\n}\n\n\n/*\n** Clear new slice of the array.\n*/\nstatic void clearNewSlice (Table *t, unsigned oldasize, unsigned newasize) {\n  for (; oldasize < newasize; oldasize++)\n    *getArrTag(t, oldasize) = LUA_VEMPTY;\n}\n\n\n/*\n** Resize table 't' for the new given sizes. Both allocations (for\n** the hash part and for the array part) can fail, which creates some\n** subtleties. If the first allocation, for the hash part, fails, an\n** error is raised and that is it. Otherwise, it copies the elements from\n** the shrinking part of the array (if it is shrinking) into the new\n** hash. Then it reallocates the array part.  If that fails, the table\n** is in its original state; the function frees the new hash part and then\n** raises the allocation error. Otherwise, it sets the new hash part\n** into the table, initializes the new part of the array (if any) with\n** nils and reinserts the elements of the old hash back into the new\n** parts of the table.\n*/\nvoid luaH_resize (lua_State *L, Table *t, unsigned newasize,\n                                          unsigned nhsize) {\n  Table newt;  /* to keep the new hash part */\n  unsigned int oldasize = setlimittosize(t);\n  ArrayCell *newarray;\n  if (newasize > MAXASIZE)\n    luaG_runerror(L, \"table overflow\");\n  /* create new hash part with appropriate size into 'newt' */\n  newt.flags = 0;\n  setnodevector(L, &newt, nhsize);\n  if (newasize < oldasize) {  /* will array shrink? */\n    /* re-insert into the new hash the elements from vanishing slice */\n    exchangehashpart(t, &newt);  /* pretend table has new hash */\n    reinsertOldSlice(L, t, oldasize, newasize);\n    exchangehashpart(t, &newt);  /* restore old hash (in case of errors) */\n  }\n  /* allocate new array */\n  newarray = resizearray(L, t, oldasize, newasize);\n  if (l_unlikely(newarray == NULL && newasize > 0)) {  /* allocation failed? */\n    freehash(L, &newt);  /* release new hash part */\n    luaM_error(L);  /* raise error (with array unchanged) */\n  }\n  /* allocation ok; initialize new part of the array */\n  exchangehashpart(t, &newt);  /* 't' has the new hash ('newt' has the old) */\n  t->array = newarray;  /* set new array part */\n  t->alimit = newasize;\n  clearNewSlice(t, oldasize, newasize);\n  /* re-insert elements from old hash part into new parts */\n  reinsert(L, &newt, t);  /* 'newt' now has the old hash */\n  freehash(L, &newt);  /* free old hash part */\n}\n\n\nvoid luaH_resizearray (lua_State *L, Table *t, unsigned int nasize) {\n  int nsize = allocsizenode(t);\n  luaH_resize(L, t, nasize, nsize);\n}\n\n/*\n** nums[i] = number of keys 'k' where 2^(i - 1) < k <= 2^i\n*/\nstatic void rehash (lua_State *L, Table *t, const TValue *ek) {\n  unsigned int asize;  /* optimal size for array part */\n  unsigned int na;  /* number of keys in the array part */\n  unsigned int nums[MAXABITS + 1];\n  int i;\n  int totaluse;\n  for (i = 0; i <= MAXABITS; i++) nums[i] = 0;  /* reset counts */\n  setlimittosize(t);\n  na = numusearray(t, nums);  /* count keys in array part */\n  totaluse = na;  /* all those keys are integer keys */\n  totaluse += numusehash(t, nums, &na);  /* count keys in hash part */\n  /* count extra key */\n  if (ttisinteger(ek))\n    na += countint(ivalue(ek), nums);\n  totaluse++;\n  /* compute new size for array part */\n  asize = computesizes(nums, &na);\n  /* resize the table to new computed sizes */\n  luaH_resize(L, t, asize, totaluse - na);\n}\n\n\n\n/*\n** }=============================================================\n*/\n\n\nTable *luaH_new (lua_State *L) {\n  GCObject *o = luaC_newobj(L, LUA_VTABLE, sizeof(Table));\n  Table *t = gco2t(o);\n  t->metatable = NULL;\n  t->flags = cast_byte(maskflags);  /* table has no metamethod fields */\n  t->array = NULL;\n  t->alimit = 0;\n  setnodevector(L, t, 0);\n  return t;\n}\n\n\n/*\n** Frees a table. The assert ensures the correctness of 'concretesize',\n** checking its result against the address of the last element in the\n** array part of the table, computed abstractly.\n*/\nvoid luaH_free (lua_State *L, Table *t) {\n  unsigned int realsize = luaH_realasize(t);\n  size_t sizeb = concretesize(realsize);\n  lua_assert((sizeb == 0 && realsize == 0) ||\n             cast_charp(t->array) + sizeb - sizeof(Value) ==\n             cast_charp(getArrVal(t, realsize - 1)));\n  freehash(L, t);\n  luaM_freemem(L, t->array, sizeb);\n  luaM_free(L, t);\n}\n\n\nstatic Node *getfreepos (Table *t) {\n  if (haslastfree(t)) {  /* does it have 'lastfree' information? */\n    /* look for a spot before 'lastfree', updating 'lastfree' */\n    while (getlastfree(t) > t->node) {\n      Node *free = --getlastfree(t);\n      if (keyisnil(free))\n        return free;\n    }\n  }\n  else {  /* no 'lastfree' information */\n    if (!isdummy(t)) {\n      int i = sizenode(t);\n      while (i--) {  /* do a linear search */\n        Node *free = gnode(t, i);\n        if (keyisnil(free))\n          return free;\n      }\n    }\n  }\n  return NULL;  /* could not find a free place */\n}\n\n\n\n/*\n** Inserts a new key into a hash table; first, check whether key's main\n** position is free. If not, check whether colliding node is in its main\n** position or not: if it is not, move colliding node to an empty place\n** and put new key in its main position; otherwise (colliding node is in\n** its main position), new key goes to an empty position.\n*/\nstatic void luaH_newkey (lua_State *L, Table *t, const TValue *key,\n                                                 TValue *value) {\n  Node *mp;\n  TValue aux;\n  if (l_unlikely(ttisnil(key)))\n    luaG_runerror(L, \"table index is nil\");\n  else if (ttisfloat(key)) {\n    lua_Number f = fltvalue(key);\n    lua_Integer k;\n    if (luaV_flttointeger(f, &k, F2Ieq)) {  /* does key fit in an integer? */\n      setivalue(&aux, k);\n      key = &aux;  /* insert it as an integer */\n    }\n    else if (l_unlikely(luai_numisnan(f)))\n      luaG_runerror(L, \"table index is NaN\");\n  }\n  if (ttisnil(value))\n    return;  /* do not insert nil values */\n  mp = mainpositionTV(t, key);\n  if (!isempty(gval(mp)) || isdummy(t)) {  /* main position is taken? */\n    Node *othern;\n    Node *f = getfreepos(t);  /* get a free place */\n    if (f == NULL) {  /* cannot find a free place? */\n      rehash(L, t, key);  /* grow table */\n      /* whatever called 'newkey' takes care of TM cache */\n      luaH_set(L, t, key, value);  /* insert key into grown table */\n      return;\n    }\n    lua_assert(!isdummy(t));\n    othern = mainpositionfromnode(t, mp);\n    if (othern != mp) {  /* is colliding node out of its main position? */\n      /* yes; move colliding node into free position */\n      while (othern + gnext(othern) != mp)  /* find previous */\n        othern += gnext(othern);\n      gnext(othern) = cast_int(f - othern);  /* rechain to point to 'f' */\n      *f = *mp;  /* copy colliding node into free pos. (mp->next also goes) */\n      if (gnext(mp) != 0) {\n        gnext(f) += cast_int(mp - f);  /* correct 'next' */\n        gnext(mp) = 0;  /* now 'mp' is free */\n      }\n      setempty(gval(mp));\n    }\n    else {  /* colliding node is in its own main position */\n      /* new node will go into free position */\n      if (gnext(mp) != 0)\n        gnext(f) = cast_int((mp + gnext(mp)) - f);  /* chain new position */\n      else lua_assert(gnext(f) == 0);\n      gnext(mp) = cast_int(f - mp);\n      mp = f;\n    }\n  }\n  setnodekey(L, mp, key);\n  luaC_barrierback(L, obj2gco(t), key);\n  lua_assert(isempty(gval(mp)));\n  setobj2t(L, gval(mp), value);\n}\n\n\nstatic const TValue *getintfromhash (Table *t, lua_Integer key) {\n  Node *n = hashint(t, key);\n  lua_assert(l_castS2U(key) - 1u >= luaH_realasize(t));\n  for (;;) {  /* check whether 'key' is somewhere in the chain */\n    if (keyisinteger(n) && keyival(n) == key)\n      return gval(n);  /* that's it */\n    else {\n      int nx = gnext(n);\n      if (nx == 0) break;\n      n += nx;\n    }\n  }\n  return &absentkey;\n}\n\n\nstatic int hashkeyisempty (Table *t, lua_Integer key) {\n  const TValue *val = getintfromhash(t, key);\n  return isempty(val);\n}\n\n\nstatic int finishnodeget (const TValue *val, TValue *res) {\n  if (!ttisnil(val)) {\n    setobj(((lua_State*)NULL), res, val);\n  }\n  return ttypetag(val);\n}\n\n\nint luaH_getint (Table *t, lua_Integer key, TValue *res) {\n  if (keyinarray(t, key)) {\n    int tag = *getArrTag(t, key - 1);\n    if (!tagisempty(tag))\n      farr2val(t, key, tag, res);\n    return tag;\n  }\n  else\n    return finishnodeget(getintfromhash(t, key), res);\n}\n\n\n/*\n** search function for short strings\n*/\nconst TValue *luaH_Hgetshortstr (Table *t, TString *key) {\n  Node *n = hashstr(t, key);\n  lua_assert(key->tt == LUA_VSHRSTR);\n  for (;;) {  /* check whether 'key' is somewhere in the chain */\n    if (keyisshrstr(n) && eqshrstr(keystrval(n), key))\n      return gval(n);  /* that's it */\n    else {\n      int nx = gnext(n);\n      if (nx == 0)\n        return &absentkey;  /* not found */\n      n += nx;\n    }\n  }\n}\n\n\nint luaH_getshortstr (Table *t, TString *key, TValue *res) {\n  return finishnodeget(luaH_Hgetshortstr(t, key), res);\n}\n\n\nstatic const TValue *Hgetstr (Table *t, TString *key) {\n  if (key->tt == LUA_VSHRSTR)\n    return luaH_Hgetshortstr(t, key);\n  else {  /* for long strings, use generic case */\n    TValue ko;\n    setsvalue(cast(lua_State *, NULL), &ko, key);\n    return getgeneric(t, &ko, 0);\n  }\n}\n\n\nint luaH_getstr (Table *t, TString *key, TValue *res) {\n  return finishnodeget(Hgetstr(t, key), res);\n}\n\n\nTString *luaH_getstrkey (Table *t, TString *key) {\n  const TValue *o = Hgetstr(t, key);\n  if (!isabstkey(o))  /* string already present? */\n    return keystrval(nodefromval(o));  /* get saved copy */\n  else\n    return NULL;\n}\n\n\n/*\n** main search function\n*/\nint luaH_get (Table *t, const TValue *key, TValue *res) {\n  const TValue *slot;\n  switch (ttypetag(key)) {\n    case LUA_VSHRSTR:\n      slot = luaH_Hgetshortstr(t, tsvalue(key));\n      break;\n    case LUA_VNUMINT:\n      return luaH_getint(t, ivalue(key), res);\n    case LUA_VNIL:\n      slot = &absentkey;\n      break;\n    case LUA_VNUMFLT: {\n      lua_Integer k;\n      if (luaV_flttointeger(fltvalue(key), &k, F2Ieq)) /* integral index? */\n        return luaH_getint(t, k, res);  /* use specialized version */\n      /* else... */\n    }  /* FALLTHROUGH */\n    default:\n      slot = getgeneric(t, key, 0);\n      break;\n  }\n  return finishnodeget(slot, res);\n}\n\n\nstatic int finishnodeset (Table *t, const TValue *slot, TValue *val) {\n  if (!ttisnil(slot)) {\n    setobj(((lua_State*)NULL), cast(TValue*, slot), val);\n    return HOK;  /* success */\n  }\n  else if (isabstkey(slot))\n    return HNOTFOUND;  /* no slot with that key */\n  else  /* return node encoded */\n    return cast_int((cast(Node*, slot) - t->node)) + HFIRSTNODE;\n}\n\n\nstatic int rawfinishnodeset (const TValue *slot, TValue *val) {\n  if (isabstkey(slot))\n    return 0;  /* no slot with that key */\n  else {\n    setobj(((lua_State*)NULL), cast(TValue*, slot), val);\n    return 1;  /* success */\n  }\n}\n\n\nint luaH_psetint (Table *t, lua_Integer key, TValue *val) {\n  if (keyinarray(t, key)) {\n    lu_byte *tag = getArrTag(t, key - 1);\n    if (!tagisempty(*tag) || checknoTM(t->metatable, TM_NEWINDEX)) {\n      fval2arr(t, key, tag, val);\n      return HOK;  /* success */\n    }\n    else\n      return ~cast_int(key);  /* empty slot in the array part */\n  }\n  else\n    return finishnodeset(t, getintfromhash(t, key), val);\n}\n\n\nint luaH_psetshortstr (Table *t, TString *key, TValue *val) {\n  return finishnodeset(t, luaH_Hgetshortstr(t, key), val);\n}\n\n\nint luaH_psetstr (Table *t, TString *key, TValue *val) {\n  return finishnodeset(t, Hgetstr(t, key), val);\n}\n\n\nint luaH_pset (Table *t, const TValue *key, TValue *val) {\n  switch (ttypetag(key)) {\n    case LUA_VSHRSTR: return luaH_psetshortstr(t, tsvalue(key), val);\n    case LUA_VNUMINT: return luaH_psetint(t, ivalue(key), val);\n    case LUA_VNIL: return HNOTFOUND;\n    case LUA_VNUMFLT: {\n      lua_Integer k;\n      if (luaV_flttointeger(fltvalue(key), &k, F2Ieq)) /* integral index? */\n        return luaH_psetint(t, k, val);  /* use specialized version */\n      /* else... */\n    }  /* FALLTHROUGH */\n    default:\n      return finishnodeset(t, getgeneric(t, key, 0), val);\n  }\n}\n\n/*\n** Finish a raw \"set table\" operation, where 'slot' is where the value\n** should have been (the result of a previous \"get table\").\n** Beware: when using this function you probably need to check a GC\n** barrier and invalidate the TM cache.\n*/\n\n\nvoid luaH_finishset (lua_State *L, Table *t, const TValue *key,\n                                    TValue *value, int hres) {\n  lua_assert(hres != HOK);\n  if (hres == HNOTFOUND) {\n    luaH_newkey(L, t, key, value);\n  }\n  else if (hres > 0) {  /* regular Node? */\n    setobj2t(L, gval(gnode(t, hres - HFIRSTNODE)), value);\n  }\n  else {  /* array entry */\n    hres = ~hres;  /* real index */\n    obj2arr(t, hres, value);\n  }\n}\n\n\n/*\n** beware: when using this function you probably need to check a GC\n** barrier and invalidate the TM cache.\n*/\nvoid luaH_set (lua_State *L, Table *t, const TValue *key, TValue *value) {\n  int hres = luaH_pset(t, key, value);\n  if (hres != HOK)\n    luaH_finishset(L, t, key, value, hres);\n}\n\n\n/*\n** Ditto for a GC barrier. (No need to invalidate the TM cache, as\n** integers cannot be keys to metamethods.)\n*/\nvoid luaH_setint (lua_State *L, Table *t, lua_Integer key, TValue *value) {\n  if (keyinarray(t, key))\n    obj2arr(t, key, value);\n  else {\n    int ok = rawfinishnodeset(getintfromhash(t, key), value);\n    if (!ok) {\n      TValue k;\n      setivalue(&k, key);\n      luaH_newkey(L, t, &k, value);\n    }\n  }\n}\n\n\n/*\n** Try to find a boundary in the hash part of table 't'. From the\n** caller, we know that 'j' is zero or present and that 'j + 1' is\n** present. We want to find a larger key that is absent from the\n** table, so that we can do a binary search between the two keys to\n** find a boundary. We keep doubling 'j' until we get an absent index.\n** If the doubling would overflow, we try LUA_MAXINTEGER. If it is\n** absent, we are ready for the binary search. ('j', being max integer,\n** is larger or equal to 'i', but it cannot be equal because it is\n** absent while 'i' is present; so 'j > i'.) Otherwise, 'j' is a\n** boundary. ('j + 1' cannot be a present integer key because it is\n** not a valid integer in Lua.)\n*/\nstatic lua_Unsigned hash_search (Table *t, lua_Unsigned j) {\n  lua_Unsigned i;\n  if (j == 0) j++;  /* the caller ensures 'j + 1' is present */\n  do {\n    i = j;  /* 'i' is a present index */\n    if (j <= l_castS2U(LUA_MAXINTEGER) / 2)\n      j *= 2;\n    else {\n      j = LUA_MAXINTEGER;\n      if (hashkeyisempty(t, j))  /* t[j] not present? */\n        break;  /* 'j' now is an absent index */\n      else  /* weird case */\n        return j;  /* well, max integer is a boundary... */\n    }\n  } while (!hashkeyisempty(t, j));  /* repeat until an absent t[j] */\n  /* i < j  &&  t[i] present  &&  t[j] absent */\n  while (j - i > 1u) {  /* do a binary search between them */\n    lua_Unsigned m = (i + j) / 2;\n    if (hashkeyisempty(t, m)) j = m;\n    else i = m;\n  }\n  return i;\n}\n\n\nstatic unsigned int binsearch (Table *array, unsigned int i, unsigned int j) {\n  while (j - i > 1u) {  /* binary search */\n    unsigned int m = (i + j) / 2;\n    if (arraykeyisempty(array, m)) j = m;\n    else i = m;\n  }\n  return i;\n}\n\n\n/*\n** Try to find a boundary in table 't'. (A 'boundary' is an integer index\n** such that t[i] is present and t[i+1] is absent, or 0 if t[1] is absent\n** and 'maxinteger' if t[maxinteger] is present.)\n** (In the next explanation, we use Lua indices, that is, with base 1.\n** The code itself uses base 0 when indexing the array part of the table.)\n** The code starts with 'limit = t->alimit', a position in the array\n** part that may be a boundary.\n**\n** (1) If 't[limit]' is empty, there must be a boundary before it.\n** As a common case (e.g., after 't[#t]=nil'), check whether 'limit-1'\n** is present. If so, it is a boundary. Otherwise, do a binary search\n** between 0 and limit to find a boundary. In both cases, try to\n** use this boundary as the new 'alimit', as a hint for the next call.\n**\n** (2) If 't[limit]' is not empty and the array has more elements\n** after 'limit', try to find a boundary there. Again, try first\n** the special case (which should be quite frequent) where 'limit+1'\n** is empty, so that 'limit' is a boundary. Otherwise, check the\n** last element of the array part. If it is empty, there must be a\n** boundary between the old limit (present) and the last element\n** (absent), which is found with a binary search. (This boundary always\n** can be a new limit.)\n**\n** (3) The last case is when there are no elements in the array part\n** (limit == 0) or its last element (the new limit) is present.\n** In this case, must check the hash part. If there is no hash part\n** or 'limit+1' is absent, 'limit' is a boundary.  Otherwise, call\n** 'hash_search' to find a boundary in the hash part of the table.\n** (In those cases, the boundary is not inside the array part, and\n** therefore cannot be used as a new limit.)\n*/\nlua_Unsigned luaH_getn (Table *t) {\n  unsigned int limit = t->alimit;\n  if (limit > 0 && arraykeyisempty(t, limit)) {  /* (1)? */\n    /* there must be a boundary before 'limit' */\n    if (limit >= 2 && !arraykeyisempty(t, limit - 1)) {\n      /* 'limit - 1' is a boundary; can it be a new limit? */\n      if (ispow2realasize(t) && !ispow2(limit - 1)) {\n        t->alimit = limit - 1;\n        setnorealasize(t);  /* now 'alimit' is not the real size */\n      }\n      return limit - 1;\n    }\n    else {  /* must search for a boundary in [0, limit] */\n      unsigned int boundary = binsearch(t, 0, limit);\n      /* can this boundary represent the real size of the array? */\n      if (ispow2realasize(t) && boundary > luaH_realasize(t) / 2) {\n        t->alimit = boundary;  /* use it as the new limit */\n        setnorealasize(t);\n      }\n      return boundary;\n    }\n  }\n  /* 'limit' is zero or present in table */\n  if (!limitequalsasize(t)) {  /* (2)? */\n    /* 'limit' > 0 and array has more elements after 'limit' */\n    if (arraykeyisempty(t, limit + 1))  /* 'limit + 1' is empty? */\n      return limit;  /* this is the boundary */\n    /* else, try last element in the array */\n    limit = luaH_realasize(t);\n    if (arraykeyisempty(t, limit)) {  /* empty? */\n      /* there must be a boundary in the array after old limit,\n         and it must be a valid new limit */\n      unsigned int boundary = binsearch(t, t->alimit, limit);\n      t->alimit = boundary;\n      return boundary;\n    }\n    /* else, new limit is present in the table; check the hash part */\n  }\n  /* (3) 'limit' is the last element and either is zero or present in table */\n  lua_assert(limit == luaH_realasize(t) &&\n             (limit == 0 || !arraykeyisempty(t, limit)));\n  if (isdummy(t) || hashkeyisempty(t, cast(lua_Integer, limit + 1)))\n    return limit;  /* 'limit + 1' is absent */\n  else  /* 'limit + 1' is also present */\n    return hash_search(t, limit);\n}\n\n\n\n#if defined(LUA_DEBUG)\n\n/* export these functions for the test library */\n\nNode *luaH_mainposition (const Table *t, const TValue *key) {\n  return mainpositionTV(t, key);\n}\n\n#endif\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/ltable.h",
		"is_binary":	false,
		"content":	"/*\n** $Id: ltable.h $\n** Lua tables (hash)\n** See Copyright Notice in lua.h\n*/\n\n#ifndef ltable_h\n#define ltable_h\n\n#include \"lobject.h\"\n\n\n#define gnode(t,i)\t(&(t)->node[i])\n#define gval(n)\t\t(&(n)->i_val)\n#define gnext(n)\t((n)->u.next)\n\n\n/*\n** Clear all bits of fast-access metamethods, which means that the table\n** may have any of these metamethods. (First access that fails after the\n** clearing will set the bit again.)\n*/\n#define invalidateTMcache(t)\t((t)->flags &= ~maskflags)\n\n\n/*\n** Bit BITDUMMY set in 'flags' means the table is using the dummy node\n** for its hash part.\n*/\n\n#define BITDUMMY\t\t(1 << 6)\n#define NOTBITDUMMY\t\tcast_byte(~BITDUMMY)\n#define isdummy(t)\t\t((t)->flags & BITDUMMY)\n\n#define setnodummy(t)\t\t((t)->flags &= NOTBITDUMMY)\n#define setdummy(t)\t\t((t)->flags |= BITDUMMY)\n\n\n\n/* allocated size for hash nodes */\n#define allocsizenode(t)\t(isdummy(t) ? 0 : sizenode(t))\n\n\n/* returns the Node, given the value of a table entry */\n#define nodefromval(v)\tcast(Node *, (v))\n\n\n\n#define luaH_fastgeti(t,k,res,tag) \\\n  { Table *h = t; lua_Unsigned u = l_castS2U(k); \\\n    if ((u - 1u < h->alimit)) { \\\n      tag = *getArrTag(h,(u)-1u); \\\n      if (!tagisempty(tag)) { farr2val(h, u, tag, res); }} \\\n    else { tag = luaH_getint(h, u, res); }}\n\n\n#define luaH_fastseti(t,k,val,hres) \\\n  { Table *h = t; lua_Unsigned u = l_castS2U(k); \\\n    if ((u - 1u < h->alimit)) { \\\n      lu_byte *tag = getArrTag(h,(u)-1u); \\\n      if (tagisempty(*tag)) hres = ~cast_int(u); \\\n      else { fval2arr(h, u, tag, val); hres = HOK; }} \\\n    else { hres = luaH_psetint(h, u, val); }}\n\n\n/* results from pset */\n#define HOK\t\t0\n#define HNOTFOUND\t1\n#define HNOTATABLE\t2\n#define HFIRSTNODE\t3\n\n/*\n** 'luaH_get*' operations set 'res', unless the value is absent, and\n** return the tag of the result,\n** The 'luaH_pset*' (pre-set) operations set the given value and return\n** HOK, unless the original value is absent. In that case, if the key\n** is really absent, they return HNOTFOUND. Otherwise, if there is a\n** slot with that key but with no value, 'luaH_pset*' return an encoding\n** of where the key is (usually called 'hres'). (pset cannot set that\n** value because there might be a metamethod.) If the slot is in the\n** hash part, the encoding is (HFIRSTNODE + hash index); if the slot is\n** in the array part, the encoding is (~array index), a negative value.\n** The value HNOTATABLE is used by the fast macros to signal that the\n** value being indexed is not a table.\n*/\n\n\n/*\n** The array part of a table is represented by an array of cells.\n** Each cell is composed of NM tags followed by NM values, so that\n** no space is wasted in padding. The last cell may be incomplete,\n** that is, it may have fewer than NM values.\n*/\n#define NM      cast_uint(sizeof(Value))\n\nstruct ArrayCell {\n  lu_byte tag[NM];\n  Value value[NM];\n};\n\n\n/* Computes the address of the tag for the abstract index 'k' */\n#define getArrTag(t,k)\t(&(t)->array[(k)/NM].tag[(k)%NM])\n\n/* Computes the address of the value for the abstract index 'k' */\n#define getArrVal(t,k)\t(&(t)->array[(k)/NM].value[(k)%NM])\n\n\n/*\n** Move TValues to/from arrays, using Lua indices\n*/\n#define arr2obj(h,k,val)  \\\n  ((val)->tt_ = *getArrTag(h,(k)-1u), (val)->value_ = *getArrVal(h,(k)-1u))\n\n#define obj2arr(h,k,val)  \\\n  (*getArrTag(h,(k)-1u) = (val)->tt_, *getArrVal(h,(k)-1u) = (val)->value_)\n\n\n/*\n** Often, we need to check the tag of a value before moving it. These\n** macros also move TValues to/from arrays, but receive the precomputed\n** tag value or address as an extra argument.\n*/\n#define farr2val(h,k,tag,res)  \\\n  ((res)->tt_ = tag, (res)->value_ = *getArrVal(h,(k)-1u))\n\n#define fval2arr(h,k,tag,val)  \\\n  (*tag = (val)->tt_, *getArrVal(h,(k)-1u) = (val)->value_)\n\n\nLUAI_FUNC int luaH_get (Table *t, const TValue *key, TValue *res);\nLUAI_FUNC int luaH_getshortstr (Table *t, TString *key, TValue *res);\nLUAI_FUNC int luaH_getstr (Table *t, TString *key, TValue *res);\nLUAI_FUNC int luaH_getint (Table *t, lua_Integer key, TValue *res);\n\n/* Special get for metamethods */\nLUAI_FUNC const TValue *luaH_Hgetshortstr (Table *t, TString *key);\n\nLUAI_FUNC TString *luaH_getstrkey (Table *t, TString *key);\n\nLUAI_FUNC int luaH_psetint (Table *t, lua_Integer key, TValue *val);\nLUAI_FUNC int luaH_psetshortstr (Table *t, TString *key, TValue *val);\nLUAI_FUNC int luaH_psetstr (Table *t, TString *key, TValue *val);\nLUAI_FUNC int luaH_pset (Table *t, const TValue *key, TValue *val);\n\nLUAI_FUNC void luaH_setint (lua_State *L, Table *t, lua_Integer key,\n                                                    TValue *value);\nLUAI_FUNC void luaH_set (lua_State *L, Table *t, const TValue *key,\n                                                 TValue *value);\n\nLUAI_FUNC void luaH_finishset (lua_State *L, Table *t, const TValue *key,\n                                              TValue *value, int hres);\nLUAI_FUNC Table *luaH_new (lua_State *L);\nLUAI_FUNC void luaH_resize (lua_State *L, Table *t, unsigned nasize,\n                                                    unsigned nhsize);\nLUAI_FUNC void luaH_resizearray (lua_State *L, Table *t, unsigned nasize);\nLUAI_FUNC void luaH_free (lua_State *L, Table *t);\nLUAI_FUNC int luaH_next (lua_State *L, Table *t, StkId key);\nLUAI_FUNC lua_Unsigned luaH_getn (Table *t);\nLUAI_FUNC unsigned luaH_realasize (const Table *t);\n\n\n#if defined(LUA_DEBUG)\nLUAI_FUNC Node *luaH_mainposition (const Table *t, const TValue *key);\n#endif\n\n\n#endif\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/ltablib.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: ltablib.c $\n** Library for Table Manipulation\n** See Copyright Notice in lua.h\n*/\n\n#define ltablib_c\n#define LUA_LIB\n\n#include \"lprefix.h\"\n\n\n#include <limits.h>\n#include <stddef.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n\n\n/*\n** Operations that an object must define to mimic a table\n** (some functions only need some of them)\n*/\n#define TAB_R\t1\t\t\t/* read */\n#define TAB_W\t2\t\t\t/* write */\n#define TAB_L\t4\t\t\t/* length */\n#define TAB_RW\t(TAB_R | TAB_W)\t\t/* read/write */\n\n\n#define aux_getn(L,n,w)\t(checktab(L, n, (w) | TAB_L), luaL_len(L, n))\n\n\nstatic int checkfield (lua_State *L, const char *key, int n) {\n  lua_pushstring(L, key);\n  return (lua_rawget(L, -n) != LUA_TNIL);\n}\n\n\n/*\n** Check that 'arg' either is a table or can behave like one (that is,\n** has a metatable with the required metamethods)\n*/\nstatic void checktab (lua_State *L, int arg, int what) {\n  if (lua_type(L, arg) != LUA_TTABLE) {  /* is it not a table? */\n    int n = 1;  /* number of elements to pop */\n    if (lua_getmetatable(L, arg) &&  /* must have metatable */\n        (!(what & TAB_R) || checkfield(L, \"__index\", ++n)) &&\n        (!(what & TAB_W) || checkfield(L, \"__newindex\", ++n)) &&\n        (!(what & TAB_L) || checkfield(L, \"__len\", ++n))) {\n      lua_pop(L, n);  /* pop metatable and tested metamethods */\n    }\n    else\n      luaL_checktype(L, arg, LUA_TTABLE);  /* force an error */\n  }\n}\n\n\nstatic int tcreate (lua_State *L) {\n  lua_Unsigned sizeseq = (lua_Unsigned)luaL_checkinteger(L, 1);\n  lua_Unsigned sizerest = (lua_Unsigned)luaL_optinteger(L, 2, 0);\n  luaL_argcheck(L, sizeseq <= UINT_MAX, 1, \"out of range\");\n  luaL_argcheck(L, sizerest <= UINT_MAX, 2, \"out of range\");\n  lua_createtable(L, (unsigned)sizeseq, (unsigned)sizerest);\n  return 1;\n}\n\n\nstatic int tinsert (lua_State *L) {\n  lua_Integer pos;  /* where to insert new element */\n  lua_Integer e = aux_getn(L, 1, TAB_RW);\n  e = luaL_intop(+, e, 1);  /* first empty element */\n  switch (lua_gettop(L)) {\n    case 2: {  /* called with only 2 arguments */\n      pos = e;  /* insert new element at the end */\n      break;\n    }\n    case 3: {\n      lua_Integer i;\n      pos = luaL_checkinteger(L, 2);  /* 2nd argument is the position */\n      /* check whether 'pos' is in [1, e] */\n      luaL_argcheck(L, (lua_Unsigned)pos - 1u < (lua_Unsigned)e, 2,\n                       \"position out of bounds\");\n      for (i = e; i > pos; i--) {  /* move up elements */\n        lua_geti(L, 1, i - 1);\n        lua_seti(L, 1, i);  /* t[i] = t[i - 1] */\n      }\n      break;\n    }\n    default: {\n      return luaL_error(L, \"wrong number of arguments to 'insert'\");\n    }\n  }\n  lua_seti(L, 1, pos);  /* t[pos] = v */\n  return 0;\n}\n\n\nstatic int tremove (lua_State *L) {\n  lua_Integer size = aux_getn(L, 1, TAB_RW);\n  lua_Integer pos = luaL_optinteger(L, 2, size);\n  if (pos != size)  /* validate 'pos' if given */\n    /* check whether 'pos' is in [1, size + 1] */\n    luaL_argcheck(L, (lua_Unsigned)pos - 1u <= (lua_Unsigned)size, 2,\n                     \"position out of bounds\");\n  lua_geti(L, 1, pos);  /* result = t[pos] */\n  for ( ; pos < size; pos++) {\n    lua_geti(L, 1, pos + 1);\n    lua_seti(L, 1, pos);  /* t[pos] = t[pos + 1] */\n  }\n  lua_pushnil(L);\n  lua_seti(L, 1, pos);  /* remove entry t[pos] */\n  return 1;\n}\n\n\n/*\n** Copy elements (1[f], ..., 1[e]) into (tt[t], tt[t+1], ...). Whenever\n** possible, copy in increasing order, which is better for rehashing.\n** \"possible\" means destination after original range, or smaller\n** than origin, or copying to another table.\n*/\nstatic int tmove (lua_State *L) {\n  lua_Integer f = luaL_checkinteger(L, 2);\n  lua_Integer e = luaL_checkinteger(L, 3);\n  lua_Integer t = luaL_checkinteger(L, 4);\n  int tt = !lua_isnoneornil(L, 5) ? 5 : 1;  /* destination table */\n  checktab(L, 1, TAB_R);\n  checktab(L, tt, TAB_W);\n  if (e >= f) {  /* otherwise, nothing to move */\n    lua_Integer n, i;\n    luaL_argcheck(L, f > 0 || e < LUA_MAXINTEGER + f, 3,\n                  \"too many elements to move\");\n    n = e - f + 1;  /* number of elements to move */\n    luaL_argcheck(L, t <= LUA_MAXINTEGER - n + 1, 4,\n                  \"destination wrap around\");\n    if (t > e || t <= f || (tt != 1 && !lua_compare(L, 1, tt, LUA_OPEQ))) {\n      for (i = 0; i < n; i++) {\n        lua_geti(L, 1, f + i);\n        lua_seti(L, tt, t + i);\n      }\n    }\n    else {\n      for (i = n - 1; i >= 0; i--) {\n        lua_geti(L, 1, f + i);\n        lua_seti(L, tt, t + i);\n      }\n    }\n  }\n  lua_pushvalue(L, tt);  /* return destination table */\n  return 1;\n}\n\n\nstatic void addfield (lua_State *L, luaL_Buffer *b, lua_Integer i) {\n  lua_geti(L, 1, i);\n  if (l_unlikely(!lua_isstring(L, -1)))\n    luaL_error(L, \"invalid value (%s) at index %I in table for 'concat'\",\n                  luaL_typename(L, -1), (LUAI_UACINT)i);\n  luaL_addvalue(b);\n}\n\n\nstatic int tconcat (lua_State *L) {\n  luaL_Buffer b;\n  lua_Integer last = aux_getn(L, 1, TAB_R);\n  size_t lsep;\n  const char *sep = luaL_optlstring(L, 2, \"\", &lsep);\n  lua_Integer i = luaL_optinteger(L, 3, 1);\n  last = luaL_optinteger(L, 4, last);\n  luaL_buffinit(L, &b);\n  for (; i < last; i++) {\n    addfield(L, &b, i);\n    luaL_addlstring(&b, sep, lsep);\n  }\n  if (i == last)  /* add last value (if interval was not empty) */\n    addfield(L, &b, i);\n  luaL_pushresult(&b);\n  return 1;\n}\n\n\n/*\n** {======================================================\n** Pack/unpack\n** =======================================================\n*/\n\nstatic int tpack (lua_State *L) {\n  int i;\n  int n = lua_gettop(L);  /* number of elements to pack */\n  lua_createtable(L, n, 1);  /* create result table */\n  lua_insert(L, 1);  /* put it at index 1 */\n  for (i = n; i >= 1; i--)  /* assign elements */\n    lua_seti(L, 1, i);\n  lua_pushinteger(L, n);\n  lua_setfield(L, 1, \"n\");  /* t.n = number of elements */\n  return 1;  /* return table */\n}\n\n\nstatic int tunpack (lua_State *L) {\n  lua_Unsigned n;\n  lua_Integer i = luaL_optinteger(L, 2, 1);\n  lua_Integer e = luaL_opt(L, luaL_checkinteger, 3, luaL_len(L, 1));\n  if (i > e) return 0;  /* empty range */\n  n = (lua_Unsigned)e - i;  /* number of elements minus 1 (avoid overflows) */\n  if (l_unlikely(n >= (unsigned int)INT_MAX  ||\n                 !lua_checkstack(L, (int)(++n))))\n    return luaL_error(L, \"too many results to unpack\");\n  for (; i < e; i++) {  /* push arg[i..e - 1] (to avoid overflows) */\n    lua_geti(L, 1, i);\n  }\n  lua_geti(L, 1, e);  /* push last element */\n  return (int)n;\n}\n\n/* }====================================================== */\n\n\n\n/*\n** {======================================================\n** Quicksort\n** (based on 'Algorithms in MODULA-3', Robert Sedgewick;\n**  Addison-Wesley, 1993.)\n** =======================================================\n*/\n\n\n/* type for array indices */\ntypedef unsigned int IdxT;\n\n\n/*\n** Produce a \"random\" 'unsigned int' to randomize pivot choice. This\n** macro is used only when 'sort' detects a big imbalance in the result\n** of a partition. (If you don't want/need this \"randomness\", ~0 is a\n** good choice.)\n*/\n#if !defined(l_randomizePivot)\n#define l_randomizePivot(L)\tluaL_makeseed(L)\n#endif\t\t\t\t\t/* } */\n\n\n/* arrays larger than 'RANLIMIT' may use randomized pivots */\n#define RANLIMIT\t100u\n\n\nstatic void set2 (lua_State *L, IdxT i, IdxT j) {\n  lua_seti(L, 1, i);\n  lua_seti(L, 1, j);\n}\n\n\n/*\n** Return true iff value at stack index 'a' is less than the value at\n** index 'b' (according to the order of the sort).\n*/\nstatic int sort_comp (lua_State *L, int a, int b) {\n  if (lua_isnil(L, 2))  /* no function? */\n    return lua_compare(L, a, b, LUA_OPLT);  /* a < b */\n  else {  /* function */\n    int res;\n    lua_pushvalue(L, 2);    /* push function */\n    lua_pushvalue(L, a-1);  /* -1 to compensate function */\n    lua_pushvalue(L, b-2);  /* -2 to compensate function and 'a' */\n    lua_call(L, 2, 1);      /* call function */\n    res = lua_toboolean(L, -1);  /* get result */\n    lua_pop(L, 1);          /* pop result */\n    return res;\n  }\n}\n\n\n/*\n** Does the partition: Pivot P is at the top of the stack.\n** precondition: a[lo] <= P == a[up-1] <= a[up],\n** so it only needs to do the partition from lo + 1 to up - 2.\n** Pos-condition: a[lo .. i - 1] <= a[i] == P <= a[i + 1 .. up]\n** returns 'i'.\n*/\nstatic IdxT partition (lua_State *L, IdxT lo, IdxT up) {\n  IdxT i = lo;  /* will be incremented before first use */\n  IdxT j = up - 1;  /* will be decremented before first use */\n  /* loop invariant: a[lo .. i] <= P <= a[j .. up] */\n  for (;;) {\n    /* next loop: repeat ++i while a[i] < P */\n    while ((void)lua_geti(L, 1, ++i), sort_comp(L, -1, -2)) {\n      if (l_unlikely(i == up - 1))  /* a[i] < P  but a[up - 1] == P  ?? */\n        luaL_error(L, \"invalid order function for sorting\");\n      lua_pop(L, 1);  /* remove a[i] */\n    }\n    /* after the loop, a[i] >= P and a[lo .. i - 1] < P */\n    /* next loop: repeat --j while P < a[j] */\n    while ((void)lua_geti(L, 1, --j), sort_comp(L, -3, -1)) {\n      if (l_unlikely(j < i))  /* j < i  but  a[j] > P ?? */\n        luaL_error(L, \"invalid order function for sorting\");\n      lua_pop(L, 1);  /* remove a[j] */\n    }\n    /* after the loop, a[j] <= P and a[j + 1 .. up] >= P */\n    if (j < i) {  /* no elements out of place? */\n      /* a[lo .. i - 1] <= P <= a[j + 1 .. i .. up] */\n      lua_pop(L, 1);  /* pop a[j] */\n      /* swap pivot (a[up - 1]) with a[i] to satisfy pos-condition */\n      set2(L, up - 1, i);\n      return i;\n    }\n    /* otherwise, swap a[i] - a[j] to restore invariant and repeat */\n    set2(L, i, j);\n  }\n}\n\n\n/*\n** Choose an element in the middle (2nd-3th quarters) of [lo,up]\n** \"randomized\" by 'rnd'\n*/\nstatic IdxT choosePivot (IdxT lo, IdxT up, unsigned int rnd) {\n  IdxT r4 = (up - lo) / 4;  /* range/4 */\n  IdxT p = (rnd ^ lo ^ up) % (r4 * 2) + (lo + r4);\n  lua_assert(lo + r4 <= p && p <= up - r4);\n  return p;\n}\n\n\n/*\n** Quicksort algorithm (recursive function)\n*/\nstatic void auxsort (lua_State *L, IdxT lo, IdxT up, unsigned rnd) {\n  while (lo < up) {  /* loop for tail recursion */\n    IdxT p;  /* Pivot index */\n    IdxT n;  /* to be used later */\n    /* sort elements 'lo', 'p', and 'up' */\n    lua_geti(L, 1, lo);\n    lua_geti(L, 1, up);\n    if (sort_comp(L, -1, -2))  /* a[up] < a[lo]? */\n      set2(L, lo, up);  /* swap a[lo] - a[up] */\n    else\n      lua_pop(L, 2);  /* remove both values */\n    if (up - lo == 1)  /* only 2 elements? */\n      return;  /* already sorted */\n    if (up - lo < RANLIMIT || rnd == 0)  /* small interval or no randomize? */\n      p = (lo + up)/2;  /* middle element is a good pivot */\n    else  /* for larger intervals, it is worth a random pivot */\n      p = choosePivot(lo, up, rnd);\n    lua_geti(L, 1, p);\n    lua_geti(L, 1, lo);\n    if (sort_comp(L, -2, -1))  /* a[p] < a[lo]? */\n      set2(L, p, lo);  /* swap a[p] - a[lo] */\n    else {\n      lua_pop(L, 1);  /* remove a[lo] */\n      lua_geti(L, 1, up);\n      if (sort_comp(L, -1, -2))  /* a[up] < a[p]? */\n        set2(L, p, up);  /* swap a[up] - a[p] */\n      else\n        lua_pop(L, 2);\n    }\n    if (up - lo == 2)  /* only 3 elements? */\n      return;  /* already sorted */\n    lua_geti(L, 1, p);  /* get middle element (Pivot) */\n    lua_pushvalue(L, -1);  /* push Pivot */\n    lua_geti(L, 1, up - 1);  /* push a[up - 1] */\n    set2(L, p, up - 1);  /* swap Pivot (a[p]) with a[up - 1] */\n    p = partition(L, lo, up);\n    /* a[lo .. p - 1] <= a[p] == P <= a[p + 1 .. up] */\n    if (p - lo < up - p) {  /* lower interval is smaller? */\n      auxsort(L, lo, p - 1, rnd);  /* call recursively for lower interval */\n      n = p - lo;  /* size of smaller interval */\n      lo = p + 1;  /* tail call for [p + 1 .. up] (upper interval) */\n    }\n    else {\n      auxsort(L, p + 1, up, rnd);  /* call recursively for upper interval */\n      n = up - p;  /* size of smaller interval */\n      up = p - 1;  /* tail call for [lo .. p - 1]  (lower interval) */\n    }\n    if ((up - lo) / 128 > n) /* partition too imbalanced? */\n      rnd = l_randomizePivot(L);  /* try a new randomization */\n  }  /* tail call auxsort(L, lo, up, rnd) */\n}\n\n\nstatic int sort (lua_State *L) {\n  lua_Integer n = aux_getn(L, 1, TAB_RW);\n  if (n > 1) {  /* non-trivial interval? */\n    luaL_argcheck(L, n < INT_MAX, 1, \"array too big\");\n    if (!lua_isnoneornil(L, 2))  /* is there a 2nd argument? */\n      luaL_checktype(L, 2, LUA_TFUNCTION);  /* must be a function */\n    lua_settop(L, 2);  /* make sure there are two arguments */\n    auxsort(L, 1, (IdxT)n, 0);\n  }\n  return 0;\n}\n\n/* }====================================================== */\n\n\nstatic const luaL_Reg tab_funcs[] = {\n  {\"concat\", tconcat},\n  {\"create\", tcreate},\n  {\"insert\", tinsert},\n  {\"pack\", tpack},\n  {\"unpack\", tunpack},\n  {\"remove\", tremove},\n  {\"move\", tmove},\n  {\"sort\", sort},\n  {NULL, NULL}\n};\n\n\nLUAMOD_API int luaopen_table (lua_State *L) {\n  luaL_newlib(L, tab_funcs);\n  return 1;\n}\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/ltests.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: ltests.c $\n** Internal Module for Debugging of the Lua Implementation\n** See Copyright Notice in lua.h\n*/\n\n#define ltests_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <limits.h>\n#include <setjmp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lapi.h\"\n#include \"lauxlib.h\"\n#include \"lcode.h\"\n#include \"lctype.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lmem.h\"\n#include \"lopcodes.h\"\n#include \"lopnames.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"lualib.h\"\n\n\n\n/*\n** The whole module only makes sense with LUA_DEBUG on\n*/\n#if defined(LUA_DEBUG)\n\n\nvoid *l_Trick = 0;\n\n\n#define obj_at(L,k)\ts2v(L->ci->func.p + (k))\n\n\nstatic int runC (lua_State *L, lua_State *L1, const char *pc);\n\n\nstatic void setnameval (lua_State *L, const char *name, int val) {\n  lua_pushinteger(L, val);\n  lua_setfield(L, -2, name);\n}\n\n\nstatic void pushobject (lua_State *L, const TValue *o) {\n  setobj2s(L, L->top.p, o);\n  api_incr_top(L);\n}\n\n\nstatic void badexit (const char *fmt, const char *s1, const char *s2) {\n  fprintf(stderr, fmt, s1);\n  if (s2)\n    fprintf(stderr, \"extra info: %s\\n\", s2);\n  /* avoid assertion failures when exiting */\n  l_memcontrol.numblocks = l_memcontrol.total = 0;\n  exit(EXIT_FAILURE);\n}\n\n\nstatic int tpanic (lua_State *L) {\n  const char *msg = (lua_type(L, -1) == LUA_TSTRING)\n                  ? lua_tostring(L, -1)\n                  : \"error object is not a string\";\n  return (badexit(\"PANIC: unprotected error in call to Lua API (%s)\\n\",\n                   msg, NULL),\n          0);  /* do not return to Lua */\n}\n\n\n/*\n** Warning function for tests. First, it concatenates all parts of\n** a warning in buffer 'buff'. Then, it has three modes:\n** - 0.normal: messages starting with '#' are shown on standard output;\n** - other messages abort the tests (they represent real warning\n** conditions; the standard tests should not generate these conditions\n** unexpectedly);\n** - 1.allow: all messages are shown;\n** - 2.store: all warnings go to the global '_WARN';\n*/\nstatic void warnf (void *ud, const char *msg, int tocont) {\n  lua_State *L = cast(lua_State *, ud);\n  static char buff[200] = \"\";  /* should be enough for tests... */\n  static int onoff = 0;\n  static int mode = 0;  /* start in normal mode */\n  static int lasttocont = 0;\n  if (!lasttocont && !tocont && *msg == '@') {  /* control message? */\n    if (buff[0] != '\\0')\n      badexit(\"Control warning during warning: %s\\naborting...\\n\", msg, buff);\n    if (strcmp(msg, \"@off\") == 0)\n      onoff = 0;\n    else if (strcmp(msg, \"@on\") == 0)\n      onoff = 1;\n    else if (strcmp(msg, \"@normal\") == 0)\n      mode = 0;\n    else if (strcmp(msg, \"@allow\") == 0)\n      mode = 1;\n    else if (strcmp(msg, \"@store\") == 0)\n      mode = 2;\n    else\n      badexit(\"Invalid control warning in test mode: %s\\naborting...\\n\",\n              msg, NULL);\n    return;\n  }\n  lasttocont = tocont;\n  if (strlen(msg) >= sizeof(buff) - strlen(buff))\n    badexit(\"warnf-buffer overflow (%s)\\n\", msg, buff);\n  strcat(buff, msg);  /* add new message to current warning */\n  if (!tocont) {  /* message finished? */\n    lua_unlock(L);\n    luaL_checkstack(L, 1, \"warn stack space\");\n    lua_getglobal(L, \"_WARN\");\n    if (!lua_toboolean(L, -1))\n      lua_pop(L, 1);  /* ok, no previous unexpected warning */\n    else {\n      badexit(\"Unhandled warning in store mode: %s\\naborting...\\n\",\n              lua_tostring(L, -1), buff);\n    }\n    lua_lock(L);\n    switch (mode) {\n      case 0: {  /* normal */\n        if (buff[0] != '#' && onoff)  /* unexpected warning? */\n          badexit(\"Unexpected warning in test mode: %s\\naborting...\\n\",\n                  buff, NULL);\n      }  /* FALLTHROUGH */\n      case 1: {  /* allow */\n        if (onoff)\n          fprintf(stderr, \"Lua warning: %s\\n\", buff);  /* print warning */\n        break;\n      }\n      case 2: {  /* store */\n        lua_unlock(L);\n        luaL_checkstack(L, 1, \"warn stack space\");\n        lua_pushstring(L, buff);\n        lua_setglobal(L, \"_WARN\");  /* assign message to global '_WARN' */\n        lua_lock(L);\n        break;\n      }\n    }\n    buff[0] = '\\0';  /* prepare buffer for next warning */\n  }\n}\n\n\n/*\n** {======================================================================\n** Controlled version for realloc.\n** =======================================================================\n*/\n\n#define MARK\t\t0x55  /* 01010101 (a nice pattern) */\n\ntypedef union Header {\n  LUAI_MAXALIGN;\n  struct {\n    size_t size;\n    int type;\n  } d;\n} Header;\n\n\n#if !defined(EXTERNMEMCHECK)\n\n/* full memory check */\n#define MARKSIZE\t16  /* size of marks after each block */\n#define fillmem(mem,size)\tmemset(mem, -MARK, size)\n\n#else\n\n/* external memory check: don't do it twice */\n#define MARKSIZE\t0\n#define fillmem(mem,size)\t/* empty */\n\n#endif\n\n\nMemcontrol l_memcontrol =\n  {0, 0UL, 0UL, 0UL, 0UL, (~0UL),\n   {0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL}};\n\n\nstatic void freeblock (Memcontrol *mc, Header *block) {\n  if (block) {\n    size_t size = block->d.size;\n    int i;\n    for (i = 0; i < MARKSIZE; i++)  /* check marks after block */\n      lua_assert(*(cast_charp(block + 1) + size + i) == MARK);\n    mc->objcount[block->d.type]--;\n    fillmem(block, sizeof(Header) + size + MARKSIZE);  /* erase block */\n    free(block);  /* actually free block */\n    mc->numblocks--;  /* update counts */\n    mc->total -= size;\n  }\n}\n\n\nvoid *debug_realloc (void *ud, void *b, size_t oldsize, size_t size) {\n  Memcontrol *mc = cast(Memcontrol *, ud);\n  Header *block = cast(Header *, b);\n  int type;\n  if (mc->memlimit == 0) {  /* first time? */\n    char *limit = getenv(\"MEMLIMIT\");  /* initialize memory limit */\n    mc->memlimit = limit ? strtoul(limit, NULL, 10) : ULONG_MAX;\n  }\n  if (block == NULL) {\n    type = (oldsize < LUA_NUMTYPES) ? oldsize : 0;\n    oldsize = 0;\n  }\n  else {\n    block--;  /* go to real header */\n    type = block->d.type;\n    lua_assert(oldsize == block->d.size);\n  }\n  if (size == 0) {\n    freeblock(mc, block);\n    return NULL;\n  }\n  if (mc->failnext) {\n    mc->failnext = 0;\n    return NULL;  /* fake a single memory allocation error */\n  }\n  if (mc->countlimit != ~0UL && size != oldsize) {  /* count limit in use? */\n    if (mc->countlimit == 0)\n      return NULL;  /* fake a memory allocation error */\n    mc->countlimit--;\n  }\n  if (size > oldsize && mc->total+size-oldsize > mc->memlimit)\n    return NULL;  /* fake a memory allocation error */\n  else {\n    Header *newblock;\n    int i;\n    size_t commonsize = (oldsize < size) ? oldsize : size;\n    size_t realsize = sizeof(Header) + size + MARKSIZE;\n    if (realsize < size) return NULL;  /* arithmetic overflow! */\n    newblock = cast(Header *, malloc(realsize));  /* alloc a new block */\n    if (newblock == NULL)\n      return NULL;  /* really out of memory? */\n    if (block) {\n      memcpy(newblock + 1, block + 1, commonsize);  /* copy old contents */\n      freeblock(mc, block);  /* erase (and check) old copy */\n    }\n    /* initialize new part of the block with something weird */\n    fillmem(cast_charp(newblock + 1) + commonsize, size - commonsize);\n    /* initialize marks after block */\n    for (i = 0; i < MARKSIZE; i++)\n      *(cast_charp(newblock + 1) + size + i) = MARK;\n    newblock->d.size = size;\n    newblock->d.type = type;\n    mc->total += size;\n    if (mc->total > mc->maxmem)\n      mc->maxmem = mc->total;\n    mc->numblocks++;\n    mc->objcount[type]++;\n    return newblock + 1;\n  }\n}\n\n\n/* }====================================================================== */\n\n\n\n/*\n** {=====================================================================\n** Functions to check memory consistency.\n** Most of these checks are done through asserts, so this code does\n** not make sense with asserts off. For this reason, it uses 'assert'\n** directly, instead of 'lua_assert'.\n** ======================================================================\n*/\n\n#include <assert.h>\n\n/*\n** Check GC invariants. For incremental mode, a black object cannot\n** point to a white one. For generational mode, really old objects\n** cannot point to young objects. Both old1 and touched2 objects\n** cannot point to new objects (but can point to survivals).\n** (Threads and open upvalues, despite being marked \"really old\",\n** continue to be visited in all collections, and therefore can point to\n** new objects. They, and only they, are old but gray.)\n*/\nstatic int testobjref1 (global_State *g, GCObject *f, GCObject *t) {\n  if (isdead(g,t)) return 0;\n  if (issweepphase(g))\n    return 1;  /* no invariants */\n  else if (g->gckind != KGC_GENMINOR)\n    return !(isblack(f) && iswhite(t));  /* basic incremental invariant */\n  else {  /* generational mode */\n    if ((getage(f) == G_OLD && isblack(f)) && !isold(t))\n      return 0;\n    if ((getage(f) == G_OLD1 || getage(f) == G_TOUCHED2) &&\n         getage(t) == G_NEW)\n      return 0;\n    return 1;\n  }\n}\n\n\nstatic void printobj (global_State *g, GCObject *o) {\n  printf(\"||%s(%p)-%c%c(%02X)||\",\n           ttypename(novariant(o->tt)), (void *)o,\n           isdead(g,o) ? 'd' : isblack(o) ? 'b' : iswhite(o) ? 'w' : 'g',\n           \"ns01oTt\"[getage(o)], o->marked);\n  if (o->tt == LUA_VSHRSTR || o->tt == LUA_VLNGSTR)\n    printf(\" '%s'\", getstr(gco2ts(o)));\n}\n\n\nvoid lua_printobj (lua_State *L, struct GCObject *o) {\n  printobj(G(L), o);\n}\n\nstatic int testobjref (global_State *g, GCObject *f, GCObject *t) {\n  int r1 = testobjref1(g, f, t);\n  if (!r1) {\n    printf(\"%d(%02X) - \", g->gcstate, g->currentwhite);\n    printobj(g, f);\n    printf(\"  ->  \");\n    printobj(g, t);\n    printf(\"\\n\");\n  }\n  return r1;\n}\n\n\nstatic void checkobjref (global_State *g, GCObject *f, GCObject *t) {\n    assert(testobjref(g, f, t));\n}\n\n\n/*\n** Version where 't' can be NULL. In that case, it should not apply the\n** macro 'obj2gco' over the object. ('t' may have several types, so this\n** definition must be a macro.)  Most checks need this version, because\n** the check may run while an object is still being created.\n*/\n#define checkobjrefN(g,f,t)\t{ if (t) checkobjref(g,f,obj2gco(t)); }\n\n\nstatic void checkvalref (global_State *g, GCObject *f, const TValue *t) {\n  assert(!iscollectable(t) || (righttt(t) && testobjref(g, f, gcvalue(t))));\n}\n\n\nstatic void checktable (global_State *g, Table *h) {\n  unsigned int i;\n  unsigned int asize = luaH_realasize(h);\n  Node *n, *limit = gnode(h, sizenode(h));\n  GCObject *hgc = obj2gco(h);\n  checkobjrefN(g, hgc, h->metatable);\n  for (i = 0; i < asize; i++) {\n    TValue aux;\n    arr2obj(h, i + 1, &aux);\n    checkvalref(g, hgc, &aux);\n  }\n  for (n = gnode(h, 0); n < limit; n++) {\n    if (!isempty(gval(n))) {\n      TValue k;\n      getnodekey(g->mainthread, &k, n);\n      assert(!keyisnil(n));\n      checkvalref(g, hgc, &k);\n      checkvalref(g, hgc, gval(n));\n    }\n  }\n}\n\n\nstatic void checkudata (global_State *g, Udata *u) {\n  int i;\n  GCObject *hgc = obj2gco(u);\n  checkobjrefN(g, hgc, u->metatable);\n  for (i = 0; i < u->nuvalue; i++)\n    checkvalref(g, hgc, &u->uv[i].uv);\n}\n\n\nstatic void checkproto (global_State *g, Proto *f) {\n  int i;\n  GCObject *fgc = obj2gco(f);\n  checkobjrefN(g, fgc, f->source);\n  for (i=0; i<f->sizek; i++) {\n    if (iscollectable(f->k + i))\n      checkobjref(g, fgc, gcvalue(f->k + i));\n  }\n  for (i=0; i<f->sizeupvalues; i++)\n    checkobjrefN(g, fgc, f->upvalues[i].name);\n  for (i=0; i<f->sizep; i++)\n    checkobjrefN(g, fgc, f->p[i]);\n  for (i=0; i<f->sizelocvars; i++)\n    checkobjrefN(g, fgc, f->locvars[i].varname);\n}\n\n\nstatic void checkCclosure (global_State *g, CClosure *cl) {\n  GCObject *clgc = obj2gco(cl);\n  int i;\n  for (i = 0; i < cl->nupvalues; i++)\n    checkvalref(g, clgc, &cl->upvalue[i]);\n}\n\n\nstatic void checkLclosure (global_State *g, LClosure *cl) {\n  GCObject *clgc = obj2gco(cl);\n  int i;\n  checkobjrefN(g, clgc, cl->p);\n  for (i=0; i<cl->nupvalues; i++) {\n    UpVal *uv = cl->upvals[i];\n    if (uv) {\n      checkobjrefN(g, clgc, uv);\n      if (!upisopen(uv))\n        checkvalref(g, obj2gco(uv), uv->v.p);\n    }\n  }\n}\n\n\nstatic int lua_checkpc (CallInfo *ci) {\n  if (!isLua(ci)) return 1;\n  else {\n    StkId f = ci->func.p;\n    Proto *p = clLvalue(s2v(f))->p;\n    return p->code <= ci->u.l.savedpc &&\n           ci->u.l.savedpc <= p->code + p->sizecode;\n  }\n}\n\n\nstatic void checkstack (global_State *g, lua_State *L1) {\n  StkId o;\n  CallInfo *ci;\n  UpVal *uv;\n  assert(!isdead(g, L1));\n  if (L1->stack.p == NULL) {  /* incomplete thread? */\n    assert(L1->openupval == NULL && L1->ci == NULL);\n    return;\n  }\n  for (uv = L1->openupval; uv != NULL; uv = uv->u.open.next)\n    assert(upisopen(uv));  /* must be open */\n  assert(L1->top.p <= L1->stack_last.p);\n  assert(L1->tbclist.p <= L1->top.p);\n  for (ci = L1->ci; ci != NULL; ci = ci->previous) {\n    assert(ci->top.p <= L1->stack_last.p);\n    assert(lua_checkpc(ci));\n  }\n  for (o = L1->stack.p; o < L1->stack_last.p; o++)\n    checkliveness(L1, s2v(o));  /* entire stack must have valid values */\n}\n\n\nstatic void checkrefs (global_State *g, GCObject *o) {\n  switch (o->tt) {\n    case LUA_VUSERDATA: {\n      checkudata(g, gco2u(o));\n      break;\n    }\n    case LUA_VUPVAL: {\n      checkvalref(g, o, gco2upv(o)->v.p);\n      break;\n    }\n    case LUA_VTABLE: {\n      checktable(g, gco2t(o));\n      break;\n    }\n    case LUA_VTHREAD: {\n      checkstack(g, gco2th(o));\n      break;\n    }\n    case LUA_VLCL: {\n      checkLclosure(g, gco2lcl(o));\n      break;\n    }\n    case LUA_VCCL: {\n      checkCclosure(g, gco2ccl(o));\n      break;\n    }\n    case LUA_VPROTO: {\n      checkproto(g, gco2p(o));\n      break;\n    }\n    case LUA_VSHRSTR:\n    case LUA_VLNGSTR: {\n      assert(!isgray(o));  /* strings are never gray */\n      break;\n    }\n    default: assert(0);\n  }\n}\n\n\n/*\n** Check consistency of an object:\n** - Dead objects can only happen in the 'allgc' list during a sweep\n** phase (controlled by the caller through 'maybedead').\n** - During pause, all objects must be white.\n** - In generational mode:\n**   * objects must be old enough for their lists ('listage').\n**   * old objects cannot be white.\n**   * old objects must be black, except for 'touched1', 'old0',\n**     threads, and open upvalues.\n**   * 'touched1' objects must be gray.\n*/\nstatic void checkobject (global_State *g, GCObject *o, int maybedead,\n                         int listage) {\n  if (isdead(g, o))\n    assert(maybedead);\n  else {\n    assert(g->gcstate != GCSpause || iswhite(o));\n    if (g->gckind == KGC_GENMINOR) {  /* generational mode? */\n      assert(getage(o) >= listage);\n      if (isold(o)) {\n        assert(!iswhite(o));\n        assert(isblack(o) ||\n        getage(o) == G_TOUCHED1 ||\n        getage(o) == G_OLD0 ||\n        o->tt == LUA_VTHREAD ||\n        (o->tt == LUA_VUPVAL && upisopen(gco2upv(o))));\n      }\n      assert(getage(o) != G_TOUCHED1 || isgray(o));\n    }\n    checkrefs(g, o);\n  }\n}\n\n\nstatic l_obj checkgraylist (global_State *g, GCObject *o) {\n  int total = 0;  /* count number of elements in the list */\n  cast_void(g);  /* better to keep it if we need to print an object */\n  while (o) {\n    assert(!!isgray(o) ^ (getage(o) == G_TOUCHED2));\n    assert(!testbit(o->marked, TESTBIT));\n    if (keepinvariant(g))\n      l_setbit(o->marked, TESTBIT);  /* mark that object is in a gray list */\n    total++;\n    switch (o->tt) {\n      case LUA_VTABLE: o = gco2t(o)->gclist; break;\n      case LUA_VLCL: o = gco2lcl(o)->gclist; break;\n      case LUA_VCCL: o = gco2ccl(o)->gclist; break;\n      case LUA_VTHREAD: o = gco2th(o)->gclist; break;\n      case LUA_VPROTO: o = gco2p(o)->gclist; break;\n      case LUA_VUSERDATA:\n        assert(gco2u(o)->nuvalue > 0);\n        o = gco2u(o)->gclist;\n        break;\n      default: assert(0);  /* other objects cannot be in a gray list */\n    }\n  }\n  return total;\n}\n\n\n/*\n** Check objects in gray lists.\n*/\nstatic l_obj checkgrays (global_State *g) {\n  int total = 0;  /* count number of elements in all lists */\n  if (!keepinvariant(g)) return total;\n  total += checkgraylist(g, g->gray);\n  total += checkgraylist(g, g->grayagain);\n  total += checkgraylist(g, g->weak);\n  total += checkgraylist(g, g->allweak);\n  total += checkgraylist(g, g->ephemeron);\n  return total;\n}\n\n\n/*\n** Check whether 'o' should be in a gray list. If so, increment\n** 'count' and check its TESTBIT. (It must have been previously set by\n** 'checkgraylist'.)\n*/\nstatic void incifingray (global_State *g, GCObject *o, l_obj *count) {\n  if (!keepinvariant(g))\n    return;  /* gray lists not being kept in these phases */\n  if (o->tt == LUA_VUPVAL) {\n    /* only open upvalues can be gray */\n    assert(!isgray(o) || upisopen(gco2upv(o)));\n    return;  /* upvalues are never in gray lists */\n  }\n  /* these are the ones that must be in gray lists */\n  if (isgray(o) || getage(o) == G_TOUCHED2) {\n    (*count)++;\n    assert(testbit(o->marked, TESTBIT));\n    resetbit(o->marked, TESTBIT);  /* prepare for next cycle */\n  }\n}\n\n\nstatic l_obj checklist (global_State *g, int maybedead, int tof,\n  GCObject *newl, GCObject *survival, GCObject *old, GCObject *reallyold) {\n  GCObject *o;\n  l_obj total = 0;  /* number of object that should be in  gray lists */\n  for (o = newl; o != survival; o = o->next) {\n    checkobject(g, o, maybedead, G_NEW);\n    incifingray(g, o, &total);\n    assert(!tof == !tofinalize(o));\n  }\n  for (o = survival; o != old; o = o->next) {\n    checkobject(g, o, 0, G_SURVIVAL);\n    incifingray(g, o, &total);\n    assert(!tof == !tofinalize(o));\n  }\n  for (o = old; o != reallyold; o = o->next) {\n    checkobject(g, o, 0, G_OLD1);\n    incifingray(g, o, &total);\n    assert(!tof == !tofinalize(o));\n  }\n  for (o = reallyold; o != NULL; o = o->next) {\n    checkobject(g, o, 0, G_OLD);\n    incifingray(g, o, &total);\n    assert(!tof == !tofinalize(o));\n  }\n  return total;\n}\n\n\nint lua_checkmemory (lua_State *L) {\n  global_State *g = G(L);\n  GCObject *o;\n  int maybedead;\n  l_obj totalin;  /* total of objects that are in gray lists */\n  l_obj totalshould;  /* total of objects that should be in gray lists */\n  if (keepinvariant(g)) {\n    assert(!iswhite(g->mainthread));\n    assert(!iswhite(gcvalue(&g->l_registry)));\n  }\n  assert(!isdead(g, gcvalue(&g->l_registry)));\n  assert(g->sweepgc == NULL || issweepphase(g));\n  totalin = checkgrays(g);\n\n  /* check 'fixedgc' list */\n  for (o = g->fixedgc; o != NULL; o = o->next) {\n    assert(o->tt == LUA_VSHRSTR && isgray(o) && getage(o) == G_OLD);\n  }\n\n  /* check 'allgc' list */\n  maybedead = (GCSatomic < g->gcstate && g->gcstate <= GCSswpallgc);\n  totalshould = checklist(g, maybedead, 0, g->allgc,\n                             g->survival, g->old1, g->reallyold);\n\n  /* check 'finobj' list */\n  totalshould += checklist(g, 0, 1, g->finobj,\n                              g->finobjsur, g->finobjold1, g->finobjrold);\n\n  /* check 'tobefnz' list */\n  for (o = g->tobefnz; o != NULL; o = o->next) {\n    checkobject(g, o, 0, G_NEW);\n    incifingray(g, o, &totalshould);\n    assert(tofinalize(o));\n    assert(o->tt == LUA_VUSERDATA || o->tt == LUA_VTABLE);\n  }\n  if (keepinvariant(g))\n    assert(totalin == totalshould);\n  return 0;\n}\n\n/* }====================================================== */\n\n\n\n/*\n** {======================================================\n** Disassembler\n** =======================================================\n*/\n\n\nstatic char *buildop (Proto *p, int pc, char *buff) {\n  char *obuff = buff;\n  Instruction i = p->code[pc];\n  OpCode o = GET_OPCODE(i);\n  const char *name = opnames[o];\n  int line = luaG_getfuncline(p, pc);\n  int lineinfo = (p->lineinfo != NULL) ? p->lineinfo[pc] : 0;\n  if (lineinfo == ABSLINEINFO)\n    buff += sprintf(buff, \"(__\");\n  else\n    buff += sprintf(buff, \"(%2d\", lineinfo);\n  buff += sprintf(buff, \" - %4d) %4d - \", line, pc);\n  switch (getOpMode(o)) {\n    case iABC:\n      sprintf(buff, \"%-12s%4d %4d %4d%s\", name,\n              GETARG_A(i), GETARG_B(i), GETARG_C(i),\n              GETARG_k(i) ? \" (k)\" : \"\");\n      break;\n    case iABx:\n      sprintf(buff, \"%-12s%4d %4d\", name, GETARG_A(i), GETARG_Bx(i));\n      break;\n    case iAsBx:\n      sprintf(buff, \"%-12s%4d %4d\", name, GETARG_A(i), GETARG_sBx(i));\n      break;\n    case iAx:\n      sprintf(buff, \"%-12s%4d\", name, GETARG_Ax(i));\n      break;\n    case isJ:\n      sprintf(buff, \"%-12s%4d\", name, GETARG_sJ(i));\n      break;\n  }\n  return obuff;\n}\n\n\n#if 0\nvoid luaI_printcode (Proto *pt, int size) {\n  int pc;\n  for (pc=0; pc<size; pc++) {\n    char buff[100];\n    printf(\"%s\\n\", buildop(pt, pc, buff));\n  }\n  printf(\"-------\\n\");\n}\n\n\nvoid luaI_printinst (Proto *pt, int pc) {\n  char buff[100];\n  printf(\"%s\\n\", buildop(pt, pc, buff));\n}\n#endif\n\n\nstatic int listcode (lua_State *L) {\n  int pc;\n  Proto *p;\n  luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1),\n                 1, \"Lua function expected\");\n  p = getproto(obj_at(L, 1));\n  lua_newtable(L);\n  setnameval(L, \"maxstack\", p->maxstacksize);\n  setnameval(L, \"numparams\", p->numparams);\n  for (pc=0; pc<p->sizecode; pc++) {\n    char buff[100];\n    lua_pushinteger(L, pc+1);\n    lua_pushstring(L, buildop(p, pc, buff));\n    lua_settable(L, -3);\n  }\n  return 1;\n}\n\n\nstatic int printcode (lua_State *L) {\n  int pc;\n  Proto *p;\n  luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1),\n                 1, \"Lua function expected\");\n  p = getproto(obj_at(L, 1));\n  printf(\"maxstack: %d\\n\", p->maxstacksize);\n  printf(\"numparams: %d\\n\", p->numparams);\n  for (pc=0; pc<p->sizecode; pc++) {\n    char buff[100];\n    printf(\"%s\\n\", buildop(p, pc, buff));\n  }\n  return 0;\n}\n\n\nstatic int listk (lua_State *L) {\n  Proto *p;\n  int i;\n  luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1),\n                 1, \"Lua function expected\");\n  p = getproto(obj_at(L, 1));\n  lua_createtable(L, p->sizek, 0);\n  for (i=0; i<p->sizek; i++) {\n    pushobject(L, p->k+i);\n    lua_rawseti(L, -2, i+1);\n  }\n  return 1;\n}\n\n\nstatic int listabslineinfo (lua_State *L) {\n  Proto *p;\n  int i;\n  luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1),\n                 1, \"Lua function expected\");\n  p = getproto(obj_at(L, 1));\n  luaL_argcheck(L, p->abslineinfo != NULL, 1, \"function has no debug info\");\n  lua_createtable(L, 2 * p->sizeabslineinfo, 0);\n  for (i=0; i < p->sizeabslineinfo; i++) {\n    lua_pushinteger(L, p->abslineinfo[i].pc);\n    lua_rawseti(L, -2, 2 * i + 1);\n    lua_pushinteger(L, p->abslineinfo[i].line);\n    lua_rawseti(L, -2, 2 * i + 2);\n  }\n  return 1;\n}\n\n\nstatic int listlocals (lua_State *L) {\n  Proto *p;\n  int pc = cast_int(luaL_checkinteger(L, 2)) - 1;\n  int i = 0;\n  const char *name;\n  luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1),\n                 1, \"Lua function expected\");\n  p = getproto(obj_at(L, 1));\n  while ((name = luaF_getlocalname(p, ++i, pc)) != NULL)\n    lua_pushstring(L, name);\n  return i-1;\n}\n\n/* }====================================================== */\n\n\n\nstatic void printstack (lua_State *L) {\n  int i;\n  int n = lua_gettop(L);\n  printf(\"stack: >>\\n\");\n  for (i = 1; i <= n; i++) {\n    printf(\"%3d: %s\\n\", i, luaL_tolstring(L, i, NULL));\n    lua_pop(L, 1);\n  }\n  printf(\"<<\\n\");\n}\n\n\nstatic int get_limits (lua_State *L) {\n  lua_createtable(L, 0, 6);\n  setnameval(L, \"IS32INT\", LUAI_IS32INT);\n  setnameval(L, \"MAXARG_Ax\", MAXARG_Ax);\n  setnameval(L, \"MAXARG_Bx\", MAXARG_Bx);\n  setnameval(L, \"OFFSET_sBx\", OFFSET_sBx);\n  setnameval(L, \"LFPF\", LFIELDS_PER_FLUSH);\n  setnameval(L, \"NUM_OPCODES\", NUM_OPCODES);\n  return 1;\n}\n\n\nstatic int mem_query (lua_State *L) {\n  if (lua_isnone(L, 1)) {\n    lua_pushinteger(L, l_memcontrol.total);\n    lua_pushinteger(L, l_memcontrol.numblocks);\n    lua_pushinteger(L, l_memcontrol.maxmem);\n    return 3;\n  }\n  else if (lua_isnumber(L, 1)) {\n    unsigned long limit = cast(unsigned long, luaL_checkinteger(L, 1));\n    if (limit == 0) limit = ULONG_MAX;\n    l_memcontrol.memlimit = limit;\n    return 0;\n  }\n  else {\n    const char *t = luaL_checkstring(L, 1);\n    int i;\n    for (i = LUA_NUMTYPES - 1; i >= 0; i--) {\n      if (strcmp(t, ttypename(i)) == 0) {\n        lua_pushinteger(L, l_memcontrol.objcount[i]);\n        return 1;\n      }\n    }\n    return luaL_error(L, \"unknown type '%s'\", t);\n  }\n}\n\n\nstatic int alloc_count (lua_State *L) {\n  if (lua_isnone(L, 1))\n    l_memcontrol.countlimit = ~0L;\n  else\n    l_memcontrol.countlimit = luaL_checkinteger(L, 1);\n  return 0;\n}\n\n\nstatic int alloc_failnext (lua_State *L) {\n  UNUSED(L);\n  l_memcontrol.failnext = 1;\n  return 0;\n}\n\n\nstatic int settrick (lua_State *L) {\n  if (ttisnil(obj_at(L, 1)))\n    l_Trick = NULL;\n  else\n    l_Trick = gcvalue(obj_at(L, 1));\n  return 0;\n}\n\n\nstatic int gc_color (lua_State *L) {\n  TValue *o;\n  luaL_checkany(L, 1);\n  o = obj_at(L, 1);\n  if (!iscollectable(o))\n    lua_pushstring(L, \"no collectable\");\n  else {\n    GCObject *obj = gcvalue(o);\n    lua_pushstring(L, isdead(G(L), obj) ? \"dead\" :\n                      iswhite(obj) ? \"white\" :\n                      isblack(obj) ? \"black\" : \"gray\");\n  }\n  return 1;\n}\n\n\nstatic int gc_age (lua_State *L) {\n  TValue *o;\n  luaL_checkany(L, 1);\n  o = obj_at(L, 1);\n  if (!iscollectable(o))\n    lua_pushstring(L, \"no collectable\");\n  else {\n    static const char *gennames[] = {\"new\", \"survival\", \"old0\", \"old1\",\n                                     \"old\", \"touched1\", \"touched2\"};\n    GCObject *obj = gcvalue(o);\n    lua_pushstring(L, gennames[getage(obj)]);\n  }\n  return 1;\n}\n\n\nstatic int gc_printobj (lua_State *L) {\n  TValue *o;\n  luaL_checkany(L, 1);\n  o = obj_at(L, 1);\n  if (!iscollectable(o))\n    printf(\"no collectable\\n\");\n  else {\n    GCObject *obj = gcvalue(o);\n    printobj(G(L), obj);\n    printf(\"\\n\");\n  }\n  return 0;\n}\n\n\nstatic int gc_state (lua_State *L) {\n  static const char *statenames[] = {\n    \"propagate\", \"atomic\", \"sweepallgc\", \"sweepfinobj\",\n    \"sweeptobefnz\", \"sweepend\", \"callfin\", \"pause\", \"\"};\n  static const int states[] = {\n    GCSpropagate, GCSenteratomic, GCSswpallgc, GCSswpfinobj,\n    GCSswptobefnz, GCSswpend, GCScallfin, GCSpause, -1};\n  int option = states[luaL_checkoption(L, 1, \"\", statenames)];\n  if (option == -1) {\n    lua_pushstring(L, statenames[G(L)->gcstate]);\n    return 1;\n  }\n  else {\n    global_State *g = G(L);\n    if (G(L)->gckind != KGC_INC)\n      luaL_error(L, \"cannot change states in generational mode\");\n    lua_lock(L);\n    if (option < g->gcstate) {  /* must cross 'pause'? */\n      luaC_runtilstate(L, GCSpause, 1);  /* run until pause */\n    }\n    luaC_runtilstate(L, option, 0);  /* do not skip propagation state */\n    lua_assert(G(L)->gcstate == option);\n    lua_unlock(L);\n    return 0;\n  }\n}\n\n\nstatic int hash_query (lua_State *L) {\n  if (lua_isnone(L, 2)) {\n    luaL_argcheck(L, lua_type(L, 1) == LUA_TSTRING, 1, \"string expected\");\n    lua_pushinteger(L, tsvalue(obj_at(L, 1))->hash);\n  }\n  else {\n    TValue *o = obj_at(L, 1);\n    Table *t;\n    luaL_checktype(L, 2, LUA_TTABLE);\n    t = hvalue(obj_at(L, 2));\n    lua_pushinteger(L, luaH_mainposition(t, o) - t->node);\n  }\n  return 1;\n}\n\n\nstatic int stacklevel (lua_State *L) {\n  unsigned long a = 0;\n  lua_pushinteger(L, (L->top.p - L->stack.p));\n  lua_pushinteger(L, stacksize(L));\n  lua_pushinteger(L, L->nCcalls);\n  lua_pushinteger(L, L->nci);\n  lua_pushinteger(L, (unsigned long)&a);\n  return 5;\n}\n\n\nstatic int table_query (lua_State *L) {\n  const Table *t;\n  int i = cast_int(luaL_optinteger(L, 2, -1));\n  unsigned int asize;\n  luaL_checktype(L, 1, LUA_TTABLE);\n  t = hvalue(obj_at(L, 1));\n  asize = luaH_realasize(t);\n  if (i == -1) {\n    lua_pushinteger(L, asize);\n    lua_pushinteger(L, allocsizenode(t));\n    lua_pushinteger(L, t->alimit);\n    return 3;\n  }\n  else if (cast_uint(i) < asize) {\n    lua_pushinteger(L, i);\n    arr2obj(t, i + 1, s2v(L->top.p));\n    api_incr_top(L);\n    lua_pushnil(L);\n  }\n  else if ((i -= asize) < sizenode(t)) {\n    TValue k;\n    getnodekey(L, &k, gnode(t, i));\n    if (!isempty(gval(gnode(t, i))) ||\n        ttisnil(&k) ||\n        ttisnumber(&k)) {\n      pushobject(L, &k);\n    }\n    else\n      lua_pushliteral(L, \"<undef>\");\n    pushobject(L, gval(gnode(t, i)));\n    if (gnext(&t->node[i]) != 0)\n      lua_pushinteger(L, gnext(&t->node[i]));\n    else\n      lua_pushnil(L);\n  }\n  return 3;\n}\n\n\nstatic int query_GCparams (lua_State *L) {\n  global_State *g = G(L);\n  lua_pushinteger(L, gettotalobjs(g));\n  lua_pushinteger(L, g->GCdebt);\n  lua_pushinteger(L, applygcparam(g, MINORMUL, 100));\n  lua_pushinteger(L, applygcparam(g, MAJORMINOR, 100));\n  lua_pushinteger(L, applygcparam(g, MINORMAJOR, 100));\n  lua_pushinteger(L, applygcparam(g, PAUSE, 100));\n  lua_pushinteger(L, applygcparam(g, STEPMUL, 100));\n  lua_pushinteger(L, applygcparam(g, STEPSIZE, 100));\n  return 8;\n}\n\n\nstatic int test_codeparam (lua_State *L) {\n  lua_Integer p = luaL_checkinteger(L, 1);\n  lua_pushinteger(L, luaO_codeparam(p));\n  return 1;\n}\n\n\nstatic int test_applyparam (lua_State *L) {\n  lua_Integer p = luaL_checkinteger(L, 1);\n  lua_Integer x = luaL_checkinteger(L, 2);\n  lua_pushinteger(L, luaO_applyparam(p, x));\n  return 1;\n}\n\n\nstatic int string_query (lua_State *L) {\n  stringtable *tb = &G(L)->strt;\n  int s = cast_int(luaL_optinteger(L, 1, 0)) - 1;\n  if (s == -1) {\n    lua_pushinteger(L ,tb->size);\n    lua_pushinteger(L ,tb->nuse);\n    return 2;\n  }\n  else if (s < tb->size) {\n    TString *ts;\n    int n = 0;\n    for (ts = tb->hash[s]; ts != NULL; ts = ts->u.hnext) {\n      setsvalue2s(L, L->top.p, ts);\n      api_incr_top(L);\n      n++;\n    }\n    return n;\n  }\n  else return 0;\n}\n\n\nstatic int getreftable (lua_State *L) {\n  if (lua_istable(L, 2))  /* is there a table as second argument? */\n    return 2;  /* use it as the table */\n  else\n    return LUA_REGISTRYINDEX;  /* default is to use the register */\n}\n\n\nstatic int tref (lua_State *L) {\n  int t = getreftable(L);\n  int level = lua_gettop(L);\n  luaL_checkany(L, 1);\n  lua_pushvalue(L, 1);\n  lua_pushinteger(L, luaL_ref(L, t));\n  cast_void(level);  /* to avoid warnings */\n  lua_assert(lua_gettop(L) == level+1);  /* +1 for result */\n  return 1;\n}\n\n\nstatic int getref (lua_State *L) {\n  int t = getreftable(L);\n  int level = lua_gettop(L);\n  lua_rawgeti(L, t, luaL_checkinteger(L, 1));\n  cast_void(level);  /* to avoid warnings */\n  lua_assert(lua_gettop(L) == level+1);\n  return 1;\n}\n\nstatic int unref (lua_State *L) {\n  int t = getreftable(L);\n  int level = lua_gettop(L);\n  luaL_unref(L, t, cast_int(luaL_checkinteger(L, 1)));\n  cast_void(level);  /* to avoid warnings */\n  lua_assert(lua_gettop(L) == level);\n  return 0;\n}\n\n\nstatic int upvalue (lua_State *L) {\n  int n = cast_int(luaL_checkinteger(L, 2));\n  luaL_checktype(L, 1, LUA_TFUNCTION);\n  if (lua_isnone(L, 3)) {\n    const char *name = lua_getupvalue(L, 1, n);\n    if (name == NULL) return 0;\n    lua_pushstring(L, name);\n    return 2;\n  }\n  else {\n    const char *name = lua_setupvalue(L, 1, n);\n    lua_pushstring(L, name);\n    return 1;\n  }\n}\n\n\nstatic int newuserdata (lua_State *L) {\n  size_t size = cast_sizet(luaL_optinteger(L, 1, 0));\n  int nuv = luaL_optinteger(L, 2, 0);\n  char *p = cast_charp(lua_newuserdatauv(L, size, nuv));\n  while (size--) *p++ = '\\0';\n  return 1;\n}\n\n\nstatic int pushuserdata (lua_State *L) {\n  lua_Integer u = luaL_checkinteger(L, 1);\n  lua_pushlightuserdata(L, cast_voidp(cast_sizet(u)));\n  return 1;\n}\n\n\nstatic int udataval (lua_State *L) {\n  lua_pushinteger(L, cast(long, lua_touserdata(L, 1)));\n  return 1;\n}\n\n\nstatic int doonnewstack (lua_State *L) {\n  lua_State *L1 = lua_newthread(L);\n  size_t l;\n  const char *s = luaL_checklstring(L, 1, &l);\n  int status = luaL_loadbuffer(L1, s, l, s);\n  if (status == LUA_OK)\n    status = lua_pcall(L1, 0, 0, 0);\n  lua_pushinteger(L, status);\n  return 1;\n}\n\n\nstatic int s2d (lua_State *L) {\n  lua_pushnumber(L, cast_num(*cast(const double *, luaL_checkstring(L, 1))));\n  return 1;\n}\n\n\nstatic int d2s (lua_State *L) {\n  double d = cast(double, luaL_checknumber(L, 1));\n  lua_pushlstring(L, cast_charp(&d), sizeof(d));\n  return 1;\n}\n\n\nstatic int num2int (lua_State *L) {\n  lua_pushinteger(L, lua_tointeger(L, 1));\n  return 1;\n}\n\n\nstatic int makeseed (lua_State *L) {\n  lua_pushinteger(L, luaL_makeseed(L));\n  return 1;\n}\n\n\nstatic int newstate (lua_State *L) {\n  void *ud;\n  lua_Alloc f = lua_getallocf(L, &ud);\n  lua_State *L1 = lua_newstate(f, ud, 0);\n  if (L1) {\n    lua_atpanic(L1, tpanic);\n    lua_pushlightuserdata(L, L1);\n  }\n  else\n    lua_pushnil(L);\n  return 1;\n}\n\n\nstatic lua_State *getstate (lua_State *L) {\n  lua_State *L1 = cast(lua_State *, lua_touserdata(L, 1));\n  luaL_argcheck(L, L1 != NULL, 1, \"state expected\");\n  return L1;\n}\n\n\nstatic int loadlib (lua_State *L) {\n  lua_State *L1 = getstate(L);\n  int load = luaL_checkinteger(L, 2);\n  int preload = luaL_checkinteger(L, 3);\n  luaL_openselectedlibs(L1, load, preload);\n  luaL_requiref(L1, \"T\", luaB_opentests, 0);\n  lua_assert(lua_type(L1, -1) == LUA_TTABLE);\n  /* 'requiref' should not reload module already loaded... */\n  luaL_requiref(L1, \"T\", NULL, 1);  /* seg. fault if it reloads */\n  /* ...but should return the same module */\n  lua_assert(lua_compare(L1, -1, -2, LUA_OPEQ));\n  return 0;\n}\n\nstatic int closestate (lua_State *L) {\n  lua_State *L1 = getstate(L);\n  lua_close(L1);\n  return 0;\n}\n\nstatic int doremote (lua_State *L) {\n  lua_State *L1 = getstate(L);\n  size_t lcode;\n  const char *code = luaL_checklstring(L, 2, &lcode);\n  int status;\n  lua_settop(L1, 0);\n  status = luaL_loadbuffer(L1, code, lcode, code);\n  if (status == LUA_OK)\n    status = lua_pcall(L1, 0, LUA_MULTRET, 0);\n  if (status != LUA_OK) {\n    lua_pushnil(L);\n    lua_pushstring(L, lua_tostring(L1, -1));\n    lua_pushinteger(L, status);\n    return 3;\n  }\n  else {\n    int i = 0;\n    while (!lua_isnone(L1, ++i))\n      lua_pushstring(L, lua_tostring(L1, i));\n    lua_pop(L1, i-1);\n    return i-1;\n  }\n}\n\n\nstatic int log2_aux (lua_State *L) {\n  unsigned int x = (unsigned int)luaL_checkinteger(L, 1);\n  lua_pushinteger(L, luaO_ceillog2(x));\n  return 1;\n}\n\n\nstruct Aux { jmp_buf jb; const char *paniccode; lua_State *L; };\n\n/*\n** does a long-jump back to \"main program\".\n*/\nstatic int panicback (lua_State *L) {\n  struct Aux *b;\n  lua_checkstack(L, 1);  /* open space for 'Aux' struct */\n  lua_getfield(L, LUA_REGISTRYINDEX, \"_jmpbuf\");  /* get 'Aux' struct */\n  b = (struct Aux *)lua_touserdata(L, -1);\n  lua_pop(L, 1);  /* remove 'Aux' struct */\n  runC(b->L, L, b->paniccode);  /* run optional panic code */\n  longjmp(b->jb, 1);\n  return 1;  /* to avoid warnings */\n}\n\nstatic int checkpanic (lua_State *L) {\n  struct Aux b;\n  void *ud;\n  lua_State *L1;\n  const char *code = luaL_checkstring(L, 1);\n  lua_Alloc f = lua_getallocf(L, &ud);\n  b.paniccode = luaL_optstring(L, 2, \"\");\n  b.L = L;\n  L1 = lua_newstate(f, ud, 0);  /* create new state */\n  if (L1 == NULL) {  /* error? */\n    lua_pushnil(L);\n    return 1;\n  }\n  lua_atpanic(L1, panicback);  /* set its panic function */\n  lua_pushlightuserdata(L1, &b);\n  lua_setfield(L1, LUA_REGISTRYINDEX, \"_jmpbuf\");  /* store 'Aux' struct */\n  if (setjmp(b.jb) == 0) {  /* set jump buffer */\n    runC(L, L1, code);  /* run code unprotected */\n    lua_pushliteral(L, \"no errors\");\n  }\n  else {  /* error handling */\n    /* move error message to original state */\n    lua_pushstring(L, lua_tostring(L1, -1));\n  }\n  lua_close(L1);\n  return 1;\n}\n\n\nstatic int externKstr (lua_State *L) {\n  size_t len;\n  const char *s = luaL_checklstring(L, 1, &len);\n  lua_pushextlstring(L, s, len, NULL, NULL);\n  return 1;\n}\n\n\n/*\n** Create a buffer with the content of a given string and then\n** create an external string using that buffer. Use the allocation\n** function from Lua to create and free the buffer.\n*/\nstatic int externstr (lua_State *L) {\n  size_t len;\n  const char *s = luaL_checklstring(L, 1, &len);\n  void *ud;\n  lua_Alloc allocf = lua_getallocf(L, &ud);  /* get allocation function */\n  /* create the buffer */\n  char *buff = cast_charp((*allocf)(ud, NULL, 0, len + 1));\n  if (buff == NULL) {  /* memory error? */\n    lua_pushliteral(L, \"not enough memory\");\n    lua_error(L);  /* raise a memory error */\n  }\n  /* copy string content to buffer, including ending 0 */\n  memcpy(buff, s, (len + 1) * sizeof(char));\n  /* create external string */\n  lua_pushextlstring(L, buff, len, allocf, ud);\n  return 1;\n}\n\n\n/*\n** {====================================================================\n** function to test the API with C. It interprets a kind of assembler\n** language with calls to the API, so the test can be driven by Lua code\n** =====================================================================\n*/\n\n\nstatic void sethookaux (lua_State *L, int mask, int count, const char *code);\n\nstatic const char *const delimits = \" \\t\\n,;\";\n\nstatic void skip (const char **pc) {\n  for (;;) {\n    if (**pc != '\\0' && strchr(delimits, **pc)) (*pc)++;\n    else if (**pc == '#') {  /* comment? */\n      while (**pc != '\\n' && **pc != '\\0') (*pc)++;  /* until end-of-line */\n    }\n    else break;\n  }\n}\n\nstatic int getnum_aux (lua_State *L, lua_State *L1, const char **pc) {\n  int res = 0;\n  int sig = 1;\n  skip(pc);\n  if (**pc == '.') {\n    res = cast_int(lua_tointeger(L1, -1));\n    lua_pop(L1, 1);\n    (*pc)++;\n    return res;\n  }\n  else if (**pc == '*') {\n    res = lua_gettop(L1);\n    (*pc)++;\n    return res;\n  }\n  else if (**pc == '!') {\n    (*pc)++;\n    if (**pc == 'G')\n      res = LUA_RIDX_GLOBALS;\n    else if (**pc == 'M')\n      res = LUA_RIDX_MAINTHREAD;\n    else lua_assert(0);\n    (*pc)++;\n    return res;\n  }\n  else if (**pc == '-') {\n    sig = -1;\n    (*pc)++;\n  }\n  if (!lisdigit(cast_uchar(**pc)))\n    luaL_error(L, \"number expected (%s)\", *pc);\n  while (lisdigit(cast_uchar(**pc))) res = res*10 + (*(*pc)++) - '0';\n  return sig*res;\n}\n\nstatic const char *getstring_aux (lua_State *L, char *buff, const char **pc) {\n  int i = 0;\n  skip(pc);\n  if (**pc == '\"' || **pc == '\\'') {  /* quoted string? */\n    int quote = *(*pc)++;\n    while (**pc != quote) {\n      if (**pc == '\\0') luaL_error(L, \"unfinished string in C script\");\n      buff[i++] = *(*pc)++;\n    }\n    (*pc)++;\n  }\n  else {\n    while (**pc != '\\0' && !strchr(delimits, **pc))\n      buff[i++] = *(*pc)++;\n  }\n  buff[i] = '\\0';\n  return buff;\n}\n\n\nstatic int getindex_aux (lua_State *L, lua_State *L1, const char **pc) {\n  skip(pc);\n  switch (*(*pc)++) {\n    case 'R': return LUA_REGISTRYINDEX;\n    case 'G': return luaL_error(L, \"deprecated index 'G'\");\n    case 'U': return lua_upvalueindex(getnum_aux(L, L1, pc));\n    default: (*pc)--; return getnum_aux(L, L1, pc);\n  }\n}\n\n\nstatic const char *const statcodes[] = {\"OK\", \"YIELD\", \"ERRRUN\",\n    \"ERRSYNTAX\", MEMERRMSG, \"ERRGCMM\", \"ERRERR\"};\n\n/*\n** Avoid these stat codes from being collected, to avoid possible\n** memory error when pushing them.\n*/\nstatic void regcodes (lua_State *L) {\n  unsigned int i;\n  for (i = 0; i < sizeof(statcodes) / sizeof(statcodes[0]); i++) {\n    lua_pushboolean(L, 1);\n    lua_setfield(L, LUA_REGISTRYINDEX, statcodes[i]);\n  }\n}\n\n\n#define EQ(s1)\t(strcmp(s1, inst) == 0)\n\n#define getnum\t\t(getnum_aux(L, L1, &pc))\n#define getstring\t(getstring_aux(L, buff, &pc))\n#define getindex\t(getindex_aux(L, L1, &pc))\n\n\nstatic int testC (lua_State *L);\nstatic int Cfunck (lua_State *L, int status, lua_KContext ctx);\n\n/*\n** arithmetic operation encoding for 'arith' instruction\n** LUA_OPIDIV  -> \\\n** LUA_OPSHL   -> <\n** LUA_OPSHR   -> >\n** LUA_OPUNM   -> _\n** LUA_OPBNOT  -> !\n*/\nstatic const char ops[] = \"+-*%^/\\\\&|~<>_!\";\n\nstatic int runC (lua_State *L, lua_State *L1, const char *pc) {\n  char buff[300];\n  int status = 0;\n  if (pc == NULL) return luaL_error(L, \"attempt to runC null script\");\n  for (;;) {\n    const char *inst = getstring;\n    if EQ(\"\") return 0;\n    else if EQ(\"absindex\") {\n      lua_pushnumber(L1, lua_absindex(L1, getindex));\n    }\n    else if EQ(\"append\") {\n      int t = getindex;\n      int i = lua_rawlen(L1, t);\n      lua_rawseti(L1, t, i + 1);\n    }\n    else if EQ(\"arith\") {\n      int op;\n      skip(&pc);\n      op = strchr(ops, *pc++) - ops;\n      lua_arith(L1, op);\n    }\n    else if EQ(\"call\") {\n      int narg = getnum;\n      int nres = getnum;\n      lua_call(L1, narg, nres);\n    }\n    else if EQ(\"callk\") {\n      int narg = getnum;\n      int nres = getnum;\n      int i = getindex;\n      lua_callk(L1, narg, nres, i, Cfunck);\n    }\n    else if EQ(\"checkstack\") {\n      int sz = getnum;\n      const char *msg = getstring;\n      if (*msg == '\\0')\n        msg = NULL;  /* to test 'luaL_checkstack' with no message */\n      luaL_checkstack(L1, sz, msg);\n    }\n    else if EQ(\"rawcheckstack\") {\n      int sz = getnum;\n      lua_pushboolean(L1, lua_checkstack(L1, sz));\n    }\n    else if EQ(\"compare\") {\n      const char *opt = getstring;  /* EQ, LT, or LE */\n      int op = (opt[0] == 'E') ? LUA_OPEQ\n                               : (opt[1] == 'T') ? LUA_OPLT : LUA_OPLE;\n      int a = getindex;\n      int b = getindex;\n      lua_pushboolean(L1, lua_compare(L1, a, b, op));\n    }\n    else if EQ(\"concat\") {\n      lua_concat(L1, getnum);\n    }\n    else if EQ(\"copy\") {\n      int f = getindex;\n      lua_copy(L1, f, getindex);\n    }\n    else if EQ(\"func2num\") {\n      lua_CFunction func = lua_tocfunction(L1, getindex);\n      lua_pushnumber(L1, cast_sizet(func));\n    }\n    else if EQ(\"getfield\") {\n      int t = getindex;\n      int tp = lua_getfield(L1, t, getstring);\n      lua_assert(tp == lua_type(L1, -1));\n    }\n    else if EQ(\"getglobal\") {\n      lua_getglobal(L1, getstring);\n    }\n    else if EQ(\"getmetatable\") {\n      if (lua_getmetatable(L1, getindex) == 0)\n        lua_pushnil(L1);\n    }\n    else if EQ(\"gettable\") {\n      int tp = lua_gettable(L1, getindex);\n      lua_assert(tp == lua_type(L1, -1));\n    }\n    else if EQ(\"gettop\") {\n      lua_pushinteger(L1, lua_gettop(L1));\n    }\n    else if EQ(\"gsub\") {\n      int a = getnum; int b = getnum; int c = getnum;\n      luaL_gsub(L1, lua_tostring(L1, a),\n                    lua_tostring(L1, b),\n                    lua_tostring(L1, c));\n    }\n    else if EQ(\"insert\") {\n      lua_insert(L1, getnum);\n    }\n    else if EQ(\"iscfunction\") {\n      lua_pushboolean(L1, lua_iscfunction(L1, getindex));\n    }\n    else if EQ(\"isfunction\") {\n      lua_pushboolean(L1, lua_isfunction(L1, getindex));\n    }\n    else if EQ(\"isnil\") {\n      lua_pushboolean(L1, lua_isnil(L1, getindex));\n    }\n    else if EQ(\"isnull\") {\n      lua_pushboolean(L1, lua_isnone(L1, getindex));\n    }\n    else if EQ(\"isnumber\") {\n      lua_pushboolean(L1, lua_isnumber(L1, getindex));\n    }\n    else if EQ(\"isstring\") {\n      lua_pushboolean(L1, lua_isstring(L1, getindex));\n    }\n    else if EQ(\"istable\") {\n      lua_pushboolean(L1, lua_istable(L1, getindex));\n    }\n    else if EQ(\"isudataval\") {\n      lua_pushboolean(L1, lua_islightuserdata(L1, getindex));\n    }\n    else if EQ(\"isuserdata\") {\n      lua_pushboolean(L1, lua_isuserdata(L1, getindex));\n    }\n    else if EQ(\"len\") {\n      lua_len(L1, getindex);\n    }\n    else if EQ(\"Llen\") {\n      lua_pushinteger(L1, luaL_len(L1, getindex));\n    }\n    else if EQ(\"loadfile\") {\n      luaL_loadfile(L1, luaL_checkstring(L1, getnum));\n    }\n    else if EQ(\"loadstring\") {\n      size_t slen;\n      const char *s = luaL_checklstring(L1, getnum, &slen);\n      const char *name = getstring;\n      const char *mode = getstring;\n      luaL_loadbufferx(L1, s, slen, name, mode);\n    }\n    else if EQ(\"newmetatable\") {\n      lua_pushboolean(L1, luaL_newmetatable(L1, getstring));\n    }\n    else if EQ(\"newtable\") {\n      lua_newtable(L1);\n    }\n    else if EQ(\"newthread\") {\n      lua_newthread(L1);\n    }\n    else if EQ(\"resetthread\") {\n      lua_pushinteger(L1, lua_resetthread(L1));  /* deprecated */\n    }\n    else if EQ(\"newuserdata\") {\n      lua_newuserdata(L1, getnum);\n    }\n    else if EQ(\"next\") {\n      lua_next(L1, -2);\n    }\n    else if EQ(\"objsize\") {\n      lua_pushinteger(L1, lua_rawlen(L1, getindex));\n    }\n    else if EQ(\"pcall\") {\n      int narg = getnum;\n      int nres = getnum;\n      status = lua_pcall(L1, narg, nres, getnum);\n    }\n    else if EQ(\"pcallk\") {\n      int narg = getnum;\n      int nres = getnum;\n      int i = getindex;\n      status = lua_pcallk(L1, narg, nres, 0, i, Cfunck);\n    }\n    else if EQ(\"pop\") {\n      lua_pop(L1, getnum);\n    }\n    else if EQ(\"printstack\") {\n      int n = getnum;\n      if (n != 0) {\n        printf(\"%s\\n\", luaL_tolstring(L1, n, NULL));\n        lua_pop(L1, 1);\n      }\n      else printstack(L1);\n    }\n    else if EQ(\"print\") {\n      const char *msg = getstring;\n      printf(\"%s\\n\", msg);\n    }\n    else if EQ(\"warningC\") {\n      const char *msg = getstring;\n      lua_warning(L1, msg, 1);\n    }\n    else if EQ(\"warning\") {\n      const char *msg = getstring;\n      lua_warning(L1, msg, 0);\n    }\n    else if EQ(\"pushbool\") {\n      lua_pushboolean(L1, getnum);\n    }\n    else if EQ(\"pushcclosure\") {\n      lua_pushcclosure(L1, testC, getnum);\n    }\n    else if EQ(\"pushint\") {\n      lua_pushinteger(L1, getnum);\n    }\n    else if EQ(\"pushnil\") {\n      lua_pushnil(L1);\n    }\n    else if EQ(\"pushnum\") {\n      lua_pushnumber(L1, (lua_Number)getnum);\n    }\n    else if EQ(\"pushstatus\") {\n      lua_pushstring(L1, statcodes[status]);\n    }\n    else if EQ(\"pushstring\") {\n      lua_pushstring(L1, getstring);\n    }\n    else if EQ(\"pushupvalueindex\") {\n      lua_pushinteger(L1, lua_upvalueindex(getnum));\n    }\n    else if EQ(\"pushvalue\") {\n      lua_pushvalue(L1, getindex);\n    }\n    else if EQ(\"pushfstringI\") {\n      lua_pushfstring(L1, lua_tostring(L, -2), (int)lua_tointeger(L, -1));\n    }\n    else if EQ(\"pushfstringS\") {\n      lua_pushfstring(L1, lua_tostring(L, -2), lua_tostring(L, -1));\n    }\n    else if EQ(\"pushfstringP\") {\n      lua_pushfstring(L1, lua_tostring(L, -2), lua_topointer(L, -1));\n    }\n    else if EQ(\"rawget\") {\n      int t = getindex;\n      lua_rawget(L1, t);\n    }\n    else if EQ(\"rawgeti\") {\n      int t = getindex;\n      lua_rawgeti(L1, t, getnum);\n    }\n    else if EQ(\"rawgetp\") {\n      int t = getindex;\n      lua_rawgetp(L1, t, cast_voidp(cast_sizet(getnum)));\n    }\n    else if EQ(\"rawset\") {\n      int t = getindex;\n      lua_rawset(L1, t);\n    }\n    else if EQ(\"rawseti\") {\n      int t = getindex;\n      lua_rawseti(L1, t, getnum);\n    }\n    else if EQ(\"rawsetp\") {\n      int t = getindex;\n      lua_rawsetp(L1, t, cast_voidp(cast_sizet(getnum)));\n    }\n    else if EQ(\"remove\") {\n      lua_remove(L1, getnum);\n    }\n    else if EQ(\"replace\") {\n      lua_replace(L1, getindex);\n    }\n    else if EQ(\"resume\") {\n      int i = getindex;\n      int nres;\n      status = lua_resume(lua_tothread(L1, i), L, getnum, &nres);\n    }\n    else if EQ(\"return\") {\n      int n = getnum;\n      if (L1 != L) {\n        int i;\n        for (i = 0; i < n; i++) {\n          int idx = -(n - i);\n          switch (lua_type(L1, idx)) {\n            case LUA_TBOOLEAN:\n              lua_pushboolean(L, lua_toboolean(L1, idx));\n              break;\n            default:\n              lua_pushstring(L, lua_tostring(L1, idx));\n              break;\n          }\n        }\n      }\n      return n;\n    }\n    else if EQ(\"rotate\") {\n      int i = getindex;\n      lua_rotate(L1, i, getnum);\n    }\n    else if EQ(\"setfield\") {\n      int t = getindex;\n      const char *s = getstring;\n      lua_setfield(L1, t, s);\n    }\n    else if EQ(\"seti\") {\n      int t = getindex;\n      lua_seti(L1, t, getnum);\n    }\n    else if EQ(\"setglobal\") {\n      const char *s = getstring;\n      lua_setglobal(L1, s);\n    }\n    else if EQ(\"sethook\") {\n      int mask = getnum;\n      int count = getnum;\n      const char *s = getstring;\n      sethookaux(L1, mask, count, s);\n    }\n    else if EQ(\"setmetatable\") {\n      int idx = getindex;\n      lua_setmetatable(L1, idx);\n    }\n    else if EQ(\"settable\") {\n      lua_settable(L1, getindex);\n    }\n    else if EQ(\"settop\") {\n      lua_settop(L1, getnum);\n    }\n    else if EQ(\"testudata\") {\n      int i = getindex;\n      lua_pushboolean(L1, luaL_testudata(L1, i, getstring) != NULL);\n    }\n    else if EQ(\"error\") {\n      lua_error(L1);\n    }\n    else if EQ(\"abort\") {\n      abort();\n    }\n    else if EQ(\"throw\") {\n#if defined(__cplusplus)\nstatic struct X { int x; } x;\n      throw x;\n#else\n      luaL_error(L1, \"C++\");\n#endif\n      break;\n    }\n    else if EQ(\"tobool\") {\n      lua_pushboolean(L1, lua_toboolean(L1, getindex));\n    }\n    else if EQ(\"tocfunction\") {\n      lua_pushcfunction(L1, lua_tocfunction(L1, getindex));\n    }\n    else if EQ(\"tointeger\") {\n      lua_pushinteger(L1, lua_tointeger(L1, getindex));\n    }\n    else if EQ(\"tonumber\") {\n      lua_pushnumber(L1, lua_tonumber(L1, getindex));\n    }\n    else if EQ(\"topointer\") {\n      lua_pushlightuserdata(L1, cast_voidp(lua_topointer(L1, getindex)));\n    }\n    else if EQ(\"touserdata\") {\n      lua_pushlightuserdata(L1, lua_touserdata(L1, getindex));\n    }\n    else if EQ(\"tostring\") {\n      const char *s = lua_tostring(L1, getindex);\n      const char *s1 = lua_pushstring(L1, s);\n      cast_void(s1);  /* to avoid warnings */\n      lua_longassert((s == NULL && s1 == NULL) || strcmp(s, s1) == 0);\n    }\n    else if EQ(\"Ltolstring\") {\n      luaL_tolstring(L1, getindex, NULL);\n    }\n    else if EQ(\"type\") {\n      lua_pushstring(L1, luaL_typename(L1, getnum));\n    }\n    else if EQ(\"xmove\") {\n      int f = getindex;\n      int t = getindex;\n      lua_State *fs = (f == 0) ? L1 : lua_tothread(L1, f);\n      lua_State *ts = (t == 0) ? L1 : lua_tothread(L1, t);\n      int n = getnum;\n      if (n == 0) n = lua_gettop(fs);\n      lua_xmove(fs, ts, n);\n    }\n    else if EQ(\"isyieldable\") {\n      lua_pushboolean(L1, lua_isyieldable(lua_tothread(L1, getindex)));\n    }\n    else if EQ(\"yield\") {\n      return lua_yield(L1, getnum);\n    }\n    else if EQ(\"yieldk\") {\n      int nres = getnum;\n      int i = getindex;\n      return lua_yieldk(L1, nres, i, Cfunck);\n    }\n    else if EQ(\"toclose\") {\n      lua_toclose(L1, getnum);\n    }\n    else if EQ(\"closeslot\") {\n      lua_closeslot(L1, getnum);\n    }\n    else luaL_error(L, \"unknown instruction %s\", buff);\n  }\n  return 0;\n}\n\n\nstatic int testC (lua_State *L) {\n  lua_State *L1;\n  const char *pc;\n  if (lua_isuserdata(L, 1)) {\n    L1 = getstate(L);\n    pc = luaL_checkstring(L, 2);\n  }\n  else if (lua_isthread(L, 1)) {\n    L1 = lua_tothread(L, 1);\n    pc = luaL_checkstring(L, 2);\n  }\n  else {\n    L1 = L;\n    pc = luaL_checkstring(L, 1);\n  }\n  return runC(L, L1, pc);\n}\n\n\nstatic int Cfunc (lua_State *L) {\n  return runC(L, L, lua_tostring(L, lua_upvalueindex(1)));\n}\n\n\nstatic int Cfunck (lua_State *L, int status, lua_KContext ctx) {\n  lua_pushstring(L, statcodes[status]);\n  lua_setglobal(L, \"status\");\n  lua_pushinteger(L, ctx);\n  lua_setglobal(L, \"ctx\");\n  return runC(L, L, lua_tostring(L, ctx));\n}\n\n\nstatic int makeCfunc (lua_State *L) {\n  luaL_checkstring(L, 1);\n  lua_pushcclosure(L, Cfunc, lua_gettop(L));\n  return 1;\n}\n\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** tests for C hooks\n** =======================================================\n*/\n\n/*\n** C hook that runs the C script stored in registry.C_HOOK[L]\n*/\nstatic void Chook (lua_State *L, lua_Debug *ar) {\n  const char *scpt;\n  const char *const events [] = {\"call\", \"ret\", \"line\", \"count\", \"tailcall\"};\n  lua_getfield(L, LUA_REGISTRYINDEX, \"C_HOOK\");\n  lua_pushlightuserdata(L, L);\n  lua_gettable(L, -2);  /* get C_HOOK[L] (script saved by sethookaux) */\n  scpt = lua_tostring(L, -1);  /* not very religious (string will be popped) */\n  lua_pop(L, 2);  /* remove C_HOOK and script */\n  lua_pushstring(L, events[ar->event]);  /* may be used by script */\n  lua_pushinteger(L, ar->currentline);  /* may be used by script */\n  runC(L, L, scpt);  /* run script from C_HOOK[L] */\n}\n\n\n/*\n** sets 'registry.C_HOOK[L] = scpt' and sets 'Chook' as a hook\n*/\nstatic void sethookaux (lua_State *L, int mask, int count, const char *scpt) {\n  if (*scpt == '\\0') {  /* no script? */\n    lua_sethook(L, NULL, 0, 0);  /* turn off hooks */\n    return;\n  }\n  lua_getfield(L, LUA_REGISTRYINDEX, \"C_HOOK\");  /* get C_HOOK table */\n  if (!lua_istable(L, -1)) {  /* no hook table? */\n    lua_pop(L, 1);  /* remove previous value */\n    lua_newtable(L);  /* create new C_HOOK table */\n    lua_pushvalue(L, -1);\n    lua_setfield(L, LUA_REGISTRYINDEX, \"C_HOOK\");  /* register it */\n  }\n  lua_pushlightuserdata(L, L);\n  lua_pushstring(L, scpt);\n  lua_settable(L, -3);  /* C_HOOK[L] = script */\n  lua_sethook(L, Chook, mask, count);\n}\n\n\nstatic int sethook (lua_State *L) {\n  if (lua_isnoneornil(L, 1))\n    lua_sethook(L, NULL, 0, 0);  /* turn off hooks */\n  else {\n    const char *scpt = luaL_checkstring(L, 1);\n    const char *smask = luaL_checkstring(L, 2);\n    int count = cast_int(luaL_optinteger(L, 3, 0));\n    int mask = 0;\n    if (strchr(smask, 'c')) mask |= LUA_MASKCALL;\n    if (strchr(smask, 'r')) mask |= LUA_MASKRET;\n    if (strchr(smask, 'l')) mask |= LUA_MASKLINE;\n    if (count > 0) mask |= LUA_MASKCOUNT;\n    sethookaux(L, mask, count, scpt);\n  }\n  return 0;\n}\n\n\nstatic int coresume (lua_State *L) {\n  int status, nres;\n  lua_State *co = lua_tothread(L, 1);\n  luaL_argcheck(L, co, 1, \"coroutine expected\");\n  status = lua_resume(co, L, 0, &nres);\n  if (status != LUA_OK && status != LUA_YIELD) {\n    lua_pushboolean(L, 0);\n    lua_insert(L, -2);\n    return 2;  /* return false + error message */\n  }\n  else {\n    lua_pushboolean(L, 1);\n    return 1;\n  }\n}\n\n/* }====================================================== */\n\n\n\nstatic const struct luaL_Reg tests_funcs[] = {\n  {\"checkmemory\", lua_checkmemory},\n  {\"closestate\", closestate},\n  {\"d2s\", d2s},\n  {\"doonnewstack\", doonnewstack},\n  {\"doremote\", doremote},\n  {\"gccolor\", gc_color},\n  {\"gcage\", gc_age},\n  {\"gcstate\", gc_state},\n  {\"pobj\", gc_printobj},\n  {\"getref\", getref},\n  {\"hash\", hash_query},\n  {\"log2\", log2_aux},\n  {\"limits\", get_limits},\n  {\"listcode\", listcode},\n  {\"printcode\", printcode},\n  {\"listk\", listk},\n  {\"listabslineinfo\", listabslineinfo},\n  {\"listlocals\", listlocals},\n  {\"loadlib\", loadlib},\n  {\"checkpanic\", checkpanic},\n  {\"newstate\", newstate},\n  {\"newuserdata\", newuserdata},\n  {\"num2int\", num2int},\n  {\"makeseed\", makeseed},\n  {\"pushuserdata\", pushuserdata},\n  {\"querystr\", string_query},\n  {\"querytab\", table_query},\n  {\"queryGCparams\", query_GCparams},\n  {\"codeparam\", test_codeparam},\n  {\"applyparam\", test_applyparam},\n  {\"ref\", tref},\n  {\"resume\", coresume},\n  {\"s2d\", s2d},\n  {\"sethook\", sethook},\n  {\"stacklevel\", stacklevel},\n  {\"testC\", testC},\n  {\"makeCfunc\", makeCfunc},\n  {\"totalmem\", mem_query},\n  {\"alloccount\", alloc_count},\n  {\"allocfailnext\", alloc_failnext},\n  {\"trick\", settrick},\n  {\"udataval\", udataval},\n  {\"unref\", unref},\n  {\"upvalue\", upvalue},\n  {\"externKstr\", externKstr},\n  {\"externstr\", externstr},\n  {NULL, NULL}\n};\n\n\nstatic void checkfinalmem (void) {\n  lua_assert(l_memcontrol.numblocks == 0);\n  lua_assert(l_memcontrol.total == 0);\n}\n\n\nint luaB_opentests (lua_State *L) {\n  void *ud;\n  lua_Alloc f = lua_getallocf(L, &ud);\n  lua_atpanic(L, &tpanic);\n  lua_setwarnf(L, &warnf, L);\n  lua_pushboolean(L, 0);\n  lua_setglobal(L, \"_WARN\");  /* _WARN = false */\n  regcodes(L);\n  atexit(checkfinalmem);\n  lua_assert(f == debug_realloc && ud == cast_voidp(&l_memcontrol));\n  lua_setallocf(L, f, ud);  /* exercise this function */\n  luaL_newlib(L, tests_funcs);\n  return 1;\n}\n\n#endif\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/ltests.h",
		"is_binary":	false,
		"content":	"/*\n** $Id: ltests.h $\n** Internal Header for Debugging of the Lua Implementation\n** See Copyright Notice in lua.h\n*/\n\n#ifndef ltests_h\n#define ltests_h\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\n/* test Lua with compatibility code */\n#define LUA_COMPAT_MATHLIB\n#define LUA_COMPAT_LT_LE\n\n\n#define LUA_DEBUG\n\n\n/* turn on assertions */\n#define LUAI_ASSERT\n\n\n/* to avoid warnings, and to make sure value is really unused */\n#define UNUSED(x)       (x=0, (void)(x))\n\n\n/* test for sizes in 'l_sprintf' (make sure whole buffer is available) */\n#undef l_sprintf\n#if !defined(LUA_USE_C89)\n#define l_sprintf(s,sz,f,i)\t(memset(s,0xAB,sz), snprintf(s,sz,f,i))\n#else\n#define l_sprintf(s,sz,f,i)\t(memset(s,0xAB,sz), sprintf(s,f,i))\n#endif\n\n\n/* get a chance to test code without jump tables */\n#define LUA_USE_JUMPTABLE\t0\n\n\n/* use 32-bit integers in random generator */\n#define LUA_RAND32\n\n\n/* memory-allocator control variables */\ntypedef struct Memcontrol {\n  int failnext;\n  unsigned long numblocks;\n  unsigned long total;\n  unsigned long maxmem;\n  unsigned long memlimit;\n  unsigned long countlimit;\n  unsigned long objcount[LUA_NUMTYPES];\n} Memcontrol;\n\nLUA_API Memcontrol l_memcontrol;\n\n\n/*\n** generic variable for debug tricks\n*/\nextern void *l_Trick;\n\n\n\n/*\n** Function to traverse and check all memory used by Lua\n*/\nLUAI_FUNC int lua_checkmemory (lua_State *L);\n\n/*\n** Function to print an object GC-friendly\n*/\nstruct GCObject;\nLUAI_FUNC void lua_printobj (lua_State *L, struct GCObject *o);\n\n\n/* test for lock/unlock */\n\nstruct L_EXTRA { int lock; int *plock; };\n#undef LUA_EXTRASPACE\n#define LUA_EXTRASPACE\tsizeof(struct L_EXTRA)\n#define getlock(l)\tcast(struct L_EXTRA*, lua_getextraspace(l))\n#define luai_userstateopen(l)  \\\n\t(getlock(l)->lock = 0, getlock(l)->plock = &(getlock(l)->lock))\n#define luai_userstateclose(l)  \\\n  lua_assert(getlock(l)->lock == 1 && getlock(l)->plock == &(getlock(l)->lock))\n#define luai_userstatethread(l,l1) \\\n  lua_assert(getlock(l1)->plock == getlock(l)->plock)\n#define luai_userstatefree(l,l1) \\\n  lua_assert(getlock(l)->plock == getlock(l1)->plock)\n#define lua_lock(l)     lua_assert((*getlock(l)->plock)++ == 0)\n#define lua_unlock(l)   lua_assert(--(*getlock(l)->plock) == 0)\n\n\n\nLUA_API int luaB_opentests (lua_State *L);\n\nLUA_API void *debug_realloc (void *ud, void *block,\n                             size_t osize, size_t nsize);\n\n#if defined(lua_c)\n#define luaL_newstate()  \\\n\tlua_newstate(debug_realloc, &l_memcontrol, luaL_makeseed(NULL))\n#define luai_openlibs(L)  \\\n  {  luaL_openlibs(L); \\\n     luaL_requiref(L, \"T\", luaB_opentests, 1); \\\n     lua_pop(L, 1); }\n#endif\n\n\n\n/* change some sizes to give some bugs a chance */\n\n#undef LUAL_BUFFERSIZE\n#define LUAL_BUFFERSIZE\t\t23\n#define MINSTRTABSIZE\t\t2\n#define MAXIWTHABS\t\t3\n\n#define STRCACHE_N\t23\n#define STRCACHE_M\t5\n\n#undef LUAI_USER_ALIGNMENT_T\n#define LUAI_USER_ALIGNMENT_T   union { char b[sizeof(void*) * 8]; }\n\n\n/*\n** This one is not compatible with tests for opcode optimizations,\n** as it blocks some optimizations\n#define MAXINDEXRK\t0\n*/\n\n\n/* make stack-overflow tests run faster */\n#undef LUAI_MAXSTACK\n#define LUAI_MAXSTACK   50000\n\n\n/* test mode uses more stack space */\n#undef LUAI_MAXCCALLS\n#define LUAI_MAXCCALLS\t180\n\n\n/* force Lua to use its own implementations */\n#undef lua_strx2number\n#undef lua_number2strx\n\n\n#endif\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/ltm.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: ltm.c $\n** Tag methods\n** See Copyright Notice in lua.h\n*/\n\n#define ltm_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lgc.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n#include \"lvm.h\"\n\n\nstatic const char udatatypename[] = \"userdata\";\n\nLUAI_DDEF const char *const luaT_typenames_[LUA_TOTALTYPES] = {\n  \"no value\",\n  \"nil\", \"boolean\", udatatypename, \"number\",\n  \"string\", \"table\", \"function\", udatatypename, \"thread\",\n  \"upvalue\", \"proto\" /* these last cases are used for tests only */\n};\n\n\nvoid luaT_init (lua_State *L) {\n  static const char *const luaT_eventname[] = {  /* ORDER TM */\n    \"__index\", \"__newindex\",\n    \"__gc\", \"__mode\", \"__len\", \"__eq\",\n    \"__add\", \"__sub\", \"__mul\", \"__mod\", \"__pow\",\n    \"__div\", \"__idiv\",\n    \"__band\", \"__bor\", \"__bxor\", \"__shl\", \"__shr\",\n    \"__unm\", \"__bnot\", \"__lt\", \"__le\",\n    \"__concat\", \"__call\", \"__close\"\n  };\n  int i;\n  for (i=0; i<TM_N; i++) {\n    G(L)->tmname[i] = luaS_new(L, luaT_eventname[i]);\n    luaC_fix(L, obj2gco(G(L)->tmname[i]));  /* never collect these names */\n  }\n}\n\n\n/*\n** function to be used with macro \"fasttm\": optimized for absence of\n** tag methods\n*/\nconst TValue *luaT_gettm (Table *events, TMS event, TString *ename) {\n  const TValue *tm = luaH_Hgetshortstr(events, ename);\n  lua_assert(event <= TM_EQ);\n  if (notm(tm)) {  /* no tag method? */\n    events->flags |= cast_byte(1u<<event);  /* cache this fact */\n    return NULL;\n  }\n  else return tm;\n}\n\n\nconst TValue *luaT_gettmbyobj (lua_State *L, const TValue *o, TMS event) {\n  Table *mt;\n  switch (ttype(o)) {\n    case LUA_TTABLE:\n      mt = hvalue(o)->metatable;\n      break;\n    case LUA_TUSERDATA:\n      mt = uvalue(o)->metatable;\n      break;\n    default:\n      mt = G(L)->mt[ttype(o)];\n  }\n  return (mt ? luaH_Hgetshortstr(mt, G(L)->tmname[event]) : &G(L)->nilvalue);\n}\n\n\n/*\n** Return the name of the type of an object. For tables and userdata\n** with metatable, use their '__name' metafield, if present.\n*/\nconst char *luaT_objtypename (lua_State *L, const TValue *o) {\n  Table *mt;\n  if ((ttistable(o) && (mt = hvalue(o)->metatable) != NULL) ||\n      (ttisfulluserdata(o) && (mt = uvalue(o)->metatable) != NULL)) {\n    const TValue *name = luaH_Hgetshortstr(mt, luaS_new(L, \"__name\"));\n    if (ttisstring(name))  /* is '__name' a string? */\n      return getstr(tsvalue(name));  /* use it as type name */\n  }\n  return ttypename(ttype(o));  /* else use standard type name */\n}\n\n\nvoid luaT_callTM (lua_State *L, const TValue *f, const TValue *p1,\n                  const TValue *p2, const TValue *p3) {\n  StkId func = L->top.p;\n  setobj2s(L, func, f);  /* push function (assume EXTRA_STACK) */\n  setobj2s(L, func + 1, p1);  /* 1st argument */\n  setobj2s(L, func + 2, p2);  /* 2nd argument */\n  setobj2s(L, func + 3, p3);  /* 3rd argument */\n  L->top.p = func + 4;\n  /* metamethod may yield only when called from Lua code */\n  if (isLuacode(L->ci))\n    luaD_call(L, func, 0);\n  else\n    luaD_callnoyield(L, func, 0);\n}\n\n\nint luaT_callTMres (lua_State *L, const TValue *f, const TValue *p1,\n                    const TValue *p2, StkId res) {\n  ptrdiff_t result = savestack(L, res);\n  StkId func = L->top.p;\n  setobj2s(L, func, f);  /* push function (assume EXTRA_STACK) */\n  setobj2s(L, func + 1, p1);  /* 1st argument */\n  setobj2s(L, func + 2, p2);  /* 2nd argument */\n  L->top.p += 3;\n  /* metamethod may yield only when called from Lua code */\n  if (isLuacode(L->ci))\n    luaD_call(L, func, 1);\n  else\n    luaD_callnoyield(L, func, 1);\n  res = restorestack(L, result);\n  setobjs2s(L, res, --L->top.p);  /* move result to its place */\n  return ttypetag(s2v(res));  /* return tag of the result */\n}\n\n\nstatic int callbinTM (lua_State *L, const TValue *p1, const TValue *p2,\n                      StkId res, TMS event) {\n  const TValue *tm = luaT_gettmbyobj(L, p1, event);  /* try first operand */\n  if (notm(tm))\n    tm = luaT_gettmbyobj(L, p2, event);  /* try second operand */\n  if (notm(tm))\n    return -1;  /* tag method not found */\n  else  /* call tag method and return the tag of the result */\n    return luaT_callTMres(L, tm, p1, p2, res);\n}\n\n\nvoid luaT_trybinTM (lua_State *L, const TValue *p1, const TValue *p2,\n                    StkId res, TMS event) {\n  if (l_unlikely(callbinTM(L, p1, p2, res, event) < 0)) {\n    switch (event) {\n      case TM_BAND: case TM_BOR: case TM_BXOR:\n      case TM_SHL: case TM_SHR: case TM_BNOT: {\n        if (ttisnumber(p1) && ttisnumber(p2))\n          luaG_tointerror(L, p1, p2);\n        else\n          luaG_opinterror(L, p1, p2, \"perform bitwise operation on\");\n      }\n      /* calls never return, but to avoid warnings: *//* FALLTHROUGH */\n      default:\n        luaG_opinterror(L, p1, p2, \"perform arithmetic on\");\n    }\n  }\n}\n\n\n/*\n** The use of 'p1' after 'callbinTM' is safe because, when a tag\n** method is not found, 'callbinTM' cannot change the stack.\n*/\nvoid luaT_tryconcatTM (lua_State *L) {\n  StkId p1 = L->top.p - 2;  /* first argument */\n  if (l_unlikely(callbinTM(L, s2v(p1), s2v(p1 + 1), p1, TM_CONCAT) < 0))\n    luaG_concaterror(L, s2v(p1), s2v(p1 + 1));\n}\n\n\nvoid luaT_trybinassocTM (lua_State *L, const TValue *p1, const TValue *p2,\n                                       int flip, StkId res, TMS event) {\n  if (flip)\n    luaT_trybinTM(L, p2, p1, res, event);\n  else\n    luaT_trybinTM(L, p1, p2, res, event);\n}\n\n\nvoid luaT_trybiniTM (lua_State *L, const TValue *p1, lua_Integer i2,\n                                   int flip, StkId res, TMS event) {\n  TValue aux;\n  setivalue(&aux, i2);\n  luaT_trybinassocTM(L, p1, &aux, flip, res, event);\n}\n\n\n/*\n** Calls an order tag method.\n** For lessequal, LUA_COMPAT_LT_LE keeps compatibility with old\n** behavior: if there is no '__le', try '__lt', based on l <= r iff\n** !(r < l) (assuming a total order). If the metamethod yields during\n** this substitution, the continuation has to know about it (to negate\n** the result of r<l); bit CIST_LEQ in the call status keeps that\n** information.\n*/\nint luaT_callorderTM (lua_State *L, const TValue *p1, const TValue *p2,\n                      TMS event) {\n  int tag = callbinTM(L, p1, p2, L->top.p, event);  /* try original event */\n  if (tag >= 0)  /* found tag method? */\n    return !tagisfalse(tag);\n#if defined(LUA_COMPAT_LT_LE)\n  else if (event == TM_LE) {\n    /* try '!(p2 < p1)' for '(p1 <= p2)' */\n    L->ci->callstatus |= CIST_LEQ;  /* mark it is doing 'lt' for 'le' */\n    tag = callbinTM(L, p2, p1, L->top.p, TM_LT);\n    L->ci->callstatus ^= CIST_LEQ;  /* clear mark */\n    if (tag >= 0)  /* found tag method? */\n      return tagisfalse(tag);\n  }\n#endif\n  luaG_ordererror(L, p1, p2);  /* no metamethod found */\n  return 0;  /* to avoid warnings */\n}\n\n\nint luaT_callorderiTM (lua_State *L, const TValue *p1, int v2,\n                       int flip, int isfloat, TMS event) {\n  TValue aux; const TValue *p2;\n  if (isfloat) {\n    setfltvalue(&aux, cast_num(v2));\n  }\n  else\n    setivalue(&aux, v2);\n  if (flip) {  /* arguments were exchanged? */\n    p2 = p1; p1 = &aux;  /* correct them */\n  }\n  else\n    p2 = &aux;\n  return luaT_callorderTM(L, p1, p2, event);\n}\n\n\nvoid luaT_adjustvarargs (lua_State *L, int nfixparams, CallInfo *ci,\n                         const Proto *p) {\n  int i;\n  int actual = cast_int(L->top.p - ci->func.p) - 1;  /* number of arguments */\n  int nextra = actual - nfixparams;  /* number of extra arguments */\n  ci->u.l.nextraargs = nextra;\n  luaD_checkstack(L, p->maxstacksize + 1);\n  /* copy function to the top of the stack */\n  setobjs2s(L, L->top.p++, ci->func.p);\n  /* move fixed parameters to the top of the stack */\n  for (i = 1; i <= nfixparams; i++) {\n    setobjs2s(L, L->top.p++, ci->func.p + i);\n    setnilvalue(s2v(ci->func.p + i));  /* erase original parameter (for GC) */\n  }\n  ci->func.p += actual + 1;\n  ci->top.p += actual + 1;\n  lua_assert(L->top.p <= ci->top.p && ci->top.p <= L->stack_last.p);\n}\n\n\nvoid luaT_getvarargs (lua_State *L, CallInfo *ci, StkId where, int wanted) {\n  int i;\n  int nextra = ci->u.l.nextraargs;\n  if (wanted < 0) {\n    wanted = nextra;  /* get all extra arguments available */\n    checkstackp(L, nextra, where);  /* ensure stack space */\n    L->top.p = where + nextra;  /* next instruction will need top */\n  }\n  for (i = 0; i < wanted && i < nextra; i++)\n    setobjs2s(L, where + i, ci->func.p - nextra + i);\n  for (; i < wanted; i++)   /* complete required results with nil */\n    setnilvalue(s2v(where + i));\n}\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/ltm.h",
		"is_binary":	false,
		"content":	"/*\n** $Id: ltm.h $\n** Tag methods\n** See Copyright Notice in lua.h\n*/\n\n#ifndef ltm_h\n#define ltm_h\n\n\n#include \"lobject.h\"\n\n\n/*\n* WARNING: if you change the order of this enumeration,\n* grep \"ORDER TM\" and \"ORDER OP\"\n*/\ntypedef enum {\n  TM_INDEX,\n  TM_NEWINDEX,\n  TM_GC,\n  TM_MODE,\n  TM_LEN,\n  TM_EQ,  /* last tag method with fast access */\n  TM_ADD,\n  TM_SUB,\n  TM_MUL,\n  TM_MOD,\n  TM_POW,\n  TM_DIV,\n  TM_IDIV,\n  TM_BAND,\n  TM_BOR,\n  TM_BXOR,\n  TM_SHL,\n  TM_SHR,\n  TM_UNM,\n  TM_BNOT,\n  TM_LT,\n  TM_LE,\n  TM_CONCAT,\n  TM_CALL,\n  TM_CLOSE,\n  TM_N\t\t/* number of elements in the enum */\n} TMS;\n\n\n/*\n** Mask with 1 in all fast-access methods. A 1 in any of these bits\n** in the flag of a (meta)table means the metatable does not have the\n** corresponding metamethod field. (Bit 6 of the flag indicates that\n** the table is using the dummy node; bit 7 is used for 'isrealasize'.)\n*/\n#define maskflags\t(~(~0u << (TM_EQ + 1)))\n\n\n/*\n** Test whether there is no tagmethod.\n** (Because tagmethods use raw accesses, the result may be an \"empty\" nil.)\n*/\n#define notm(tm)\tttisnil(tm)\n\n#define checknoTM(mt,e)\t((mt) == NULL || (mt)->flags & (1u<<(e)))\n\n#define gfasttm(g,mt,e)  \\\n  (checknoTM(mt, e) ? NULL : luaT_gettm(mt, e, (g)->tmname[e]))\n\n#define fasttm(l,mt,e)\tgfasttm(G(l), mt, e)\n\n#define ttypename(x)\tluaT_typenames_[(x) + 1]\n\nLUAI_DDEC(const char *const luaT_typenames_[LUA_TOTALTYPES];)\n\n\nLUAI_FUNC const char *luaT_objtypename (lua_State *L, const TValue *o);\n\nLUAI_FUNC const TValue *luaT_gettm (Table *events, TMS event, TString *ename);\nLUAI_FUNC const TValue *luaT_gettmbyobj (lua_State *L, const TValue *o,\n                                                       TMS event);\nLUAI_FUNC void luaT_init (lua_State *L);\n\nLUAI_FUNC void luaT_callTM (lua_State *L, const TValue *f, const TValue *p1,\n                            const TValue *p2, const TValue *p3);\nLUAI_FUNC int luaT_callTMres (lua_State *L, const TValue *f,\n                              const TValue *p1, const TValue *p2, StkId p3);\nLUAI_FUNC void luaT_trybinTM (lua_State *L, const TValue *p1, const TValue *p2,\n                              StkId res, TMS event);\nLUAI_FUNC void luaT_tryconcatTM (lua_State *L);\nLUAI_FUNC void luaT_trybinassocTM (lua_State *L, const TValue *p1,\n       const TValue *p2, int inv, StkId res, TMS event);\nLUAI_FUNC void luaT_trybiniTM (lua_State *L, const TValue *p1, lua_Integer i2,\n                               int inv, StkId res, TMS event);\nLUAI_FUNC int luaT_callorderTM (lua_State *L, const TValue *p1,\n                                const TValue *p2, TMS event);\nLUAI_FUNC int luaT_callorderiTM (lua_State *L, const TValue *p1, int v2,\n                                 int inv, int isfloat, TMS event);\n\nLUAI_FUNC void luaT_adjustvarargs (lua_State *L, int nfixparams,\n                                   struct CallInfo *ci, const Proto *p);\nLUAI_FUNC void luaT_getvarargs (lua_State *L, struct CallInfo *ci,\n                                              StkId where, int wanted);\n\n\n#endif\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lua.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: lua.c $\n** Lua stand-alone interpreter\n** See Copyright Notice in lua.h\n*/\n\n#define lua_c\n\n#include \"lprefix.h\"\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <signal.h>\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n\n\n#if !defined(LUA_PROGNAME)\n#define LUA_PROGNAME\t\t\"lua\"\n#endif\n\n#if !defined(LUA_INIT_VAR)\n#define LUA_INIT_VAR\t\t\"LUA_INIT\"\n#endif\n\n#define LUA_INITVARVERSION\tLUA_INIT_VAR LUA_VERSUFFIX\n\n\nstatic lua_State *globalL = NULL;\n\nstatic const char *progname = LUA_PROGNAME;\n\n\n#if defined(LUA_USE_POSIX)   /* { */\n\n/*\n** Use 'sigaction' when available.\n*/\nstatic void setsignal (int sig, void (*handler)(int)) {\n  struct sigaction sa;\n  sa.sa_handler = handler;\n  sa.sa_flags = 0;\n  sigemptyset(&sa.sa_mask);  /* do not mask any signal */\n  sigaction(sig, &sa, NULL);\n}\n\n#else           /* }{ */\n\n#define setsignal            signal\n\n#endif                               /* } */\n\n\n/*\n** Hook set by signal function to stop the interpreter.\n*/\nstatic void lstop (lua_State *L, lua_Debug *ar) {\n  (void)ar;  /* unused arg. */\n  lua_sethook(L, NULL, 0, 0);  /* reset hook */\n  luaL_error(L, \"interrupted!\");\n}\n\n\n/*\n** Function to be called at a C signal. Because a C signal cannot\n** just change a Lua state (as there is no proper synchronization),\n** this function only sets a hook that, when called, will stop the\n** interpreter.\n*/\nstatic void laction (int i) {\n  int flag = LUA_MASKCALL | LUA_MASKRET | LUA_MASKLINE | LUA_MASKCOUNT;\n  setsignal(i, SIG_DFL); /* if another SIGINT happens, terminate process */\n  lua_sethook(globalL, lstop, flag, 1);\n}\n\n\nstatic void print_usage (const char *badoption) {\n  lua_writestringerror(\"%s: \", progname);\n  if (badoption[1] == 'e' || badoption[1] == 'l')\n    lua_writestringerror(\"'%s' needs argument\\n\", badoption);\n  else\n    lua_writestringerror(\"unrecognized option '%s'\\n\", badoption);\n  lua_writestringerror(\n  \"usage: %s [options] [script [args]]\\n\"\n  \"Available options are:\\n\"\n  \"  -e stat   execute string 'stat'\\n\"\n  \"  -i        enter interactive mode after executing 'script'\\n\"\n  \"  -l mod    require library 'mod' into global 'mod'\\n\"\n  \"  -l g=mod  require library 'mod' into global 'g'\\n\"\n  \"  -v        show version information\\n\"\n  \"  -E        ignore environment variables\\n\"\n  \"  -W        turn warnings on\\n\"\n  \"  --        stop handling options\\n\"\n  \"  -         stop handling options and execute stdin\\n\"\n  ,\n  progname);\n}\n\n\n/*\n** Prints an error message, adding the program name in front of it\n** (if present)\n*/\nstatic void l_message (const char *pname, const char *msg) {\n  if (pname) lua_writestringerror(\"%s: \", pname);\n  lua_writestringerror(\"%s\\n\", msg);\n}\n\n\n/*\n** Check whether 'status' is not OK and, if so, prints the error\n** message on the top of the stack. It assumes that the error object\n** is a string, as it was either generated by Lua or by 'msghandler'.\n*/\nstatic int report (lua_State *L, int status) {\n  if (status != LUA_OK) {\n    const char *msg = lua_tostring(L, -1);\n    l_message(progname, msg);\n    lua_pop(L, 1);  /* remove message */\n  }\n  return status;\n}\n\n\n/*\n** Message handler used to run all chunks\n*/\nstatic int msghandler (lua_State *L) {\n  const char *msg = lua_tostring(L, 1);\n  if (msg == NULL) {  /* is error object not a string? */\n    if (luaL_callmeta(L, 1, \"__tostring\") &&  /* does it have a metamethod */\n        lua_type(L, -1) == LUA_TSTRING)  /* that produces a string? */\n      return 1;  /* that is the message */\n    else\n      msg = lua_pushfstring(L, \"(error object is a %s value)\",\n                               luaL_typename(L, 1));\n  }\n  luaL_traceback(L, L, msg, 1);  /* append a standard traceback */\n  return 1;  /* return the traceback */\n}\n\n\n/*\n** Interface to 'lua_pcall', which sets appropriate message function\n** and C-signal handler. Used to run all chunks.\n*/\nstatic int docall (lua_State *L, int narg, int nres) {\n  int status;\n  int base = lua_gettop(L) - narg;  /* function index */\n  lua_pushcfunction(L, msghandler);  /* push message handler */\n  lua_insert(L, base);  /* put it under function and args */\n  globalL = L;  /* to be available to 'laction' */\n  setsignal(SIGINT, laction);  /* set C-signal handler */\n  status = lua_pcall(L, narg, nres, base);\n  setsignal(SIGINT, SIG_DFL); /* reset C-signal handler */\n  lua_remove(L, base);  /* remove message handler from the stack */\n  return status;\n}\n\n\nstatic void print_version (void) {\n  lua_writestring(LUA_COPYRIGHT, strlen(LUA_COPYRIGHT));\n  lua_writeline();\n}\n\n\n/*\n** Create the 'arg' table, which stores all arguments from the\n** command line ('argv'). It should be aligned so that, at index 0,\n** it has 'argv[script]', which is the script name. The arguments\n** to the script (everything after 'script') go to positive indices;\n** other arguments (before the script name) go to negative indices.\n** If there is no script name, assume interpreter's name as base.\n** (If there is no interpreter's name either, 'script' is -1, so\n** table sizes are zero.)\n*/\nstatic void createargtable (lua_State *L, char **argv, int argc, int script) {\n  int i, narg;\n  narg = argc - (script + 1);  /* number of positive indices */\n  lua_createtable(L, narg, script + 1);\n  for (i = 0; i < argc; i++) {\n    lua_pushstring(L, argv[i]);\n    lua_rawseti(L, -2, i - script);\n  }\n  lua_setglobal(L, \"arg\");\n}\n\n\nstatic int dochunk (lua_State *L, int status) {\n  if (status == LUA_OK) status = docall(L, 0, 0);\n  return report(L, status);\n}\n\n\nstatic int dofile (lua_State *L, const char *name) {\n  return dochunk(L, luaL_loadfile(L, name));\n}\n\n\nstatic int dostring (lua_State *L, const char *s, const char *name) {\n  return dochunk(L, luaL_loadbuffer(L, s, strlen(s), name));\n}\n\n\n/*\n** Receives 'globname[=modname]' and runs 'globname = require(modname)'.\n** If there is no explicit modname and globname contains a '-', cut\n** the sufix after '-' (the \"version\") to make the global name.\n*/\nstatic int dolibrary (lua_State *L, char *globname) {\n  int status;\n  char *suffix = NULL;\n  char *modname = strchr(globname, '=');\n  if (modname == NULL) {  /* no explicit name? */\n    modname = globname;  /* module name is equal to global name */\n    suffix = strchr(modname, *LUA_IGMARK);  /* look for a suffix mark */\n  }\n  else {\n    *modname = '\\0';  /* global name ends here */\n    modname++;  /* module name starts after the '=' */\n  }\n  lua_getglobal(L, \"require\");\n  lua_pushstring(L, modname);\n  status = docall(L, 1, 1);  /* call 'require(modname)' */\n  if (status == LUA_OK) {\n    if (suffix != NULL)  /* is there a suffix mark? */\n      *suffix = '\\0';  /* remove sufix from global name */\n    lua_setglobal(L, globname);  /* globname = require(modname) */\n  }\n  return report(L, status);\n}\n\n\n/*\n** Push on the stack the contents of table 'arg' from 1 to #arg\n*/\nstatic int pushargs (lua_State *L) {\n  int i, n;\n  if (lua_getglobal(L, \"arg\") != LUA_TTABLE)\n    luaL_error(L, \"'arg' is not a table\");\n  n = (int)luaL_len(L, -1);\n  luaL_checkstack(L, n + 3, \"too many arguments to script\");\n  for (i = 1; i <= n; i++)\n    lua_rawgeti(L, -i, i);\n  lua_remove(L, -i);  /* remove table from the stack */\n  return n;\n}\n\n\nstatic int handle_script (lua_State *L, char **argv) {\n  int status;\n  const char *fname = argv[0];\n  if (strcmp(fname, \"-\") == 0 && strcmp(argv[-1], \"--\") != 0)\n    fname = NULL;  /* stdin */\n  status = luaL_loadfile(L, fname);\n  if (status == LUA_OK) {\n    int n = pushargs(L);  /* push arguments to script */\n    status = docall(L, n, LUA_MULTRET);\n  }\n  return report(L, status);\n}\n\n\n/* bits of various argument indicators in 'args' */\n#define has_error\t1\t/* bad option */\n#define has_i\t\t2\t/* -i */\n#define has_v\t\t4\t/* -v */\n#define has_e\t\t8\t/* -e */\n#define has_E\t\t16\t/* -E */\n\n\n/*\n** Traverses all arguments from 'argv', returning a mask with those\n** needed before running any Lua code or an error code if it finds any\n** invalid argument. In case of error, 'first' is the index of the bad\n** argument.  Otherwise, 'first' is -1 if there is no program name,\n** 0 if there is no script name, or the index of the script name.\n*/\nstatic int collectargs (char **argv, int *first) {\n  int args = 0;\n  int i;\n  if (argv[0] != NULL) {  /* is there a program name? */\n    if (argv[0][0])  /* not empty? */\n      progname = argv[0];  /* save it */\n  }\n  else {  /* no program name */\n    *first = -1;\n    return 0;\n  }\n  for (i = 1; argv[i] != NULL; i++) {  /* handle arguments */\n    *first = i;\n    if (argv[i][0] != '-')  /* not an option? */\n        return args;  /* stop handling options */\n    switch (argv[i][1]) {  /* else check option */\n      case '-':  /* '--' */\n        if (argv[i][2] != '\\0')  /* extra characters after '--'? */\n          return has_error;  /* invalid option */\n        *first = i + 1;\n        return args;\n      case '\\0':  /* '-' */\n        return args;  /* script \"name\" is '-' */\n      case 'E':\n        if (argv[i][2] != '\\0')  /* extra characters? */\n          return has_error;  /* invalid option */\n        args |= has_E;\n        break;\n      case 'W':\n        if (argv[i][2] != '\\0')  /* extra characters? */\n          return has_error;  /* invalid option */\n        break;\n      case 'i':\n        args |= has_i;  /* (-i implies -v) *//* FALLTHROUGH */\n      case 'v':\n        if (argv[i][2] != '\\0')  /* extra characters? */\n          return has_error;  /* invalid option */\n        args |= has_v;\n        break;\n      case 'e':\n        args |= has_e;  /* FALLTHROUGH */\n      case 'l':  /* both options need an argument */\n        if (argv[i][2] == '\\0') {  /* no concatenated argument? */\n          i++;  /* try next 'argv' */\n          if (argv[i] == NULL || argv[i][0] == '-')\n            return has_error;  /* no next argument or it is another option */\n        }\n        break;\n      default:  /* invalid option */\n        return has_error;\n    }\n  }\n  *first = 0;  /* no script name */\n  return args;\n}\n\n\n/*\n** Processes options 'e' and 'l', which involve running Lua code, and\n** 'W', which also affects the state.\n** Returns 0 if some code raises an error.\n*/\nstatic int runargs (lua_State *L, char **argv, int n) {\n  int i;\n  for (i = 1; i < n; i++) {\n    int option = argv[i][1];\n    lua_assert(argv[i][0] == '-');  /* already checked */\n    switch (option) {\n      case 'e':  case 'l': {\n        int status;\n        char *extra = argv[i] + 2;  /* both options need an argument */\n        if (*extra == '\\0') extra = argv[++i];\n        lua_assert(extra != NULL);\n        status = (option == 'e')\n                 ? dostring(L, extra, \"=(command line)\")\n                 : dolibrary(L, extra);\n        if (status != LUA_OK) return 0;\n        break;\n      }\n      case 'W':\n        lua_warning(L, \"@on\", 0);  /* warnings on */\n        break;\n    }\n  }\n  return 1;\n}\n\n\nstatic int handle_luainit (lua_State *L) {\n  const char *name = \"=\" LUA_INITVARVERSION;\n  const char *init = getenv(name + 1);\n  if (init == NULL) {\n    name = \"=\" LUA_INIT_VAR;\n    init = getenv(name + 1);  /* try alternative name */\n  }\n  if (init == NULL) return LUA_OK;\n  else if (init[0] == '@')\n    return dofile(L, init+1);\n  else\n    return dostring(L, init, name);\n}\n\n\n/*\n** {==================================================================\n** Read-Eval-Print Loop (REPL)\n** ===================================================================\n*/\n\n#if !defined(LUA_PROMPT)\n#define LUA_PROMPT\t\t\"> \"\n#define LUA_PROMPT2\t\t\">> \"\n#endif\n\n#if !defined(LUA_MAXINPUT)\n#define LUA_MAXINPUT\t\t512\n#endif\n\n\n/*\n** lua_stdin_is_tty detects whether the standard input is a 'tty' (that\n** is, whether we're running lua interactively).\n*/\n#if !defined(lua_stdin_is_tty)\t/* { */\n\n#if defined(LUA_USE_POSIX)\t/* { */\n\n#include <unistd.h>\n#define lua_stdin_is_tty()\tisatty(0)\n\n#elif defined(LUA_USE_WINDOWS)\t/* }{ */\n\n#include <io.h>\n#include <windows.h>\n\n#define lua_stdin_is_tty()\t_isatty(_fileno(stdin))\n\n#else\t\t\t\t/* }{ */\n\n/* ISO C definition */\n#define lua_stdin_is_tty()\t1  /* assume stdin is a tty */\n\n#endif\t\t\t\t/* } */\n\n#endif\t\t\t\t/* } */\n\n\n/*\n** lua_readline defines how to show a prompt and then read a line from\n** the standard input.\n** lua_saveline defines how to \"save\" a read line in a \"history\".\n** lua_freeline defines how to free a line read by lua_readline.\n*/\n#if !defined(lua_readline)\t/* { */\n\n#if defined(LUA_USE_READLINE)\t/* { */\n\n#include <readline/readline.h>\n#include <readline/history.h>\n#define lua_initreadline(L)\t((void)L, rl_readline_name=\"lua\")\n#define lua_readline(L,b,p)\t((void)L, ((b)=readline(p)) != NULL)\n#define lua_saveline(L,line)\t((void)L, add_history(line))\n#define lua_freeline(L,b)\t((void)L, free(b))\n\n#else\t\t\t\t/* }{ */\n\n#define lua_initreadline(L)  ((void)L)\n#define lua_readline(L,b,p) \\\n        ((void)L, fputs(p, stdout), fflush(stdout),  /* show prompt */ \\\n        fgets(b, LUA_MAXINPUT, stdin) != NULL)  /* get line */\n#define lua_saveline(L,line)\t{ (void)L; (void)line; }\n#define lua_freeline(L,b)\t{ (void)L; (void)b; }\n\n#endif\t\t\t\t/* } */\n\n#endif\t\t\t\t/* } */\n\n\n/*\n** Return the string to be used as a prompt by the interpreter. Leave\n** the string (or nil, if using the default value) on the stack, to keep\n** it anchored.\n*/\nstatic const char *get_prompt (lua_State *L, int firstline) {\n  if (lua_getglobal(L, firstline ? \"_PROMPT\" : \"_PROMPT2\") == LUA_TNIL)\n    return (firstline ? LUA_PROMPT : LUA_PROMPT2);  /* use the default */\n  else {  /* apply 'tostring' over the value */\n    const char *p = luaL_tolstring(L, -1, NULL);\n    lua_remove(L, -2);  /* remove original value */\n    return p;\n  }\n}\n\n/* mark in error messages for incomplete statements */\n#define EOFMARK\t\t\"<eof>\"\n#define marklen\t\t(sizeof(EOFMARK)/sizeof(char) - 1)\n\n\n/*\n** Check whether 'status' signals a syntax error and the error\n** message at the top of the stack ends with the above mark for\n** incomplete statements.\n*/\nstatic int incomplete (lua_State *L, int status) {\n  if (status == LUA_ERRSYNTAX) {\n    size_t lmsg;\n    const char *msg = lua_tolstring(L, -1, &lmsg);\n    if (lmsg >= marklen && strcmp(msg + lmsg - marklen, EOFMARK) == 0) {\n      lua_pop(L, 1);\n      return 1;\n    }\n  }\n  return 0;  /* else... */\n}\n\n\n/*\n** Prompt the user, read a line, and push it into the Lua stack.\n*/\nstatic int pushline (lua_State *L, int firstline) {\n  char buffer[LUA_MAXINPUT];\n  char *b = buffer;\n  size_t l;\n  const char *prmt = get_prompt(L, firstline);\n  int readstatus = lua_readline(L, b, prmt);\n  if (readstatus == 0)\n    return 0;  /* no input (prompt will be popped by caller) */\n  lua_pop(L, 1);  /* remove prompt */\n  l = strlen(b);\n  if (l > 0 && b[l-1] == '\\n')  /* line ends with newline? */\n    b[--l] = '\\0';  /* remove it */\n  if (firstline && b[0] == '=')  /* for compatibility with 5.2, ... */\n    lua_pushfstring(L, \"return %s\", b + 1);  /* change '=' to 'return' */\n  else\n    lua_pushlstring(L, b, l);\n  lua_freeline(L, b);\n  return 1;\n}\n\n\n/*\n** Try to compile line on the stack as 'return <line>;'; on return, stack\n** has either compiled chunk or original line (if compilation failed).\n*/\nstatic int addreturn (lua_State *L) {\n  const char *line = lua_tostring(L, -1);  /* original line */\n  const char *retline = lua_pushfstring(L, \"return %s;\", line);\n  int status = luaL_loadbuffer(L, retline, strlen(retline), \"=stdin\");\n  if (status == LUA_OK) {\n    lua_remove(L, -2);  /* remove modified line */\n    if (line[0] != '\\0')  /* non empty? */\n      lua_saveline(L, line);  /* keep history */\n  }\n  else\n    lua_pop(L, 2);  /* pop result from 'luaL_loadbuffer' and modified line */\n  return status;\n}\n\n\n/*\n** Read multiple lines until a complete Lua statement\n*/\nstatic int multiline (lua_State *L) {\n  for (;;) {  /* repeat until gets a complete statement */\n    size_t len;\n    const char *line = lua_tolstring(L, 1, &len);  /* get what it has */\n    int status = luaL_loadbuffer(L, line, len, \"=stdin\");  /* try it */\n    if (!incomplete(L, status) || !pushline(L, 0)) {\n      lua_saveline(L, line);  /* keep history */\n      return status;  /* cannot or should not try to add continuation line */\n    }\n    lua_pushliteral(L, \"\\n\");  /* add newline... */\n    lua_insert(L, -2);  /* ...between the two lines */\n    lua_concat(L, 3);  /* join them */\n  }\n}\n\n\n/*\n** Read a line and try to load (compile) it first as an expression (by\n** adding \"return \" in front of it) and second as a statement. Return\n** the final status of load/call with the resulting function (if any)\n** in the top of the stack.\n*/\nstatic int loadline (lua_State *L) {\n  int status;\n  lua_settop(L, 0);\n  if (!pushline(L, 1))\n    return -1;  /* no input */\n  if ((status = addreturn(L)) != LUA_OK)  /* 'return ...' did not work? */\n    status = multiline(L);  /* try as command, maybe with continuation lines */\n  lua_remove(L, 1);  /* remove line from the stack */\n  lua_assert(lua_gettop(L) == 1);\n  return status;\n}\n\n\n/*\n** Prints (calling the Lua 'print' function) any values on the stack\n*/\nstatic void l_print (lua_State *L) {\n  int n = lua_gettop(L);\n  if (n > 0) {  /* any result to be printed? */\n    luaL_checkstack(L, LUA_MINSTACK, \"too many results to print\");\n    lua_getglobal(L, \"print\");\n    lua_insert(L, 1);\n    if (lua_pcall(L, n, 0, 0) != LUA_OK)\n      l_message(progname, lua_pushfstring(L, \"error calling 'print' (%s)\",\n                                             lua_tostring(L, -1)));\n  }\n}\n\n\n/*\n** Do the REPL: repeatedly read (load) a line, evaluate (call) it, and\n** print any results.\n*/\nstatic void doREPL (lua_State *L) {\n  int status;\n  const char *oldprogname = progname;\n  progname = NULL;  /* no 'progname' on errors in interactive mode */\n  lua_initreadline(L);\n  while ((status = loadline(L)) != -1) {\n    if (status == LUA_OK)\n      status = docall(L, 0, LUA_MULTRET);\n    if (status == LUA_OK) l_print(L);\n    else report(L, status);\n  }\n  lua_settop(L, 0);  /* clear stack */\n  lua_writeline();\n  progname = oldprogname;\n}\n\n/* }================================================================== */\n\n#if !defined(luai_openlibs)\n#define luai_openlibs(L)\tluaL_openselectedlibs(L, ~0, 0)\n#endif\n\n\n/*\n** Main body of stand-alone interpreter (to be called in protected mode).\n** Reads the options and handles them all.\n*/\nstatic int pmain (lua_State *L) {\n  int argc = (int)lua_tointeger(L, 1);\n  char **argv = (char **)lua_touserdata(L, 2);\n  int script;\n  int args = collectargs(argv, &script);\n  int optlim = (script > 0) ? script : argc; /* first argv not an option */\n  luaL_checkversion(L);  /* check that interpreter has correct version */\n  if (args == has_error) {  /* bad arg? */\n    print_usage(argv[script]);  /* 'script' has index of bad arg. */\n    return 0;\n  }\n  if (args & has_v)  /* option '-v'? */\n    print_version();\n  if (args & has_E) {  /* option '-E'? */\n    lua_pushboolean(L, 1);  /* signal for libraries to ignore env. vars. */\n    lua_setfield(L, LUA_REGISTRYINDEX, \"LUA_NOENV\");\n  }\n  luai_openlibs(L);  /* open standard libraries */\n  createargtable(L, argv, argc, script);  /* create table 'arg' */\n  lua_gc(L, LUA_GCRESTART);  /* start GC... */\n  lua_gc(L, LUA_GCGEN);  /* ...in generational mode */\n  if (!(args & has_E)) {  /* no option '-E'? */\n    if (handle_luainit(L) != LUA_OK)  /* run LUA_INIT */\n      return 0;  /* error running LUA_INIT */\n  }\n  if (!runargs(L, argv, optlim))  /* execute arguments -e and -l */\n    return 0;  /* something failed */\n  if (script > 0) {  /* execute main script (if there is one) */\n    if (handle_script(L, argv + script) != LUA_OK)\n      return 0;  /* interrupt in case of error */\n  }\n  if (args & has_i)  /* -i option? */\n    doREPL(L);  /* do read-eval-print loop */\n  else if (script < 1 && !(args & (has_e | has_v))) { /* no active option? */\n    if (lua_stdin_is_tty()) {  /* running in interactive mode? */\n      print_version();\n      doREPL(L);  /* do read-eval-print loop */\n    }\n    else dofile(L, NULL);  /* executes stdin as a file */\n  }\n  lua_pushboolean(L, 1);  /* signal no errors */\n  return 1;\n}\n\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lua.h",
		"is_binary":	false,
		"content":	"/*\n** $Id: lua.h $\n** Lua - A Scripting Language\n** Lua.org, PUC-Rio, Brazil (www.lua.org)\n** See Copyright Notice at the end of this file\n*/\n\n\n#ifndef lua_h\n#define lua_h\n\n#include <stdarg.h>\n#include <stddef.h>\n\n\n#define LUA_COPYRIGHT\tLUA_RELEASE \"  Copyright (C) 1994-2023 Lua.org, PUC-Rio\"\n#define LUA_AUTHORS\t\"R. Ierusalimschy, L. H. de Figueiredo, W. Celes\"\n\n\n#define LUA_VERSION_MAJOR_N\t5\n#define LUA_VERSION_MINOR_N\t5\n#define LUA_VERSION_RELEASE_N\t0\n\n#define LUA_VERSION_NUM  (LUA_VERSION_MAJOR_N * 100 + LUA_VERSION_MINOR_N)\n#define LUA_VERSION_RELEASE_NUM  (LUA_VERSION_NUM * 100 + LUA_VERSION_RELEASE_N)\n\n\n#include \"luaconf.h\"\n\n\n/* mark for precompiled code ('<esc>Lua') */\n#define LUA_SIGNATURE\t\"\\x1bLua\"\n\n/* option for multiple returns in 'lua_pcall' and 'lua_call' */\n#define LUA_MULTRET\t(-1)\n\n\n/*\n** Pseudo-indices\n** (-LUAI_MAXSTACK is the minimum valid index; we keep some free empty\n** space after that to help overflow detection)\n*/\n#define LUA_REGISTRYINDEX\t(-LUAI_MAXSTACK - 1000)\n#define lua_upvalueindex(i)\t(LUA_REGISTRYINDEX - (i))\n\n\n/* thread status */\n#define LUA_OK\t\t0\n#define LUA_YIELD\t1\n#define LUA_ERRRUN\t2\n#define LUA_ERRSYNTAX\t3\n#define LUA_ERRMEM\t4\n#define LUA_ERRERR\t5\n\n\ntypedef struct lua_State lua_State;\n\n\n/*\n** basic types\n*/\n#define LUA_TNONE\t\t(-1)\n\n#define LUA_TNIL\t\t0\n#define LUA_TBOOLEAN\t\t1\n#define LUA_TLIGHTUSERDATA\t2\n#define LUA_TNUMBER\t\t3\n#define LUA_TSTRING\t\t4\n#define LUA_TTABLE\t\t5\n#define LUA_TFUNCTION\t\t6\n#define LUA_TUSERDATA\t\t7\n#define LUA_TTHREAD\t\t8\n\n#define LUA_NUMTYPES\t\t9\n\n\n\n/* minimum Lua stack available to a C function */\n#define LUA_MINSTACK\t20\n\n\n/* predefined values in the registry */\n/* index 1 is reserved for the reference mechanism */\n#define LUA_RIDX_GLOBALS\t2\n#define LUA_RIDX_MAINTHREAD\t3\n#define LUA_RIDX_LAST\t\t3\n\n\n/* type of numbers in Lua */\ntypedef LUA_NUMBER lua_Number;\n\n\n/* type for integer functions */\ntypedef LUA_INTEGER lua_Integer;\n\n/* unsigned integer type */\ntypedef LUA_UNSIGNED lua_Unsigned;\n\n/* type for continuation-function contexts */\ntypedef LUA_KCONTEXT lua_KContext;\n\n\n/*\n** Type for C functions registered with Lua\n*/\ntypedef int (*lua_CFunction) (lua_State *L);\n\n/*\n** Type for continuation functions\n*/\ntypedef int (*lua_KFunction) (lua_State *L, int status, lua_KContext ctx);\n\n\n/*\n** Type for functions that read/write blocks when loading/dumping Lua chunks\n*/\ntypedef const char * (*lua_Reader) (lua_State *L, void *ud, size_t *sz);\n\ntypedef int (*lua_Writer) (lua_State *L, const void *p, size_t sz, void *ud);\n\n\n/*\n** Type for memory-allocation functions\n*/\ntypedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);\n\n\n/*\n** Type for warning functions\n*/\ntypedef void (*lua_WarnFunction) (void *ud, const char *msg, int tocont);\n\n\n/*\n** Type used by the debug API to collect debug information\n*/\ntypedef struct lua_Debug lua_Debug;\n\n\n/*\n** Functions to be called by the debugger in specific events\n*/\ntypedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);\n\n\n/*\n** generic extra include file\n*/\n#if defined(LUA_USER_H)\n#include LUA_USER_H\n#endif\n\n\n/*\n** RCS ident string\n*/\nextern const char lua_ident[];\n\n\n/*\n** state manipulation\n*/\nLUA_API lua_State *(lua_newstate) (lua_Alloc f, void *ud, unsigned seed);\nLUA_API void       (lua_close) (lua_State *L);\nLUA_API lua_State *(lua_newthread) (lua_State *L);\nLUA_API int        (lua_closethread) (lua_State *L, lua_State *from);\n\nLUA_API lua_CFunction (lua_atpanic) (lua_State *L, lua_CFunction panicf);\n\n\nLUA_API lua_Number (lua_version) (lua_State *L);\n\n\n/*\n** basic stack manipulation\n*/\nLUA_API int   (lua_absindex) (lua_State *L, int idx);\nLUA_API int   (lua_gettop) (lua_State *L);\nLUA_API void  (lua_settop) (lua_State *L, int idx);\nLUA_API void  (lua_pushvalue) (lua_State *L, int idx);\nLUA_API void  (lua_rotate) (lua_State *L, int idx, int n);\nLUA_API void  (lua_copy) (lua_State *L, int fromidx, int toidx);\nLUA_API int   (lua_checkstack) (lua_State *L, int n);\n\nLUA_API void  (lua_xmove) (lua_State *from, lua_State *to, int n);\n\n\n/*\n** access functions (stack -> C)\n*/\n\nLUA_API int             (lua_isnumber) (lua_State *L, int idx);\nLUA_API int             (lua_isstring) (lua_State *L, int idx);\nLUA_API int             (lua_iscfunction) (lua_State *L, int idx);\nLUA_API int             (lua_isinteger) (lua_State *L, int idx);\nLUA_API int             (lua_isuserdata) (lua_State *L, int idx);\nLUA_API int             (lua_type) (lua_State *L, int idx);\nLUA_API const char     *(lua_typename) (lua_State *L, int tp);\n\nLUA_API lua_Number      (lua_tonumberx) (lua_State *L, int idx, int *isnum);\nLUA_API lua_Integer     (lua_tointegerx) (lua_State *L, int idx, int *isnum);\nLUA_API int             (lua_toboolean) (lua_State *L, int idx);\nLUA_API const char     *(lua_tolstring) (lua_State *L, int idx, size_t *len);\nLUA_API lua_Unsigned    (lua_rawlen) (lua_State *L, int idx);\nLUA_API lua_CFunction   (lua_tocfunction) (lua_State *L, int idx);\nLUA_API void\t       *(lua_touserdata) (lua_State *L, int idx);\nLUA_API lua_State      *(lua_tothread) (lua_State *L, int idx);\nLUA_API const void     *(lua_topointer) (lua_State *L, int idx);\n\n\n/*\n** Comparison and arithmetic functions\n*/\n\n#define LUA_OPADD\t0\t/* ORDER TM, ORDER OP */\n#define LUA_OPSUB\t1\n#define LUA_OPMUL\t2\n#define LUA_OPMOD\t3\n#define LUA_OPPOW\t4\n#define LUA_OPDIV\t5\n#define LUA_OPIDIV\t6\n#define LUA_OPBAND\t7\n#define LUA_OPBOR\t8\n#define LUA_OPBXOR\t9\n#define LUA_OPSHL\t10\n#define LUA_OPSHR\t11\n#define LUA_OPUNM\t12\n#define LUA_OPBNOT\t13\n\nLUA_API void  (lua_arith) (lua_State *L, int op);\n\n#define LUA_OPEQ\t0\n#define LUA_OPLT\t1\n#define LUA_OPLE\t2\n\nLUA_API int   (lua_rawequal) (lua_State *L, int idx1, int idx2);\nLUA_API int   (lua_compare) (lua_State *L, int idx1, int idx2, int op);\n\n\n/*\n** push functions (C -> stack)\n*/\nLUA_API void        (lua_pushnil) (lua_State *L);\nLUA_API void        (lua_pushnumber) (lua_State *L, lua_Number n);\nLUA_API void        (lua_pushinteger) (lua_State *L, lua_Integer n);\nLUA_API const char *(lua_pushlstring) (lua_State *L, const char *s, size_t len);\nLUA_API const char *(lua_pushextlstring) (lua_State *L,\n\t\tconst char *s, size_t len, lua_Alloc falloc, void *ud);\nLUA_API const char *(lua_pushstring) (lua_State *L, const char *s);\nLUA_API const char *(lua_pushvfstring) (lua_State *L, const char *fmt,\n                                                      va_list argp);\nLUA_API const char *(lua_pushfstring) (lua_State *L, const char *fmt, ...);\nLUA_API void  (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n);\nLUA_API void  (lua_pushboolean) (lua_State *L, int b);\nLUA_API void  (lua_pushlightuserdata) (lua_State *L, void *p);\nLUA_API int   (lua_pushthread) (lua_State *L);\n\n\n/*\n** get functions (Lua -> stack)\n*/\nLUA_API int (lua_getglobal) (lua_State *L, const char *name);\nLUA_API int (lua_gettable) (lua_State *L, int idx);\nLUA_API int (lua_getfield) (lua_State *L, int idx, const char *k);\nLUA_API int (lua_geti) (lua_State *L, int idx, lua_Integer n);\nLUA_API int (lua_rawget) (lua_State *L, int idx);\nLUA_API int (lua_rawgeti) (lua_State *L, int idx, lua_Integer n);\nLUA_API int (lua_rawgetp) (lua_State *L, int idx, const void *p);\n\nLUA_API void  (lua_createtable) (lua_State *L, unsigned narr, unsigned nrec);\nLUA_API void *(lua_newuserdatauv) (lua_State *L, size_t sz, int nuvalue);\nLUA_API int   (lua_getmetatable) (lua_State *L, int objindex);\nLUA_API int  (lua_getiuservalue) (lua_State *L, int idx, int n);\n\n\n/*\n** set functions (stack -> Lua)\n*/\nLUA_API void  (lua_setglobal) (lua_State *L, const char *name);\nLUA_API void  (lua_settable) (lua_State *L, int idx);\nLUA_API void  (lua_setfield) (lua_State *L, int idx, const char *k);\nLUA_API void  (lua_seti) (lua_State *L, int idx, lua_Integer n);\nLUA_API void  (lua_rawset) (lua_State *L, int idx);\nLUA_API void  (lua_rawseti) (lua_State *L, int idx, lua_Integer n);\nLUA_API void  (lua_rawsetp) (lua_State *L, int idx, const void *p);\nLUA_API int   (lua_setmetatable) (lua_State *L, int objindex);\nLUA_API int   (lua_setiuservalue) (lua_State *L, int idx, int n);\n\n\n/*\n** 'load' and 'call' functions (load and run Lua code)\n*/\nLUA_API void  (lua_callk) (lua_State *L, int nargs, int nresults,\n                           lua_KContext ctx, lua_KFunction k);\n#define lua_call(L,n,r)\t\tlua_callk(L, (n), (r), 0, NULL)\n\nLUA_API int   (lua_pcallk) (lua_State *L, int nargs, int nresults, int errfunc,\n                            lua_KContext ctx, lua_KFunction k);\n#define lua_pcall(L,n,r,f)\tlua_pcallk(L, (n), (r), (f), 0, NULL)\n\nLUA_API int   (lua_load) (lua_State *L, lua_Reader reader, void *dt,\n                          const char *chunkname, const char *mode);\n\nLUA_API int (lua_dump) (lua_State *L, lua_Writer writer, void *data, int strip);\n\n\n/*\n** coroutine functions\n*/\nLUA_API int  (lua_yieldk)     (lua_State *L, int nresults, lua_KContext ctx,\n                               lua_KFunction k);\nLUA_API int  (lua_resume)     (lua_State *L, lua_State *from, int narg,\n                               int *nres);\nLUA_API int  (lua_status)     (lua_State *L);\nLUA_API int (lua_isyieldable) (lua_State *L);\n\n#define lua_yield(L,n)\t\tlua_yieldk(L, (n), 0, NULL)\n\n\n/*\n** Warning-related functions\n*/\nLUA_API void (lua_setwarnf) (lua_State *L, lua_WarnFunction f, void *ud);\nLUA_API void (lua_warning)  (lua_State *L, const char *msg, int tocont);\n\n\n/*\n** garbage-collection options\n*/\n\n#define LUA_GCSTOP\t\t0\n#define LUA_GCRESTART\t\t1\n#define LUA_GCCOLLECT\t\t2\n#define LUA_GCCOUNT\t\t3\n#define LUA_GCCOUNTB\t\t4\n#define LUA_GCSTEP\t\t5\n#define LUA_GCISRUNNING\t\t6\n#define LUA_GCGEN\t\t7\n#define LUA_GCINC\t\t8\n#define LUA_GCPARAM\t\t9\n\n\n/*\n** garbage-collection parameters\n*/\n/* parameters for generational mode */\n#define LUA_GCPMINORMUL\t\t0  /* control minor collections */\n#define LUA_GCPMAJORMINOR\t1  /* control shift major->minor */\n#define LUA_GCPMINORMAJOR\t2  /* control shift minor->major */\n\n/* parameters for incremental mode */\n#define LUA_GCPPAUSE\t\t3  /* size of pause between successive GCs */\n#define LUA_GCPSTEPMUL\t\t4  /* GC \"speed\" */\n#define LUA_GCPSTEPSIZE\t\t5  /* GC granularity */\n\n/* number of parameters */\n#define LUA_GCPN\t\t6\n\n\nLUA_API int (lua_gc) (lua_State *L, int what, ...);\n\n\n/*\n** miscellaneous functions\n*/\n\nLUA_API int   (lua_error) (lua_State *L);\n\nLUA_API int   (lua_next) (lua_State *L, int idx);\n\nLUA_API void  (lua_concat) (lua_State *L, int n);\nLUA_API void  (lua_len)    (lua_State *L, int idx);\n\nLUA_API size_t   (lua_stringtonumber) (lua_State *L, const char *s);\n\nLUA_API lua_Alloc (lua_getallocf) (lua_State *L, void **ud);\nLUA_API void      (lua_setallocf) (lua_State *L, lua_Alloc f, void *ud);\n\nLUA_API void (lua_toclose) (lua_State *L, int idx);\nLUA_API void (lua_closeslot) (lua_State *L, int idx);\n\n\n/*\n** {==============================================================\n** some useful macros\n** ===============================================================\n*/\n\n#define lua_getextraspace(L)\t((void *)((char *)(L) - LUA_EXTRASPACE))\n\n#define lua_tonumber(L,i)\tlua_tonumberx(L,(i),NULL)\n#define lua_tointeger(L,i)\tlua_tointegerx(L,(i),NULL)\n\n#define lua_pop(L,n)\t\tlua_settop(L, -(n)-1)\n\n#define lua_newtable(L)\t\tlua_createtable(L, 0, 0)\n\n#define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))\n\n#define lua_pushcfunction(L,f)\tlua_pushcclosure(L, (f), 0)\n\n#define lua_isfunction(L,n)\t(lua_type(L, (n)) == LUA_TFUNCTION)\n#define lua_istable(L,n)\t(lua_type(L, (n)) == LUA_TTABLE)\n#define lua_islightuserdata(L,n)\t(lua_type(L, (n)) == LUA_TLIGHTUSERDATA)\n#define lua_isnil(L,n)\t\t(lua_type(L, (n)) == LUA_TNIL)\n#define lua_isboolean(L,n)\t(lua_type(L, (n)) == LUA_TBOOLEAN)\n#define lua_isthread(L,n)\t(lua_type(L, (n)) == LUA_TTHREAD)\n#define lua_isnone(L,n)\t\t(lua_type(L, (n)) == LUA_TNONE)\n#define lua_isnoneornil(L, n)\t(lua_type(L, (n)) <= 0)\n\n#define lua_pushliteral(L, s)\tlua_pushstring(L, \"\" s)\n\n#define lua_pushglobaltable(L)  \\\n\t((void)lua_rawgeti(L, LUA_REGISTRYINDEX, LUA_RIDX_GLOBALS))\n\n#define lua_tostring(L,i)\tlua_tolstring(L, (i), NULL)\n\n\n#define lua_insert(L,idx)\tlua_rotate(L, (idx), 1)\n\n#define lua_remove(L,idx)\t(lua_rotate(L, (idx), -1), lua_pop(L, 1))\n\n#define lua_replace(L,idx)\t(lua_copy(L, -1, (idx)), lua_pop(L, 1))\n\n/* }============================================================== */\n\n\n/*\n** {==============================================================\n** compatibility macros\n** ===============================================================\n*/\n#if defined(LUA_COMPAT_APIINTCASTS)\n\n#define lua_pushunsigned(L,n)\tlua_pushinteger(L, (lua_Integer)(n))\n#define lua_tounsignedx(L,i,is)\t((lua_Unsigned)lua_tointegerx(L,i,is))\n#define lua_tounsigned(L,i)\tlua_tounsignedx(L,(i),NULL)\n\n#endif\n\n#define lua_newuserdata(L,s)\tlua_newuserdatauv(L,s,1)\n#define lua_getuservalue(L,idx)\tlua_getiuservalue(L,idx,1)\n#define lua_setuservalue(L,idx)\tlua_setiuservalue(L,idx,1)\n\n#define lua_resetthread(L)\tlua_closethread(L,NULL)\n\n/* }============================================================== */\n\n/*\n** {======================================================================\n** Debug API\n** =======================================================================\n*/\n\n\n/*\n** Event codes\n*/\n#define LUA_HOOKCALL\t0\n#define LUA_HOOKRET\t1\n#define LUA_HOOKLINE\t2\n#define LUA_HOOKCOUNT\t3\n#define LUA_HOOKTAILCALL 4\n\n\n/*\n** Event masks\n*/\n#define LUA_MASKCALL\t(1 << LUA_HOOKCALL)\n#define LUA_MASKRET\t(1 << LUA_HOOKRET)\n#define LUA_MASKLINE\t(1 << LUA_HOOKLINE)\n#define LUA_MASKCOUNT\t(1 << LUA_HOOKCOUNT)\n\n\nLUA_API int (lua_getstack) (lua_State *L, int level, lua_Debug *ar);\nLUA_API int (lua_getinfo) (lua_State *L, const char *what, lua_Debug *ar);\nLUA_API const char *(lua_getlocal) (lua_State *L, const lua_Debug *ar, int n);\nLUA_API const char *(lua_setlocal) (lua_State *L, const lua_Debug *ar, int n);\nLUA_API const char *(lua_getupvalue) (lua_State *L, int funcindex, int n);\nLUA_API const char *(lua_setupvalue) (lua_State *L, int funcindex, int n);\n\nLUA_API void *(lua_upvalueid) (lua_State *L, int fidx, int n);\nLUA_API void  (lua_upvaluejoin) (lua_State *L, int fidx1, int n1,\n                                               int fidx2, int n2);\n\nLUA_API void (lua_sethook) (lua_State *L, lua_Hook func, int mask, int count);\nLUA_API lua_Hook (lua_gethook) (lua_State *L);\nLUA_API int (lua_gethookmask) (lua_State *L);\nLUA_API int (lua_gethookcount) (lua_State *L);\n\n\nstruct lua_Debug {\n  int event;\n  const char *name;\t/* (n) */\n  const char *namewhat;\t/* (n) 'global', 'local', 'field', 'method' */\n  const char *what;\t/* (S) 'Lua', 'C', 'main', 'tail' */\n  const char *source;\t/* (S) */\n  size_t srclen;\t/* (S) */\n  int currentline;\t/* (l) */\n  int linedefined;\t/* (S) */\n  int lastlinedefined;\t/* (S) */\n  unsigned char nups;\t/* (u) number of upvalues */\n  unsigned char nparams;/* (u) number of parameters */\n  char isvararg;        /* (u) */\n  char istailcall;\t/* (t) */\n  unsigned short ftransfer;   /* (r) index of first value transferred */\n  unsigned short ntransfer;   /* (r) number of transferred values */\n  char short_src[LUA_IDSIZE]; /* (S) */\n  /* private part */\n  struct CallInfo *i_ci;  /* active function */\n};\n\n/* }====================================================================== */\n\n\n#define LUAI_TOSTRAUX(x)\t#x\n#define LUAI_TOSTR(x)\t\tLUAI_TOSTRAUX(x)\n\n#define LUA_VERSION_MAJOR\tLUAI_TOSTR(LUA_VERSION_MAJOR_N)\n#define LUA_VERSION_MINOR\tLUAI_TOSTR(LUA_VERSION_MINOR_N)\n#define LUA_VERSION_RELEASE\tLUAI_TOSTR(LUA_VERSION_RELEASE_N)\n\n#define LUA_VERSION\t\"Lua \" LUA_VERSION_MAJOR \".\" LUA_VERSION_MINOR\n#define LUA_RELEASE\tLUA_VERSION \".\" LUA_VERSION_RELEASE\n\n\n/******************************************************************************\n* Copyright (C) 1994-2023 Lua.org, PUC-Rio.\n*\n* Permission is hereby granted, free of charge, to any person obtaining\n* a copy of this software and associated documentation files (the\n* \"Software\"), to deal in the Software without restriction, including\n* without limitation the rights to use, copy, modify, merge, publish,\n* distribute, sublicense, and/or sell copies of the Software, and to\n* permit persons to whom the Software is furnished to do so, subject to\n* the following conditions:\n*\n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n******************************************************************************/\n\n\n#endif\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/luaconf.h",
		"is_binary":	false,
		"content":	"/*\n** $Id: luaconf.h $\n** Configuration file for Lua\n** See Copyright Notice in lua.h\n*/\n\n\n#ifndef luaconf_h\n#define luaconf_h\n\n#include <limits.h>\n#include <stddef.h>\n\n\n/*\n** ===================================================================\n** General Configuration File for Lua\n**\n** Some definitions here can be changed externally, through the compiler\n** (e.g., with '-D' options): They are commented out or protected\n** by '#if !defined' guards. However, several other definitions\n** should be changed directly here, either because they affect the\n** Lua ABI (by making the changes here, you ensure that all software\n** connected to Lua, such as C libraries, will be compiled with the same\n** configuration); or because they are seldom changed.\n**\n** Search for \"@@\" to find all configurable definitions.\n** ===================================================================\n*/\n\n\n/*\n** {====================================================================\n** System Configuration: macros to adapt (if needed) Lua to some\n** particular platform, for instance restricting it to C89.\n** =====================================================================\n*/\n\n/*\n@@ LUA_USE_C89 controls the use of non-ISO-C89 features.\n** Define it if you want Lua to avoid the use of a few C99 features\n** or Windows-specific features on Windows.\n*/\n/* #define LUA_USE_C89 */\n\n\n/*\n** By default, Lua on Windows use (some) specific Windows features\n*/\n#if !defined(LUA_USE_C89) && defined(_WIN32) && !defined(_WIN32_WCE)\n#define LUA_USE_WINDOWS  /* enable goodies for regular Windows */\n#endif\n\n\n#if defined(LUA_USE_WINDOWS)\n#define LUA_DL_DLL\t/* enable support for DLL */\n#define LUA_USE_C89\t/* broadly, Windows is C89 */\n#endif\n\n\n#if defined(LUA_USE_LINUX)\n#define LUA_USE_POSIX\n#define LUA_USE_DLOPEN\t\t/* needs an extra library: -ldl */\n#endif\n\n\n#if defined(LUA_USE_MACOSX)\n#define LUA_USE_POSIX\n#define LUA_USE_DLOPEN\t\t/* MacOS does not need -ldl */\n#endif\n\n\n#if defined(LUA_USE_IOS)\n#define LUA_USE_POSIX\n#define LUA_USE_DLOPEN\n#endif\n\n\n/*\n@@ LUAI_IS32INT is true iff 'int' has (at least) 32 bits.\n*/\n#define LUAI_IS32INT\t((UINT_MAX >> 30) >= 3)\n\n/* }================================================================== */\n\n\n\n/*\n** {==================================================================\n** Configuration for Number types. These options should not be\n** set externally, because any other code connected to Lua must\n** use the same configuration.\n** ===================================================================\n*/\n\n/*\n@@ LUA_INT_TYPE defines the type for Lua integers.\n@@ LUA_FLOAT_TYPE defines the type for Lua floats.\n** Lua should work fine with any mix of these options supported\n** by your C compiler. The usual configurations are 64-bit integers\n** and 'double' (the default), 32-bit integers and 'float' (for\n** restricted platforms), and 'long'/'double' (for C compilers not\n** compliant with C99, which may not have support for 'long long').\n*/\n\n/* predefined options for LUA_INT_TYPE */\n#define LUA_INT_INT\t\t1\n#define LUA_INT_LONG\t\t2\n#define LUA_INT_LONGLONG\t3\n\n/* predefined options for LUA_FLOAT_TYPE */\n#define LUA_FLOAT_FLOAT\t\t1\n#define LUA_FLOAT_DOUBLE\t2\n#define LUA_FLOAT_LONGDOUBLE\t3\n\n\n/* Default configuration ('long long' and 'double', for 64-bit Lua) */\n#define LUA_INT_DEFAULT\t\tLUA_INT_LONGLONG\n#define LUA_FLOAT_DEFAULT\tLUA_FLOAT_DOUBLE\n\n\n/*\n@@ LUA_32BITS enables Lua with 32-bit integers and 32-bit floats.\n*/\n#define LUA_32BITS\t0\n\n\n/*\n@@ LUA_C89_NUMBERS ensures that Lua uses the largest types available for\n** C89 ('long' and 'double'); Windows always has '__int64', so it does\n** not need to use this case.\n*/\n#if defined(LUA_USE_C89) && !defined(LUA_USE_WINDOWS)\n#define LUA_C89_NUMBERS\t\t1\n#else\n#define LUA_C89_NUMBERS\t\t0\n#endif\n\n\n#if LUA_32BITS\t\t/* { */\n/*\n** 32-bit integers and 'float'\n*/\n#if LUAI_IS32INT  /* use 'int' if big enough */\n#define LUA_INT_TYPE\tLUA_INT_INT\n#else  /* otherwise use 'long' */\n#define LUA_INT_TYPE\tLUA_INT_LONG\n#endif\n#define LUA_FLOAT_TYPE\tLUA_FLOAT_FLOAT\n\n#elif LUA_C89_NUMBERS\t/* }{ */\n/*\n** largest types available for C89 ('long' and 'double')\n*/\n#define LUA_INT_TYPE\tLUA_INT_LONG\n#define LUA_FLOAT_TYPE\tLUA_FLOAT_DOUBLE\n\n#else\t\t/* }{ */\n/* use defaults */\n\n#define LUA_INT_TYPE\tLUA_INT_DEFAULT\n#define LUA_FLOAT_TYPE\tLUA_FLOAT_DEFAULT\n\n#endif\t\t\t\t/* } */\n\n\n/* }================================================================== */\n\n\n\n/*\n** {==================================================================\n** Configuration for Paths.\n** ===================================================================\n*/\n\n/*\n** LUA_PATH_SEP is the character that separates templates in a path.\n** LUA_PATH_MARK is the string that marks the substitution points in a\n** template.\n** LUA_EXEC_DIR in a Windows path is replaced by the executable's\n** directory.\n*/\n#define LUA_PATH_SEP            \";\"\n#define LUA_PATH_MARK           \"?\"\n#define LUA_EXEC_DIR            \"!\"\n\n\n/*\n@@ LUA_PATH_DEFAULT is the default path that Lua uses to look for\n** Lua libraries.\n@@ LUA_CPATH_DEFAULT is the default path that Lua uses to look for\n** C libraries.\n** CHANGE them if your machine has a non-conventional directory\n** hierarchy or if you want to install your libraries in\n** non-conventional directories.\n*/\n\n#define LUA_VDIR\tLUA_VERSION_MAJOR \".\" LUA_VERSION_MINOR\n#if defined(_WIN32)\t/* { */\n/*\n** In Windows, any exclamation mark ('!') in the path is replaced by the\n** path of the directory of the executable file of the current process.\n*/\n#define LUA_LDIR\t\"!\\\\lua\\\\\"\n#define LUA_CDIR\t\"!\\\\\"\n#define LUA_SHRDIR\t\"!\\\\..\\\\share\\\\lua\\\\\" LUA_VDIR \"\\\\\"\n\n#if !defined(LUA_PATH_DEFAULT)\n#define LUA_PATH_DEFAULT  \\\n\t\tLUA_LDIR\"?.lua;\"  LUA_LDIR\"?\\\\init.lua;\" \\\n\t\tLUA_CDIR\"?.lua;\"  LUA_CDIR\"?\\\\init.lua;\" \\\n\t\tLUA_SHRDIR\"?.lua;\" LUA_SHRDIR\"?\\\\init.lua;\" \\\n\t\t\".\\\\?.lua;\" \".\\\\?\\\\init.lua\"\n#endif\n\n#if !defined(LUA_CPATH_DEFAULT)\n#define LUA_CPATH_DEFAULT \\\n\t\tLUA_CDIR\"?.dll;\" \\\n\t\tLUA_CDIR\"..\\\\lib\\\\lua\\\\\" LUA_VDIR \"\\\\?.dll;\" \\\n\t\tLUA_CDIR\"loadall.dll;\" \".\\\\?.dll\"\n#endif\n\n#else\t\t\t/* }{ */\n\n#define LUA_ROOT\t\"/usr/local/\"\n#define LUA_LDIR\tLUA_ROOT \"share/lua/\" LUA_VDIR \"/\"\n#define LUA_CDIR\tLUA_ROOT \"lib/lua/\" LUA_VDIR \"/\"\n\n#if !defined(LUA_PATH_DEFAULT)\n#define LUA_PATH_DEFAULT  \\\n\t\tLUA_LDIR\"?.lua;\"  LUA_LDIR\"?/init.lua;\" \\\n\t\tLUA_CDIR\"?.lua;\"  LUA_CDIR\"?/init.lua;\" \\\n\t\t\"./?.lua;\" \"./?/init.lua\"\n#endif\n\n#if !defined(LUA_CPATH_DEFAULT)\n#define LUA_CPATH_DEFAULT \\\n\t\tLUA_CDIR\"?.so;\" LUA_CDIR\"loadall.so;\" \"./?.so\"\n#endif\n\n#endif\t\t\t/* } */\n\n\n/*\n@@ LUA_DIRSEP is the directory separator (for submodules).\n** CHANGE it if your machine does not use \"/\" as the directory separator\n** and is not Windows. (On Windows Lua automatically uses \"\\\".)\n*/\n#if !defined(LUA_DIRSEP)\n\n#if defined(_WIN32)\n#define LUA_DIRSEP\t\"\\\\\"\n#else\n#define LUA_DIRSEP\t\"/\"\n#endif\n\n#endif\n\n\n/*\n** LUA_IGMARK is a mark to ignore all after it when building the\n** module name (e.g., used to build the luaopen_ function name).\n** Typically, the sufix after the mark is the module version,\n** as in \"mod-v1.2.so\".\n*/\n#define LUA_IGMARK\t\t\"-\"\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Marks for exported symbols in the C code\n** ===================================================================\n*/\n\n/*\n@@ LUA_API is a mark for all core API functions.\n@@ LUALIB_API is a mark for all auxiliary library functions.\n@@ LUAMOD_API is a mark for all standard library opening functions.\n** CHANGE them if you need to define those functions in some special way.\n** For instance, if you want to create one Windows DLL with the core and\n** the libraries, you may want to use the following definition (define\n** LUA_BUILD_AS_DLL to get it).\n*/\n#if defined(LUA_BUILD_AS_DLL)\t/* { */\n\n#if defined(LUA_CORE) || defined(LUA_LIB)\t/* { */\n#define LUA_API __declspec(dllexport)\n#else\t\t\t\t\t\t/* }{ */\n#define LUA_API __declspec(dllimport)\n#endif\t\t\t\t\t\t/* } */\n\n#else\t\t\t\t/* }{ */\n\n#define LUA_API\t\textern\n\n#endif\t\t\t\t/* } */\n\n\n/*\n** More often than not the libs go together with the core.\n*/\n#define LUALIB_API\tLUA_API\n#define LUAMOD_API\tLUA_API\n\n\n/*\n@@ LUAI_FUNC is a mark for all extern functions that are not to be\n** exported to outside modules.\n@@ LUAI_DDEF and LUAI_DDEC are marks for all extern (const) variables,\n** none of which to be exported to outside modules (LUAI_DDEF for\n** definitions and LUAI_DDEC for declarations).\n** CHANGE them if you need to mark them in some special way. Elf/gcc\n** (versions 3.2 and later) mark them as \"hidden\" to optimize access\n** when Lua is compiled as a shared library. Not all elf targets support\n** this attribute. Unfortunately, gcc does not offer a way to check\n** whether the target offers that support, and those without support\n** give a warning about it. To avoid these warnings, change to the\n** default definition.\n*/\n#if defined(__GNUC__) && ((__GNUC__*100 + __GNUC_MINOR__) >= 302) && \\\n    defined(__ELF__)\t\t/* { */\n#define LUAI_FUNC\t__attribute__((visibility(\"internal\"))) extern\n#else\t\t\t\t/* }{ */\n#define LUAI_FUNC\textern\n#endif\t\t\t\t/* } */\n\n#define LUAI_DDEC(dec)\tLUAI_FUNC dec\n#define LUAI_DDEF\t/* empty */\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Compatibility with previous versions\n** ===================================================================\n*/\n\n/*\n@@ LUA_COMPAT_5_3 controls other macros for compatibility with Lua 5.3.\n** You can define it to get all options, or change specific options\n** to fit your specific needs.\n*/\n#if defined(LUA_COMPAT_5_3)\t/* { */\n\n/*\n@@ LUA_COMPAT_MATHLIB controls the presence of several deprecated\n** functions in the mathematical library.\n** (These functions were already officially removed in 5.3;\n** nevertheless they are still available here.)\n*/\n#define LUA_COMPAT_MATHLIB\n\n/*\n@@ LUA_COMPAT_APIINTCASTS controls the presence of macros for\n** manipulating other integer types (lua_pushunsigned, lua_tounsigned,\n** luaL_checkint, luaL_checklong, etc.)\n** (These macros were also officially removed in 5.3, but they are still\n** available here.)\n*/\n#define LUA_COMPAT_APIINTCASTS\n\n\n/*\n@@ LUA_COMPAT_LT_LE controls the emulation of the '__le' metamethod\n** using '__lt'.\n*/\n#define LUA_COMPAT_LT_LE\n\n\n/*\n@@ The following macros supply trivial compatibility for some\n** changes in the API. The macros themselves document how to\n** change your code to avoid using them.\n** (Once more, these macros were officially removed in 5.3, but they are\n** still available here.)\n*/\n#define lua_strlen(L,i)\t\tlua_rawlen(L, (i))\n\n#define lua_objlen(L,i)\t\tlua_rawlen(L, (i))\n\n#define lua_equal(L,idx1,idx2)\t\tlua_compare(L,(idx1),(idx2),LUA_OPEQ)\n#define lua_lessthan(L,idx1,idx2)\tlua_compare(L,(idx1),(idx2),LUA_OPLT)\n\n#endif\t\t\t\t/* } */\n\n/* }================================================================== */\n\n\n\n/*\n** {==================================================================\n** Configuration for Numbers (low-level part).\n** Change these definitions if no predefined LUA_FLOAT_* / LUA_INT_*\n** satisfy your needs.\n** ===================================================================\n*/\n\n/*\n@@ LUAI_UACNUMBER is the result of a 'default argument promotion'\n@@ over a floating number.\n@@ l_floatatt(x) corrects float attribute 'x' to the proper float type\n** by prefixing it with one of FLT/DBL/LDBL.\n@@ LUA_NUMBER_FRMLEN is the length modifier for writing floats.\n@@ LUA_NUMBER_FMT is the format for writing floats.\n@@ lua_number2str converts a float to a string.\n@@ l_mathop allows the addition of an 'l' or 'f' to all math operations.\n@@ l_floor takes the floor of a float.\n@@ lua_str2number converts a decimal numeral to a number.\n*/\n\n\n/* The following definitions are good for most cases here */\n\n#define l_floor(x)\t\t(l_mathop(private_lua_embed_floor)(x))\n\n#define lua_number2str(s,sz,n)  \\\n\tl_sprintf((s), sz, LUA_NUMBER_FMT, (LUAI_UACNUMBER)(n))\n\n/*\n@@ lua_numbertointeger converts a float number with an integral value\n** to an integer, or returns 0 if float is not within the range of\n** a lua_Integer.  (The range comparisons are tricky because of\n** rounding. The tests here assume a two-complement representation,\n** where MININTEGER always has an exact representation as a float;\n** MAXINTEGER may not have one, and therefore its conversion to float\n** may have an ill-defined value.)\n*/\n#define lua_numbertointeger(n,p) \\\n  ((n) >= (LUA_NUMBER)(LUA_MININTEGER) && \\\n   (n) < -(LUA_NUMBER)(LUA_MININTEGER) && \\\n      (*(p) = (LUA_INTEGER)(n), 1))\n\n\n/* now the variable definitions */\n\n#if LUA_FLOAT_TYPE == LUA_FLOAT_FLOAT\t\t/* { single float */\n\n#define LUA_NUMBER\tfloat\n\n#define l_floatatt(n)\t\t(FLT_##n)\n\n#define LUAI_UACNUMBER\tdouble\n\n#define LUA_NUMBER_FRMLEN\t\"\"\n#define LUA_NUMBER_FMT\t\t\"%.7g\"\n\n#define l_mathop(op)\t\top##f\n\n#define lua_str2number(s,p)\tstrtof((s), (p))\n\n\n#elif LUA_FLOAT_TYPE == LUA_FLOAT_LONGDOUBLE\t/* }{ long double */\n\n#define LUA_NUMBER\tlong double\n\n#define l_floatatt(n)\t\t(LDBL_##n)\n\n#define LUAI_UACNUMBER\tlong double\n\n#define LUA_NUMBER_FRMLEN\t\"L\"\n#define LUA_NUMBER_FMT\t\t\"%.19Lg\"\n\n#define l_mathop(op)\t\top##l\n\n#define lua_str2number(s,p)\tstrtold((s), (p))\n\n#elif LUA_FLOAT_TYPE == LUA_FLOAT_DOUBLE\t/* }{ double */\n\n#define LUA_NUMBER\tdouble\n\n#define l_floatatt(n)\t\t(DBL_##n)\n\n#define LUAI_UACNUMBER\tdouble\n\n#define LUA_NUMBER_FRMLEN\t\"\"\n#define LUA_NUMBER_FMT\t\t\"%.14g\"\n\n#define l_mathop(op)\t\top\n\n#define lua_str2number(s,p)\tstrtod((s), (p))\n\n#else\t\t\t\t\t\t/* }{ */\n\n#error \"numeric float type not defined\"\n\n#endif\t\t\t\t\t/* } */\n\n\n\n/*\n@@ LUA_UNSIGNED is the unsigned version of LUA_INTEGER.\n@@ LUAI_UACINT is the result of a 'default argument promotion'\n@@ over a LUA_INTEGER.\n@@ LUA_INTEGER_FRMLEN is the length modifier for reading/writing integers.\n@@ LUA_INTEGER_FMT is the format for writing integers.\n@@ LUA_MAXINTEGER is the maximum value for a LUA_INTEGER.\n@@ LUA_MININTEGER is the minimum value for a LUA_INTEGER.\n@@ LUA_MAXUNSIGNED is the maximum value for a LUA_UNSIGNED.\n@@ lua_integer2str converts an integer to a string.\n*/\n\n\n/* The following definitions are good for most cases here */\n\n#define LUA_INTEGER_FMT\t\t\"%\" LUA_INTEGER_FRMLEN \"d\"\n\n#define LUAI_UACINT\t\tLUA_INTEGER\n\n#define lua_integer2str(s,sz,n)  \\\n\tl_sprintf((s), sz, LUA_INTEGER_FMT, (LUAI_UACINT)(n))\n\n/*\n** use LUAI_UACINT here to avoid problems with promotions (which\n** can turn a comparison between unsigneds into a signed comparison)\n*/\n#define LUA_UNSIGNED\t\tunsigned LUAI_UACINT\n\n\n/* now the variable definitions */\n\n#if LUA_INT_TYPE == LUA_INT_INT\t\t/* { int */\n\n#define LUA_INTEGER\t\tint\n#define LUA_INTEGER_FRMLEN\t\"\"\n\n#define LUA_MAXINTEGER\t\tINT_MAX\n#define LUA_MININTEGER\t\tINT_MIN\n\n#define LUA_MAXUNSIGNED\t\tUINT_MAX\n\n#elif LUA_INT_TYPE == LUA_INT_LONG\t/* }{ long */\n\n#define LUA_INTEGER\t\tlong\n#define LUA_INTEGER_FRMLEN\t\"l\"\n\n#define LUA_MAXINTEGER\t\tLONG_MAX\n#define LUA_MININTEGER\t\tLONG_MIN\n\n#define LUA_MAXUNSIGNED\t\tULONG_MAX\n\n#elif LUA_INT_TYPE == LUA_INT_LONGLONG\t/* }{ long long */\n\n/* use presence of macro LLONG_MAX as proxy for C99 compliance */\n#if defined(LLONG_MAX)\t\t/* { */\n/* use ISO C99 stuff */\n\n#define LUA_INTEGER\t\tlong long\n#define LUA_INTEGER_FRMLEN\t\"ll\"\n\n#define LUA_MAXINTEGER\t\tLLONG_MAX\n#define LUA_MININTEGER\t\tLLONG_MIN\n\n#define LUA_MAXUNSIGNED\t\tULLONG_MAX\n\n#elif defined(LUA_USE_WINDOWS) /* }{ */\n/* in Windows, can use specific Windows types */\n\n#define LUA_INTEGER\t\t__int64\n#define LUA_INTEGER_FRMLEN\t\"I64\"\n\n#define LUA_MAXINTEGER\t\t_I64_MAX\n#define LUA_MININTEGER\t\t_I64_MIN\n\n#define LUA_MAXUNSIGNED\t\t_UI64_MAX\n\n#else\t\t\t\t/* }{ */\n\n#error \"Compiler does not support 'long long'. Use option '-DLUA_32BITS' \\\n  or '-DLUA_C89_NUMBERS' (see file 'luaconf.h' for details)\"\n\n#endif\t\t\t\t/* } */\n\n#else\t\t\t\t/* }{ */\n\n#error \"numeric integer type not defined\"\n\n#endif\t\t\t\t/* } */\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Dependencies with C99 and other C details\n** ===================================================================\n*/\n\n/*\n@@ l_sprintf is equivalent to 'snprintf' or 'sprintf' in C89.\n** (All uses in Lua have only one format item.)\n*/\n#if !defined(LUA_USE_C89)\n#define l_sprintf(s,sz,f,i)\tsnprintf(s,sz,f,i)\n#else\n#define l_sprintf(s,sz,f,i)\t((void)(sz), sprintf(s,f,i))\n#endif\n\n\n/*\n@@ lua_strx2number converts a hexadecimal numeral to a number.\n** In C99, 'strtod' does that conversion. Otherwise, you can\n** leave 'lua_strx2number' undefined and Lua will provide its own\n** implementation.\n*/\n#if !defined(LUA_USE_C89)\n#define lua_strx2number(s,p)\t\tlua_str2number(s,p)\n#endif\n\n\n/*\n@@ lua_pointer2str converts a pointer to a readable string in a\n** non-specified way.\n*/\n#define lua_pointer2str(buff,sz,p)\tl_sprintf(buff,sz,\"%p\",p)\n\n\n/*\n@@ lua_number2strx converts a float to a hexadecimal numeral.\n** In C99, 'sprintf' (with format specifiers '%a'/'%A') does that.\n** Otherwise, you can leave 'lua_number2strx' undefined and Lua will\n** provide its own implementation.\n*/\n#if !defined(LUA_USE_C89)\n#define lua_number2strx(L,b,sz,f,n)  \\\n\t((void)L, l_sprintf(b,sz,f,(LUAI_UACNUMBER)(n)))\n#endif\n\n\n/*\n** 'strtof' and 'opf' variants for math functions are not valid in\n** C89. Otherwise, the macro 'HUGE_VALF' is a good proxy for testing the\n** availability of these variants. ('math.h' is already included in\n** all files that use these macros.)\n*/\n#if defined(LUA_USE_C89) || (defined(HUGE_VAL) && !defined(HUGE_VALF))\n#undef l_mathop  /* variants not available */\n#undef lua_str2number\n#define l_mathop(op)\t\t(lua_Number)op  /* no variant */\n#define lua_str2number(s,p)\t((lua_Number)strtod((s), (p)))\n#endif\n\n\n/*\n@@ LUA_KCONTEXT is the type of the context ('ctx') for continuation\n** functions.  It must be a numerical type; Lua will use 'intptr_t' if\n** available, otherwise it will use 'ptrdiff_t' (the nearest thing to\n** 'intptr_t' in C89)\n*/\n#define LUA_KCONTEXT\tptrdiff_t\n\n#if !defined(LUA_USE_C89) && defined(__STDC_VERSION__) && \\\n    __STDC_VERSION__ >= 199901L\n#include <stdint.h>\n#if defined(INTPTR_MAX)  /* even in C99 this type is optional */\n#undef LUA_KCONTEXT\n#define LUA_KCONTEXT\tintptr_t\n#endif\n#endif\n\n\n/*\n@@ lua_getlocaledecpoint gets the locale \"radix character\" (decimal point).\n** Change that if you do not want to use C locales. (Code using this\n** macro must include the header 'locale.h'.)\n*/\n#if !defined(lua_getlocaledecpoint)\n#define lua_getlocaledecpoint()\t\t(localeconv()->decimal_point[0])\n#endif\n\n\n/*\n** macros to improve jump prediction, used mostly for error handling\n** and debug facilities. (Some macros in the Lua API use these macros.\n** Define LUA_NOBUILTIN if you do not want '__builtin_expect' in your\n** code.)\n*/\n#if !defined(luai_likely)\n\n#if defined(__GNUC__) && !defined(LUA_NOBUILTIN)\n#define luai_likely(x)\t\t(__builtin_expect(((x) != 0), 1))\n#define luai_unlikely(x)\t(__builtin_expect(((x) != 0), 0))\n#else\n#define luai_likely(x)\t\t(x)\n#define luai_unlikely(x)\t(x)\n#endif\n\n#endif\n\n\n#if defined(LUA_CORE) || defined(LUA_LIB)\n/* shorter names for Lua's own use */\n#define l_likely(x)\tluai_likely(x)\n#define l_unlikely(x)\tluai_unlikely(x)\n#endif\n\n\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Language Variations\n** =====================================================================\n*/\n\n/*\n@@ LUA_NOCVTN2S/LUA_NOCVTS2N control how Lua performs some\n** coercions. Define LUA_NOCVTN2S to turn off automatic coercion from\n** numbers to strings. Define LUA_NOCVTS2N to turn off automatic\n** coercion from strings to numbers.\n*/\n/* #define LUA_NOCVTN2S */\n/* #define LUA_NOCVTS2N */\n\n\n/*\n@@ LUA_USE_APICHECK turns on several consistency checks on the C API.\n** Define it as a help when debugging C code.\n*/\n#if defined(LUA_USE_APICHECK)\n#include <assert.h>\n#define luai_apicheck(l,e)\tassert(e)\n#endif\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Macros that affect the API and must be stable (that is, must be the\n** same when you compile Lua and when you compile code that links to\n** Lua).\n** =====================================================================\n*/\n\n/*\n@@ LUAI_MAXSTACK limits the size of the Lua stack.\n** CHANGE it if you need a different limit. This limit is arbitrary;\n** its only purpose is to stop Lua from consuming unlimited stack\n** space (and to reserve some numbers for pseudo-indices).\n** (It must fit into max(size_t)/32 and max(int)/2.)\n*/\n#if LUAI_IS32INT\n#define LUAI_MAXSTACK\t\t1000000\n#else\n#define LUAI_MAXSTACK\t\t15000\n#endif\n\n\n/*\n@@ LUA_EXTRASPACE defines the size of a raw memory area associated with\n** a Lua state with very fast access.\n** CHANGE it if you need a different size.\n*/\n#define LUA_EXTRASPACE\t\t(sizeof(void *))\n\n\n/*\n@@ LUA_IDSIZE gives the maximum size for the description of the source\n** of a function in debug information.\n** CHANGE it if you want a different size.\n*/\n#define LUA_IDSIZE\t60\n\n\n/*\n@@ LUAL_BUFFERSIZE is the initial buffer size used by the lauxlib\n** buffer system.\n*/\n#define LUAL_BUFFERSIZE   ((int)(16 * sizeof(void*) * sizeof(lua_Number)))\n\n\n/*\n@@ LUAI_MAXALIGN defines fields that, when used in a union, ensure\n** maximum alignment for the other items in that union.\n*/\n#define LUAI_MAXALIGN  lua_Number n; double u; void *s; lua_Integer i; long l\n\n/* }================================================================== */\n\n\n\n\n\n/* =================================================================== */\n\n/*\n** Local configuration. You can use this space to add your redefinitions\n** without modifying the main part of the file.\n*/\n\n\n\n\n\n#endif\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lualib.h",
		"is_binary":	false,
		"content":	"/*\n** $Id: lualib.h $\n** Lua standard libraries\n** See Copyright Notice in lua.h\n*/\n\n\n#ifndef lualib_h\n#define lualib_h\n\n#include \"lua.h\"\n\n\n/* version suffix for environment variable names */\n#define LUA_VERSUFFIX          \"_\" LUA_VERSION_MAJOR \"_\" LUA_VERSION_MINOR\n\n#define LUA_GLIBK\t\t1\nLUAMOD_API int (luaopen_base) (lua_State *L);\n\n#define LUA_LOADLIBNAME\t\"package\"\n#define LUA_LOADLIBK\t(LUA_GLIBK << 1)\nLUAMOD_API int (luaopen_package) (lua_State *L);\n\n\n#define LUA_COLIBNAME\t\"coroutine\"\n#define LUA_COLIBK\t(LUA_LOADLIBK << 1)\nLUAMOD_API int (luaopen_coroutine) (lua_State *L);\n\n#define LUA_DBLIBNAME\t\"debug\"\n#define LUA_DBLIBK\t(LUA_COLIBK << 1)\nLUAMOD_API int (luaopen_debug) (lua_State *L);\n\n#define LUA_IOLIBNAME\t\"io\"\n#define LUA_IOLIBK\t(LUA_DBLIBK << 1)\nLUAMOD_API int (luaopen_io) (lua_State *L);\n\n#define LUA_MATHLIBNAME\t\"math\"\n#define LUA_MATHLIBK\t(LUA_IOLIBK << 1)\nLUAMOD_API int (luaopen_math) (lua_State *L);\n\n#define LUA_OSLIBNAME\t\"os\"\n#define LUA_OSLIBK\t(LUA_MATHLIBK << 1)\nLUAMOD_API int (luaopen_os) (lua_State *L);\n\n#define LUA_STRLIBNAME\t\"string\"\n#define LUA_STRLIBK\t(LUA_OSLIBK << 1)\nLUAMOD_API int (luaopen_string) (lua_State *L);\n\n#define LUA_TABLIBNAME\t\"table\"\n#define LUA_TABLIBK\t(LUA_STRLIBK << 1)\nLUAMOD_API int (luaopen_table) (lua_State *L);\n\n#define LUA_UTF8LIBNAME\t\"utf8\"\n#define LUA_UTF8LIBK\t(LUA_TABLIBK << 1)\nLUAMOD_API int (luaopen_utf8) (lua_State *L);\n\n\n/* open selected libraries */\nLUALIB_API void (luaL_openselectedlibs) (lua_State *L, int load, int preload);\n\n/* open all libraries */\n#define luaL_openlibs(L)\tluaL_openselectedlibs(L, ~0, 0)\n\n\n#endif\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lundump.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: lundump.c $\n** load precompiled Lua chunks\n** See Copyright Notice in lua.h\n*/\n\n#define lundump_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <limits.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"lundump.h\"\n#include \"lzio.h\"\n\n\n#if !defined(luai_verifycode)\n#define luai_verifycode(L,f)  /* empty */\n#endif\n\n\ntypedef struct {\n  lua_State *L;\n  ZIO *Z;\n  const char *name;\n  Table *h;  /* list for string reuse */\n  lu_mem offset;  /* current position relative to beginning of dump */\n  lua_Integer nstr;  /* number of strings in the list */\n  lu_byte fixed;  /* dump is fixed in memory */\n} LoadState;\n\n\nstatic l_noret private_lua_error (LoadState *S, const char *why) {\n  luaO_pushfstring(S->L, \"%s: bad binary format (%s)\", S->name, why);\n  luaD_throw(S->L, LUA_ERRSYNTAX);\n}\n\n\n/*\n** All high-level loads go through loadVector; you can change it to\n** adapt to the endianness of the input\n*/\n#define loadVector(S,b,n)\tloadBlock(S,b,(n)*sizeof((b)[0]))\n\nstatic void loadBlock (LoadState *S, void *b, size_t size) {\n  if (luaZ_read(S->Z, b, size) != 0)\n      private_lua_error(S, \"truncated chunk\");\n  S->offset += size;\n}\n\n\nstatic void loadAlign (LoadState *S, int align) {\n  int padding = align - (S->offset % align);\n  if (padding < align) {  /* apd == align means no padding */\n    lua_Integer paddingContent;\n    loadBlock(S, &paddingContent, padding);\n    lua_assert(S->offset % align == 0);\n  }\n}\n\n\n#define getaddr(S,n,t)\tcast(t *, getaddr_(S,(n) * sizeof(t)))\n\nstatic const void *getaddr_ (LoadState *S, size_t size) {\n  const void *block = luaZ_getaddr(S->Z, size);\n  S->offset += size;\n  if (block == NULL)\n      private_lua_error(S, \"truncated fixed buffer\");\n  return block;\n}\n\n\n#define loadVar(S,x)\t\tloadVector(S,&x,1)\n\n\nstatic lu_byte loadByte (LoadState *S) {\n  int b = zgetc(S->Z);\n  if (b == EOZ)\n      private_lua_error(S, \"truncated chunk\");\n  S->offset++;\n  return cast_byte(b);\n}\n\n\nstatic size_t loadVarint (LoadState *S, size_t limit) {\n  size_t x = 0;\n  int b;\n  limit >>= 7;\n  do {\n    b = loadByte(S);\n    if (x > limit)\n        private_lua_error(S, \"integer overflow\");\n    x = (x << 7) | (b & 0x7f);\n  } while ((b & 0x80) != 0);\n  return x;\n}\n\n\nstatic size_t loadSize (LoadState *S) {\n  return loadVarint(S, MAX_SIZET);\n}\n\n\nstatic int loadInt (LoadState *S) {\n  return cast_int(loadVarint(S, cast_sizet(INT_MAX)));\n}\n\n\nstatic lua_Number loadNumber (LoadState *S) {\n  lua_Number x;\n  loadVar(S, x);\n  return x;\n}\n\n\nstatic lua_Integer loadInteger (LoadState *S) {\n  lua_Integer x;\n  loadVar(S, x);\n  return x;\n}\n\n\n/*\n** Load a nullable string into slot 'sl' from prototype 'p'. The\n** assignment to the slot and the barrier must be performed before any\n** possible GC activity, to anchor the string. (Both 'loadVector' and\n** 'luaH_setint' can call the GC.)\n*/\nstatic void loadString (LoadState *S, Proto *p, TString **sl) {\n  lua_State *L = S->L;\n  TString *ts;\n  TValue sv;\n  size_t size = loadSize(S);\n  if (size == 0) {  /* no string? */\n    lua_assert(*sl == NULL);  /* must be prefilled */\n    return;\n  }\n  else if (size == 1) {  /* previously saved string? */\n    lua_Integer idx = cast(lua_Integer, loadSize(S));  /* get its index */\n    TValue stv;\n    luaH_getint(S->h, idx, &stv);  /* get its value */\n    *sl = ts = tsvalue(&stv);\n    luaC_objbarrier(L, p, ts);\n    return;  /* do not save it again */\n  }\n  else if ((size -= 2) <= LUAI_MAXSHORTLEN) {  /* short string? */\n    char buff[LUAI_MAXSHORTLEN + 1];  /* extra space for '\\0' */\n    loadVector(S, buff, size + 1);  /* load string into buffer */\n    *sl = ts = luaS_newlstr(L, buff, size);  /* create string */\n    luaC_objbarrier(L, p, ts);\n  }\n  else if (S->fixed) {  /* for a fixed buffer, use a fixed string */\n    const char *s = getaddr(S, size + 1, char);  /* get content address */\n    *sl = ts = luaS_newextlstr(L, s, size, NULL, NULL);\n    luaC_objbarrier(L, p, ts);\n  }\n  else {  /* create internal copy */\n    *sl = ts = luaS_createlngstrobj(L, size);  /* create string */\n    luaC_objbarrier(L, p, ts);\n    loadVector(S, getlngstr(ts), size + 1);  /* load directly in final place */\n  }\n  /* add string to list of saved strings */\n  S->nstr++;\n  setsvalue(L, &sv, ts);\n  luaH_setint(L, S->h, S->nstr, &sv);\n  luaC_objbarrierback(L, obj2gco(S->h), ts);\n}\n\n\nstatic void loadCode (LoadState *S, Proto *f) {\n  int n = loadInt(S);\n  loadAlign(S, sizeof(f->code[0]));\n  if (S->fixed) {\n    f->code = getaddr(S, n, Instruction);\n    f->sizecode = n;\n  }\n  else {\n    f->code = luaM_newvectorchecked(S->L, n, Instruction);\n    f->sizecode = n;\n    loadVector(S, f->code, n);\n  }\n}\n\n\nstatic void loadFunction(LoadState *S, Proto *f);\n\n\nstatic void loadConstants (LoadState *S, Proto *f) {\n  int i;\n  int n = loadInt(S);\n  f->k = luaM_newvectorchecked(S->L, n, TValue);\n  f->sizek = n;\n  for (i = 0; i < n; i++)\n    setnilvalue(&f->k[i]);\n  for (i = 0; i < n; i++) {\n    TValue *o = &f->k[i];\n    int t = loadByte(S);\n    switch (t) {\n      case LUA_VNIL:\n        setnilvalue(o);\n        break;\n      case LUA_VFALSE:\n        setbfvalue(o);\n        break;\n      case LUA_VTRUE:\n        setbtvalue(o);\n        break;\n      case LUA_VNUMFLT:\n        setfltvalue(o, loadNumber(S));\n        break;\n      case LUA_VNUMINT:\n        setivalue(o, loadInteger(S));\n        break;\n      case LUA_VSHRSTR:\n      case LUA_VLNGSTR: {\n        lua_assert(f->source == NULL);\n        loadString(S, f, &f->source);  /* use 'source' to anchor string */\n        if (f->source == NULL)\n            private_lua_error(S, \"bad format for constant string\");\n        setsvalue2n(S->L, o, f->source);  /* save it in the right place */\n        f->source = NULL;\n        break;\n      }\n      default: lua_assert(0);\n    }\n  }\n}\n\n\nstatic void loadProtos (LoadState *S, Proto *f) {\n  int i;\n  int n = loadInt(S);\n  f->p = luaM_newvectorchecked(S->L, n, Proto *);\n  f->sizep = n;\n  for (i = 0; i < n; i++)\n    f->p[i] = NULL;\n  for (i = 0; i < n; i++) {\n    f->p[i] = luaF_newproto(S->L);\n    luaC_objbarrier(S->L, f, f->p[i]);\n    loadFunction(S, f->p[i]);\n  }\n}\n\n\n/*\n** Load the upvalues for a function. The names must be filled first,\n** because the filling of the other fields can raise read errors and\n** the creation of the error message can call an emergency collection;\n** in that case all prototypes must be consistent for the GC.\n*/\nstatic void loadUpvalues (LoadState *S, Proto *f) {\n  int i, n;\n  n = loadInt(S);\n  f->upvalues = luaM_newvectorchecked(S->L, n, Upvaldesc);\n  f->sizeupvalues = n;\n  for (i = 0; i < n; i++)  /* make array valid for GC */\n    f->upvalues[i].name = NULL;\n  for (i = 0; i < n; i++) {  /* following calls can raise errors */\n    f->upvalues[i].instack = loadByte(S);\n    f->upvalues[i].idx = loadByte(S);\n    f->upvalues[i].kind = loadByte(S);\n  }\n}\n\n\nstatic void loadDebug (LoadState *S, Proto *f) {\n  int i, n;\n  n = loadInt(S);\n  if (S->fixed) {\n    f->lineinfo = getaddr(S, n, ls_byte);\n    f->sizelineinfo = n;\n  }\n  else {\n    f->lineinfo = luaM_newvectorchecked(S->L, n, ls_byte);\n    f->sizelineinfo = n;\n    loadVector(S, f->lineinfo, n);\n  }\n  n = loadInt(S);\n  if (n > 0) {\n    loadAlign(S, sizeof(int));\n    if (S->fixed) {\n      f->abslineinfo = getaddr(S, n, AbsLineInfo);\n      f->sizeabslineinfo = n;\n    }\n    else {\n      f->abslineinfo = luaM_newvectorchecked(S->L, n, AbsLineInfo);\n      f->sizeabslineinfo = n;\n      loadVector(S, f->abslineinfo, n);\n    }\n  }\n  n = loadInt(S);\n  f->locvars = luaM_newvectorchecked(S->L, n, LocVar);\n  f->sizelocvars = n;\n  for (i = 0; i < n; i++)\n    f->locvars[i].varname = NULL;\n  for (i = 0; i < n; i++) {\n    loadString(S, f, &f->locvars[i].varname);\n    f->locvars[i].startpc = loadInt(S);\n    f->locvars[i].endpc = loadInt(S);\n  }\n  n = loadInt(S);\n  if (n != 0)  /* does it have debug information? */\n    n = f->sizeupvalues;  /* must be this many */\n  for (i = 0; i < n; i++)\n    loadString(S, f, &f->upvalues[i].name);\n}\n\n\nstatic void loadFunction (LoadState *S, Proto *f) {\n  f->linedefined = loadInt(S);\n  f->lastlinedefined = loadInt(S);\n  f->numparams = loadByte(S);\n  f->flag = loadByte(S) & PF_ISVARARG;  /* get only the meaningful flags */\n  if (S->fixed)\n    f->flag |= PF_FIXED;  /* signal that code is fixed */\n  f->maxstacksize = loadByte(S);\n  loadCode(S, f);\n  loadConstants(S, f);\n  loadUpvalues(S, f);\n  loadProtos(S, f);\n  loadString(S, f, &f->source);\n  loadDebug(S, f);\n}\n\n\nstatic void checkliteral (LoadState *S, const char *s, const char *msg) {\n  char buff[sizeof(LUA_SIGNATURE) + sizeof(LUAC_DATA)]; /* larger than both */\n  size_t len = strlen(s);\n  loadVector(S, buff, len);\n  if (memcmp(s, buff, len) != 0)\n      private_lua_error(S, msg);\n}\n\n\nstatic void fchecksize (LoadState *S, size_t size, const char *tname) {\n  if (loadByte(S) != size)\n      private_lua_error(S, luaO_pushfstring(S->L, \"%s size mismatch\", tname));\n}\n\n\n#define checksize(S,t)\tfchecksize(S,sizeof(t),#t)\n\nstatic void checkHeader (LoadState *S) {\n  /* skip 1st char (already read and checked) */\n  checkliteral(S, &LUA_SIGNATURE[1], \"not a binary chunk\");\n  if (loadByte(S) != LUAC_VERSION)\n      private_lua_error(S, \"version mismatch\");\n  if (loadByte(S) != LUAC_FORMAT)\n      private_lua_error(S, \"format mismatch\");\n  checkliteral(S, LUAC_DATA, \"corrupted chunk\");\n  checksize(S, Instruction);\n  checksize(S, lua_Integer);\n  checksize(S, lua_Number);\n  if (loadInteger(S) != LUAC_INT)\n      private_lua_error(S, \"integer format mismatch\");\n  if (loadNumber(S) != LUAC_NUM)\n      private_lua_error(S, \"float format mismatch\");\n}\n\n\n/*\n** Load precompiled chunk.\n*/\nLClosure *luaU_undump (lua_State *L, ZIO *Z, const char *name, int fixed) {\n  LoadState S;\n  LClosure *cl;\n  if (*name == '@' || *name == '=')\n    S.name = name + 1;\n  else if (*name == LUA_SIGNATURE[0])\n    S.name = \"binary string\";\n  else\n    S.name = name;\n  S.L = L;\n  S.Z = Z;\n  S.fixed = fixed;\n  S.offset = 1;  /* fist byte was already read */\n  checkHeader(&S);\n  cl = luaF_newLclosure(L, loadByte(&S));\n  setclLvalue2s(L, L->top.p, cl);\n  luaD_inctop(L);\n  S.h = luaH_new(L);  /* create list of saved strings */\n  S.nstr = 0;\n  sethvalue2s(L, L->top.p, S.h);  /* anchor it */\n  luaD_inctop(L);\n  cl->p = luaF_newproto(L);\n  luaC_objbarrier(L, cl, cl->p);\n  loadFunction(&S, cl->p);\n  lua_assert(cl->nupvalues == cl->p->sizeupvalues);\n  luai_verifycode(L, cl->p);\n  L->top.p--;  /* pop table */\n  return cl;\n}\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lundump.h",
		"is_binary":	false,
		"content":	"/*\n** $Id: lundump.h $\n** load precompiled Lua chunks\n** See Copyright Notice in lua.h\n*/\n\n#ifndef lundump_h\n#define lundump_h\n\n#include <limits.h>\n\n#include \"llimits.h\"\n#include \"lobject.h\"\n#include \"lzio.h\"\n\n\n/* data to catch conversion errors */\n#define LUAC_DATA\t\"\\x19\\x93\\r\\n\\x1a\\n\"\n\n#define LUAC_INT\t0x5678\n#define LUAC_NUM\tcast_num(370.5)\n\n/*\n** Encode major-minor version in one byte, one nibble for each\n*/\n#define LUAC_VERSION\t(LUA_VERSION_MAJOR_N*16+LUA_VERSION_MINOR_N)\n\n#define LUAC_FORMAT\t0\t/* this is the official format */\n\n\n/* load one chunk; from lundump.c */\nLUAI_FUNC LClosure* luaU_undump (lua_State* L, ZIO* Z, const char* name,\n                                               int fixed);\n\n/* dump one chunk; from ldump.c */\nLUAI_FUNC int luaU_dump (lua_State* L, const Proto* f, lua_Writer w,\n                         void* data, int strip);\n\n#endif\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lutf8lib.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: lutf8lib.c $\n** Standard library for UTF-8 manipulation\n** See Copyright Notice in lua.h\n*/\n\n#define lutf8lib_c\n#define LUA_LIB\n\n#include \"lprefix.h\"\n\n\n#include <assert.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n\n\n#define MAXUNICODE\t0x10FFFFu\n\n#define MAXUTF\t\t0x7FFFFFFFu\n\n\n#define MSGInvalid\t\"invalid UTF-8 code\"\n\n/*\n** Integer type for decoded UTF-8 values; MAXUTF needs 31 bits.\n*/\n#if (UINT_MAX >> 30) >= 1\ntypedef unsigned int utfint;\n#else\ntypedef unsigned long utfint;\n#endif\n\n\n#define iscont(c)\t(((c) & 0xC0) == 0x80)\n#define iscontp(p)\tiscont(*(p))\n\n\n/* from strlib */\n/* translate a relative string position: negative means back from end */\nstatic lua_Integer u_posrelat (lua_Integer pos, size_t len) {\n  if (pos >= 0) return pos;\n  else if (0u - (size_t)pos > len) return 0;\n  else return (lua_Integer)len + pos + 1;\n}\n\n\n/*\n** Decode one UTF-8 sequence, returning NULL if byte sequence is\n** invalid.  The array 'limits' stores the minimum value for each\n** sequence length, to check for overlong representations. Its first\n** entry forces an error for non-ascii bytes with no continuation\n** bytes (count == 0).\n*/\nstatic const char *utf8_decode (const char *s, utfint *val, int strict) {\n  static const utfint limits[] =\n        {~(utfint)0, 0x80, 0x800, 0x10000u, 0x200000u, 0x4000000u};\n  unsigned int c = (unsigned char)s[0];\n  utfint res = 0;  /* final result */\n  if (c < 0x80)  /* ascii? */\n    res = c;\n  else {\n    int count = 0;  /* to count number of continuation bytes */\n    for (; c & 0x40; c <<= 1) {  /* while it needs continuation bytes... */\n      unsigned int cc = (unsigned char)s[++count];  /* read next byte */\n      if (!iscont(cc))  /* not a continuation byte? */\n        return NULL;  /* invalid byte sequence */\n      res = (res << 6) | (cc & 0x3F);  /* add lower 6 bits from cont. byte */\n    }\n    res |= ((utfint)(c & 0x7F) << (count * 5));  /* add first byte */\n    if (count > 5 || res > MAXUTF || res < limits[count])\n      return NULL;  /* invalid byte sequence */\n    s += count;  /* skip continuation bytes read */\n  }\n  if (strict) {\n    /* check for invalid code points; too large or surrogates */\n    if (res > MAXUNICODE || (0xD800u <= res && res <= 0xDFFFu))\n      return NULL;\n  }\n  if (val) *val = res;\n  return s + 1;  /* +1 to include first byte */\n}\n\n\n/*\n** utf8len(s [, i [, j [, lax]]]) --> number of characters that\n** start in the range [i,j], or nil + current position if 's' is not\n** well formed in that interval\n*/\nstatic int utflen (lua_State *L) {\n  lua_Integer n = 0;  /* counter for the number of characters */\n  size_t len;  /* string length in bytes */\n  const char *s = luaL_checklstring(L, 1, &len);\n  lua_Integer posi = u_posrelat(luaL_optinteger(L, 2, 1), len);\n  lua_Integer posj = u_posrelat(luaL_optinteger(L, 3, -1), len);\n  int lax = lua_toboolean(L, 4);\n  luaL_argcheck(L, 1 <= posi && --posi <= (lua_Integer)len, 2,\n                   \"initial position out of bounds\");\n  luaL_argcheck(L, --posj < (lua_Integer)len, 3,\n                   \"final position out of bounds\");\n  while (posi <= posj) {\n    const char *s1 = utf8_decode(s + posi, NULL, !lax);\n    if (s1 == NULL) {  /* conversion error? */\n      luaL_pushfail(L);  /* return fail ... */\n      lua_pushinteger(L, posi + 1);  /* ... and current position */\n      return 2;\n    }\n    posi = s1 - s;\n    n++;\n  }\n  lua_pushinteger(L, n);\n  return 1;\n}\n\n\n/*\n** codepoint(s, [i, [j [, lax]]]) -> returns codepoints for all\n** characters that start in the range [i,j]\n*/\nstatic int codepoint (lua_State *L) {\n  size_t len;\n  const char *s = luaL_checklstring(L, 1, &len);\n  lua_Integer posi = u_posrelat(luaL_optinteger(L, 2, 1), len);\n  lua_Integer pose = u_posrelat(luaL_optinteger(L, 3, posi), len);\n  int lax = lua_toboolean(L, 4);\n  int n;\n  const char *se;\n  luaL_argcheck(L, posi >= 1, 2, \"out of bounds\");\n  luaL_argcheck(L, pose <= (lua_Integer)len, 3, \"out of bounds\");\n  if (posi > pose) return 0;  /* empty interval; return no values */\n  if (pose - posi >= INT_MAX)  /* (lua_Integer -> int) overflow? */\n    return luaL_error(L, \"string slice too long\");\n  n = (int)(pose -  posi) + 1;  /* upper bound for number of returns */\n  luaL_checkstack(L, n, \"string slice too long\");\n  n = 0;  /* count the number of returns */\n  se = s + pose;  /* string end */\n  for (s += posi - 1; s < se;) {\n    utfint code;\n    s = utf8_decode(s, &code, !lax);\n    if (s == NULL)\n      return luaL_error(L, MSGInvalid);\n    lua_pushinteger(L, code);\n    n++;\n  }\n  return n;\n}\n\n\nstatic void pushutfchar (lua_State *L, int arg) {\n  lua_Unsigned code = (lua_Unsigned)luaL_checkinteger(L, arg);\n  luaL_argcheck(L, code <= MAXUTF, arg, \"value out of range\");\n  lua_pushfstring(L, \"%U\", (long)code);\n}\n\n\n/*\n** utfchar(n1, n2, ...)  -> char(n1)..char(n2)...\n*/\nstatic int utfchar (lua_State *L) {\n  int n = lua_gettop(L);  /* number of arguments */\n  if (n == 1)  /* optimize common case of single char */\n    pushutfchar(L, 1);\n  else {\n    int i;\n    luaL_Buffer b;\n    luaL_buffinit(L, &b);\n    for (i = 1; i <= n; i++) {\n      pushutfchar(L, i);\n      luaL_addvalue(&b);\n    }\n    luaL_pushresult(&b);\n  }\n  return 1;\n}\n\n\n/*\n** offset(s, n, [i])  -> index where n-th character counting from\n**   position 'i' starts; 0 means character at 'i'.\n*/\nstatic int byteoffset (lua_State *L) {\n  size_t len;\n  const char *s = luaL_checklstring(L, 1, &len);\n  lua_Integer n  = luaL_checkinteger(L, 2);\n  lua_Integer posi = (n >= 0) ? 1 : len + 1;\n  posi = u_posrelat(luaL_optinteger(L, 3, posi), len);\n  luaL_argcheck(L, 1 <= posi && --posi <= (lua_Integer)len, 3,\n                   \"position out of bounds\");\n  if (n == 0) {\n    /* find beginning of current byte sequence */\n    while (posi > 0 && iscontp(s + posi)) posi--;\n  }\n  else {\n    if (iscontp(s + posi))\n      return luaL_error(L, \"initial position is a continuation byte\");\n    if (n < 0) {\n       while (n < 0 && posi > 0) {  /* move back */\n         do {  /* find beginning of previous character */\n           posi--;\n         } while (posi > 0 && iscontp(s + posi));\n         n++;\n       }\n     }\n     else {\n       n--;  /* do not move for 1st character */\n       while (n > 0 && posi < (lua_Integer)len) {\n         do {  /* find beginning of next character */\n           posi++;\n         } while (iscontp(s + posi));  /* (cannot pass final '\\0') */\n         n--;\n       }\n     }\n  }\n  if (n == 0)  /* did it find given character? */\n    lua_pushinteger(L, posi + 1);\n  else  /* no such character */\n    luaL_pushfail(L);\n  return 1;\n}\n\n\nstatic int iter_aux (lua_State *L, int strict) {\n  size_t len;\n  const char *s = luaL_checklstring(L, 1, &len);\n  lua_Unsigned n = (lua_Unsigned)lua_tointeger(L, 2);\n  if (n < len) {\n    while (iscontp(s + n)) n++;  /* go to next character */\n  }\n  if (n >= len)  /* (also handles original 'n' being negative) */\n    return 0;  /* no more codepoints */\n  else {\n    utfint code;\n    const char *next = utf8_decode(s + n, &code, strict);\n    if (next == NULL || iscontp(next))\n      return luaL_error(L, MSGInvalid);\n    lua_pushinteger(L, n + 1);\n    lua_pushinteger(L, code);\n    return 2;\n  }\n}\n\n\nstatic int iter_auxstrict (lua_State *L) {\n  return iter_aux(L, 1);\n}\n\nstatic int iter_auxlax (lua_State *L) {\n  return iter_aux(L, 0);\n}\n\n\nstatic int iter_codes (lua_State *L) {\n  int lax = lua_toboolean(L, 2);\n  const char *s = luaL_checkstring(L, 1);\n  luaL_argcheck(L, !iscontp(s), 1, MSGInvalid);\n  lua_pushcfunction(L, lax ? iter_auxlax : iter_auxstrict);\n  lua_pushvalue(L, 1);\n  lua_pushinteger(L, 0);\n  return 3;\n}\n\n\n/* pattern to match a single UTF-8 character */\n#define UTF8PATT\t\"[\\0-\\x7F\\xC2-\\xFD][\\x80-\\xBF]*\"\n\n\nstatic const luaL_Reg funcs[] = {\n  {\"offset\", byteoffset},\n  {\"codepoint\", codepoint},\n  {\"char\", utfchar},\n  {\"len\", utflen},\n  {\"codes\", iter_codes},\n  /* placeholders */\n  {\"charpattern\", NULL},\n  {NULL, NULL}\n};\n\n\nLUAMOD_API int luaopen_utf8 (lua_State *L) {\n  luaL_newlib(L, funcs);\n  lua_pushlstring(L, UTF8PATT, sizeof(UTF8PATT)/sizeof(char) - 1);\n  lua_setfield(L, -2, \"charpattern\");\n  return 1;\n}\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lvm.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: lvm.c $\n** Lua virtual machine\n** See Copyright Notice in lua.h\n*/\n\n#define lvm_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n#include \"lvm.h\"\n\n\n/*\n** By default, use jump tables in the main interpreter loop on gcc\n** and compatible compilers.\n*/\n#if !defined(LUA_USE_JUMPTABLE)\n#if defined(__GNUC__)\n#define LUA_USE_JUMPTABLE\t1\n#else\n#define LUA_USE_JUMPTABLE\t0\n#endif\n#endif\n\n\n\n/* limit for table tag-method chains (to avoid infinite loops) */\n#define MAXTAGLOOP\t2000\n\n\n/*\n** 'l_intfitsf' checks whether a given integer is in the range that\n** can be converted to a float without rounding. Used in comparisons.\n*/\n\n/* number of bits in the mantissa of a float */\n#define NBM\t\t(l_floatatt(MANT_DIG))\n\n/*\n** Check whether some integers may not fit in a float, testing whether\n** (maxinteger >> NBM) > 0. (That implies (1 << NBM) <= maxinteger.)\n** (The shifts are done in parts, to avoid shifting by more than the size\n** of an integer. In a worst case, NBM == 113 for long double and\n** sizeof(long) == 32.)\n*/\n#if ((((LUA_MAXINTEGER >> (NBM / 4)) >> (NBM / 4)) >> (NBM / 4)) \\\n\t>> (NBM - (3 * (NBM / 4))))  >  0\n\n/* limit for integers that fit in a float */\n#define MAXINTFITSF\t((lua_Unsigned)1 << NBM)\n\n/* check whether 'i' is in the interval [-MAXINTFITSF, MAXINTFITSF] */\n#define l_intfitsf(i)\t((MAXINTFITSF + l_castS2U(i)) <= (2 * MAXINTFITSF))\n\n#else  /* all integers fit in a float precisely */\n\n#define l_intfitsf(i)\t1\n\n#endif\n\n\n/*\n** Try to convert a value from string to a number value.\n** If the value is not a string or is a string not representing\n** a valid numeral (or if coercions from strings to numbers\n** are disabled via macro 'cvt2num'), do not modify 'result'\n** and return 0.\n*/\nstatic int l_strton (const TValue *obj, TValue *result) {\n  lua_assert(obj != result);\n  if (!cvt2num(obj))  /* is object not a string? */\n    return 0;\n  else {\n  TString *st = tsvalue(obj);\n  size_t stlen;\n  const char *s = getlstr(st, stlen);\n  return (luaO_str2num(s, result) == stlen + 1);\n  }\n}\n\n\n/*\n** Try to convert a value to a float. The float case is already handled\n** by the macro 'tonumber'.\n*/\nint luaV_tonumber_ (const TValue *obj, lua_Number *n) {\n  TValue v;\n  if (ttisinteger(obj)) {\n    *n = cast_num(ivalue(obj));\n    return 1;\n  }\n  else if (l_strton(obj, &v)) {  /* string coercible to number? */\n    *n = nvalue(&v);  /* convert result of 'luaO_str2num' to a float */\n    return 1;\n  }\n  else\n    return 0;  /* conversion failed */\n}\n\n\n/*\n** try to convert a float to an integer, rounding according to 'mode'.\n*/\nint luaV_flttointeger (lua_Number n, lua_Integer *p, F2Imod mode) {\n  lua_Number f = l_floor(n);\n  if (n != f) {  /* not an integral value? */\n    if (mode == F2Ieq) return 0;  /* fails if mode demands integral value */\n    else if (mode == F2Iceil)  /* needs ceil? */\n      f += 1;  /* convert floor to ceil (remember: n != f) */\n  }\n  return lua_numbertointeger(f, p);\n}\n\n\n/*\n** try to convert a value to an integer, rounding according to 'mode',\n** without string coercion.\n** (\"Fast track\" handled by macro 'tointegerns'.)\n*/\nint luaV_tointegerns (const TValue *obj, lua_Integer *p, F2Imod mode) {\n  if (ttisfloat(obj))\n    return luaV_flttointeger(fltvalue(obj), p, mode);\n  else if (ttisinteger(obj)) {\n    *p = ivalue(obj);\n    return 1;\n  }\n  else\n    return 0;\n}\n\n\n/*\n** try to convert a value to an integer.\n*/\nint luaV_tointeger (const TValue *obj, lua_Integer *p, F2Imod mode) {\n  TValue v;\n  if (l_strton(obj, &v))  /* does 'obj' point to a numerical string? */\n    obj = &v;  /* change it to point to its corresponding number */\n  return luaV_tointegerns(obj, p, mode);\n}\n\n\n/*\n** Try to convert a 'for' limit to an integer, preserving the semantics\n** of the loop. Return true if the loop must not run; otherwise, '*p'\n** gets the integer limit.\n** (The following explanation assumes a positive step; it is valid for\n** negative steps mutatis mutandis.)\n** If the limit is an integer or can be converted to an integer,\n** rounding down, that is the limit.\n** Otherwise, check whether the limit can be converted to a float. If\n** the float is too large, clip it to LUA_MAXINTEGER.  If the float\n** is too negative, the loop should not run, because any initial\n** integer value is greater than such limit; so, the function returns\n** true to signal that. (For this latter case, no integer limit would be\n** correct; even a limit of LUA_MININTEGER would run the loop once for\n** an initial value equal to LUA_MININTEGER.)\n*/\nstatic int forlimit (lua_State *L, lua_Integer init, const TValue *lim,\n                                   lua_Integer *p, lua_Integer step) {\n  if (!luaV_tointeger(lim, p, (step < 0 ? F2Iceil : F2Ifloor))) {\n    /* not coercible to in integer */\n    lua_Number flim;  /* try to convert to float */\n    if (!tonumber(lim, &flim)) /* cannot convert to float? */\n      luaG_forerror(L, lim, \"limit\");\n    /* else 'flim' is a float out of integer bounds */\n    if (luai_numlt(0, flim)) {  /* if it is positive, it is too large */\n      if (step < 0) return 1;  /* initial value must be less than it */\n      *p = LUA_MAXINTEGER;  /* truncate */\n    }\n    else {  /* it is less than min integer */\n      if (step > 0) return 1;  /* initial value must be greater than it */\n      *p = LUA_MININTEGER;  /* truncate */\n    }\n  }\n  return (step > 0 ? init > *p : init < *p);  /* not to run? */\n}\n\n\n/*\n** Prepare a numerical for loop (opcode OP_FORPREP).\n** Before execution, stack is as follows:\n**   ra     : initial value\n**   ra + 1 : limit\n**   ra + 2 : step\n** Return true to skip the loop. Otherwise,\n** after preparation, stack will be as follows:\n**   ra     : loop counter (integer loops) or limit (float loops)\n**   ra + 1 : step\n**   ra + 2 : control variable\n*/\nstatic int forprep (lua_State *L, StkId ra) {\n  TValue *pinit = s2v(ra);\n  TValue *plimit = s2v(ra + 1);\n  TValue *pstep = s2v(ra + 2);\n  if (ttisinteger(pinit) && ttisinteger(pstep)) { /* integer loop? */\n    lua_Integer init = ivalue(pinit);\n    lua_Integer step = ivalue(pstep);\n    lua_Integer limit;\n    if (step == 0)\n      luaG_runerror(L, \"'for' step is zero\");\n    if (forlimit(L, init, plimit, &limit, step))\n      return 1;  /* skip the loop */\n    else {  /* prepare loop counter */\n      lua_Unsigned count;\n      if (step > 0) {  /* ascending loop? */\n        count = l_castS2U(limit) - l_castS2U(init);\n        if (step != 1)  /* avoid division in the too common case */\n          count /= l_castS2U(step);\n      }\n      else {  /* step < 0; descending loop */\n        count = l_castS2U(init) - l_castS2U(limit);\n        /* 'step+1' avoids negating 'mininteger' */\n        count /= l_castS2U(-(step + 1)) + 1u;\n      }\n      /* use 'chgivalue' for places that for sure had integers */\n      chgivalue(s2v(ra), l_castU2S(count));  /* change init to count */\n      setivalue(s2v(ra + 1), step);  /* change limit to step */\n      chgivalue(s2v(ra + 2), init);  /* change step to init */\n    }\n  }\n  else {  /* try making all values floats */\n    lua_Number init; lua_Number limit; lua_Number step;\n    if (l_unlikely(!tonumber(plimit, &limit)))\n      luaG_forerror(L, plimit, \"limit\");\n    if (l_unlikely(!tonumber(pstep, &step)))\n      luaG_forerror(L, pstep, \"step\");\n    if (l_unlikely(!tonumber(pinit, &init)))\n      luaG_forerror(L, pinit, \"initial value\");\n    if (step == 0)\n      luaG_runerror(L, \"'for' step is zero\");\n    if (luai_numlt(0, step) ? luai_numlt(limit, init)\n                            : luai_numlt(init, limit))\n      return 1;  /* skip the loop */\n    else {\n      /* make sure all values are floats */\n      setfltvalue(s2v(ra), limit);\n      setfltvalue(s2v(ra + 1), step);\n      setfltvalue(s2v(ra + 2), init);  /* control variable */\n    }\n  }\n  return 0;\n}\n\n\n/*\n** Execute a step of a float numerical for loop, returning\n** true iff the loop must continue. (The integer case is\n** written online with opcode OP_FORLOOP, for performance.)\n*/\nstatic int floatforloop (StkId ra) {\n  lua_Number step = fltvalue(s2v(ra + 1));\n  lua_Number limit = fltvalue(s2v(ra));\n  lua_Number idx = fltvalue(s2v(ra + 2));  /* control variable */\n  idx = luai_numadd(L, idx, step);  /* increment index */\n  if (luai_numlt(0, step) ? luai_numle(idx, limit)\n                          : luai_numle(limit, idx)) {\n    chgfltvalue(s2v(ra + 2), idx);  /* update control variable */\n    return 1;  /* jump back */\n  }\n  else\n    return 0;  /* finish the loop */\n}\n\n\n/*\n** Finish the table access 'val = t[key]' and return the tag of the result.\n*/\nint luaV_finishget (lua_State *L, const TValue *t, TValue *key, StkId val,\n                      int tag) {\n  int loop;  /* counter to avoid infinite loops */\n  const TValue *tm;  /* metamethod */\n  for (loop = 0; loop < MAXTAGLOOP; loop++) {\n    if (tag == LUA_VNOTABLE) {  /* 't' is not a table? */\n      lua_assert(!ttistable(t));\n      tm = luaT_gettmbyobj(L, t, TM_INDEX);\n      if (l_unlikely(notm(tm)))\n        luaG_typeerror(L, t, \"index\");  /* no metamethod */\n      /* else will try the metamethod */\n    }\n    else {  /* 't' is a table */\n      tm = fasttm(L, hvalue(t)->metatable, TM_INDEX);  /* table's metamethod */\n      if (tm == NULL) {  /* no metamethod? */\n        setnilvalue(s2v(val));  /* result is nil */\n        return LUA_VNIL;\n      }\n      /* else will try the metamethod */\n    }\n    if (ttisfunction(tm)) {  /* is metamethod a function? */\n      tag = luaT_callTMres(L, tm, t, key, val);  /* call it */\n      return tag;  /* return tag of the result */\n    }\n    t = tm;  /* else try to access 'tm[key]' */\n    luaV_fastget(t, key, s2v(val), luaH_get, tag);\n    if (!tagisempty(tag))\n      return tag;  /* done */\n    /* else repeat (tail call 'luaV_finishget') */\n  }\n  luaG_runerror(L, \"'__index' chain too long; possible loop\");\n  return 0;  /* to avoid warnings */\n}\n\n\n/*\n** Finish a table assignment 't[key] = val'.\n*/\nvoid luaV_finishset (lua_State *L, const TValue *t, TValue *key,\n                      TValue *val, int hres) {\n  int loop;  /* counter to avoid infinite loops */\n  for (loop = 0; loop < MAXTAGLOOP; loop++) {\n    const TValue *tm;  /* '__newindex' metamethod */\n    if (hres != HNOTATABLE) {  /* is 't' a table? */\n      Table *h = hvalue(t);  /* save 't' table */\n      tm = fasttm(L, h->metatable, TM_NEWINDEX);  /* get metamethod */\n      if (tm == NULL) {  /* no metamethod? */\n        luaH_finishset(L, h, key, val, hres);  /* set new value */\n        invalidateTMcache(h);\n        luaC_barrierback(L, obj2gco(h), val);\n        return;\n      }\n      /* else will try the metamethod */\n    }\n    else {  /* not a table; check metamethod */\n      tm = luaT_gettmbyobj(L, t, TM_NEWINDEX);\n      if (l_unlikely(notm(tm)))\n        luaG_typeerror(L, t, \"index\");\n    }\n    /* try the metamethod */\n    if (ttisfunction(tm)) {\n      luaT_callTM(L, tm, t, key, val);\n      return;\n    }\n    t = tm;  /* else repeat assignment over 'tm' */\n    luaV_fastset(t, key, val, hres, luaH_pset);\n    if (hres == HOK)\n      return;  /* done */\n    /* else 'return luaV_finishset(L, t, key, val, slot)' (loop) */\n  }\n  luaG_runerror(L, \"'__newindex' chain too long; possible loop\");\n}\n\n\n/*\n** Compare two strings 'ts1' x 'ts2', returning an integer less-equal-\n** -greater than zero if 'ts1' is less-equal-greater than 'ts2'.\n** The code is a little tricky because it allows '\\0' in the strings\n** and it uses 'strcoll' (to respect locales) for each segment\n** of the strings. Note that segments can compare equal but still\n** have different lengths.\n*/\nstatic int l_strcmp (const TString *ts1, const TString *ts2) {\n  size_t rl1;  /* real length */\n  const char *s1 = getlstr(ts1, rl1);\n  size_t rl2;\n  const char *s2 = getlstr(ts2, rl2);\n  for (;;) {  /* for each segment */\n    int temp = strcoll(s1, s2);\n    if (temp != 0)  /* not equal? */\n      return temp;  /* done */\n    else {  /* strings are equal up to a '\\0' */\n      size_t zl1 = strlen(s1);  /* index of first '\\0' in 's1' */\n      size_t zl2 = strlen(s2);  /* index of first '\\0' in 's2' */\n      if (zl2 == rl2)  /* 's2' is finished? */\n        return (zl1 == rl1) ? 0 : 1;  /* check 's1' */\n      else if (zl1 == rl1)  /* 's1' is finished? */\n        return -1;  /* 's1' is less than 's2' ('s2' is not finished) */\n      /* both strings longer than 'zl'; go on comparing after the '\\0' */\n      zl1++; zl2++;\n      s1 += zl1; rl1 -= zl1; s2 += zl2; rl2 -= zl2;\n    }\n  }\n}\n\n\n/*\n** Check whether integer 'i' is less than float 'f'. If 'i' has an\n** exact representation as a float ('l_intfitsf'), compare numbers as\n** floats. Otherwise, use the equivalence 'i < f <=> i < ceil(f)'.\n** If 'ceil(f)' is out of integer range, either 'f' is greater than\n** all integers or less than all integers.\n** (The test with 'l_intfitsf' is only for performance; the else\n** case is correct for all values, but it is slow due to the conversion\n** from float to int.)\n** When 'f' is NaN, comparisons must result in false.\n*/\nl_sinline int LTintfloat (lua_Integer i, lua_Number f) {\n  if (l_intfitsf(i))\n    return luai_numlt(cast_num(i), f);  /* compare them as floats */\n  else {  /* i < f <=> i < ceil(f) */\n    lua_Integer fi;\n    if (luaV_flttointeger(f, &fi, F2Iceil))  /* fi = ceil(f) */\n      return i < fi;   /* compare them as integers */\n    else  /* 'f' is either greater or less than all integers */\n      return f > 0;  /* greater? */\n  }\n}\n\n\n/*\n** Check whether integer 'i' is less than or equal to float 'f'.\n** See comments on previous function.\n*/\nl_sinline int LEintfloat (lua_Integer i, lua_Number f) {\n  if (l_intfitsf(i))\n    return luai_numle(cast_num(i), f);  /* compare them as floats */\n  else {  /* i <= f <=> i <= floor(f) */\n    lua_Integer fi;\n    if (luaV_flttointeger(f, &fi, F2Ifloor))  /* fi = floor(f) */\n      return i <= fi;   /* compare them as integers */\n    else  /* 'f' is either greater or less than all integers */\n      return f > 0;  /* greater? */\n  }\n}\n\n\n/*\n** Check whether float 'f' is less than integer 'i'.\n** See comments on previous function.\n*/\nl_sinline int LTfloatint (lua_Number f, lua_Integer i) {\n  if (l_intfitsf(i))\n    return luai_numlt(f, cast_num(i));  /* compare them as floats */\n  else {  /* f < i <=> floor(f) < i */\n    lua_Integer fi;\n    if (luaV_flttointeger(f, &fi, F2Ifloor))  /* fi = floor(f) */\n      return fi < i;   /* compare them as integers */\n    else  /* 'f' is either greater or less than all integers */\n      return f < 0;  /* less? */\n  }\n}\n\n\n/*\n** Check whether float 'f' is less than or equal to integer 'i'.\n** See comments on previous function.\n*/\nl_sinline int LEfloatint (lua_Number f, lua_Integer i) {\n  if (l_intfitsf(i))\n    return luai_numle(f, cast_num(i));  /* compare them as floats */\n  else {  /* f <= i <=> ceil(f) <= i */\n    lua_Integer fi;\n    if (luaV_flttointeger(f, &fi, F2Iceil))  /* fi = ceil(f) */\n      return fi <= i;   /* compare them as integers */\n    else  /* 'f' is either greater or less than all integers */\n      return f < 0;  /* less? */\n  }\n}\n\n\n/*\n** Return 'l < r', for numbers.\n*/\nl_sinline int LTnum (const TValue *l, const TValue *r) {\n  lua_assert(ttisnumber(l) && ttisnumber(r));\n  if (ttisinteger(l)) {\n    lua_Integer li = ivalue(l);\n    if (ttisinteger(r))\n      return li < ivalue(r);  /* both are integers */\n    else  /* 'l' is int and 'r' is float */\n      return LTintfloat(li, fltvalue(r));  /* l < r ? */\n  }\n  else {\n    lua_Number lf = fltvalue(l);  /* 'l' must be float */\n    if (ttisfloat(r))\n      return luai_numlt(lf, fltvalue(r));  /* both are float */\n    else  /* 'l' is float and 'r' is int */\n      return LTfloatint(lf, ivalue(r));\n  }\n}\n\n\n/*\n** Return 'l <= r', for numbers.\n*/\nl_sinline int LEnum (const TValue *l, const TValue *r) {\n  lua_assert(ttisnumber(l) && ttisnumber(r));\n  if (ttisinteger(l)) {\n    lua_Integer li = ivalue(l);\n    if (ttisinteger(r))\n      return li <= ivalue(r);  /* both are integers */\n    else  /* 'l' is int and 'r' is float */\n      return LEintfloat(li, fltvalue(r));  /* l <= r ? */\n  }\n  else {\n    lua_Number lf = fltvalue(l);  /* 'l' must be float */\n    if (ttisfloat(r))\n      return luai_numle(lf, fltvalue(r));  /* both are float */\n    else  /* 'l' is float and 'r' is int */\n      return LEfloatint(lf, ivalue(r));\n  }\n}\n\n\n/*\n** return 'l < r' for non-numbers.\n*/\nstatic int lessthanothers (lua_State *L, const TValue *l, const TValue *r) {\n  lua_assert(!ttisnumber(l) || !ttisnumber(r));\n  if (ttisstring(l) && ttisstring(r))  /* both are strings? */\n    return l_strcmp(tsvalue(l), tsvalue(r)) < 0;\n  else\n    return luaT_callorderTM(L, l, r, TM_LT);\n}\n\n\n/*\n** Main operation less than; return 'l < r'.\n*/\nint luaV_lessthan (lua_State *L, const TValue *l, const TValue *r) {\n  if (ttisnumber(l) && ttisnumber(r))  /* both operands are numbers? */\n    return LTnum(l, r);\n  else return lessthanothers(L, l, r);\n}\n\n\n/*\n** return 'l <= r' for non-numbers.\n*/\nstatic int lessequalothers (lua_State *L, const TValue *l, const TValue *r) {\n  lua_assert(!ttisnumber(l) || !ttisnumber(r));\n  if (ttisstring(l) && ttisstring(r))  /* both are strings? */\n    return l_strcmp(tsvalue(l), tsvalue(r)) <= 0;\n  else\n    return luaT_callorderTM(L, l, r, TM_LE);\n}\n\n\n/*\n** Main operation less than or equal to; return 'l <= r'.\n*/\nint luaV_lessequal (lua_State *L, const TValue *l, const TValue *r) {\n  if (ttisnumber(l) && ttisnumber(r))  /* both operands are numbers? */\n    return LEnum(l, r);\n  else return lessequalothers(L, l, r);\n}\n\n\n/*\n** Main operation for equality of Lua values; return 't1 == t2'.\n** L == NULL means raw equality (no metamethods)\n*/\nint luaV_equalobj (lua_State *L, const TValue *t1, const TValue *t2) {\n  const TValue *tm;\n  if (ttypetag(t1) != ttypetag(t2)) {  /* not the same variant? */\n    if (ttype(t1) != ttype(t2) || ttype(t1) != LUA_TNUMBER)\n      return 0;  /* only numbers can be equal with different variants */\n    else {  /* two numbers with different variants */\n      /* One of them is an integer. If the other does not have an\n         integer value, they cannot be equal; otherwise, compare their\n         integer values. */\n      lua_Integer i1, i2;\n      return (luaV_tointegerns(t1, &i1, F2Ieq) &&\n              luaV_tointegerns(t2, &i2, F2Ieq) &&\n              i1 == i2);\n    }\n  }\n  /* values have same type and same variant */\n  switch (ttypetag(t1)) {\n    case LUA_VNIL: case LUA_VFALSE: case LUA_VTRUE: return 1;\n    case LUA_VNUMINT: return (ivalue(t1) == ivalue(t2));\n    case LUA_VNUMFLT: return luai_numeq(fltvalue(t1), fltvalue(t2));\n    case LUA_VLIGHTUSERDATA: return pvalue(t1) == pvalue(t2);\n    case LUA_VLCF: return fvalue(t1) == fvalue(t2);\n    case LUA_VSHRSTR: return eqshrstr(tsvalue(t1), tsvalue(t2));\n    case LUA_VLNGSTR: return luaS_eqlngstr(tsvalue(t1), tsvalue(t2));\n    case LUA_VUSERDATA: {\n      if (uvalue(t1) == uvalue(t2)) return 1;\n      else if (L == NULL) return 0;\n      tm = fasttm(L, uvalue(t1)->metatable, TM_EQ);\n      if (tm == NULL)\n        tm = fasttm(L, uvalue(t2)->metatable, TM_EQ);\n      break;  /* will try TM */\n    }\n    case LUA_VTABLE: {\n      if (hvalue(t1) == hvalue(t2)) return 1;\n      else if (L == NULL) return 0;\n      tm = fasttm(L, hvalue(t1)->metatable, TM_EQ);\n      if (tm == NULL)\n        tm = fasttm(L, hvalue(t2)->metatable, TM_EQ);\n      break;  /* will try TM */\n    }\n    default:\n      return gcvalue(t1) == gcvalue(t2);\n  }\n  if (tm == NULL)  /* no TM? */\n    return 0;  /* objects are different */\n  else {\n    int tag = luaT_callTMres(L, tm, t1, t2, L->top.p);  /* call TM */\n    return !tagisfalse(tag);\n  }\n}\n\n\n/* macro used by 'luaV_concat' to ensure that element at 'o' is a string */\n#define tostring(L,o)  \\\n\t(ttisstring(o) || (cvt2str(o) && (luaO_tostring(L, o), 1)))\n\n#define isemptystr(o)\t(ttisshrstring(o) && tsvalue(o)->shrlen == 0)\n\n/* copy strings in stack from top - n up to top - 1 to buffer */\nstatic void copy2buff (StkId top, int n, char *buff) {\n  size_t tl = 0;  /* size already copied */\n  do {\n    TString *st = tsvalue(s2v(top - n));\n    size_t l;  /* length of string being copied */\n    const char *s = getlstr(st, l);\n    memcpy(buff + tl, s, l * sizeof(char));\n    tl += l;\n  } while (--n > 0);\n}\n\n\n/*\n** Main operation for concatenation: concat 'total' values in the stack,\n** from 'L->top.p - total' up to 'L->top.p - 1'.\n*/\nvoid luaV_concat (lua_State *L, int total) {\n  if (total == 1)\n    return;  /* \"all\" values already concatenated */\n  do {\n    StkId top = L->top.p;\n    int n = 2;  /* number of elements handled in this pass (at least 2) */\n    if (!(ttisstring(s2v(top - 2)) || cvt2str(s2v(top - 2))) ||\n        !tostring(L, s2v(top - 1)))\n      luaT_tryconcatTM(L);  /* may invalidate 'top' */\n    else if (isemptystr(s2v(top - 1)))  /* second operand is empty? */\n      cast_void(tostring(L, s2v(top - 2)));  /* result is first operand */\n    else if (isemptystr(s2v(top - 2))) {  /* first operand is empty string? */\n      setobjs2s(L, top - 2, top - 1);  /* result is second op. */\n    }\n    else {\n      /* at least two non-empty string values; get as many as possible */\n      size_t tl = tsslen(tsvalue(s2v(top - 1)));\n      TString *ts;\n      /* collect total length and number of strings */\n      for (n = 1; n < total && tostring(L, s2v(top - n - 1)); n++) {\n        size_t l = tsslen(tsvalue(s2v(top - n - 1)));\n        if (l_unlikely(l >= MAX_SIZE - sizeof(TString) - tl)) {\n          L->top.p = top - total;  /* pop strings to avoid wasting stack */\n          luaG_runerror(L, \"string length overflow\");\n        }\n        tl += l;\n      }\n      if (tl <= LUAI_MAXSHORTLEN) {  /* is result a short string? */\n        char buff[LUAI_MAXSHORTLEN];\n        copy2buff(top, n, buff);  /* copy strings to buffer */\n        ts = luaS_newlstr(L, buff, tl);\n      }\n      else {  /* long string; copy strings directly to final result */\n        ts = luaS_createlngstrobj(L, tl);\n        copy2buff(top, n, getlngstr(ts));\n      }\n      setsvalue2s(L, top - n, ts);  /* create result */\n    }\n    total -= n - 1;  /* got 'n' strings to create one new */\n    L->top.p -= n - 1;  /* popped 'n' strings and pushed one */\n  } while (total > 1);  /* repeat until only 1 result left */\n}\n\n\n/*\n** Main operation 'ra = #rb'.\n*/\nvoid luaV_objlen (lua_State *L, StkId ra, const TValue *rb) {\n  const TValue *tm;\n  switch (ttypetag(rb)) {\n    case LUA_VTABLE: {\n      Table *h = hvalue(rb);\n      tm = fasttm(L, h->metatable, TM_LEN);\n      if (tm) break;  /* metamethod? break switch to call it */\n      setivalue(s2v(ra), luaH_getn(h));  /* else primitive len */\n      return;\n    }\n    case LUA_VSHRSTR: {\n      setivalue(s2v(ra), tsvalue(rb)->shrlen);\n      return;\n    }\n    case LUA_VLNGSTR: {\n      setivalue(s2v(ra), tsvalue(rb)->u.lnglen);\n      return;\n    }\n    default: {  /* try metamethod */\n      tm = luaT_gettmbyobj(L, rb, TM_LEN);\n      if (l_unlikely(notm(tm)))  /* no metamethod? */\n        luaG_typeerror(L, rb, \"get length of\");\n      break;\n    }\n  }\n  luaT_callTMres(L, tm, rb, rb, ra);\n}\n\n\n/*\n** Integer division; return 'm // n', that is, floor(m/n).\n** C division truncates its result (rounds towards zero).\n** 'floor(q) == trunc(q)' when 'q >= 0' or when 'q' is integer,\n** otherwise 'floor(q) == trunc(q) - 1'.\n*/\nlua_Integer luaV_idiv (lua_State *L, lua_Integer m, lua_Integer n) {\n  if (l_unlikely(l_castS2U(n) + 1u <= 1u)) {  /* special cases: -1 or 0 */\n    if (n == 0)\n      luaG_runerror(L, \"attempt to divide by zero\");\n    return intop(-, 0, m);   /* n==-1; avoid overflow with 0x80000...//-1 */\n  }\n  else {\n    lua_Integer q = m / n;  /* perform C division */\n    if ((m ^ n) < 0 && m % n != 0)  /* 'm/n' would be negative non-integer? */\n      q -= 1;  /* correct result for different rounding */\n    return q;\n  }\n}\n\n\n/*\n** Integer modulus; return 'm % n'. (Assume that C '%' with\n** negative operands follows C99 behavior. See previous comment\n** about luaV_idiv.)\n*/\nlua_Integer luaV_mod (lua_State *L, lua_Integer m, lua_Integer n) {\n  if (l_unlikely(l_castS2U(n) + 1u <= 1u)) {  /* special cases: -1 or 0 */\n    if (n == 0)\n      luaG_runerror(L, \"attempt to perform 'n%%0'\");\n    return 0;   /* m % -1 == 0; avoid overflow with 0x80000...%-1 */\n  }\n  else {\n    lua_Integer r = m % n;\n    if (r != 0 && (r ^ n) < 0)  /* 'm/n' would be non-integer negative? */\n      r += n;  /* correct result for different rounding */\n    return r;\n  }\n}\n\n\n/*\n** Float modulus\n*/\nlua_Number luaV_modf (lua_State *L, lua_Number m, lua_Number n) {\n  lua_Number r;\n  luai_nummod(L, m, n, r);\n  return r;\n}\n\n\n/* number of bits in an integer */\n#define NBITS\tcast_int(sizeof(lua_Integer) * CHAR_BIT)\n\n\n/*\n** Shift left operation. (Shift right just negates 'y'.)\n*/\nlua_Integer luaV_shiftl (lua_Integer x, lua_Integer y) {\n  if (y < 0) {  /* shift right? */\n    if (y <= -NBITS) return 0;\n    else return intop(>>, x, -y);\n  }\n  else {  /* shift left */\n    if (y >= NBITS) return 0;\n    else return intop(<<, x, y);\n  }\n}\n\n\n/*\n** create a new Lua closure, push it in the stack, and initialize\n** its upvalues.\n*/\nstatic void pushclosure (lua_State *L, Proto *p, UpVal **encup, StkId base,\n                         StkId ra) {\n  int nup = p->sizeupvalues;\n  Upvaldesc *uv = p->upvalues;\n  int i;\n  LClosure *ncl = luaF_newLclosure(L, nup);\n  ncl->p = p;\n  setclLvalue2s(L, ra, ncl);  /* anchor new closure in stack */\n  for (i = 0; i < nup; i++) {  /* fill in its upvalues */\n    if (uv[i].instack)  /* upvalue refers to local variable? */\n      ncl->upvals[i] = luaF_findupval(L, base + uv[i].idx);\n    else  /* get upvalue from enclosing function */\n      ncl->upvals[i] = encup[uv[i].idx];\n    luaC_objbarrier(L, ncl, ncl->upvals[i]);\n  }\n}\n\n\n/*\n** finish execution of an opcode interrupted by a yield\n*/\nvoid luaV_finishOp (lua_State *L) {\n  CallInfo *ci = L->ci;\n  StkId base = ci->func.p + 1;\n  Instruction inst = *(ci->u.l.savedpc - 1);  /* interrupted instruction */\n  OpCode op = GET_OPCODE(inst);\n  switch (op) {  /* finish its execution */\n    case OP_MMBIN: case OP_MMBINI: case OP_MMBINK: {\n      setobjs2s(L, base + GETARG_A(*(ci->u.l.savedpc - 2)), --L->top.p);\n      break;\n    }\n    case OP_UNM: case OP_BNOT: case OP_LEN:\n    case OP_GETTABUP: case OP_GETTABLE: case OP_GETI:\n    case OP_GETFIELD: case OP_SELF: {\n      setobjs2s(L, base + GETARG_A(inst), --L->top.p);\n      break;\n    }\n    case OP_LT: case OP_LE:\n    case OP_LTI: case OP_LEI:\n    case OP_GTI: case OP_GEI:\n    case OP_EQ: {  /* note that 'OP_EQI'/'OP_EQK' cannot yield */\n      int res = !l_isfalse(s2v(L->top.p - 1));\n      L->top.p--;\n#if defined(LUA_COMPAT_LT_LE)\n      if (ci->callstatus & CIST_LEQ) {  /* \"<=\" using \"<\" instead? */\n        ci->callstatus ^= CIST_LEQ;  /* clear mark */\n        res = !res;  /* negate result */\n      }\n#endif\n      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_JMP);\n      if (res != GETARG_k(inst))  /* condition failed? */\n        ci->u.l.savedpc++;  /* skip jump instruction */\n      break;\n    }\n    case OP_CONCAT: {\n      StkId top = L->top.p - 1;  /* top when 'luaT_tryconcatTM' was called */\n      int a = GETARG_A(inst);      /* first element to concatenate */\n      int total = cast_int(top - 1 - (base + a));  /* yet to concatenate */\n      setobjs2s(L, top - 2, top);  /* put TM result in proper position */\n      L->top.p = top - 1;  /* top is one after last element (at top-2) */\n      luaV_concat(L, total);  /* concat them (may yield again) */\n      break;\n    }\n    case OP_CLOSE: {  /* yielded closing variables */\n      ci->u.l.savedpc--;  /* repeat instruction to close other vars. */\n      break;\n    }\n    case OP_RETURN: {  /* yielded closing variables */\n      StkId ra = base + GETARG_A(inst);\n      /* adjust top to signal correct number of returns, in case the\n         return is \"up to top\" ('isIT') */\n      L->top.p = ra + ci->u2.nres;\n      /* repeat instruction to close other vars. and complete the return */\n      ci->u.l.savedpc--;\n      break;\n    }\n    default: {\n      /* only these other opcodes can yield */\n      lua_assert(op == OP_TFORCALL || op == OP_CALL ||\n           op == OP_TAILCALL || op == OP_SETTABUP || op == OP_SETTABLE ||\n           op == OP_SETI || op == OP_SETFIELD);\n      break;\n    }\n  }\n}\n\n\n\n\n/*\n** {==================================================================\n** Macros for arithmetic/bitwise/comparison opcodes in 'luaV_execute'\n** ===================================================================\n*/\n\n#define l_addi(L,a,b)\tintop(+, a, b)\n#define l_subi(L,a,b)\tintop(-, a, b)\n#define l_muli(L,a,b)\tintop(*, a, b)\n#define l_band(a,b)\tintop(&, a, b)\n#define l_bor(a,b)\tintop(|, a, b)\n#define l_bxor(a,b)\tintop(^, a, b)\n\n#define l_lti(a,b)\t(a < b)\n#define l_lei(a,b)\t(a <= b)\n#define l_gti(a,b)\t(a > b)\n#define l_gei(a,b)\t(a >= b)\n\n\n/*\n** Arithmetic operations with immediate operands. 'iop' is the integer\n** operation, 'fop' is the float operation.\n*/\n#define op_arithI(L,iop,fop) {  \\\n  StkId ra = RA(i); \\\n  TValue *v1 = vRB(i);  \\\n  int imm = GETARG_sC(i);  \\\n  if (ttisinteger(v1)) {  \\\n    lua_Integer iv1 = ivalue(v1);  \\\n    pc++; setivalue(s2v(ra), iop(L, iv1, imm));  \\\n  }  \\\n  else if (ttisfloat(v1)) {  \\\n    lua_Number nb = fltvalue(v1);  \\\n    lua_Number fimm = cast_num(imm);  \\\n    pc++; setfltvalue(s2v(ra), fop(L, nb, fimm)); \\\n  }}\n\n\n/*\n** Auxiliary function for arithmetic operations over floats and others\n** with two operands.\n*/\n#define op_arithf_aux(L,v1,v2,fop) {  \\\n  lua_Number n1; lua_Number n2;  \\\n  if (tonumberns(v1, n1) && tonumberns(v2, n2)) {  \\\n    pc++; setfltvalue(s2v(ra), fop(L, n1, n2));  \\\n  }}\n\n\n/*\n** Arithmetic operations over floats and others with register operands.\n*/\n#define op_arithf(L,fop) {  \\\n  StkId ra = RA(i); \\\n  TValue *v1 = vRB(i);  \\\n  TValue *v2 = vRC(i);  \\\n  op_arithf_aux(L, v1, v2, fop); }\n\n\n/*\n** Arithmetic operations with K operands for floats.\n*/\n#define op_arithfK(L,fop) {  \\\n  StkId ra = RA(i); \\\n  TValue *v1 = vRB(i);  \\\n  TValue *v2 = KC(i); lua_assert(ttisnumber(v2));  \\\n  op_arithf_aux(L, v1, v2, fop); }\n\n\n/*\n** Arithmetic operations over integers and floats.\n*/\n#define op_arith_aux(L,v1,v2,iop,fop) {  \\\n  StkId ra = RA(i); \\\n  if (ttisinteger(v1) && ttisinteger(v2)) {  \\\n    lua_Integer i1 = ivalue(v1); lua_Integer i2 = ivalue(v2);  \\\n    pc++; setivalue(s2v(ra), iop(L, i1, i2));  \\\n  }  \\\n  else op_arithf_aux(L, v1, v2, fop); }\n\n\n/*\n** Arithmetic operations with register operands.\n*/\n#define op_arith(L,iop,fop) {  \\\n  TValue *v1 = vRB(i);  \\\n  TValue *v2 = vRC(i);  \\\n  op_arith_aux(L, v1, v2, iop, fop); }\n\n\n/*\n** Arithmetic operations with K operands.\n*/\n#define op_arithK(L,iop,fop) {  \\\n  TValue *v1 = vRB(i);  \\\n  TValue *v2 = KC(i); lua_assert(ttisnumber(v2));  \\\n  op_arith_aux(L, v1, v2, iop, fop); }\n\n\n/*\n** Bitwise operations with constant operand.\n*/\n#define op_bitwiseK(L,op) {  \\\n  StkId ra = RA(i); \\\n  TValue *v1 = vRB(i);  \\\n  TValue *v2 = KC(i);  \\\n  lua_Integer i1;  \\\n  lua_Integer i2 = ivalue(v2);  \\\n  if (tointegerns(v1, &i1)) {  \\\n    pc++; setivalue(s2v(ra), op(i1, i2));  \\\n  }}\n\n\n/*\n** Bitwise operations with register operands.\n*/\n#define op_bitwise(L,op) {  \\\n  StkId ra = RA(i); \\\n  TValue *v1 = vRB(i);  \\\n  TValue *v2 = vRC(i);  \\\n  lua_Integer i1; lua_Integer i2;  \\\n  if (tointegerns(v1, &i1) && tointegerns(v2, &i2)) {  \\\n    pc++; setivalue(s2v(ra), op(i1, i2));  \\\n  }}\n\n\n/*\n** Order operations with register operands. 'opn' actually works\n** for all numbers, but the fast track improves performance for\n** integers.\n*/\n#define op_order(L,opi,opn,other) {  \\\n  StkId ra = RA(i); \\\n  int cond;  \\\n  TValue *rb = vRB(i);  \\\n  if (ttisinteger(s2v(ra)) && ttisinteger(rb)) {  \\\n    lua_Integer ia = ivalue(s2v(ra));  \\\n    lua_Integer ib = ivalue(rb);  \\\n    cond = opi(ia, ib);  \\\n  }  \\\n  else if (ttisnumber(s2v(ra)) && ttisnumber(rb))  \\\n    cond = opn(s2v(ra), rb);  \\\n  else  \\\n    Protect(cond = other(L, s2v(ra), rb));  \\\n  docondjump(); }\n\n\n/*\n** Order operations with immediate operand. (Immediate operand is\n** always small enough to have an exact representation as a float.)\n*/\n#define op_orderI(L,opi,opf,inv,tm) {  \\\n  StkId ra = RA(i); \\\n  int cond;  \\\n  int im = GETARG_sB(i);  \\\n  if (ttisinteger(s2v(ra)))  \\\n    cond = opi(ivalue(s2v(ra)), im);  \\\n  else if (ttisfloat(s2v(ra))) {  \\\n    lua_Number fa = fltvalue(s2v(ra));  \\\n    lua_Number fim = cast_num(im);  \\\n    cond = opf(fa, fim);  \\\n  }  \\\n  else {  \\\n    int isf = GETARG_C(i);  \\\n    Protect(cond = luaT_callorderiTM(L, s2v(ra), im, inv, isf, tm));  \\\n  }  \\\n  docondjump(); }\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Function 'luaV_execute': main interpreter loop\n** ===================================================================\n*/\n\n/*\n** some macros for common tasks in 'luaV_execute'\n*/\n\n\n#define RA(i)\t(base+GETARG_A(i))\n#define RB(i)\t(base+GETARG_B(i))\n#define vRB(i)\ts2v(RB(i))\n#define KB(i)\t(k+GETARG_B(i))\n#define RC(i)\t(base+GETARG_C(i))\n#define vRC(i)\ts2v(RC(i))\n#define KC(i)\t(k+GETARG_C(i))\n#define RKC(i)\t((TESTARG_k(i)) ? k + GETARG_C(i) : s2v(base + GETARG_C(i)))\n\n\n\n#define updatetrap(ci)  (trap = ci->u.l.trap)\n\n#define updatebase(ci)\t(base = ci->func.p + 1)\n\n\n#define updatestack(ci)  \\\n\t{ if (l_unlikely(trap)) { updatebase(ci); ra = RA(i); } }\n\n\n/*\n** Execute a jump instruction. The 'updatetrap' allows signals to stop\n** tight loops. (Without it, the local copy of 'trap' could never change.)\n*/\n#define dojump(ci,i,e)\t{ pc += GETARG_sJ(i) + e; updatetrap(ci); }\n\n\n/* for test instructions, execute the jump instruction that follows it */\n#define donextjump(ci)\t{ Instruction ni = *pc; dojump(ci, ni, 1); }\n\n/*\n** do a conditional jump: skip next instruction if 'cond' is not what\n** was expected (parameter 'k'), else do next instruction, which must\n** be a jump.\n*/\n#define docondjump()\tif (cond != GETARG_k(i)) pc++; else donextjump(ci);\n\n\n/*\n** Correct global 'pc'.\n*/\n#define savepc(L)\t(ci->u.l.savedpc = pc)\n\n\n/*\n** Whenever code can raise errors, the global 'pc' and the global\n** 'top' must be correct to report occasional errors.\n*/\n#define savestate(L,ci)\t\t(savepc(L), L->top.p = ci->top.p)\n\n\n/*\n** Protect code that, in general, can raise errors, reallocate the\n** stack, and change the hooks.\n*/\n#define Protect(exp)  (savestate(L,ci), (exp), updatetrap(ci))\n\n/* special version that does not change the top */\n#define ProtectNT(exp)  (savepc(L), (exp), updatetrap(ci))\n\n/*\n** Protect code that can only raise errors. (That is, it cannot change\n** the stack or hooks.)\n*/\n#define halfProtect(exp)  (savestate(L,ci), (exp))\n\n/* 'c' is the limit of live values in the stack */\n#define checkGC(L,c)  \\\n\t{ luaC_condGC(L, (savepc(L), L->top.p = (c)), \\\n                         updatetrap(ci)); \\\n           luai_threadyield(L); }\n\n\n/* fetch an instruction and prepare its execution */\n#define vmfetch()\t{ \\\n  if (l_unlikely(trap)) {  /* stack reallocation or hooks? */ \\\n    trap = luaG_traceexec(L, pc);  /* handle hooks */ \\\n    updatebase(ci);  /* correct stack */ \\\n  } \\\n  i = *(pc++); \\\n}\n\n#define vmdispatch(o)\tswitch(o)\n#define vmcase(l)\tcase l:\n#define vmbreak\t\tbreak\n\n\nvoid luaV_execute (lua_State *L, CallInfo *ci) {\n  LClosure *cl;\n  TValue *k;\n  StkId base;\n  const Instruction *pc;\n  int trap;\n#if LUA_USE_JUMPTABLE\n#include \"ljumptab.h\"\n#endif\n startfunc:\n  trap = L->hookmask;\n returning:  /* trap already set */\n  cl = ci_func(ci);\n  k = cl->p->k;\n  pc = ci->u.l.savedpc;\n  if (l_unlikely(trap))\n    trap = luaG_tracecall(L);\n  base = ci->func.p + 1;\n  /* main loop of interpreter */\n  for (;;) {\n    Instruction i;  /* instruction being executed */\n    vmfetch();\n    #if 0\n      /* low-level line tracing for debugging Lua */\n      printf(\"line: %d\\n\", luaG_getfuncline(cl->p, pcRel(pc, cl->p)));\n    #endif\n    lua_assert(base == ci->func.p + 1);\n    lua_assert(base <= L->top.p && L->top.p <= L->stack_last.p);\n    /* invalidate top for instructions not expecting it */\n    lua_assert(isIT(i) || (cast_void(L->top.p = base), 1));\n    vmdispatch (GET_OPCODE(i)) {\n      vmcase(OP_MOVE) {\n        StkId ra = RA(i);\n        setobjs2s(L, ra, RB(i));\n        vmbreak;\n      }\n      vmcase(OP_LOADI) {\n        StkId ra = RA(i);\n        lua_Integer b = GETARG_sBx(i);\n        setivalue(s2v(ra), b);\n        vmbreak;\n      }\n      vmcase(OP_LOADF) {\n        StkId ra = RA(i);\n        int b = GETARG_sBx(i);\n        setfltvalue(s2v(ra), cast_num(b));\n        vmbreak;\n      }\n      vmcase(OP_LOADK) {\n        StkId ra = RA(i);\n        TValue *rb = k + GETARG_Bx(i);\n        setobj2s(L, ra, rb);\n        vmbreak;\n      }\n      vmcase(OP_LOADKX) {\n        StkId ra = RA(i);\n        TValue *rb;\n        rb = k + GETARG_Ax(*pc); pc++;\n        setobj2s(L, ra, rb);\n        vmbreak;\n      }\n      vmcase(OP_LOADFALSE) {\n        StkId ra = RA(i);\n        setbfvalue(s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_LFALSESKIP) {\n        StkId ra = RA(i);\n        setbfvalue(s2v(ra));\n        pc++;  /* skip next instruction */\n        vmbreak;\n      }\n      vmcase(OP_LOADTRUE) {\n        StkId ra = RA(i);\n        setbtvalue(s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_LOADNIL) {\n        StkId ra = RA(i);\n        int b = GETARG_B(i);\n        do {\n          setnilvalue(s2v(ra++));\n        } while (b--);\n        vmbreak;\n      }\n      vmcase(OP_GETUPVAL) {\n        StkId ra = RA(i);\n        int b = GETARG_B(i);\n        setobj2s(L, ra, cl->upvals[b]->v.p);\n        vmbreak;\n      }\n      vmcase(OP_SETUPVAL) {\n        StkId ra = RA(i);\n        UpVal *uv = cl->upvals[GETARG_B(i)];\n        setobj(L, uv->v.p, s2v(ra));\n        luaC_barrier(L, uv, s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_GETTABUP) {\n        StkId ra = RA(i);\n        TValue *upval = cl->upvals[GETARG_B(i)]->v.p;\n        TValue *rc = KC(i);\n        TString *key = tsvalue(rc);  /* key must be a short string */\n        int tag;\n        luaV_fastget(upval, key, s2v(ra), luaH_getshortstr, tag);\n        if (tagisempty(tag))\n          Protect(luaV_finishget(L, upval, rc, ra, tag));\n        vmbreak;\n      }\n      vmcase(OP_GETTABLE) {\n        StkId ra = RA(i);\n        TValue *rb = vRB(i);\n        TValue *rc = vRC(i);\n        int tag;\n        if (ttisinteger(rc)) {  /* fast track for integers? */\n          luaV_fastgeti(rb, ivalue(rc), s2v(ra), tag);\n        }\n        else\n          luaV_fastget(rb, rc, s2v(ra), luaH_get, tag);\n        if (tagisempty(tag))\n          Protect(luaV_finishget(L, rb, rc, ra, tag));\n        vmbreak;\n      }\n      vmcase(OP_GETI) {\n        StkId ra = RA(i);\n        TValue *rb = vRB(i);\n        int c = GETARG_C(i);\n        int tag;\n        luaV_fastgeti(rb, c, s2v(ra), tag);\n        if (tagisempty(tag)) {\n          TValue key;\n          setivalue(&key, c);\n          Protect(luaV_finishget(L, rb, &key, ra, tag));\n        }\n        vmbreak;\n      }\n      vmcase(OP_GETFIELD) {\n        StkId ra = RA(i);\n        TValue *rb = vRB(i);\n        TValue *rc = KC(i);\n        TString *key = tsvalue(rc);  /* key must be a short string */\n        int tag;\n        luaV_fastget(rb, key, s2v(ra), luaH_getshortstr, tag);\n        if (tagisempty(tag))\n          Protect(luaV_finishget(L, rb, rc, ra, tag));\n        vmbreak;\n      }\n      vmcase(OP_SETTABUP) {\n        int hres;\n        TValue *upval = cl->upvals[GETARG_A(i)]->v.p;\n        TValue *rb = KB(i);\n        TValue *rc = RKC(i);\n        TString *key = tsvalue(rb);  /* key must be a short string */\n        luaV_fastset(upval, key, rc, hres, luaH_psetshortstr);\n        if (hres == HOK)\n          luaV_finishfastset(L, upval, rc);\n        else\n          Protect(luaV_finishset(L, upval, rb, rc, hres));\n        vmbreak;\n      }\n      vmcase(OP_SETTABLE) {\n        StkId ra = RA(i);\n        int hres;\n        TValue *rb = vRB(i);  /* key (table is in 'ra') */\n        TValue *rc = RKC(i);  /* value */\n        if (ttisinteger(rb)) {  /* fast track for integers? */\n          luaV_fastseti(s2v(ra), ivalue(rb), rc, hres);\n        }\n        else {\n          luaV_fastset(s2v(ra), rb, rc, hres, luaH_pset);\n        }\n        if (hres == HOK)\n          luaV_finishfastset(L, s2v(ra), rc);\n        else\n          Protect(luaV_finishset(L, s2v(ra), rb, rc, hres));\n        vmbreak;\n      }\n      vmcase(OP_SETI) {\n        StkId ra = RA(i);\n        int hres;\n        int b = GETARG_B(i);\n        TValue *rc = RKC(i);\n        luaV_fastseti(s2v(ra), b, rc, hres);\n        if (hres == HOK)\n          luaV_finishfastset(L, s2v(ra), rc);\n        else {\n          TValue key;\n          setivalue(&key, b);\n          Protect(luaV_finishset(L, s2v(ra), &key, rc, hres));\n        }\n        vmbreak;\n      }\n      vmcase(OP_SETFIELD) {\n        StkId ra = RA(i);\n        int hres;\n        TValue *rb = KB(i);\n        TValue *rc = RKC(i);\n        TString *key = tsvalue(rb);  /* key must be a short string */\n        luaV_fastset(s2v(ra), key, rc, hres, luaH_psetshortstr);\n        if (hres == HOK)\n          luaV_finishfastset(L, s2v(ra), rc);\n        else\n          Protect(luaV_finishset(L, s2v(ra), rb, rc, hres));\n        vmbreak;\n      }\n      vmcase(OP_NEWTABLE) {\n        StkId ra = RA(i);\n        int b = GETARG_B(i);  /* log2(hash size) + 1 */\n        int c = GETARG_C(i);  /* array size */\n        Table *t;\n        if (b > 0)\n          b = 1 << (b - 1);  /* size is 2^(b - 1) */\n        lua_assert((!TESTARG_k(i)) == (GETARG_Ax(*pc) == 0));\n        if (TESTARG_k(i))  /* non-zero extra argument? */\n          c += GETARG_Ax(*pc) * (MAXARG_C + 1);  /* add it to size */\n        pc++;  /* skip extra argument */\n        L->top.p = ra + 1;  /* correct top in case of emergency GC */\n        t = luaH_new(L);  /* memory allocation */\n        sethvalue2s(L, ra, t);\n        if (b != 0 || c != 0)\n          luaH_resize(L, t, c, b);  /* idem */\n        checkGC(L, ra + 1);\n        vmbreak;\n      }\n      vmcase(OP_SELF) {\n        StkId ra = RA(i);\n        int tag;\n        TValue *rb = vRB(i);\n        TValue *rc = RKC(i);\n        TString *key = tsvalue(rc);  /* key must be a string */\n        setobj2s(L, ra + 1, rb);\n        luaV_fastget(rb, key, s2v(ra), luaH_getstr, tag);\n        if (tagisempty(tag))\n          Protect(luaV_finishget(L, rb, rc, ra, tag));\n        vmbreak;\n      }\n      vmcase(OP_ADDI) {\n        op_arithI(L, l_addi, luai_numadd);\n        vmbreak;\n      }\n      vmcase(OP_ADDK) {\n        op_arithK(L, l_addi, luai_numadd);\n        vmbreak;\n      }\n      vmcase(OP_SUBK) {\n        op_arithK(L, l_subi, luai_numsub);\n        vmbreak;\n      }\n      vmcase(OP_MULK) {\n        op_arithK(L, l_muli, luai_nummul);\n        vmbreak;\n      }\n      vmcase(OP_MODK) {\n        savestate(L, ci);  /* in case of division by 0 */\n        op_arithK(L, luaV_mod, luaV_modf);\n        vmbreak;\n      }\n      vmcase(OP_POWK) {\n        op_arithfK(L, luai_numpow);\n        vmbreak;\n      }\n      vmcase(OP_DIVK) {\n        op_arithfK(L, luai_numdiv);\n        vmbreak;\n      }\n      vmcase(OP_IDIVK) {\n        savestate(L, ci);  /* in case of division by 0 */\n        op_arithK(L, luaV_idiv, luai_numidiv);\n        vmbreak;\n      }\n      vmcase(OP_BANDK) {\n        op_bitwiseK(L, l_band);\n        vmbreak;\n      }\n      vmcase(OP_BORK) {\n        op_bitwiseK(L, l_bor);\n        vmbreak;\n      }\n      vmcase(OP_BXORK) {\n        op_bitwiseK(L, l_bxor);\n        vmbreak;\n      }\n      vmcase(OP_SHRI) {\n        StkId ra = RA(i);\n        TValue *rb = vRB(i);\n        int ic = GETARG_sC(i);\n        lua_Integer ib;\n        if (tointegerns(rb, &ib)) {\n          pc++; setivalue(s2v(ra), luaV_shiftl(ib, -ic));\n        }\n        vmbreak;\n      }\n      vmcase(OP_SHLI) {\n        StkId ra = RA(i);\n        TValue *rb = vRB(i);\n        int ic = GETARG_sC(i);\n        lua_Integer ib;\n        if (tointegerns(rb, &ib)) {\n          pc++; setivalue(s2v(ra), luaV_shiftl(ic, ib));\n        }\n        vmbreak;\n      }\n      vmcase(OP_ADD) {\n        op_arith(L, l_addi, luai_numadd);\n        vmbreak;\n      }\n      vmcase(OP_SUB) {\n        op_arith(L, l_subi, luai_numsub);\n        vmbreak;\n      }\n      vmcase(OP_MUL) {\n        op_arith(L, l_muli, luai_nummul);\n        vmbreak;\n      }\n      vmcase(OP_MOD) {\n        savestate(L, ci);  /* in case of division by 0 */\n        op_arith(L, luaV_mod, luaV_modf);\n        vmbreak;\n      }\n      vmcase(OP_POW) {\n        op_arithf(L, luai_numpow);\n        vmbreak;\n      }\n      vmcase(OP_DIV) {  /* float division (always with floats) */\n        op_arithf(L, luai_numdiv);\n        vmbreak;\n      }\n      vmcase(OP_IDIV) {  /* floor division */\n        savestate(L, ci);  /* in case of division by 0 */\n        op_arith(L, luaV_idiv, luai_numidiv);\n        vmbreak;\n      }\n      vmcase(OP_BAND) {\n        op_bitwise(L, l_band);\n        vmbreak;\n      }\n      vmcase(OP_BOR) {\n        op_bitwise(L, l_bor);\n        vmbreak;\n      }\n      vmcase(OP_BXOR) {\n        op_bitwise(L, l_bxor);\n        vmbreak;\n      }\n      vmcase(OP_SHR) {\n        op_bitwise(L, luaV_shiftr);\n        vmbreak;\n      }\n      vmcase(OP_SHL) {\n        op_bitwise(L, luaV_shiftl);\n        vmbreak;\n      }\n      vmcase(OP_MMBIN) {\n        StkId ra = RA(i);\n        Instruction pi = *(pc - 2);  /* original arith. expression */\n        TValue *rb = vRB(i);\n        TMS tm = (TMS)GETARG_C(i);\n        StkId result = RA(pi);\n        lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);\n        Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));\n        vmbreak;\n      }\n      vmcase(OP_MMBINI) {\n        StkId ra = RA(i);\n        Instruction pi = *(pc - 2);  /* original arith. expression */\n        int imm = GETARG_sB(i);\n        TMS tm = (TMS)GETARG_C(i);\n        int flip = GETARG_k(i);\n        StkId result = RA(pi);\n        Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));\n        vmbreak;\n      }\n      vmcase(OP_MMBINK) {\n        StkId ra = RA(i);\n        Instruction pi = *(pc - 2);  /* original arith. expression */\n        TValue *imm = KB(i);\n        TMS tm = (TMS)GETARG_C(i);\n        int flip = GETARG_k(i);\n        StkId result = RA(pi);\n        Protect(luaT_trybinassocTM(L, s2v(ra), imm, flip, result, tm));\n        vmbreak;\n      }\n      vmcase(OP_UNM) {\n        StkId ra = RA(i);\n        TValue *rb = vRB(i);\n        lua_Number nb;\n        if (ttisinteger(rb)) {\n          lua_Integer ib = ivalue(rb);\n          setivalue(s2v(ra), intop(-, 0, ib));\n        }\n        else if (tonumberns(rb, nb)) {\n          setfltvalue(s2v(ra), luai_numunm(L, nb));\n        }\n        else\n          Protect(luaT_trybinTM(L, rb, rb, ra, TM_UNM));\n        vmbreak;\n      }\n      vmcase(OP_BNOT) {\n        StkId ra = RA(i);\n        TValue *rb = vRB(i);\n        lua_Integer ib;\n        if (tointegerns(rb, &ib)) {\n          setivalue(s2v(ra), intop(^, ~l_castS2U(0), ib));\n        }\n        else\n          Protect(luaT_trybinTM(L, rb, rb, ra, TM_BNOT));\n        vmbreak;\n      }\n      vmcase(OP_NOT) {\n        StkId ra = RA(i);\n        TValue *rb = vRB(i);\n        if (l_isfalse(rb))\n          setbtvalue(s2v(ra));\n        else\n          setbfvalue(s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_LEN) {\n        StkId ra = RA(i);\n        Protect(luaV_objlen(L, ra, vRB(i)));\n        vmbreak;\n      }\n      vmcase(OP_CONCAT) {\n        StkId ra = RA(i);\n        int n = GETARG_B(i);  /* number of elements to concatenate */\n        L->top.p = ra + n;  /* mark the end of concat operands */\n        ProtectNT(luaV_concat(L, n));\n        checkGC(L, L->top.p); /* 'luaV_concat' ensures correct top */\n        vmbreak;\n      }\n      vmcase(OP_CLOSE) {\n        StkId ra = RA(i);\n        Protect(luaF_close(L, ra, LUA_OK, 1));\n        vmbreak;\n      }\n      vmcase(OP_TBC) {\n        StkId ra = RA(i);\n        /* create new to-be-closed upvalue */\n        halfProtect(luaF_newtbcupval(L, ra));\n        vmbreak;\n      }\n      vmcase(OP_JMP) {\n        dojump(ci, i, 0);\n        vmbreak;\n      }\n      vmcase(OP_EQ) {\n        StkId ra = RA(i);\n        int cond;\n        TValue *rb = vRB(i);\n        Protect(cond = luaV_equalobj(L, s2v(ra), rb));\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_LT) {\n        op_order(L, l_lti, LTnum, lessthanothers);\n        vmbreak;\n      }\n      vmcase(OP_LE) {\n        op_order(L, l_lei, LEnum, lessequalothers);\n        vmbreak;\n      }\n      vmcase(OP_EQK) {\n        StkId ra = RA(i);\n        TValue *rb = KB(i);\n        /* basic types do not use '__eq'; we can use raw equality */\n        int cond = luaV_rawequalobj(s2v(ra), rb);\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_EQI) {\n        StkId ra = RA(i);\n        int cond;\n        int im = GETARG_sB(i);\n        if (ttisinteger(s2v(ra)))\n          cond = (ivalue(s2v(ra)) == im);\n        else if (ttisfloat(s2v(ra)))\n          cond = luai_numeq(fltvalue(s2v(ra)), cast_num(im));\n        else\n          cond = 0;  /* other types cannot be equal to a number */\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_LTI) {\n        op_orderI(L, l_lti, luai_numlt, 0, TM_LT);\n        vmbreak;\n      }\n      vmcase(OP_LEI) {\n        op_orderI(L, l_lei, luai_numle, 0, TM_LE);\n        vmbreak;\n      }\n      vmcase(OP_GTI) {\n        op_orderI(L, l_gti, luai_numgt, 1, TM_LT);\n        vmbreak;\n      }\n      vmcase(OP_GEI) {\n        op_orderI(L, l_gei, luai_numge, 1, TM_LE);\n        vmbreak;\n      }\n      vmcase(OP_TEST) {\n        StkId ra = RA(i);\n        int cond = !l_isfalse(s2v(ra));\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_TESTSET) {\n        StkId ra = RA(i);\n        TValue *rb = vRB(i);\n        if (l_isfalse(rb) == GETARG_k(i))\n          pc++;\n        else {\n          setobj2s(L, ra, rb);\n          donextjump(ci);\n        }\n        vmbreak;\n      }\n      vmcase(OP_CALL) {\n        StkId ra = RA(i);\n        CallInfo *newci;\n        int b = GETARG_B(i);\n        int nresults = GETARG_C(i) - 1;\n        if (b != 0)  /* fixed number of arguments? */\n          L->top.p = ra + b;  /* top signals number of arguments */\n        /* else previous instruction set top */\n        savepc(L);  /* in case of errors */\n        if ((newci = luaD_precall(L, ra, nresults)) == NULL)\n          updatetrap(ci);  /* C call; nothing else to be done */\n        else {  /* Lua call: run function in this same C frame */\n          ci = newci;\n          goto startfunc;\n        }\n        vmbreak;\n      }\n      vmcase(OP_TAILCALL) {\n        StkId ra = RA(i);\n        int b = GETARG_B(i);  /* number of arguments + 1 (function) */\n        int n;  /* number of results when calling a C function */\n        int nparams1 = GETARG_C(i);\n        /* delta is virtual 'func' - real 'func' (vararg functions) */\n        int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;\n        if (b != 0)\n          L->top.p = ra + b;\n        else  /* previous instruction set top */\n          b = cast_int(L->top.p - ra);\n        savepc(ci);  /* several calls here can raise errors */\n        if (TESTARG_k(i)) {\n          luaF_closeupval(L, base);  /* close upvalues from current call */\n          lua_assert(L->tbclist.p < base);  /* no pending tbc variables */\n          lua_assert(base == ci->func.p + 1);\n        }\n        if ((n = luaD_pretailcall(L, ci, ra, b, delta)) < 0)  /* Lua function? */\n          goto startfunc;  /* execute the callee */\n        else {  /* C function? */\n          ci->func.p -= delta;  /* restore 'func' (if vararg) */\n          luaD_poscall(L, ci, n);  /* finish caller */\n          updatetrap(ci);  /* 'luaD_poscall' can change hooks */\n          goto ret;  /* caller returns after the tail call */\n        }\n      }\n      vmcase(OP_RETURN) {\n        StkId ra = RA(i);\n        int n = GETARG_B(i) - 1;  /* number of results */\n        int nparams1 = GETARG_C(i);\n        if (n < 0)  /* not fixed? */\n          n = cast_int(L->top.p - ra);  /* get what is available */\n        savepc(ci);\n        if (TESTARG_k(i)) {  /* may there be open upvalues? */\n          ci->u2.nres = n;  /* save number of returns */\n          if (L->top.p < ci->top.p)\n            L->top.p = ci->top.p;\n          luaF_close(L, base, CLOSEKTOP, 1);\n          updatetrap(ci);\n          updatestack(ci);\n        }\n        if (nparams1)  /* vararg function? */\n          ci->func.p -= ci->u.l.nextraargs + nparams1;\n        L->top.p = ra + n;  /* set call for 'luaD_poscall' */\n        luaD_poscall(L, ci, n);\n        updatetrap(ci);  /* 'luaD_poscall' can change hooks */\n        goto ret;\n      }\n      vmcase(OP_RETURN0) {\n        if (l_unlikely(L->hookmask)) {\n          StkId ra = RA(i);\n          L->top.p = ra;\n          savepc(ci);\n          luaD_poscall(L, ci, 0);  /* no hurry... */\n          trap = 1;\n        }\n        else {  /* do the 'poscall' here */\n          int nres;\n          L->ci = ci->previous;  /* back to caller */\n          L->top.p = base - 1;\n          for (nres = ci->nresults; l_unlikely(nres > 0); nres--)\n            setnilvalue(s2v(L->top.p++));  /* all results are nil */\n        }\n        goto ret;\n      }\n      vmcase(OP_RETURN1) {\n        if (l_unlikely(L->hookmask)) {\n          StkId ra = RA(i);\n          L->top.p = ra + 1;\n          savepc(ci);\n          luaD_poscall(L, ci, 1);  /* no hurry... */\n          trap = 1;\n        }\n        else {  /* do the 'poscall' here */\n          int nres = ci->nresults;\n          L->ci = ci->previous;  /* back to caller */\n          if (nres == 0)\n            L->top.p = base - 1;  /* asked for no results */\n          else {\n            StkId ra = RA(i);\n            setobjs2s(L, base - 1, ra);  /* at least this result */\n            L->top.p = base;\n            for (; l_unlikely(nres > 1); nres--)\n              setnilvalue(s2v(L->top.p++));  /* complete missing results */\n          }\n        }\n       ret:  /* return from a Lua function */\n        if (ci->callstatus & CIST_FRESH)\n          return;  /* end this frame */\n        else {\n          ci = ci->previous;\n          goto returning;  /* continue running caller in this frame */\n        }\n      }\n      vmcase(OP_FORLOOP) {\n        StkId ra = RA(i);\n        if (ttisinteger(s2v(ra + 1))) {  /* integer loop? */\n          lua_Unsigned count = l_castS2U(ivalue(s2v(ra)));\n          if (count > 0) {  /* still more iterations? */\n            lua_Integer step = ivalue(s2v(ra + 1));\n            lua_Integer idx = ivalue(s2v(ra + 2));  /* control variable */\n            chgivalue(s2v(ra), count - 1);  /* update counter */\n            idx = intop(+, idx, step);  /* add step to index */\n            chgivalue(s2v(ra + 2), idx);  /* update control variable */\n            pc -= GETARG_Bx(i);  /* jump back */\n          }\n        }\n        else if (floatforloop(ra))  /* float loop */\n          pc -= GETARG_Bx(i);  /* jump back */\n        updatetrap(ci);  /* allows a signal to break the loop */\n        vmbreak;\n      }\n      vmcase(OP_FORPREP) {\n        StkId ra = RA(i);\n        savestate(L, ci);  /* in case of errors */\n        if (forprep(L, ra))\n          pc += GETARG_Bx(i) + 1;  /* skip the loop */\n        vmbreak;\n      }\n      vmcase(OP_TFORPREP) {\n       /* before: 'ra' has the iterator function, 'ra + 1' has the state,\n          'ra + 2' has the initial value for the control variable, and\n          'ra + 3' has the closing variable. This opcode then swaps the\n          control and the closing variables and marks the closing variable\n          as to-be-closed.\n       */\n       StkId ra = RA(i);\n       TValue temp;  /* to swap control and closing variables */\n       setobj(L, &temp, s2v(ra + 3));\n       setobjs2s(L, ra + 3, ra + 2);\n       setobj2s(L, ra + 2, &temp);\n        /* create to-be-closed upvalue (if closing var. is not nil) */\n        halfProtect(luaF_newtbcupval(L, ra + 2));\n        pc += GETARG_Bx(i);  /* go to end of the loop */\n        i = *(pc++);  /* fetch next instruction */\n        lua_assert(GET_OPCODE(i) == OP_TFORCALL && ra == RA(i));\n        goto l_tforcall;\n      }\n      vmcase(OP_TFORCALL) {\n       l_tforcall: {\n        /* 'ra' has the iterator function, 'ra + 1' has the state,\n           'ra + 2' has the closing variable, and 'ra + 3' has the control\n           variable. The call will use the stack starting at 'ra + 3',\n           so that it preserves the first three values, and the first\n           return will be the new value for the control variable.\n        */\n        StkId ra = RA(i);\n        setobjs2s(L, ra + 5, ra + 3);  /* copy the control variable */\n        setobjs2s(L, ra + 4, ra + 1);  /* copy state */\n        setobjs2s(L, ra + 3, ra);  /* copy function */\n        L->top.p = ra + 3 + 3;\n        ProtectNT(luaD_call(L, ra + 3, GETARG_C(i)));  /* do the call */\n        updatestack(ci);  /* stack may have changed */\n        i = *(pc++);  /* go to next instruction */\n        lua_assert(GET_OPCODE(i) == OP_TFORLOOP && ra == RA(i));\n        goto l_tforloop;\n      }}\n      vmcase(OP_TFORLOOP) {\n       l_tforloop: {\n        StkId ra = RA(i);\n        if (!ttisnil(s2v(ra + 3)))  /* continue loop? */\n          pc -= GETARG_Bx(i);  /* jump back */\n        vmbreak;\n      }}\n      vmcase(OP_SETLIST) {\n        StkId ra = RA(i);\n        int n = GETARG_B(i);\n        unsigned int last = GETARG_C(i);\n        Table *h = hvalue(s2v(ra));\n        if (n == 0)\n          n = cast_int(L->top.p - ra) - 1;  /* get up to the top */\n        else\n          L->top.p = ci->top.p;  /* correct top in case of emergency GC */\n        last += n;\n        if (TESTARG_k(i)) {\n          last += GETARG_Ax(*pc) * (MAXARG_C + 1);\n          pc++;\n        }\n        if (last > luaH_realasize(h))  /* needs more space? */\n          luaH_resizearray(L, h, last);  /* preallocate it at once */\n        for (; n > 0; n--) {\n          TValue *val = s2v(ra + n);\n          obj2arr(h, last, val);\n          last--;\n          luaC_barrierback(L, obj2gco(h), val);\n        }\n        vmbreak;\n      }\n      vmcase(OP_CLOSURE) {\n        StkId ra = RA(i);\n        Proto *p = cl->p->p[GETARG_Bx(i)];\n        halfProtect(pushclosure(L, p, cl->upvals, base, ra));\n        checkGC(L, ra + 1);\n        vmbreak;\n      }\n      vmcase(OP_VARARG) {\n        StkId ra = RA(i);\n        int n = GETARG_C(i) - 1;  /* required results */\n        Protect(luaT_getvarargs(L, ci, ra, n));\n        vmbreak;\n      }\n      vmcase(OP_VARARGPREP) {\n        ProtectNT(luaT_adjustvarargs(L, GETARG_A(i), ci, cl->p));\n        if (l_unlikely(trap)) {  /* previous \"Protect\" updated trap */\n          luaD_hookcall(L, ci);\n          L->oldpc = 1;  /* next opcode will be seen as a \"new\" line */\n        }\n        updatebase(ci);  /* function has new base after adjustment */\n        vmbreak;\n      }\n      vmcase(OP_EXTRAARG) {\n        lua_assert(0);\n        vmbreak;\n      }\n    }\n  }\n}\n\n/* }================================================================== */\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lvm.h",
		"is_binary":	false,
		"content":	"/*\n** $Id: lvm.h $\n** Lua virtual machine\n** See Copyright Notice in lua.h\n*/\n\n#ifndef lvm_h\n#define lvm_h\n\n\n#include \"ldo.h\"\n#include \"lobject.h\"\n#include \"ltm.h\"\n\n\n#if !defined(LUA_NOCVTN2S)\n#define cvt2str(o)\tttisnumber(o)\n#else\n#define cvt2str(o)\t0\t/* no conversion from numbers to strings */\n#endif\n\n\n#if !defined(LUA_NOCVTS2N)\n#define cvt2num(o)\tttisstring(o)\n#else\n#define cvt2num(o)\t0\t/* no conversion from strings to numbers */\n#endif\n\n\n/*\n** You can define LUA_FLOORN2I if you want to convert floats to integers\n** by flooring them (instead of raising an error if they are not\n** integral values)\n*/\n#if !defined(LUA_FLOORN2I)\n#define LUA_FLOORN2I\t\tF2Ieq\n#endif\n\n\n/*\n** Rounding modes for float->integer coercion\n */\ntypedef enum {\n  F2Ieq,     /* no rounding; accepts only integral values */\n  F2Ifloor,  /* takes the floor of the number */\n  F2Iceil    /* takes the ceil of the number */\n} F2Imod;\n\n\n/* convert an object to a float (including string coercion) */\n#define tonumber(o,n) \\\n\t(ttisfloat(o) ? (*(n) = fltvalue(o), 1) : luaV_tonumber_(o,n))\n\n\n/* convert an object to a float (without string coercion) */\n#define tonumberns(o,n) \\\n\t(ttisfloat(o) ? ((n) = fltvalue(o), 1) : \\\n\t(ttisinteger(o) ? ((n) = cast_num(ivalue(o)), 1) : 0))\n\n\n/* convert an object to an integer (including string coercion) */\n#define tointeger(o,i) \\\n  (l_likely(ttisinteger(o)) ? (*(i) = ivalue(o), 1) \\\n                          : luaV_tointeger(o,i,LUA_FLOORN2I))\n\n\n/* convert an object to an integer (without string coercion) */\n#define tointegerns(o,i) \\\n  (l_likely(ttisinteger(o)) ? (*(i) = ivalue(o), 1) \\\n                          : luaV_tointegerns(o,i,LUA_FLOORN2I))\n\n\n#define intop(op,v1,v2) l_castU2S(l_castS2U(v1) op l_castS2U(v2))\n\n#define luaV_rawequalobj(t1,t2)\t\tluaV_equalobj(NULL,t1,t2)\n\n\n/*\n** fast track for 'gettable'\n*/\n#define luaV_fastget(t,k,res,f, tag) \\\n  (tag = (!ttistable(t) ? LUA_VNOTABLE : f(hvalue(t), k, res)))\n\n\n/*\n** Special case of 'luaV_fastget' for integers, inlining the fast case\n** of 'luaH_getint'.\n*/\n#define luaV_fastgeti(t,k,res,tag) \\\n  if (!ttistable(t)) tag = LUA_VNOTABLE; \\\n  else { luaH_fastgeti(hvalue(t), k, res, tag); }\n\n\n#define luaV_fastset(t,k,val,hres,f) \\\n  (hres = (!ttistable(t) ? HNOTATABLE : f(hvalue(t), k, val)))\n\n#define luaV_fastseti(t,k,val,hres) \\\n  if (!ttistable(t)) hres = HNOTATABLE; \\\n  else { luaH_fastseti(hvalue(t), k, val, hres); }\n\n\n/*\n** Finish a fast set operation (when fast set succeeds).\n*/\n#define luaV_finishfastset(L,t,v)\tluaC_barrierback(L, gcvalue(t), v)\n\n\n/*\n** Shift right is the same as shift left with a negative 'y'\n*/\n#define luaV_shiftr(x,y)\tluaV_shiftl(x,intop(-, 0, y))\n\n\n\nLUAI_FUNC int luaV_equalobj (lua_State *L, const TValue *t1, const TValue *t2);\nLUAI_FUNC int luaV_lessthan (lua_State *L, const TValue *l, const TValue *r);\nLUAI_FUNC int luaV_lessequal (lua_State *L, const TValue *l, const TValue *r);\nLUAI_FUNC int luaV_tonumber_ (const TValue *obj, lua_Number *n);\nLUAI_FUNC int luaV_tointeger (const TValue *obj, lua_Integer *p, F2Imod mode);\nLUAI_FUNC int luaV_tointegerns (const TValue *obj, lua_Integer *p,\n                                F2Imod mode);\nLUAI_FUNC int luaV_flttointeger (lua_Number n, lua_Integer *p, F2Imod mode);\nLUAI_FUNC int luaV_finishget (lua_State *L, const TValue *t, TValue *key,\n                                            StkId val, int tag);\nLUAI_FUNC void luaV_finishset (lua_State *L, const TValue *t, TValue *key,\n                                             TValue *val, int aux);\nLUAI_FUNC void luaV_finishOp (lua_State *L);\nLUAI_FUNC void luaV_execute (lua_State *L, CallInfo *ci);\nLUAI_FUNC void luaV_concat (lua_State *L, int total);\nLUAI_FUNC lua_Integer luaV_idiv (lua_State *L, lua_Integer x, lua_Integer y);\nLUAI_FUNC lua_Integer luaV_mod (lua_State *L, lua_Integer x, lua_Integer y);\nLUAI_FUNC lua_Number luaV_modf (lua_State *L, lua_Number x, lua_Number y);\nLUAI_FUNC lua_Integer luaV_shiftl (lua_Integer x, lua_Integer y);\nLUAI_FUNC void luaV_objlen (lua_State *L, StkId ra, const TValue *rb);\n\n#endif\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lzio.c",
		"is_binary":	false,
		"content":	"/*\n** $Id: lzio.c $\n** Buffered streams\n** See Copyright Notice in lua.h\n*/\n\n#define lzio_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"llimits.h\"\n#include \"lmem.h\"\n#include \"lstate.h\"\n#include \"lzio.h\"\n\n\nint luaZ_fill (ZIO *z) {\n  size_t size;\n  lua_State *L = z->L;\n  const char *buff;\n  lua_unlock(L);\n  buff = z->reader(L, z->data, &size);\n  lua_lock(L);\n  if (buff == NULL || size == 0)\n    return EOZ;\n  z->n = size - 1;  /* discount char being returned */\n  z->p = buff;\n  return cast_uchar(*(z->p++));\n}\n\n\nvoid luaZ_init (lua_State *L, ZIO *z, lua_Reader reader, void *data) {\n  z->L = L;\n  z->reader = reader;\n  z->data = data;\n  z->n = 0;\n  z->p = NULL;\n}\n\n\n/* --------------------------------------------------------------- read --- */\n\nstatic int checkbuffer (ZIO *z) {\n  if (z->n == 0) {  /* no bytes in buffer? */\n    if (luaZ_fill(z) == EOZ)  /* try to read more */\n      return 0;  /* no more input */\n    else {\n      z->n++;  /* luaZ_fill consumed first byte; put it back */\n      z->p--;\n    }\n  }\n  return 1;  /* now buffer has something */\n}\n\n\nsize_t luaZ_read (ZIO *z, void *b, size_t n) {\n  while (n) {\n    size_t m;\n    if (!checkbuffer(z))\n      return n;  /* no more input; return number of missing bytes */\n    m = (n <= z->n) ? n : z->n;  /* min. between n and z->n */\n    memcpy(b, z->p, m);\n    z->n -= m;\n    z->p += m;\n    b = (char *)b + m;\n    n -= m;\n  }\n  return 0;\n}\n\n\nconst void *luaZ_getaddr (ZIO* z, size_t n) {\n  const void *res;\n  if (!checkbuffer(z))\n    return NULL;  /* no more input */\n  if (z->n < n)  /* not enough bytes? */\n    return NULL;  /* block not whole; cannot give an address */\n  res = z->p;  /* get block address */\n  z->n -= n;  /* consume these bytes */\n  z->p += n;\n  return res;\n}\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/lzio.h",
		"is_binary":	false,
		"content":	"/*\n** $Id: lzio.h $\n** Buffered streams\n** See Copyright Notice in lua.h\n*/\n\n\n#ifndef lzio_h\n#define lzio_h\n\n#include \"lua.h\"\n\n#include \"lmem.h\"\n\n\n#define EOZ\t(-1)\t\t\t/* end of stream */\n\ntypedef struct Zio ZIO;\n\n#define zgetc(z)  (((z)->n--)>0 ?  cast_uchar(*(z)->p++) : luaZ_fill(z))\n\n\ntypedef struct Mbuffer {\n  char *buffer;\n  size_t n;\n  size_t buffsize;\n} Mbuffer;\n\n#define luaZ_initbuffer(L, buff) ((buff)->buffer = NULL, (buff)->buffsize = 0)\n\n#define luaZ_buffer(buff)\t((buff)->buffer)\n#define luaZ_sizebuffer(buff)\t((buff)->buffsize)\n#define luaZ_bufflen(buff)\t((buff)->n)\n\n#define luaZ_buffremove(buff,i)\t((buff)->n -= (i))\n#define luaZ_resetbuffer(buff) ((buff)->n = 0)\n\n\n#define luaZ_resizebuffer(L, buff, size) \\\n\t((buff)->buffer = luaM_reallocvchar(L, (buff)->buffer, \\\n\t\t\t\t(buff)->buffsize, size), \\\n\t(buff)->buffsize = size)\n\n#define luaZ_freebuffer(L, buff)\tluaZ_resizebuffer(L, buff, 0)\n\n\nLUAI_FUNC void luaZ_init (lua_State *L, ZIO *z, lua_Reader reader,\n                                        void *data);\nLUAI_FUNC size_t luaZ_read (ZIO* z, void *b, size_t n);\t/* read next n bytes */\n\nLUAI_FUNC const void *luaZ_getaddr (ZIO* z, size_t n);\n\n\n/* --------- Private Part ------------------ */\n\nstruct Zio {\n  size_t n;\t\t\t/* bytes still unread */\n  const char *p;\t\t/* current position in buffer */\n  lua_Reader reader;\t\t/* reader function */\n  void *data;\t\t\t/* additional data */\n  lua_State *L;\t\t\t/* Lua state (for reader) */\n};\n\n\nLUAI_FUNC int luaZ_fill (ZIO *z);\n\n#endif\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/dependencies/lua/onelua.c",
		"is_binary":	false,
		"content":	"/*\n** Lua core, libraries, and interpreter in a single file.\n** Compiling just this file generates a complete Lua stand-alone\n** program:\n**\n** $ gcc -O2 -std=c99 -o lua onelua.c -lm\n**\n** or\n**\n** $ gcc -O2 -std=c89 -DLUA_USE_C89 -o lua onelua.c -lm\n**\n*/\n\n/* default is to build the full interpreter */\n#ifndef MAKE_LIB\n#ifndef MAKE_LUAC\n#ifndef MAKE_LUA\n#define MAKE_LUA\n#endif\n#endif\n#endif\n\n\n/*\n** Choose suitable platform-specific features. Default is no\n** platform-specific features. Some of these options may need extra\n** libraries such as -ldl -lreadline -lncurses\n*/\n#if 0\n#define LUA_USE_LINUX\n#define LUA_USE_MACOSX\n#define LUA_USE_POSIX\n#define LUA_ANSI\n#endif\n\n\n/* no need to change anything below this line ----------------------------- */\n\n#include \"lprefix.h\"\n\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <float.h>\n#include <limits.h>\n#include <locale.h>\n#include <math.h>\n#include <setjmp.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include \"custom_math/custom_math.h\"\n\n/* setup for luaconf.h */\n#define LUA_CORE\n#define LUA_LIB\n#define ltable_c\n#define lvm_c\n#include \"luaconf.h\"\n\n/* do not export internal symbols */\n#undef LUAI_FUNC\n#undef LUAI_DDEC\n#undef LUAI_DDEF\n#define LUAI_FUNC\tstatic\n#define LUAI_DDEC(def)\t/* empty */\n#define LUAI_DDEF\tstatic\n\n/* core -- used by all */\n#include \"custom_math/custom_math.c\"\n#include \"lzio.c\"\n#include \"lctype.c\"\n#include \"lopcodes.c\"\n#include \"lmem.c\"\n#include \"lundump.c\"\n#include \"ldump.c\"\n#include \"lstate.c\"\n#include \"lgc.c\"\n#include \"llex.c\"\n#include \"lcode.c\"\n#include \"lparser.c\"\n#include \"ldebug.c\"\n#include \"lfunc.c\"\n#include \"lobject.c\"\n#include \"ltm.c\"\n#include \"lstring.c\"\n#include \"ltable.c\"\n#include \"ldo.c\"\n#include \"lvm.c\"\n#include \"lapi.c\"\n\n/* auxiliary library -- used by all */\n#include \"lauxlib.c\"\n\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/extra/"
	}, {
		"path":	"src/dependencies/luaCEmbed/extra/extra.c",
		"is_binary":	false,
		"content":	"\n\nconst char * LuaCembed_convert_arg_code(int arg_code){\n    if(arg_code == LUA_CEMBED_NOT_FOUND){\n        return PRIVATE_LUA_CEMBED_NOT_FOUND_STRING;\n    }\n\n    if(arg_code == LUA_CEMBED_STRING){\n        return PRIVATE_LUA_CEMBED_STRING_STRING;\n\n    }\n    if(arg_code == LUA_CEMBED_NUMBER){\n        return PRIVATE_LUA_CEMBED_NUMBER_STRING;\n    }\n    if(arg_code == LUA_CEMBED_BOOL){\n        return  PRIVATE_LUA_CEMBED_BOOL_STRING;\n    }\n    if(arg_code == LUA_CEMBED_NIL){\n        return  PRIVATE_LUA_CEMBED_NIL_STRING;\n    }\n    if(arg_code == LUA_CEMBED_TABLE){\n        return  PRIVATE_LUA_CEMBED_TABLE_STRING;\n    }\n    if(arg_code == LUA_CEMBED_FUNCTION){\n        return PRIVATE_LUA_CEMBED_FUNCTION_STRING;\n    }\n\n    return PRIVATE_LUA_CEMBED_UNKNOW_STRING;\n}\n\nchar * private_LuaCembed_format_vaarg(const char *expresion, va_list args){\n\n    va_list args_copy;\n    va_copy(args_copy, args);\n    long required_size = vsnprintf(NULL, 0,expresion,args_copy);\n    va_end(args_copy);\n    char *buffer = (char*)malloc(sizeof(char) * required_size + 2);\n    vsnprintf(buffer,sizeof (char) * required_size+1,expresion,args);\n    return buffer;\n}\nchar * private_LuaCembed_format(const char *expresion, ...){\n    va_list  args;\n    va_start(args,expresion);\n    char *result = private_LuaCembed_format_vaarg(expresion,args);\n    va_end(args);\n    return  result;\n}"
	}, {
		"path":	"src/dependencies/luaCEmbed/extra/extra.h",
		"is_binary":	false,
		"content":	"\n\nconst char * LuaCembed_convert_arg_code(int arg_code);\n\n\nchar * private_LuaCembed_format_vaarg(const char *expresion, va_list args);\n\nchar * private_LuaCembed_format(const char *expresion, ...);\n\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/namespace/"
	}, {
		"path":	"src/dependencies/luaCEmbed/namespace/LuaCEmbedNamespace/"
	}, {
		"path":	"src/dependencies/luaCEmbed/namespace/LuaCEmbedNamespace/LuaCEmbedNamespace.c",
		"is_binary":	false,
		"content":	"\n\n#include \"../../LuaCEmbed/basic/basic.h\"\n\nLuaCEmbedNamespace newLuaCEmbedNamespace(){\n    LuaCEmbedNamespace self = {0};\n    self.newLuaLib = newLuaCEmbedLib;\n    self.load_lib_from_c = LuaCEmbed_load_lib_from_c;\n    self.newLuaEvaluation = newLuaCEmbedEvaluation;\n    self.set_delete_function = LuaCembed_set_delete_function;\n    self.perform = LuaCembed_perform;\n    self.set_memory_limit = LuaCEmbed_set_memory_limit;\n    self.clear_errors = LuaCEmbed_clear_errors;\n    self.convert_arg_code = LuaCembed_convert_arg_code;\n    self.tables = newLuaCembedTableModule();\n    self.args = newLuaCembedArgsModule();\n    self.types = newLuaCEmbedTypeModule();\n    self.globals = newLuaCEmbedGlobalModule();\n    self.response = newLuaCEmbedResponseModule();\n    self.get_error_message = LuaCEmbed_get_error_message;\n    self.has_errors = LuaCEmbed_has_errors;\n    self.set_timeout = LuaCEmbed_set_timeout;\n    self.evaluate = LuaCEmbed_evaluate;\n    self.get_string_evaluation = LuaCEmbed_get_evaluation_string;\n    self.get_evaluation_type = LuaCEmbed_get_evaluation_type;\n    self.get_evaluation_size = LuaCEmbed_get_evaluation_table_size;\n    self.get_evaluation_long = LuaCEmbed_get_evaluation_long;\n    self.get_evaluation_double  = LuaCEmbed_get_evaluation_double;\n    self.get_evaluation_bool = LuaCEmbed_get_evaluation_bool;\n    self.evaluete_file = LuaCEmbed_evaluete_file;\n    self.add_callback = LuaCEmbed_add_callback;\n    self.add_global_callback = LuaCEmbed_add_global_callback;\n    self.set_bool_lib_prop = LuaCEmbed_set_bool_lib_prop;\n    self.set_long_lib_prop = LuaCEmbed_set_long_lib_prop;\n    self.set_double_lib_prop = LuaCEmbed_set_double_lib_prop;\n    self.set_string_lib_prop = LuaCEmbed_set_string_lib_prop;\n    self.set_table_lib_prop = LuaCEmbed_set_table_lib_prop;\n    self.get_long_lib_prop = LuaCEmbed_get_long_lib_prop;\n    self.get_double_lib_prop = LuaCEmbed_get_double_lib_prop;\n    self.get_bool_lib_prop  = LuaCEmbed_get_bool_lib_prop;\n    self.get_string_lib_prop = LuaCEmbed_get_string_lib_prop;\n    self.get_table_lib_prop = LuaCEmbed_get_table_lib_prop;\n\n    self.free = LuaCEmbed_free;\n    return self;\n}\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/namespace/LuaCEmbedNamespace/LuaCEmbedNamespace.h",
		"is_binary":	false,
		"content":	"\n\ntypedef struct{\n    LuaCEmbedTypeModule  types;\n    LuaCEmbedResponseModule  response;\n    LuaCembedArgsModule args;\n    LuaCEmbedGlobalModule  globals;\n    LuaCembedTableModule tables;\n    void (*clear_errors)(LuaCEmbed *self);\n    LuaCEmbed * (*newLuaLib)(lua_State *state);\n    void (*set_delete_function)(LuaCEmbed *self,void (*delelte_function)(struct  LuaCEmbed *self));\n    LuaCEmbed * (*newLuaEvaluation)();\n    void (*load_lib_from_c)(LuaCEmbed *self,int (*callback)(lua_State *l),const char *name);\n    int (*perform)(LuaCEmbed *self);\n    const char * (*convert_arg_code)(int arg_code);\n    void (*set_memory_limit)(LuaCEmbed *self, double limit);\n\n    char * (*get_error_message)(LuaCEmbed *self);\n    bool (*has_errors)(LuaCEmbed *self);\n    void (*set_timeout)(int seconds);\n    int (*evaluate)(LuaCEmbed *self, const char *code, ...);\n    char * (*get_string_evaluation)(LuaCEmbed *self,const char *code, ...);\n    int  (*get_evaluation_type)(LuaCEmbed *self,const char *code,...);\n    long (*get_evaluation_size)(LuaCEmbed *self,const char *code,...);\n    long long  (*get_evaluation_long)(LuaCEmbed *self,const char *code,...);\n    double (*get_evaluation_double)(LuaCEmbed *self,const char *code,...);\n    bool (*get_evaluation_bool)(LuaCEmbed *self, const char *code,...);\n\n    void (*set_long_lib_prop)(LuaCEmbed *self,const char *name,long long  value);\n\n    void (*set_double_lib_prop)(LuaCEmbed *self,const char *name,double value);\n    void (*set_bool_lib_prop)(LuaCEmbed *self,const char *name,bool value);\n    void (*set_string_lib_prop)(LuaCEmbed *self,const char *name,const char * value);\n    void (*set_table_lib_prop)(LuaCEmbed *self,const char *name,LuaCEmbedTable *value);\n\n    long long  (*get_long_lib_prop)(LuaCEmbed *self,const char *name);\n    double (*get_double_lib_prop)(LuaCEmbed *self,const char *name);\n    bool (*get_bool_lib_prop)(LuaCEmbed *self,const char *name);\n    char * (*get_string_lib_prop)(LuaCEmbed *self,const char *name);\n    LuaCEmbedTable *(*get_table_lib_prop)(LuaCEmbed *self,const char *name);\n\n    int (*evaluete_file)(LuaCEmbed *self, const char *file);\n    void (*add_callback)(LuaCEmbed *self, const char *callback_name, LuaCEmbedResponse* (*callback)(LuaCEmbed *args) );\n    void (*add_global_callback)(LuaCEmbed *self, const char *callback_name, LuaCEmbedResponse* (*callback)(LuaCEmbed *args) );\n\n    void (*free)(LuaCEmbed *self);\n\n} LuaCEmbedNamespace;\n\nLuaCEmbedNamespace newLuaCEmbedNamespace();\n\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/namespace/args/"
	}, {
		"path":	"src/dependencies/luaCEmbed/namespace/args/args.c",
		"is_binary":	false,
		"content":	"\n\nLuaCembedArgsModule newLuaCembedArgsModule(){\n    LuaCembedArgsModule self = {0};\n    self.get_bool = LuaCEmbed_get_bool_arg;\n    self.get_long = LuaCEmbed_get_long_arg;\n    self.get_double = LuaCEmbed_get_double_arg;\n    self.get_str = LuaCEmbed_get_str_arg;\n    self.get_raw_str = LuaCEmbed_get_raw_str_arg;\n    self.get_type = LuaCEmbed_get_arg_type;\n    self.get_table = LuaCEmbed_get_arg_table;\n    self.size = LuaCEmbed_get_total_args;\n    self.get_type_clojure_evalation = LuaCEmbed_get_type_clojure_evalation;\n    self.generate_arg_clojure_evalation = LuaCEmbed_generate_arg_clojure_evalation;\n    self.get_bool_arg_clojure_evalation = LuaCEmbed_get_bool_arg_clojure_evalation;\n    self.get_long_arg_clojure_evalation = LuaCEmbed_get_long_arg_clojure_evalation;\n    self.get_double_arg_clojure_evalation = LuaCEmbed_get_double_arg_clojure_evalation;\n    self.get_string_arg_clojure_evalation = LuaCEmbed_get_string_arg_clojure_evalation;\n    self.run_lambda = LuaCEmbed_run_args_lambda;\n    return self;\n}"
	}, {
		"path":	"src/dependencies/luaCEmbed/namespace/args/args.h",
		"is_binary":	false,
		"content":	"\ntypedef struct {\n\n\n    int  (*size)(LuaCEmbed *self);\n    int  (*get_type)(LuaCEmbed *self,int index);\n    long long  (*get_long)(LuaCEmbed *self, int index);\n    double (*get_double)(LuaCEmbed *self, int index);\n    bool (*get_bool)(LuaCEmbed *self, int index);\n    char * (*get_raw_str)(LuaCEmbed *self, long *size, int index);\n    char * (*get_str)(LuaCEmbed *self, int index);\n    LuaCEmbedTable  * (*get_table)(LuaCEmbed *self,int index);\n    int  (*generate_arg_clojure_evalation)(LuaCEmbed *self,int index,const char *code,...);\n    int  (*get_type_clojure_evalation)(LuaCEmbed *self,int index,const char *code,...);\n    long long    (*get_long_arg_clojure_evalation)(LuaCEmbed *self,int index,const char *code,...);\n    double (*get_double_arg_clojure_evalation)(LuaCEmbed *self,int index,const char *code,...);\n    bool (*get_bool_arg_clojure_evalation)(LuaCEmbed *self,int index,const char *code,...);\n    char* (*get_string_arg_clojure_evalation)(LuaCEmbed *self,int index,const char *code,...);\n    LuaCEmbedTable* (*run_lambda)(LuaCEmbed *self, int index, LuaCEmbedTable *args_to_call,int total_returns);\n\n\n\n\n} LuaCembedArgsModule;\n\nLuaCembedArgsModule newLuaCembedArgsModule();"
	}, {
		"path":	"src/dependencies/luaCEmbed/namespace/declaration.h",
		"is_binary":	false,
		"content":	"\n#include \"types/types.h\"\n#include \"response/response.h\"\n#include \"globals/globals.h\"\n#include \"args/args.h\"\n#include \"table/table.h\"\n#include \"LuaCEmbedNamespace/LuaCEmbedNamespace.h\""
	}, {
		"path":	"src/dependencies/luaCEmbed/namespace/definition.h",
		"is_binary":	false,
		"content":	"\n#include \"types/types.c\"\n#include \"response/response.c\"\n#include \"globals/globals.c\"\n#include \"args/args.c\"\n#include \"table/table.c\"\n#include \"LuaCEmbedNamespace/LuaCEmbedNamespace.c\""
	}, {
		"path":	"src/dependencies/luaCEmbed/namespace/globals/"
	}, {
		"path":	"src/dependencies/luaCEmbed/namespace/globals/globals.c",
		"is_binary":	false,
		"content":	"\n\nLuaCEmbedGlobalModule newLuaCEmbedGlobalModule(){\n    LuaCEmbedGlobalModule self = {0};\n    self.ensure_type = LuaCEmbed_ensure_global_type;\n    self.get_double = LuaCEmbed_get_global_double;\n    self.get_string = LuaCEmbed_get_global_string;\n    self.get_long = LuaCEmbed_get_global_long;\n    self.get_raw_string = LuaCEmbed_get_global_raw_string;\n    self.set_raw_string = LuaCEmbed_set_global_raw_string;\n    self.get_bool = LuaCEmbed_get_global_bool;\n    self.get_type = LuaCEmbed_get_global_type;\n    self.run_global_lambda = LuaCEmbed_run_global_lambda;\n    self.set_table = LuaCEmbed_set_global_table;\n    self.set_string = LuaCEmbed_set_global_string;\n    self.set_bool = LuaCEmbed_set_global_bool;\n    self.set_double = LuaCEmbed_set_global_double;\n    self.set_long = LuaCEmbed_set_global_long;\n    self.new_table = LuaCembed_new_global_table;\n    self.get_table = LuaCembed_get_global_table;\n\n    return self;\n}"
	}, {
		"path":	"src/dependencies/luaCEmbed/namespace/globals/globals.h",
		"is_binary":	false,
		"content":	"\n\ntypedef struct {\n\n    int (*ensure_type)(LuaCEmbed *self, const char *name,int expected_type);\n    int (*get_type)(LuaCEmbed *self,const char *name);\n    long long  (*get_long)(LuaCEmbed *self,const char *name);\n    double (*get_double)(LuaCEmbed *self,const char *name);\n    bool (*get_bool)(LuaCEmbed *self,const char *name);\n    char * (*get_string)(LuaCEmbed *self,const char *name);\n    LuaCEmbedTable* (*run_global_lambda)(LuaCEmbed *self, const char *name, LuaCEmbedTable *args_to_call, int total_returns);\n    void (*set_table)(LuaCEmbed *self, const char *name, LuaCEmbedTable *table);\n    void (*set_raw_string)(LuaCEmbed *self, const char *name, const  char *value, long size);\n    char * (*get_raw_string)(LuaCEmbed *self, const char *name, long *size);\n\n\n    void (*set_string)(LuaCEmbed *self,const char *name,const  char *value);\n    void (*set_long)(LuaCEmbed *self,const char *name,long long  value);\n    void (*set_double)(LuaCEmbed *self,const char *name,double value);\n    void (*set_bool)(LuaCEmbed *self,const char *name,bool value);\n\n    LuaCEmbedTable * (*get_table)(LuaCEmbed *self, const char *name);\n    LuaCEmbedTable * (*new_table)(LuaCEmbed *self, const char *name);\n\n\n}LuaCEmbedGlobalModule;\n\nLuaCEmbedGlobalModule newLuaCEmbedGlobalModule();"
	}, {
		"path":	"src/dependencies/luaCEmbed/namespace/response/"
	}, {
		"path":	"src/dependencies/luaCEmbed/namespace/response/response.c",
		"is_binary":	false,
		"content":	"\n\nLuaCEmbedResponseModule newLuaCEmbedResponseModule(){\n    LuaCEmbedResponseModule self = {0};\n    self.send_multi_return = LuaCEmbed_send_multi_return;\n    self.send_str = LuaCEmbed_send_str;\n    self.send_str_reference = LuaCEmbed_send_str_reference;\n    self.send_raw_string = LuaCEmbed_send_raw_string;\n    self.send_raw_string_reference = LuaCEmbed_send_raw_string_reference;\n    self.send_bool = LuaCEmbed_send_bool;\n    self.send_double = LuaCEmbed_send_double;\n    self.send_evaluation_function =  LuaCEmbed_send_evaluation;\n    self.send_long = LuaCEmbed_send_long;\n    self.send_table = LuaCEmbed_send_table;\n    self.send_error = LuaCEmbed_send_error;\n    return  self;\n}\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/namespace/response/response.h",
		"is_binary":	false,
		"content":	"\n\ntypedef struct {\n    LuaCEmbedResponse * (*send_multi_return)(LuaCEmbedTable *table);\n    LuaCEmbedResponse * (*send_str)(const char *text);\n    LuaCEmbedResponse * (*send_raw_string)(const char *text,long size);\n    LuaCEmbedResponse * (*send_str_reference)( const char *text);\n    LuaCEmbedResponse * (*send_raw_string_reference)(const char *text,long size);\n    LuaCEmbedResponse * (*send_table)(LuaCEmbedTable *table);\n    LuaCEmbedResponse * (*send_evaluation_function)(const char *function);\n    LuaCEmbedResponse  * (*send_double)(double value);\n    LuaCEmbedResponse  * (*send_bool)(bool value);\n    LuaCEmbedResponse  * (*send_long)(long value);\n    LuaCEmbedResponse * (*send_error)(const char *format,...);\n\n}LuaCEmbedResponseModule;\n\nLuaCEmbedResponseModule newLuaCEmbedResponseModule();"
	}, {
		"path":	"src/dependencies/luaCEmbed/namespace/table/"
	}, {
		"path":	"src/dependencies/luaCEmbed/namespace/table/table.c",
		"is_binary":	false,
		"content":	"\n\nLuaCembedTableModule newLuaCembedTableModule(){\n    LuaCembedTableModule self ={0};\n\n    self.append_string = LuaCEmbedTable_append_string;\n    self.append_bool = LuaCEmbedTable_append_bool;\n    self.append_double = LuaCEmbedTable_append_double;\n    self.append_long = LuaCEmbedTable_append_long;\n    self.append_table = LuaCEmbedTable_append_table;\n    self.append_evaluation = LuaCEmbedTable_append_evaluation;\n\n    self.insert_string_at_index = LuaCEmbedTable_insert_string_at_index;\n    self.insert_double_at_index = LuaCEmbedTable_insert_double_at_index;\n    self.insert_long_at_index = LuaCEmbedTable_insert_long_at_index;\n    self.insert_table_at_index = LuaCEmbedTable_insert_table_at_index;\n\n    self.set_evaluation_prop = LuaCEmbedTable_set_evaluation_prop;\n    self.set_method = LuaCEmbedTable_set_method;\n    self.set_method = LuaCEmbedTable_set_method;\n    self.set_bool_prop = LuaCEmbedTable_set_bool_prop;\n    self.set_double_prop = LuaCEmbedTable_set_double_prop;\n    self.set_long_prop = LuaCEmbedTable_set_long_prop;\n    self.set_string_prop = LuaCEmbedTable_set_string_prop;\n\n    self.get_sub_table_prop = LuaCEmbedTable_get_sub_table_by_key;\n    self.new_sub_table_prop = LuaCEmbedTable_new_sub_table_by_key;\n    self.set_sub_table_prop = LuaCEmbedTable_set_sub_table_prop;\n    self.new_anonymous_table = LuaCembed_new_anonymous_table;\n\n    self.set_sub_table_by_index = LuaCEmbedTable_set_sub_table_by_index;\n    self.get_bool_prop = LuaCembedTable_get_bool_prop;\n    self.get_double_prop = LuaCembedTable_get_double_prop;\n    self.get_long_prop = LuaCembedTable_get_long_prop;\n    self.get_string_prop = LuaCembedTable_get_string_prop;\n    self.get_type_prop = LuaCEmbedTable_get_type_prop;\n    self.destroy_prop = LuaCembedTable_destroy_prop;\n\n    self.set_long_by_index = LuaCEmbedTable_set_long_by_index;\n    self.set_bool_by_index= LuaCEmbedTable_set_bool_by_index;\n    self.set_double_by_index =LuaCEmbedTable_set_double_by_index;\n    self.set_string_by_index = LuaCEmbedTable_set_string_by_index;\n    self.set_evaluation_by_index = LuaCEmbedTable_set_evaluation_by_index;\n\n    self.get_listable_size = LuaCEmbedTable_get_listable_size;\n\n    self.new_sub_table_appending = LuaCEmbedTable_new_sub_table_appending;\n    self.has_key = LuaCembedTable_has_key_at_index;\n    self.get_key_by_index = LuaCembedTable_get_key_by_index;\n    self.get_size = LuaCEmbedTable_get_full_size;\n    self.get_type_by_index = LuaCEmbedTable_get_type_by_index;\n    self.get_long_by_index = LuaCEmbedTable_get_long_by_index;\n    self.get_double_by_index = LuaCEmbedTable_get_double_by_index;\n    self.get_bool_by_index = LuaCEmbedTable_get_bool_by_index;\n    self.get_string_by_index= LuaCEmbedTable_get_string_by_index;\n    self.get_sub_table_by_index = LuaCEmbedTable_get_sub_table_by_index;\n    return self;\n}\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/namespace/table/table.h",
		"is_binary":	false,
		"content":	"\ntypedef struct {\n\n    void  (*append_string)(LuaCEmbedTable *self,  const char *value);\n    void  (*append_long)(LuaCEmbedTable *self,  long long   value);\n    void  (*append_double)(LuaCEmbedTable *self, double  value);\n    void  (*append_bool)(LuaCEmbedTable *self,  bool value);\n    void  (*append_table)(LuaCEmbedTable *self, LuaCEmbedTable *table);\n    void  (*set_evaluation_prop)(LuaCEmbedTable *self, const char *name, const char *code, ...);\n    void  (*append_evaluation)(LuaCEmbedTable *self, const char *code, ...);\n\n    void  (*insert_string_at_index)(LuaCEmbedTable *self, long index, const char *value);\n    void  (*insert_bool_at_index)(LuaCEmbedTable *self, long index,bool value);\n    void  (*insert_long_at_index)(LuaCEmbedTable *self, long long  index,long value);\n    void  (*insert_double_at_index)(LuaCEmbedTable *self, long index,double value);\n    void  (*insert_table_at_index)(LuaCEmbedTable *self, long index,LuaCEmbedTable *table);\n\n\n\n    void (*set_sub_table_by_index)(LuaCEmbedTable *self, long index,LuaCEmbedTable *sub_table);\n    void  (*set_string_by_index)(LuaCEmbedTable *self, long index, const char *value);\n    void  (*set_long_by_index)(LuaCEmbedTable *self, long long  index, long  value);\n    void  (*set_double_by_index)(LuaCEmbedTable *self, long index, double  value);\n    void  (*set_bool_by_index)(LuaCEmbedTable *self, long index, bool value);\n    void  (*set_evaluation_by_index)(LuaCEmbedTable *self, long index, const char *code, ...);\n    long  (*get_listable_size)(LuaCEmbedTable *self);\n    LuaCEmbedTable  *(*get_sub_table_by_index)(LuaCEmbedTable *self, long index);\n\n    LuaCEmbedTable  *(*new_sub_table_appending)(LuaCEmbedTable *self);\n\n    void (*set_method)(LuaCEmbedTable *self , const char *name, LuaCEmbedResponse *(*callback)(LuaCEmbedTable  *self, LuaCEmbed *args));\n    void  (*set_string_prop)(LuaCEmbedTable *self , const char *name, const char *value);\n    void  (*set_long_prop)(LuaCEmbedTable *self , const char *name, long long   value);\n    void  (*set_double_prop)(LuaCEmbedTable *self , const char *name, double  value);\n    void  (*set_bool_prop)(LuaCEmbedTable *self , const char *name, bool value);\n    int  (*get_type_prop)(LuaCEmbedTable *self, const char *name);\n    char*  (*get_string_prop)(LuaCEmbedTable *self , const char *name);\n    long long   (*get_long_prop)(LuaCEmbedTable *self , const char *name);\n    double  (*get_double_prop)(LuaCEmbedTable *self , const char *name);\n    bool  (*get_bool_prop)(LuaCEmbedTable *self , const char *name);\n    LuaCEmbedTable * (*new_anonymous_table)(LuaCEmbed *self);\n    void (*destroy_prop)(LuaCEmbedTable *self, const char *name);\n\n    LuaCEmbedTable  *(*get_sub_table_prop)(LuaCEmbedTable *self, const char *name);\n    LuaCEmbedTable  *(*new_sub_table_prop)(LuaCEmbedTable *self, const char *name);\n    void (*set_sub_table_prop)(LuaCEmbedTable *self, const char *name, LuaCEmbedTable *sub_table);\n    char *(*get_key_by_index)(LuaCEmbedTable *self, long index);\n    bool (*has_key)(LuaCEmbedTable *self,long index);\n\n    long  (*get_size)(LuaCEmbedTable *self);\n    int (*get_type_by_index)(LuaCEmbedTable *self, int index);\n    long long  (*get_long_by_index)(LuaCEmbedTable *self, int index);\n    double (*get_double_by_index)(LuaCEmbedTable *self, int index);\n    char * (*get_string_by_index)(LuaCEmbedTable *self, int index);\n    bool (*get_bool_by_index)(LuaCEmbedTable *self, int index);\n\n}LuaCembedTableModule;\n\nLuaCembedTableModule newLuaCembedTableModule();\n"
	}, {
		"path":	"src/dependencies/luaCEmbed/namespace/types/"
	}, {
		"path":	"src/dependencies/luaCEmbed/namespace/types/types.c",
		"is_binary":	false,
		"content":	"\nLuaCEmbedTypeModule newLuaCEmbedTypeModule(){\n    LuaCEmbedTypeModule  self = {0};\n    self.NOT_FOUND = LUA_CEMBED_NOT_FOUND;\n    self.STRING = LUA_CEMBED_STRING;\n    self.NUMBER = LUA_CEMBED_NUMBER;\n    self.BOOL = LUA_CEMBED_BOOL;\n    self.NILL = LUA_CEMBED_NIL;\n    self.TABLE = LUA_CEMBED_TABLE;\n    self.FUNCTION = LUA_CEMBED_FUNCTION;\n    return self;\n}"
	}, {
		"path":	"src/dependencies/luaCEmbed/namespace/types/types.h",
		"is_binary":	false,
		"content":	"\n\ntypedef struct {\n    int NOT_FOUND;\n    int STRING;\n    int NUMBER;\n    int BOOL;\n    int NILL;\n    int TABLE;\n    int FUNCTION;\n\n\n}LuaCEmbedTypeModule;\n\nLuaCEmbedTypeModule newLuaCEmbedTypeModule();"
	}, {
		"path":	"src/dependencies/luaCEmbed/one.c",
		"is_binary":	false,
		"content":	"\n\n#ifndef LUACEMBED_H\n\n#include \"declaration.h\"\n#include \"definition.h\"\n\n#define LUACEMBED_H\n#endif "
	}, {
		"path":	"src/dependencies/luaCEmbed/src/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/args/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/args/args_error/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/args/basic/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/args/evaluation/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/basic/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/callback_handle/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/evaluation/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/globals/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/globals/errors/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/globals/getters/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/globals/setters/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/lib_props/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/lib_start/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/memory/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/table/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/table/table/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/table/table/append/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/table/table/basic/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/table/table/destroy/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/table/table/errors/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/table/table/getters/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/table/table/getters/index/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/table/table/getters/keys/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/table/table/setters/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/table/table/setters/index/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/table/table/setters/insert/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/table/table/setters/keys/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/table/table/sub_tables/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/table/table/sub_tables/index/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/table/table/sub_tables/key/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbed/table/table_array/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/LuaCEmbedResponse/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/constants/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/dependencies/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/dependencies/lua/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/dependencies/lua/custom_math/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/extra/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/namespace/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/namespace/LuaCEmbedNamespace/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/namespace/args/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/namespace/globals/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/namespace/response/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/namespace/table/"
	}, {
		"path":	"src/dependencies/luaCEmbed/src/namespace/types/"
	}, {
		"path":	"src/entity_modification/"
	}, {
		"path":	"src/entity_modification/entity_modification.c",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse * lua_get_entity_last_modification_in_unix(LuaCEmbed *args) {\n    char *file = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)) {\n        char *error_msg =  LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error_msg);\n    }\n    long last_modification = dtw_get_entity_last_motification_in_unix(file);\n    if(last_modification == -1) {\n        return NULL;\n    }\n    return LuaCEmbed_send_long(last_modification);\n}\n\n\nLuaCEmbedResponse * lua_get_entity_last_modification(LuaCEmbed *args) {\n    char *file = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)) {\n        char *error_msg =  LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error_msg);\n    }\n    char *last_modification = dtw_get_entity_last_motification_in_string(file);\n    if(last_modification == NULL) {\n        return NULL;\n    }\n    LuaCEmbedResponse *response  = LuaCEmbed_send_str(last_modification);\n    free(last_modification);\n    return  response;\n}\n"
	}, {
		"path":	"src/entity_modification/entity_modification.h",
		"is_binary":	false,
		"content":	"LuaCEmbedResponse * lua_get_entity_last_modification_in_unix(LuaCEmbed *args);\n\n\nLuaCEmbedResponse * lua_get_entity_last_modification(LuaCEmbed *args);\n"
	}, {
		"path":	"src/extra/"
	}, {
		"path":	"src/extra/extra.c",
		"is_binary":	false,
		"content":	"\nbool get_table_props_or_default_bool(LuaCEmbedTable *table,const char *prop,bool default_value){\n    if(table == NULL){\n        return default_value;\n    }\n    if(LuaCEmbedTable_get_type_prop(table,prop) != LUA_CEMBED_NIL){\n        return LuaCembedTable_get_bool_prop(table,prop);\n    }\n    return default_value;\n}\n\nLuaCEmbedResponse * concat_path(LuaCEmbed *args){\n    char *path1 = LuaCEmbed_get_str_arg(args,0);\n    char *path2 = LuaCEmbed_get_str_arg(args,1);\n\n    if(LuaCEmbed_has_errors(args)){\n        char *error_msg = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error_msg);\n    }\n    char *value = dtw_concat_path(path1,path2);\n    LuaCEmbedResponse *response = LuaCEmbed_send_str(value);\n    free(value);\n    return  response;\n}\nLuaCEmbedResponse * starts_with(LuaCEmbed *args){\n    char *content =  LuaCEmbed_get_str_arg(args,0);\n    char *comparation =  LuaCEmbed_get_str_arg(args,1);\n\n    if(LuaCEmbed_has_errors(args)){\n        char *error_msg = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error_msg);\n    }\n    bool result = dtw_starts_with(content,comparation);\n    return LuaCEmbed_send_bool(result);\n}\n\nLuaCEmbedResponse * ends_with(LuaCEmbed *args){\n    char *content =  LuaCEmbed_get_str_arg(args,0);\n    char *comparation =  LuaCEmbed_get_str_arg(args,1);\n\n    if(LuaCEmbed_has_errors(args)){\n        char *error_msg = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error_msg);\n    }\n    bool result = dtw_ends_with(content,comparation);\n    return LuaCEmbed_send_bool(result);\n}\n\n"
	}, {
		"path":	"src/extra/extra.h",
		"is_binary":	false,
		"content":	"\nbool get_table_props_or_default_bool(LuaCEmbedTable *table,const char *prop,bool default_value);\n\n\nLuaCEmbedResponse * concat_path(LuaCEmbed *args);\n\nLuaCEmbedResponse * starts_with(LuaCEmbed *args);\n\nLuaCEmbedResponse * ends_with(LuaCEmbed *args);\n"
	}, {
		"path":	"src/fork_process/"
	}, {
		"path":	"src/fork_process/fork_process.c",
		"is_binary":	false,
		"content":	"\nint lua_do_the_world_sleep_mili_seconds(long miliseconds){\n     struct timespec rem;\n     struct timespec req= {\n          (int)(miliseconds / 1000),     /* secs (Must be Non-Negative) */\n          (miliseconds % 1000) * 1000000 /* nano (Must be in range of 0 to 999999999) */\n      };\n\n     return nanosleep(&req , &rem);\n}\n\nLuaCEmbedResponse * fork_wait(LuaCEmbedTable *self,LuaCEmbed *args) {\n\n     int timeout = LuaCEmbed_get_long_arg(args,0);\n     if(LuaCEmbed_has_errors(args)) {\n          char *error_msg = LuaCEmbed_get_error_message(args);\n          return LuaCEmbed_send_error(error_msg);\n     }\n     int wait_time = LuaCembedTable_get_long_prop(self,FORK_SLEEP_PROP);\n     int waited= 0;\n     int pid = LuaCembedTable_get_long_prop(self,PID_PROP);\n     while (true) {\n          int status;\n          pid = waitpid(pid, &status, WNOHANG);\n          LuaCEmbedTable_set_long_prop(self,FORK_STATUS_METHOD,status);\n\n          if(pid != 0) {\n               return LuaCEmbed_send_bool(true);\n          }\n          lua_do_the_world_sleep_mili_seconds(wait_time);\n          waited+=wait_time;\n          if(waited > timeout && timeout != -1) {\n               break;\n          }\n     }\n     return LuaCEmbed_send_bool(false);\n}\n\n\nLuaCEmbedResponse * is_fork_alive(LuaCEmbedTable *self,LuaCEmbed *args) {\n     int pid = LuaCembedTable_get_long_prop(self,PID_PROP);\n     int status;\n     pid_t new_pid = waitpid(pid, &status, WNOHANG);\n     LuaCEmbedTable_set_long_prop(self,FORK_STATUS_METHOD,status);\n\n     if(new_pid == 0) {\n          return LuaCEmbed_send_bool(true);\n     }\n     return LuaCEmbed_send_bool(false);\n}\n\n\n\nLuaCEmbedResponse * kill_process(LuaCEmbedTable *self,LuaCEmbed *args) {\n     int pid = LuaCembedTable_get_long_prop(self,PID_PROP);\n     kill(pid, SIGKILL);\n     return  NULL;\n}\n\nLuaCEmbedResponse * fork_delete(LuaCEmbedTable *self,LuaCEmbed *args) {\n     int pid = LuaCembedTable_get_long_prop(self,PID_PROP);\n     kill(pid, SIGKILL);\n     return  NULL;\n}\n\nLuaCEmbedResponse * create_fork_process(LuaCEmbed *args) {\n\n     int pid =fork();\n     if(pid==0) {\n\n          LuaCEmbed_run_args_lambda(args,0,NULL,0);\n          if(LuaCEmbed_has_errors(args)) {\n               printf(\"error %s\\n\",LuaCEmbed_get_error_message(args));\n               LuaCEmbed_clear_errors(args);\n          }\n          exit(0);\n     }\n     if(pid == -1) {\n          return LuaCEmbed_send_error(IMPOSSIBLE_TO_FORK);\n     }\n\n     LuaCEmbedTable *self =LuaCembed_new_anonymous_table(args);\n     LuaCEmbedTable_set_long_prop(self,PID_PROP,pid);\n     LuaCEmbedTable_set_long_prop(self,FORK_SLEEP_PROP,FORK_SLEEP_DEFAULT_TIME);\n     LuaCEmbedTable_set_method(self,DELETE_METHOD,fork_delete);\n     LuaCEmbedTable_set_method(self,KILL_FORK_METHOD,kill_process);\n     LuaCEmbedTable_set_method(self,IS_FORK_ALIVE_METHOD,is_fork_alive);\n     LuaCEmbedTable_set_method(self,FORK_WAIT_METHOD,fork_wait);\n     return LuaCEmbed_send_table(self);\n\n\n}"
	}, {
		"path":	"src/fork_process/fork_process.h",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse * is_fork_alive(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * fork_delete(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * fork_wait(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * kill_process(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * create_fork_process(LuaCEmbed *args);"
	}, {
		"path":	"src/hasher/"
	}, {
		"path":	"src/hasher/hasher.c",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse * hasher_digest_path(LuaCEmbedTable *self,LuaCEmbed *args){\n    char *path = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n    DtwHash *hash = (DtwHash*)LuaCembedTable_get_long_prop(self,HASH_POINTER);\n    int type =dtw_entity_type(path);\n\n    if(type== DTW_FILE_TYPE){\n        DtwHash_digest_file(hash,path);\n    }\n    if(type == DTW_FOLDER_TYPE){\n        DtwHash_digest_folder_by_content(hash,path);\n    }\n\n    return LuaCEmbed_send_str(hash->hash);\n}\n\nLuaCEmbedResponse * hasher_digest_file(LuaCEmbedTable *self,LuaCEmbed *args){\n    char *filename = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n\n    DtwHash *hash = (DtwHash*)LuaCembedTable_get_long_prop(self,HASH_POINTER);\n    DtwHash_digest_file(hash,filename);\n    return NULL;\n}\n\nLuaCEmbedResponse * hasher_digest_folder_by_content(LuaCEmbedTable *self, LuaCEmbed *args){\n    char *folder = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n\n    DtwHash *hash = (DtwHash*)LuaCembedTable_get_long_prop(self,HASH_POINTER);\n    DtwHash_digest_folder_by_content(hash,folder);\n    return NULL;\n}\n\nLuaCEmbedResponse * hasher_digest_folder_by_last_modification(LuaCEmbedTable *self, LuaCEmbed *args){\n    char *folder = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n\n\n    DtwHash *hash = (DtwHash*)LuaCembedTable_get_long_prop(self,HASH_POINTER);\n    DtwHash_digest_folder_by_last_modification(hash,folder);\n    return NULL;\n}\n\n\n\nLuaCEmbedResponse * delete_hasher(LuaCEmbedTable *self,LuaCEmbed *args){\n    DtwHash *hash = (DtwHash*)LuaCembedTable_get_long_prop(self,HASH_POINTER);\n    DtwHash_free(hash);\n    return NULL;\n}\n\nLuaCEmbedResponse * hasher_digest(LuaCEmbedTable *self,LuaCEmbed *args){\n    Writeble  *write_obj = create_writeble(args,0);\n    if(write_obj->error){\n        LuaCEmbedResponse *response =  write_obj->error;\n        Writeble_free(write_obj);\n        return  response;\n    }\n    DtwHash *hash = (DtwHash*)LuaCembedTable_get_long_prop(self,HASH_POINTER);\n    DtwHash_digest_any(hash,write_obj->content,write_obj->size);\n    Writeble_free(write_obj);\n    return NULL;\n}\n\nLuaCEmbedResponse * hasher_get_value(LuaCEmbedTable *self,LuaCEmbed *args){\n    DtwHash *hash = (DtwHash*)LuaCembedTable_get_long_prop(self,HASH_POINTER);\n    return LuaCEmbed_send_str(hash->hash);\n}\n\n\nLuaCEmbedResponse * create_hasher(LuaCEmbed *args){\n    LuaCEmbedTable * self = LuaCembed_new_anonymous_table(args);\n    DtwHash *hash = newDtwHash();\n    LuaCEmbedTable_set_long_prop(self,HASH_POINTER,(long long)hash);\n    LuaCEmbedTable_set_method(self,DIGEST_PATH,hasher_digest_path);\n    LuaCEmbedTable_set_method(self, DIGESST_METHOD, hasher_digest);\n    LuaCEmbedTable_set_method(self, TO_STRING_METHOD, hasher_get_value);\n    LuaCEmbedTable_set_method(self, GET_VALUE_METHOD, hasher_get_value);\n    LuaCEmbedTable_set_method(self, DIGESST_FILE_METHOD, hasher_digest_file);\n    LuaCEmbedTable_set_method(self, DIGESST_FOLDER_BY_CONTENT_METHOD, hasher_digest_folder_by_content);\n    LuaCEmbedTable_set_method(self, DIGESST_FOLDER_BY_LAST_MODIFICATION_METHOD, hasher_digest_folder_by_last_modification);\n    LuaCEmbedTable_set_method(self, DELETE_METHOD, delete_hasher);\n    return LuaCEmbed_send_table(self);\n}\n"
	}, {
		"path":	"src/hasher/hasher.h",
		"is_binary":	false,
		"content":	"\n\nLuaCEmbedResponse * hasher_digest_file(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * hasher_digest_path(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * hasher_digest_folder_by_content(LuaCEmbedTable *self, LuaCEmbed *args);\n\nLuaCEmbedResponse * hasher_digest_folder_by_last_modification(LuaCEmbedTable *self, LuaCEmbed *args);\n\nLuaCEmbedResponse * hasher_get_value(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * hasher_digest(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * delete_hasher(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * create_hasher(LuaCEmbed *args);\n"
	}, {
		"path":	"src/io/"
	}, {
		"path":	"src/io/io.c",
		"is_binary":	false,
		"content":	"\n\nLuaCEmbedResponse  * load_file(LuaCEmbed *args){\n    char *filename = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n\n    long  size;\n    unsigned  char *content = dtw_load_binary_content(filename,&size);\n    if(content == NULL) {\n        return  NULL;\n    }\n\n    LuaCEmbedResponse  *response  = LuaCEmbed_send_raw_string((char*)content,size);\n    free(content);\n    return  response;\n}\n\nLuaCEmbedResponse  * write_file(LuaCEmbed *args){\n    char *filename = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n    bool writed = false;\n    long total_args = LuaCEmbed_get_total_args(args);\n    if(total_args == 0){\n        writed  = dtw_write_string_file_content(filename,\"\");\n        return LuaCEmbed_send_bool(writed);\n    }\n    Writeble  *write_obj = create_writeble(args,1);\n    if(write_obj->error){\n        LuaCEmbedResponse *response =  write_obj->error;\n        Writeble_free(write_obj);\n        return  response;\n    }\n    writed = dtw_write_any_content(filename,write_obj->content,write_obj->size);\n    Writeble_free(write_obj);\n    return  LuaCEmbed_send_bool(writed);\n\n\n}\nLuaCEmbedResponse  * is_dir(LuaCEmbed *args){\n    char *source = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n    int type = dtw_entity_type(source);\n    return LuaCEmbed_send_bool(type == DTW_FOLDER_TYPE);\n}\n\nLuaCEmbedResponse  * exist(LuaCEmbed *args){\n    char *source = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n    int type = dtw_entity_type(source);\n    return LuaCEmbed_send_bool(type != DTW_NOT_FOUND);\n}\n\nLuaCEmbedResponse  * is_blob(LuaCEmbed *args){\n\n    Writeble  *write_obj = create_writeble(args,1);\n    if(write_obj->error){\n        LuaCEmbedResponse *response =  write_obj->error;\n        Writeble_free(write_obj);\n        return  response;\n    }\n    bool is_binary = write_obj->is_binary;\n    Writeble_free(write_obj);\n    return LuaCEmbed_send_bool(is_binary);\n\n}\n\nLuaCEmbedResponse  * is_file(LuaCEmbed *args){\n    char *source = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n    int type = dtw_entity_type(source);\n    return LuaCEmbed_send_bool(type == DTW_FILE_TYPE);\n}\n\nLuaCEmbedResponse  * is_blob_file(LuaCEmbed *args){\n    char *source = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n    int type = dtw_complex_entity_type(source);\n    return LuaCEmbed_send_bool(type == DTW_COMPLEX_BINARY);\n}\n\n\n\n\nLuaCEmbedResponse  * copy_any_overwriting(LuaCEmbed *args){\n    char *source = LuaCEmbed_get_str_arg(args,0);\n    char *dest = LuaCEmbed_get_str_arg(args,1);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n\n    bool writed = dtw_copy_any(source,dest,DTW_NOT_MERGE);\n    return LuaCEmbed_send_bool(writed);\n}\n\n\nLuaCEmbedResponse  * copy_any_merging(LuaCEmbed *args){\n    char *source = LuaCEmbed_get_str_arg(args,0);\n    char *dest = LuaCEmbed_get_str_arg(args,1);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n    bool writed = dtw_copy_any(source,dest,DTW_MERGE);\n    return LuaCEmbed_send_bool(writed);\n}\n\nLuaCEmbedResponse  * move_any_overwriting(LuaCEmbed *args){\n    char *source = LuaCEmbed_get_str_arg(args,0);\n    char *dest = LuaCEmbed_get_str_arg(args,1);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n    bool writed = dtw_move_any(source,dest,DTW_NOT_MERGE);\n    return LuaCEmbed_send_bool(writed);\n}\nLuaCEmbedResponse  * move_any_merging(LuaCEmbed *args){\n    char *source = LuaCEmbed_get_str_arg(args,0);\n    char *dest = LuaCEmbed_get_str_arg(args,1);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n    bool writed = dtw_move_any(source,dest,DTW_MERGE);\n    return LuaCEmbed_send_bool(writed);\n}\n\n\nLuaCEmbedResponse  * remove_any(LuaCEmbed *args){\n    char *source = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n    bool writed = dtw_remove_any(source);\n    return LuaCEmbed_send_bool(writed);\n}\n\n\n"
	}, {
		"path":	"src/io/io.h",
		"is_binary":	false,
		"content":	"\n\nLuaCEmbedResponse  * load_file(LuaCEmbed *args);\n\nLuaCEmbedResponse  * write_file(LuaCEmbed *args);\n\nLuaCEmbedResponse  * copy_any_overwriting(LuaCEmbed *args);\n\nLuaCEmbedResponse  * is_dir(LuaCEmbed *args);\nLuaCEmbedResponse  * is_blob(LuaCEmbed *args);\n\nLuaCEmbedResponse  * is_blob_file(LuaCEmbed *args);\n\nLuaCEmbedResponse  * exist(LuaCEmbed *args);\n\nLuaCEmbedResponse  * is_file(LuaCEmbed *args);\n\n\n\nLuaCEmbedResponse  * copy_any_merging(LuaCEmbed *args);\n\nLuaCEmbedResponse  * move_any_overwriting(LuaCEmbed *args);\n\nLuaCEmbedResponse  * move_any_merging(LuaCEmbed *args);\n\nLuaCEmbedResponse  * remove_any(LuaCEmbed *args);\n"
	}, {
		"path":	"src/listage/"
	}, {
		"path":	"src/listage/listage.c",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse  * aply_listage(LuaCEmbed *args,DtwStringArray* (*callback)(const char *folder,bool concat_path)){\n    char *source = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n    bool concat_path = false;\n    if(LuaCEmbed_get_total_args(args) >= 2){\n        concat_path = LuaCEmbed_get_bool_arg(args,1);\n    }\n    DtwStringArray * listage = callback(source,concat_path);\n    DtwStringArray_sort(listage);\n    LuaCEmbedTable * table = LuaCembed_new_anonymous_table(args);\n    for(int i = 0; i < listage->size; i++){\n        char * current_value = listage->strings[i];\n        LuaCEmbedTable_append_string(table,current_value);\n    }\n\n    LuaCEmbedTable *final = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_append_table(final,table);\n    LuaCEmbedTable_append_long(final,listage->size);\n    DtwStringArray_free(listage);\n    return LuaCEmbed_send_multi_return(final);\n}\n\nLuaCEmbedResponse  * list_files(LuaCEmbed *args){\n    return aply_listage(args,dtw_list_files);\n}\n\nLuaCEmbedResponse  * list_dirs(LuaCEmbed *args){\n    return aply_listage(args,dtw_list_dirs);\n\n}\n\nLuaCEmbedResponse  * list_all(LuaCEmbed *args){\n    return aply_listage(args,dtw_list_all);\n}\n\nLuaCEmbedResponse  * list_files_recursively(LuaCEmbed *args){\n   return aply_listage(args,dtw_list_files_recursively);\n}\n\nLuaCEmbedResponse  * list_dirs_recursively(LuaCEmbed *args){\n    return aply_listage(args,dtw_list_dirs_recursively);\n}\n\nLuaCEmbedResponse  * list_all_recursively(LuaCEmbed *args){\n    return aply_listage(args,dtw_list_all_recursively);\n}\n"
	}, {
		"path":	"src/listage/listage.h",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse  * aply_listage(LuaCEmbed *args,DtwStringArray* (*callback)(const char *folder,bool concat_path));\n\n\nLuaCEmbedResponse  * list_files(LuaCEmbed *args);\n\nLuaCEmbedResponse  * list_dirs(LuaCEmbed *args);\n\nLuaCEmbedResponse  * list_all(LuaCEmbed *args);\n\nLuaCEmbedResponse  * list_files_recursively(LuaCEmbed *args);\n\nLuaCEmbedResponse  * list_dirs_recursively(LuaCEmbed *args);\n\nLuaCEmbedResponse  * list_all_recursively(LuaCEmbed *args);\n"
	}, {
		"path":	"src/locker/"
	}, {
		"path":	"src/locker/locker.c",
		"is_binary":	false,
		"content":	"\n\nLuaCEmbedResponse *locker_unlock(LuaCEmbedTable *self,LuaCEmbed *args) {\n    char *filename = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)) {\n        char *error_msg = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error_msg);\n    }\n    DtwLocker *locker = (DtwLocker*)LuaCembedTable_get_long_prop(self,LOCKER_POINTER);\n    DtwLocker_unlock(locker,filename);\n    return LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse *locker_lock(LuaCEmbedTable *self,LuaCEmbed *args) {\n    char *filename = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)) {\n        char *error_msg = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error_msg);\n    }\n    DtwLocker *locker = (DtwLocker*)LuaCembedTable_get_long_prop(self,LOCKER_POINTER);\n    if(DtwLocker_lock(locker,filename)) {\n        return LuaCEmbed_send_bool(false);\n    }\n    return LuaCEmbed_send_bool(true);\n}\n\n\nLuaCEmbedResponse *locker_delete(LuaCEmbedTable *self,LuaCEmbed *args) {\n    DtwLocker *locker = (DtwLocker*)LuaCembedTable_get_long_prop(self,LOCKER_POINTER);\n    DtwLocker_free(locker);\n    return  NULL;\n}\n\nLuaCEmbedResponse *create_locker(LuaCEmbed *args) {\n    DtwLocker *locker = newDtwLocker();\n    LuaCEmbedTable *self = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_set_long_prop(self,LOCKER_POINTER,(long long)locker);\n    LuaCEmbedTable_set_method(self,DELETE_METHOD,locker_delete);\n    LuaCEmbedTable_set_method(self,LOCKER_LOCK_METHOD,locker_lock);\n    LuaCEmbedTable_set_method(self,UNLOCK_METHOD,locker_unlock);\n    return LuaCEmbed_send_table(self);\n}"
	}, {
		"path":	"src/locker/locker.h",
		"is_binary":	false,
		"content":	"\n\n\nLuaCEmbedResponse *locker_unlock(LuaCEmbedTable *self,LuaCEmbed *args);\n\n\nLuaCEmbedResponse *locker_lock(LuaCEmbedTable *self,LuaCEmbed *args);\n\n\nLuaCEmbedResponse *locker_delete(LuaCEmbedTable *self,LuaCEmbed *args);\n\n\nLuaCEmbedResponse *create_locker(LuaCEmbed *args);"
	}, {
		"path":	"src/macros/"
	}, {
		"path":	"src/macros/all.h",
		"is_binary":	false,
		"content":	"#include  \"try_protections.h\"\n\n\n"
	}, {
		"path":	"src/macros/try_protections.h",
		"is_binary":	false,
		"content":	"\n\n#define writeble_protect(writeble,args)if(writeble->error){\\\n        LuaCEmbedTable *multi_response = LuaCembed_new_anonymous_table(args);\\\n        LuaCEmbedTable_append_bool(multi_response,false);\\\n        LuaCEmbedResponse *response =  write_obj->error;\\\n        LuaCEmbedTable_append_string(multi_response,response->string_val);\\\n        Writeble_free(write_obj);\\\n        private_LuaCEmbedResponse_free(write_obj->error);\\\n        return  LuaCEmbed_send_multi_return(multi_response);\\\n}\n\n#define resource_protect(resource,args)if(DtwResource_error(resource)){\\\n        LuaCEmbedTable *multi_response = LuaCembed_new_anonymous_table(args);\\\nchar *error_mensage = DtwResource_get_error_message(resource);\\\nLuaCEmbedTable_append_bool(multi_response,false);\\\nLuaCEmbedTable_append_string(multi_response,error_mensage);\\\nDtwResource_clear_errors(resource);\\\nreturn  LuaCEmbed_send_multi_return(multi_response);\\\n    }\n\n#define args_protect(args) if(LuaCEmbed_has_errors(args)){\\\n        char *error_message = LuaCEmbed_get_error_message(args);\\\n        LuaCEmbedTable *multi_response = LuaCembed_new_anonymous_table(args);\\\n        LuaCEmbedTable_append_bool(multi_response,false);\\\n        LuaCEmbedTable_append_string(multi_response,error_message);\\\n        LuaCEmbed_clear_errors(args);\\\n        return  LuaCEmbed_send_multi_return(multi_response);\\\n}\n"
	}, {
		"path":	"src/one.c",
		"is_binary":	false,
		"content":	"\n#include <inttypes.h>\n\n#include \"dependecies.h\"\n\n#include \"declaration.h\"\n#include \"definition.h\"\n\n\nvoid start_lua_props(LuaCEmbed *l){\n    LuaCEmbed_add_callback(l,LOAD_FILE,load_file);\n    LuaCEmbed_add_callback(l,WRITE_FILE,write_file);\n    LuaCEmbed_add_callback(l,COPY_ANY_OVERWRITING,copy_any_overwriting);\n    LuaCEmbed_add_callback(l,COPY_ANY_MERGING,copy_any_merging);\n    LuaCEmbed_add_callback(l,MOVE_ANY_OVERWRITING,move_any_overwriting);\n    LuaCEmbed_add_callback(l,MOVE_ANY_MERGING,move_any_merging);\n    LuaCEmbed_add_callback(l,REMOVE_ANY,remove_any);\n    LuaCEmbed_add_callback(l,LIST_FILES,list_files);\n    LuaCEmbed_add_callback(l,LIST_FILES_RECURSIVELY,list_files_recursively);\n    LuaCEmbed_add_callback(l,LIST_DIRS,list_dirs);\n    LuaCEmbed_add_callback(l,LIST_DIRS_RECURSIVELY,list_dirs_recursively);\n    LuaCEmbed_add_callback(l,LIST_ALL,list_all);\n    LuaCEmbed_add_callback(l,LIST_ALL_RECURSIVELY,list_all_recursively);\n    LuaCEmbed_add_callback(l,BBASE_64_ENCODE_FILE,base64_encode_file);\n    LuaCEmbed_add_callback(l,BBASE_64_ENCODE,base64_encode);\n    LuaCEmbed_add_callback(l,BBASE_64_DECODE,base64_decode);\n    LuaCEmbed_add_callback(l,GENERATE_SHA,generate_sha);\n    LuaCEmbed_add_callback(l,GENERATE_SHA_FROM_FILE,generate_sha_from_file);\n    LuaCEmbed_add_callback(l, NEW_RESOURCE, create_resource);\n    LuaCEmbed_add_callback(l,IS_BLOB_FUNC,is_blob);\n    LuaCEmbed_add_callback(l,IS_DIR_FUNC,is_dir);\n    LuaCEmbed_add_callback(l,IS_FILE_FUNC,is_file);\n    LuaCEmbed_add_callback(l, IS_FILE_BLOB, is_blob_file);\n    LuaCEmbed_add_callback(l,NEW_HASHER,create_hasher);\n    LuaCEmbed_add_callback(l,GENERATE_SHA_FROM_FOLDER_BY_CONTENT,generate_sha_from_folder_by_content);\n    LuaCEmbed_add_callback(l,GENERATE_SHA_FROM_FOLDER_BY_LAST_MODIFICATION,generate_sha_from_folder_by_last_modification);\n    LuaCEmbed_add_callback(l, NEW_TRANSACTION, transaction_new_transaction);\n    LuaCEmbed_add_callback(l,NEW_TRANSACTION_FROM_JSON_STRING,create_transaction_from_json_string);\n    LuaCEmbed_add_callback(l,TRY_NEW_TRANSACTION_FROM_JSON_STRING,try_create_transaction_from_json_string);\n    LuaCEmbed_add_callback(l,NEW_TRANSACTION_FROM_JSON_FILE,create_transaction_from_json_file);\n    LuaCEmbed_add_callback(l,TRY_NEW_TRANSACTION_FROM_JSON_FILE,try_create_transaction_from_json_file);\n    LuaCEmbed_add_callback(l,NEW_PATH,create_path);\n    LuaCEmbed_add_callback(l,NEW_TREE,create_empty_tree);\n    LuaCEmbed_add_callback(l,CONCAT_PATH,concat_path);\n    LuaCEmbed_add_callback(l,NEW_TREE_FROM_HARWARE,create_tree_fro_hardware);\n    LuaCEmbed_add_callback(l,STARTS_WITH,starts_with);\n    LuaCEmbed_add_callback(l,ENDS_WITH,ends_with);\n    LuaCEmbed_add_callback(l,NEW_RANDONIZER,create_randonizer);\n    LuaCEmbed_add_callback(l,NEW_FORK,create_fork_process);\n    LuaCEmbed_add_callback(l,NEW_LOCKER,create_locker);\n    LuaCEmbed_add_callback(l,GET_ENTITY_LAST_MODIFICATION,lua_get_entity_last_modification);\n    LuaCEmbed_add_callback(l,GET_ENTITY_LAST_MODIFICATION_IN_UNIX,lua_get_entity_last_modification_in_unix);\n}\n\nint load_luaDoTheWorld(lua_State *state){\n\n    LuaCEmbed * l  = newLuaCEmbedLib(state);\n    start_lua_props(l);\n\n    return LuaCembed_perform(l);\n}\n\n"
	}, {
		"path":	"src/path/"
	}, {
		"path":	"src/path/path.c",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse *path_changed(LuaCEmbedTable *self,LuaCEmbed *args){\n    DtwPath *self_path = (DtwPath*)LuaCembedTable_get_long_prop(self,PATH_POINTER);\n    return LuaCEmbed_send_bool(DtwPath_changed(self_path));\n}\nLuaCEmbedResponse *path_unpack(LuaCEmbedTable *self,LuaCEmbed *args){\n    DtwPath *self_path = (DtwPath*)LuaCembedTable_get_long_prop(self,PATH_POINTER);\n    int total_dirs = DtwPath_get_total_dirs(self_path);\n    int size= total_dirs;\n    LuaCEmbedTable *elements =LuaCembed_new_anonymous_table(args);\n    for(int i =0;i <total_dirs;i++){\n        char *current=DtwPath_get_sub_dirs_from_index(self_path,i,i);\n        LuaCEmbedTable_append_string(elements,current);\n    }\n    char *full_name = DtwPath_get_full_name(self_path);\n    if(full_name !=NULL){\n        LuaCEmbedTable_append_string(elements,full_name);\n        size+=1;\n    }\n    LuaCEmbedTable *final_response =LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_append_table(final_response,elements);\n    LuaCEmbedTable_append_long(final_response,size);\n    return LuaCEmbed_send_multi_return(final_response);\n\n\n\n\n    return NULL;\n}\n\nLuaCEmbedResponse *path_add_start_dir(LuaCEmbedTable *self,LuaCEmbed *args){\n    char *start_dir = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error);\n    }\n    DtwPath *self_path = (DtwPath*)LuaCembedTable_get_long_prop(self,PATH_POINTER);\n    DtwPath_add_start_dir(self_path,start_dir);\n    return LuaCEmbed_send_table(self);\n}\n\n\nLuaCEmbedResponse *path_add_end_dir(LuaCEmbedTable *self,LuaCEmbed *args){\n    char *end_dir = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error);\n    }\n    DtwPath *self_path = (DtwPath*)LuaCembedTable_get_long_prop(self,PATH_POINTER);\n    DtwPath_add_end_dir(self_path,end_dir);\n    return LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse *path_get_dir(LuaCEmbedTable *self,LuaCEmbed *args){\n    DtwPath *self_path = (DtwPath*)LuaCembedTable_get_long_prop(self,PATH_POINTER);\n    char *dir = DtwPath_get_dir(self_path);\n    if(dir == NULL){\n        return NULL;\n    }\n    return  LuaCEmbed_send_str_reference(dir);\n\n}\n\nLuaCEmbedResponse *path_get_extension(LuaCEmbedTable *self,LuaCEmbed *args){\n    DtwPath *self_path = (DtwPath*)LuaCembedTable_get_long_prop(self,PATH_POINTER);\n    char *extension = DtwPath_get_extension(self_path);\n    if(extension == NULL){\n        return  NULL;\n    }\n    return  LuaCEmbed_send_str_reference(extension);\n}\n\nLuaCEmbedResponse *path_get_name(LuaCEmbedTable *self,LuaCEmbed *args){\n    DtwPath *self_path = (DtwPath*)LuaCembedTable_get_long_prop(self,PATH_POINTER);\n    char * fullname = DtwPath_get_full_name(self_path);\n    if(fullname== NULL){\n        return  NULL;\n    }\n    return  LuaCEmbed_send_str_reference(fullname);\n}\n\nLuaCEmbedResponse *path_get_only_name(LuaCEmbedTable *self,LuaCEmbed *args){\n    DtwPath *self_path = (DtwPath*)LuaCembedTable_get_long_prop(self,PATH_POINTER);\n    char *name = DtwPath_get_name(self_path);\n    if(name == NULL){\n        return NULL;\n    }\n    return  LuaCEmbed_send_str_reference(name);\n}\n\nLuaCEmbedResponse *path_get_full_path(LuaCEmbedTable *self,LuaCEmbed *args){\n    DtwPath *self_path = (DtwPath*)LuaCembedTable_get_long_prop(self,PATH_POINTER);\n    return  LuaCEmbed_send_str_reference(DtwPath_get_path(self_path));\n}\n\nLuaCEmbedResponse *path_to_string(LuaCEmbedTable *self,LuaCEmbed *args){\n    DtwPath *self_path = (DtwPath*)LuaCembedTable_get_long_prop(self,PATH_POINTER);\n    return  LuaCEmbed_send_str_reference(DtwPath_get_path(self_path));\n}\n\nLuaCEmbedResponse *path_set_name(LuaCEmbedTable *self,LuaCEmbed *args){\n    char *new_full_name = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error);\n    }\n    DtwPath *self_path = (DtwPath*)LuaCembedTable_get_long_prop(self,PATH_POINTER);\n\n    DtwPath_set_full_name(self_path,new_full_name);\n    return LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse *path_set_only_name(LuaCEmbedTable *self,LuaCEmbed *args){\n    char *new_name = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error);\n    }\n    DtwPath *self_path = (DtwPath*)LuaCembedTable_get_long_prop(self,PATH_POINTER);\n\n    DtwPath_set_name(self_path,new_name);\n    return LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse *path_set_extension(LuaCEmbedTable *self,LuaCEmbed *args){\n    char *new_extension = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error);\n    }\n    DtwPath *self_path = (DtwPath*)LuaCembedTable_get_long_prop(self,PATH_POINTER);\n\n    DtwPath_set_extension(self_path,new_extension);\n    return LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse *path_set_dir(LuaCEmbedTable *self,LuaCEmbed *args){\n    char *new_dir = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error);\n    }\n    DtwPath *self_path = (DtwPath*)LuaCembedTable_get_long_prop(self,PATH_POINTER);\n\n    DtwPath_set_dir(self_path,new_dir);\n    return LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse *path_set_path(LuaCEmbedTable *self,LuaCEmbed *args){\n    char *new_path = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error);\n    }\n    DtwPath *self_path = (DtwPath*)LuaCembedTable_get_long_prop(self,PATH_POINTER);\n\n    DtwPath_set_path(self_path,new_path);\n    return LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse *path_replace_dirs(LuaCEmbedTable *self,LuaCEmbed *args){\n    char *old_dir = LuaCEmbed_get_str_arg(args,0);\n    char *new_dir = LuaCEmbed_get_str_arg(args,1);\n    if(LuaCEmbed_has_errors(args)){\n        char *error = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error);\n    }\n    DtwPath *self_path = (DtwPath*)LuaCembedTable_get_long_prop(self,PATH_POINTER);\n\n    DtwPath_replace_dirs(self_path,old_dir,new_dir);\n    return LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse *path_get_total_dirs(LuaCEmbedTable *self,LuaCEmbed *args){\n    DtwPath *self_path = (DtwPath*)LuaCembedTable_get_long_prop(self,PATH_POINTER);\n    return  LuaCEmbed_send_long(DtwPath_get_total_dirs(self_path));\n}\n\nLuaCEmbedResponse *path_get_sub_dirs_from_index(LuaCEmbedTable *self,LuaCEmbed *args){\n    long start_index = LuaCEmbed_get_long_arg(args,0);\n    long end_index = LuaCEmbed_get_long_arg(args,1);\n    if(LuaCEmbed_has_errors(args)){\n        char *error = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error);\n    }\n    DtwPath *self_path = (DtwPath*)LuaCembedTable_get_long_prop(self,PATH_POINTER);\n    char *sub_dirs = DtwPath_get_sub_dirs_from_index(self_path,start_index,end_index);\n    if(sub_dirs == NULL){\n        return NULL;\n    }\n    return LuaCEmbed_send_str_reference(sub_dirs);;\n}\n\nLuaCEmbedResponse *path_insert_dir_at_index(LuaCEmbedTable *self,LuaCEmbed *args){\n    long index = LuaCEmbed_get_long_arg(args,0);\n    char *dir = LuaCEmbed_get_str_arg(args,1);\n    if(LuaCEmbed_has_errors(args)){\n        char *error = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error);\n    }\n    DtwPath *self_path = (DtwPath*)LuaCembedTable_get_long_prop(self,PATH_POINTER);\n    DtwPath_insert_dir_at_index(self_path,index,dir);\n    return LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse *path_remove_sub_dir_at_index(LuaCEmbedTable *self,LuaCEmbed *args){\n    long start = LuaCEmbed_get_long_arg(args,0);\n    long end = LuaCEmbed_get_long_arg(args,1);\n    if(LuaCEmbed_has_errors(args)){\n        char *error = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error);\n    }\n    DtwPath *self_path = (DtwPath*)LuaCembedTable_get_long_prop(self,PATH_POINTER);\n    DtwPath_remove_sub_dirs_at_index(self_path,start,end);\n    return LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse *path_insert_dir_after(LuaCEmbedTable *self,LuaCEmbed *args){\n    char *after_dir  = LuaCEmbed_get_str_arg(args,0);\n    char *dir = LuaCEmbed_get_str_arg(args,1);\n\n    if(LuaCEmbed_has_errors(args)){\n        char *error = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error);\n    }\n    DtwPath *self_path = (DtwPath*)LuaCembedTable_get_long_prop(self,PATH_POINTER);\n    DtwPath_insert_dir_after(self_path,after_dir,dir);\n    return LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse *path_insert_dir_before(LuaCEmbedTable *self,LuaCEmbed *args){\n    char *before_dir  = LuaCEmbed_get_str_arg(args,0);\n    char *dir = LuaCEmbed_get_str_arg(args,1);\n\n    if(LuaCEmbed_has_errors(args)){\n        char *error = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error);\n    }\n    DtwPath *self_path = (DtwPath*)LuaCembedTable_get_long_prop(self,PATH_POINTER);\n    DtwPath_insert_dir_before(self_path,before_dir,dir);\n    return LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse *path_remove_sub_dirs_at(LuaCEmbedTable *self,LuaCEmbed *args){\n    char *dirs_to_remove  = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error);\n    }\n    DtwPath *self_path = (DtwPath*)LuaCembedTable_get_long_prop(self,PATH_POINTER);\n    DtwPath_remove_sub_dirs_at(self_path,dirs_to_remove);\n    return LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse *path_delete(LuaCEmbedTable *self,LuaCEmbed *args){\n\n    bool its_a_ref = LuaCembedTable_get_bool_prop(self,IS_A_REF);\n    if(!its_a_ref){\n        DtwPath *self_path = (DtwPath*)LuaCembedTable_get_long_prop(self,PATH_POINTER);\n        DtwPath_free(self_path);\n    }\n\n    return NULL;\n}\n\nLuaCEmbedTable *raw_create_path(LuaCEmbed *args,DtwPath *path){\n    LuaCEmbedTable *self = LuaCembed_new_anonymous_table(args);\n\n    LuaCEmbedTable_set_long_prop(self,PATH_POINTER,(long long )path);\n    LuaCEmbedTable_set_method(self,PATH_ADD_END_DIR_METHOD,path_add_end_dir);\n    LuaCEmbedTable_set_method(self,PATH_CHANGED_METHOD,path_changed);\n    LuaCEmbedTable_set_method(self,PATH_ADD_START_DIR_METHOD,path_add_start_dir);\n    LuaCEmbedTable_set_method(self,GET_DIR_METHOD,path_get_dir);\n    LuaCEmbedTable_set_method(self,GET_EXTENSION_METHOD,path_get_extension);\n    LuaCEmbedTable_set_method(self,GET_NAME_METHOD,path_get_name);\n    LuaCEmbedTable_set_method(self,GET_ONLY_NAME_METHOD,path_get_only_name);\n    LuaCEmbedTable_set_method(self,TO_STRING_METHOD,path_to_string);\n    LuaCEmbedTable_set_method(self,PATH_GET_FULL_PATH_METHOD,path_get_full_path);\n    LuaCEmbedTable_set_method(self,SET_EXTENSION_METHOD,path_set_extension);\n    LuaCEmbedTable_set_method(self,PATH_SET_ONLY_NAME_METHOD,path_set_only_name);\n    LuaCEmbedTable_set_method(self,PATH_SET_NAME_METHOD,path_set_name);\n    LuaCEmbedTable_set_method(self,PATH_SET_DIR_METHOD,path_set_dir);\n    LuaCEmbedTable_set_method(self,PATH_SET_PATH_METHOD,path_set_path);\n\n    LuaCEmbedTable_set_method(self,PATH_REPLACE_DIRS_METHOD,path_replace_dirs);\n    LuaCEmbedTable_set_method(self,PATH_GET_TOTAL_DIRS_METHOD,path_get_total_dirs);\n    LuaCEmbedTable_set_method(self,PATH_GET_SUB_DIRS_FROM_INDEX_METHOD,path_get_sub_dirs_from_index);\n    LuaCEmbedTable_set_method(self,PATH_INSERT_DIR_AT_INDEX_METHOD,path_insert_dir_at_index);\n    LuaCEmbedTable_set_method(self,PATH_REMOVE_SUB_DIR_AT_INDEX_METHOD,path_remove_sub_dir_at_index);\n    LuaCEmbedTable_set_method(self,PATH_INSERT_DIR_AFTER_METHOD,path_insert_dir_after);\n    LuaCEmbedTable_set_method(self,PATH_INSERT_DIR_BEFORE_METHOD,path_insert_dir_before);\n    LuaCEmbedTable_set_method(self,PATH_REMOVE_SUB_DIRS_AT_METHOD,path_remove_sub_dirs_at);\n    LuaCEmbedTable_set_method(self,PATH_UNPACK,path_unpack);\n    LuaCEmbedTable_set_method(self,DELETE_METHOD,path_delete);\n\n    return self;\n}\n\nLuaCEmbedTable *create_path_reference(LuaCEmbed *args,DtwPath *path){\n    LuaCEmbedTable *self =  raw_create_path(args,path);\n    LuaCEmbedTable_set_bool_prop(self,IS_A_REF,true);\n    return self;\n}\n\n\nLuaCEmbedResponse *create_path(LuaCEmbed *args){\n    char *content = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error);\n    }\n    DtwPath *path = newDtwPath(content);\n    LuaCEmbedTable *self =  raw_create_path(args,path);\n    LuaCEmbedTable_set_bool_prop(self,IS_A_REF,false);\n    return LuaCEmbed_send_table(self);\n}\n\n"
	}, {
		"path":	"src/path/path.h",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse *path_changed(LuaCEmbedTable *self,LuaCEmbed *args);\n\n\nLuaCEmbedResponse *path_add_start_dir(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse *path_add_end_dir(LuaCEmbedTable *self,LuaCEmbed *args);\n\n\nLuaCEmbedResponse *path_get_dir(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse *path_get_extension(LuaCEmbedTable *self,LuaCEmbed *args);\n\n\nLuaCEmbedResponse *path_get_name(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse *path_get_only_name(LuaCEmbedTable *self,LuaCEmbed *args);\n\n\nLuaCEmbedResponse *path_get_full_path(LuaCEmbedTable *self,LuaCEmbed *args);\n\n\nLuaCEmbedResponse *path_to_string(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse *path_set_name(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse *path_set_only_name(LuaCEmbedTable *self,LuaCEmbed *args);\n\n\nLuaCEmbedResponse *path_set_extension(LuaCEmbedTable *self,LuaCEmbed *args);\n\n\nLuaCEmbedResponse *path_set_dir(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse *path_set_path(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse *path_replace_dirs(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse *path_get_total_dirs(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse *path_get_sub_dirs_from_index(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse *path_insert_dir_at_index(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse *path_remove_sub_dir_at_index(LuaCEmbedTable *self,LuaCEmbed *args);\n\n\nLuaCEmbedResponse *path_insert_dir_after(LuaCEmbedTable *self,LuaCEmbed *args);\n\n\nLuaCEmbedResponse *path_insert_dir_before(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse *path_remove_sub_dirs_at(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse *path_unpack(LuaCEmbedTable *self,LuaCEmbed *args);\n\n\nLuaCEmbedResponse *path_delete(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedTable *raw_create_path(LuaCEmbed *args,DtwPath *path);\n\n\nLuaCEmbedTable *create_path_reference(LuaCEmbed *args,DtwPath *path);\n\n\nLuaCEmbedResponse *create_path(LuaCEmbed *args);\n\n"
	}, {
		"path":	"src/randonizer/"
	}, {
		"path":	"src/randonizer/randonizer.c",
		"is_binary":	false,
		"content":	"LuaCEmbedResponse *set_randonizer_seed_seed(LuaCEmbedTable *self,LuaCEmbed *args) {\n\n    DtwRandonizer *random = (DtwRandonizer*)LuaCembedTable_get_long_prop(self,RANDONIZER_POINTER);\n    long seed = LuaCEmbed_get_long_arg(args,0);\n    if(LuaCEmbed_has_errors(args)) {\n        char *msg = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(msg);\n    }\n    random->seed = seed;\n    return LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse *set_randonizer_internal_seed(LuaCEmbedTable *self,LuaCEmbed *args) {\n\n    DtwRandonizer *random = (DtwRandonizer*)LuaCembedTable_get_long_prop(self,RANDONIZER_POINTER);\n    long seed = LuaCEmbed_get_long_arg(args,0);\n    if(LuaCEmbed_has_errors(args)) {\n        char *msg = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(msg);\n    }\n    random->internal_seed = seed;\n    return LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse *generate_randonizer_token(LuaCEmbedTable *self,LuaCEmbed *args) {\n    DtwRandonizer *random = (DtwRandonizer*)LuaCembedTable_get_long_prop(self,RANDONIZER_POINTER);\n    long size = LuaCEmbed_get_long_arg(args,0);\n    if(LuaCEmbed_has_errors(args)) {\n        char *msg = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(msg);\n    }\n    char *token = DtwRandonizer_generate_token(random,size);\n    LuaCEmbedResponse *response = LuaCEmbed_send_str(token);\n    free(token);\n    return response;\n}\nLuaCEmbedResponse *generate_randonizer_num(LuaCEmbedTable *self,LuaCEmbed *args) {\n    DtwRandonizer *random = (DtwRandonizer*)LuaCembedTable_get_long_prop(self,RANDONIZER_POINTER);\n    long max = LuaCEmbed_get_long_arg(args,0);\n    if(LuaCEmbed_has_errors(args)) {\n        char *msg = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(msg);\n    }\n    long num  = DtwRandonizer_generate_num(random,max);\n    return LuaCEmbed_send_long(num);\n\n}\nLuaCEmbedResponse *delete_randonizer(LuaCEmbedTable *self,LuaCEmbed *args) {\n    DtwRandonizer *random = (DtwRandonizer*)LuaCembedTable_get_long_prop(self,RANDONIZER_POINTER);\n    DtwRandonizer_free(random);\n    return NULL;\n}\nLuaCEmbedResponse *create_randonizer(LuaCEmbed *args) {\n    DtwRandonizer *random = newDtwRandonizer();\n    LuaCEmbedTable *self =  LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_set_long_prop(self,RANDONIZER_POINTER,(long long)random);\n    LuaCEmbedTable_set_method(self,SET_RANDONIZER_SEED_METHOD,set_randonizer_seed_seed);\n    LuaCEmbedTable_set_method(self,SET_RANDONIZER_INTERNAL_SEED_METHOD,set_randonizer_internal_seed);\n    LuaCEmbedTable_set_method(self,GENERATE_RANDONIZER_TOKEN,generate_randonizer_token);\n    LuaCEmbedTable_set_method(self,DELETE_METHOD,delete_randonizer);\n    LuaCEmbedTable_set_method(self,GENERATE_RANDONIZER_NUM_METHOD,generate_randonizer_num);\n    return LuaCEmbed_send_table(self);\n}"
	}, {
		"path":	"src/randonizer/randonizer.h",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse *set_randonizer_time_seed(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse *set_randonizer_seed_seed(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse *generate_randonizer_token(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse *generate_randonizer_num(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse *delete_randonizer(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse *create_randonizer(LuaCEmbed *args);"
	}, {
		"path":	"src/resource/"
	}, {
		"path":	"src/resource/database_schema/"
	}, {
		"path":	"src/resource/database_schema/database_schema.c",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse * database_schema_set_index_name(LuaCEmbedTable *self,LuaCEmbed *args) {\n    char *index_name =  LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)) {\n        char *error_msg = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error_msg);\n    }\n    DtwDatabaseSchema *root_sschema = (DtwDatabaseSchema*)LuaCembedTable_get_long_prop(self,DATABASE_SCHEMA_POINTER);\n    root_sschema->index_name =index_name;\n    return LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse * database_schema_set_value_name(LuaCEmbedTable *self,LuaCEmbed *args) {\n    char *value_name =  LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)) {\n        char *error_msg = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error_msg);\n    }\n    DtwDatabaseSchema *root_sschema = (DtwDatabaseSchema*)LuaCembedTable_get_long_prop(self,DATABASE_SCHEMA_POINTER);\n    root_sschema->value_name =value_name;\n    return LuaCEmbed_send_table(self);\n}\n\n\nLuaCEmbedResponse * database_schema_add_sub_schema(LuaCEmbedTable *self,LuaCEmbed *args) {\n    char *name = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *message = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(message);\n    }\n\n    DtwDatabaseSchema *root_sschema = (DtwDatabaseSchema*)LuaCembedTable_get_long_prop(self,DATABASE_SCHEMA_POINTER);\n    DtwSchema *sub_schmea = DtwDtatabaseSchema_new_subSchema(root_sschema,name);\n    LuaCEmbedTable *created_table = raw_create_schema(args,sub_schmea);\n    return LuaCEmbed_send_table(created_table);\n}\n\nLuaCEmbedTable * raw_create_database_schema(LuaCEmbed *args,DtwDatabaseSchema *database_schema) {\n    LuaCEmbedTable *self = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_set_long_prop(self,DATABASE_SCHEMA_POINTER,(long long)database_schema);\n    LuaCEmbedTable_set_method(self,SUB_SCHEMA_METHOD,database_schema_add_sub_schema);\n    LuaCEmbedTable_set_method(self,SET_INDEX_NAME_METHOD,database_schema_set_index_name);\n    LuaCEmbedTable_set_method(self,SET_VALUE_NAME_METHOD,database_schema_set_value_name);\n    return self;\n}"
	}, {
		"path":	"src/resource/database_schema/database_schema.h",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse * database_schema_set_index_name(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * database_schema_set_value_name(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * database_schema_add_sub_schema(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedTable * raw_create_database_schema(LuaCEmbed *args,DtwDatabaseSchema *database_schema);"
	}, {
		"path":	"src/resource/declaration.h",
		"is_binary":	false,
		"content":	"#include \"database_schema/database_schema.h\"\n#include \"schemas/schemas.h\"\n#include \"resource/declaration.h\"\n"
	}, {
		"path":	"src/resource/definition.h",
		"is_binary":	false,
		"content":	"#include \"database_schema/database_schema.c\"\n#include \"schemas/schemas.c\"\n#include \"resource/definition.h\"\n"
	}, {
		"path":	"src/resource/resource/"
	}, {
		"path":	"src/resource/resource/declaration.h",
		"is_binary":	false,
		"content":	"#include \"getters/getters.h\"\n#include \"schema/schema.h\"\n#include \"resource/resource.h\"\n#include \"sub_resource/sub_resource.h\"\n#include \"resource_iterable/resource_iterable.h\"\n#include \"schema_iterable/schema_iterable.h\""
	}, {
		"path":	"src/resource/resource/definition.h",
		"is_binary":	false,
		"content":	"#include \"getters/getters.c\"\n\n#include \"schema/schema.c\"\n#include \"resource/resource.c\"\n#include \"sub_resource/sub_resource.c\"\n#include \"resource_iterable/resource_iterable.c\"\n#include \"schema_iterable/schema_iterable.c\""
	}, {
		"path":	"src/resource/resource/getters/"
	}, {
		"path":	"src/resource/resource/getters/getters.c",
		"is_binary":	false,
		"content":	"LuaCEmbedResponse * resource_to_string(LuaCEmbedTable  *self,LuaCEmbed *args){\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    int  type = DtwResource_type(resource);\n    if(type == DTW_NOT_FOUND || type == DTW_FOLDER_TYPE ){\n        return  LuaCEmbed_send_str(resource->path);\n    }\n    long size;\n    bool is_binary;\n    unsigned  char *content =  DtwResource_get_any(resource,&size,&is_binary);\n    return LuaCEmbed_send_raw_string_reference((char*)content,size);\n\n}\n\n\nLuaCEmbedResponse * resource_to_number(LuaCEmbedTable  *self,LuaCEmbed *args){\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    double value = DtwResource_get_double(resource);\n    if(DtwResource_error(resource)){\n        char *error_message = DtwResource_get_error_message(resource);\n        LuaCEmbedResponse *response = LuaCEmbed_send_error(error_message);\n        DtwResource_clear_errors(resource);\n        return response;\n    }\n    return LuaCEmbed_send_double(value);\n}\n\nLuaCEmbedResponse * resource_value(LuaCEmbedTable  *self,LuaCEmbed *args){\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    int type = DtwResource_type(resource);\n\n    if(type == DTW_FOLDER_TYPE || type == DTW_NOT_FOUND){\n        return NULL;\n    }\n\n    if(type == DTW_COMPLEX_DOUBLE_TYPE || type == DTW_COMPLEX_LONG_TYPE){\n        double value = DtwResource_get_double(resource);\n        return LuaCEmbed_send_double(value);\n    }\n\n    if(type == DTW_COMPLEX_BOOL_TYPE){\n        bool value= DtwResource_get_bool(resource);\n        return LuaCEmbed_send_bool(value);\n    }\n\n    if(type == DTW_COMPLEX_BINARY || type == DTW_COMPLEX_STRING_TYPE){\n\n        long size;\n        bool is_binary;\n        unsigned  char *content =  DtwResource_get_any(resource,&size,&is_binary);\n        return LuaCEmbed_send_raw_string_reference((char*)content,size);\n    }\n\n    return NULL;\n}\nLuaCEmbedResponse * resource_value_string(LuaCEmbedTable  *self,LuaCEmbed *args){\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    int type = DtwResource_type(resource);\n    if(type != DTW_NOT_FOUND && type != DTW_FOLDER_TYPE){\n        long size;\n        bool is_binary;\n        unsigned  char *content =  DtwResource_get_any(resource,&size,&is_binary);\n        return LuaCEmbed_send_raw_string_reference((char*)content,size);\n    }\n    return NULL;\n}\n\nLuaCEmbedResponse * resource_value_number(LuaCEmbedTable  *self,LuaCEmbed *args){\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    int type = DtwResource_type(resource);\n\n    if(type == DTW_COMPLEX_DOUBLE_TYPE || type == DTW_COMPLEX_LONG_TYPE){\n        double value = DtwResource_get_double(resource);\n        return LuaCEmbed_send_double(value);\n    }\n\n    return NULL;\n}\n\nLuaCEmbedResponse * resource_value_bool(LuaCEmbedTable  *self,LuaCEmbed *args){\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    int type = DtwResource_type(resource);\n\n\n    if(type == DTW_COMPLEX_BOOL_TYPE){\n        bool value= DtwResource_get_bool(resource);\n        return LuaCEmbed_send_bool(value);\n    }\n\n\n    return NULL;\n}\n\nLuaCEmbedResponse * resource_value_from_sub_resource(LuaCEmbedTable  *self,LuaCEmbed *args){\n    char *src = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n\n    DtwResource  *master = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResource *sub = DtwResource_sub_resource(master,src);\n\n    int type = DtwResource_type(sub);\n\n    if(type == DTW_FOLDER_TYPE || type == DTW_NOT_FOUND){\n        return NULL;\n    }\n    if(type == DTW_COMPLEX_DOUBLE_TYPE || type == DTW_COMPLEX_LONG_TYPE){\n        double value = DtwResource_get_double(sub);\n        return LuaCEmbed_send_double(value);\n    }\n\n\n    if(type == DTW_COMPLEX_BOOL_TYPE){\n        bool value= DtwResource_get_bool(sub);\n        return LuaCEmbed_send_bool(value);\n    }\n\n    if(type == DTW_COMPLEX_BINARY || type == DTW_COMPLEX_STRING_TYPE ){\n        long size;\n        unsigned  char *content =  DtwResource_get_binary(sub,&size);\n        return LuaCEmbed_send_raw_string_reference((char*)content,size);\n    }\n\n    return NULL;\n}\n\nLuaCEmbedResponse * resource_to_boolean(LuaCEmbedTable  *self,LuaCEmbed *args){\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    bool value = DtwResource_get_bool(resource);\n    if(DtwResource_error(resource)){\n        char *error_message = DtwResource_get_error_message(resource);\n        LuaCEmbedResponse *response = LuaCEmbed_send_error(error_message);\n        DtwResource_clear_errors(resource);\n        return response;\n    }\n    return LuaCEmbed_send_bool(value);\n}"
	}, {
		"path":	"src/resource/resource/getters/getters.h",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse * resource_to_string(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * resource_to_number(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * resource_value(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * resource_value_string(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * resource_value_number(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * resource_value_bool(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * resource_value_from_sub_resource(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * resource_to_boolean(LuaCEmbedTable  *self,LuaCEmbed *args);"
	}, {
		"path":	"src/resource/resource/resource/"
	}, {
		"path":	"src/resource/resource/resource/resource.c",
		"is_binary":	false,
		"content":	"\n#include \"../../../constants/resource_methods.h\"\n#include \"../schema/schema.h\"\n\nLuaCEmbedResponse * free_resource(LuaCEmbedTable  *self, LuaCEmbed *args){\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n\n    DtwResource_free(resource);\n\n\n    return  NULL;\n\n}\n\n\nLuaCEmbedResponse * resource_get_path(LuaCEmbedTable  *self,LuaCEmbed *args){\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    return LuaCEmbed_send_str(resource->path);\n}\n\nLuaCEmbedResponse * resource_rename(LuaCEmbedTable  *self,LuaCEmbed *args){\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    char *new_name = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n\n    DtwResource_rename(resource,new_name);\n    if(DtwResource_error(resource)){\n        char *error_mensage = DtwResource_get_error_message(resource);\n        LuaCEmbedResponse *response = LuaCEmbed_send_error(error_mensage);\n        DtwResource_clear_errors(resource);\n        return  response;\n    }\n    return  LuaCEmbed_send_table(self);\n\n}\nLuaCEmbedResponse * resource_try_rename(LuaCEmbedTable  *self,LuaCEmbed *args) {\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    char *new_name = LuaCEmbed_get_str_arg(args,0);\n    args_protect(args)\n    DtwResource_rename(resource,new_name);\n    resource_protect(resource,args)\n    LuaCEmbedTable *multi_response = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_append_bool(multi_response,true);\n    return LuaCEmbed_send_multi_return(multi_response);\n\n}\nLuaCEmbedResponse * resource_set_value(LuaCEmbedTable  *self,LuaCEmbed *args){\n    Writeble  *write_obj = create_writeble(args,0);\n    if(write_obj->error){\n        LuaCEmbedResponse *response =  write_obj->error;\n        Writeble_free(write_obj);\n        return  response;\n    }\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResource_set_any(resource,write_obj->content, write_obj->size,write_obj->is_binary);\n    Writeble_free(write_obj);\n    if(DtwResource_error(resource)){\n        char *error_mensage = DtwResource_get_error_message(resource);\n        LuaCEmbedResponse *response = LuaCEmbed_send_error(error_mensage);\n        DtwResource_clear_errors(resource);\n        return  response;\n    }\n\n    return  LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse * resource_try_set_value(LuaCEmbedTable  *self,LuaCEmbed *args) {\n    Writeble  *write_obj = create_writeble(args,1);\n    writeble_protect(write_obj,args)\n\n\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResource_set_any(resource,write_obj->content, write_obj->size,write_obj->is_binary);\n    Writeble_free(write_obj);\n    resource_protect(resource,args)\n\n    LuaCEmbedTable * multi_response = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_append_bool(multi_response,true);\n    return LuaCEmbed_send_multi_return(multi_response);\n}\n\nLuaCEmbedResponse * resource_commit(LuaCEmbedTable  *self,LuaCEmbed *args){\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResource_commit(resource);\n    return  LuaCEmbed_send_table(self);\n\n}\n\nLuaCEmbedResponse * resource_destroy(LuaCEmbedTable  *self,LuaCEmbed *args){\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResource_destroy(resource);\n    if(DtwResource_error(resource)){\n        char *error_mensage = DtwResource_get_error_message(resource);\n        LuaCEmbedResponse *response = LuaCEmbed_send_error(error_mensage);\n        DtwResource_clear_errors(resource);\n        return  response;\n    }\n    return  LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse * resource_try_destroy(LuaCEmbedTable  *self,LuaCEmbed *args) {\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResource_destroy(resource);\n    resource_protect(resource,args)\n    LuaCEmbedTable *multi_response =  LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_append_bool(multi_response,true);\n    return LuaCEmbed_send_multi_return(multi_response);\n}\n\nLuaCEmbedResponse * unload_resurce(LuaCEmbedTable  *self, LuaCEmbed *args){\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResource_unload(resource);\n    return  LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse * lock_resource(LuaCEmbedTable  *self, LuaCEmbed *args){\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    if(DtwResource_lock(resource)) {\n        return LuaCEmbed_send_bool(false);\n    }\n    return LuaCEmbed_send_bool(true);\n}\n\nLuaCEmbedResponse * unlock_resource(LuaCEmbedTable  *self, LuaCEmbed *args){\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResource_unlock(resource);\n    return  LuaCEmbed_send_table(self);\n}\n\n\nLuaCEmbedResponse * resource_set_value_in_sub_resource(LuaCEmbedTable  *self,LuaCEmbed *args){\n\n    char *folder = LuaCEmbed_get_str_arg(args,0);\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n    Writeble  *write_obj = create_writeble(args,1);\n    if(write_obj->error){\n        LuaCEmbedResponse *response =  write_obj->error;\n        Writeble_free(write_obj);\n        return  response;\n    }\n    DtwResource *values = DtwResource_sub_resource(resource,folder);\n    DtwResource_set_any(values,write_obj->content,write_obj->size,write_obj->is_binary);\n    Writeble_free(write_obj);\n    if(DtwResource_error(resource)){\n        char *error_mensage = DtwResource_get_error_message(resource);\n        LuaCEmbedResponse *response = LuaCEmbed_send_error(error_mensage);\n        DtwResource_clear_errors(resource);\n        return  response;\n    }\n\n    return LuaCEmbed_send_table(self);\n\n}\nLuaCEmbedResponse * resource_try_set_value_in_sub_resource(LuaCEmbedTable  *self,LuaCEmbed *args) {\n    char *folder = LuaCEmbed_get_str_arg(args,0);\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    args_protect(args)\n    Writeble  *write_obj = create_writeble(args,1);\n    writeble_protect(write_obj,args)\n\n    DtwResource *values = DtwResource_sub_resource(resource,folder);\n    DtwResource_set_binary(values,write_obj->content,write_obj->size);\n    Writeble_free(write_obj);\n    LuaCEmbedTable *multi_response =  LuaCembed_new_anonymous_table(args);\n    resource_protect(resource,args)\n    return LuaCEmbed_send_multi_return(multi_response);\n}\n\nLuaCEmbedResponse * resource_is_blob(LuaCEmbedTable  *self,LuaCEmbed *args){\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResource_load(resource);\n    return LuaCEmbed_send_bool(resource->is_binary);\n}\n\n\nLuaCEmbedResponse * resource_get_type(LuaCEmbedTable  *self,LuaCEmbed *args) {\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    const char *type = DtwResource_type_in_str(resource);\n\n    return LuaCEmbed_send_str(type);\n}\n\n\n\nLuaCEmbedTable *raw_create_resource(LuaCEmbed *args,DtwResource *resource){\n\n    LuaCEmbedTable * self  = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_set_long_prop(self,DTW_TYPE,DTW_RESOURCE_TYPE);\n\n\n    LuaCEmbedTable_set_long_prop(self,RESOURCE_POINTER,(long long )resource);\n    LuaCEmbedTable_set_method(self,TO_STRING_METHOD,resource_to_string);\n    LuaCEmbedTable_set_method(self,TO_NUMBER_METHOD,resource_to_number);\n    LuaCEmbedTable_set_method(self,TO_BOOLEAN_METHOD,resource_to_boolean);\n    LuaCEmbedTable_set_method(self,GET_VALUE_METHOD,resource_value);\n    LuaCEmbedTable_set_method(self, INDEX_METHOD, resource_sub_resource_index);\n    LuaCEmbedTable_set_method(self, SUB_RESOURCE_METHOD, resource_sub_resource_method);\n    LuaCEmbedTable_set_method(self,RESOURCE_RENAME_METHOD,resource_rename);\n\n    LuaCEmbedTable_set_method(self,RESOURCE_GET_TYPE,resource_get_type);\n    LuaCEmbedTable_set_method(self,LIST_METHOD,resource_list);\n    LuaCEmbedTable_set_method(self,EACH_METHOD,resource_foreach);\n    LuaCEmbedTable_set_method(self,MAP_METHOD,resource_map);\n    LuaCEmbedTable_set_method(self,COUNT_METHOD,resource_count);\n    LuaCEmbedTable_set_method(self,FIND_METHOD,resource_find);\n    LuaCEmbedTable_set_method(self,FILTER_METHOD,resource_filter);\n\n    LuaCEmbedTable_set_method(self,RESOURCE_GET_STRING,resource_value_string);\n    LuaCEmbedTable_set_method(self,RESOURCE_GET_NUMBER,resource_value_number);\n    LuaCEmbedTable_set_method(self,RESOURCE_GET_BOOL,resource_value_bool);\n\n    LuaCEmbedTable_set_method(self, SUB_RESOURCE_NEXT_METHOD, resource_sub_resource_next);\n    LuaCEmbedTable_set_method(self, SUB_RESOURCE_NOW_METHOD, resource_sub_resource_now);\n    LuaCEmbedTable_set_method(self, SUB_RESOURCE_NOW_IN_UNIX, resource_sub_resource_now_in_unix);\n    LuaCEmbedTable_set_method(self,SUB_RESOURCE_RANDOM,resource_sub_resource_random);\n    LuaCEmbedTable_set_method(self,LOCK_METHOD,lock_resource);\n    LuaCEmbedTable_set_method(self,UNLOCK_METHOD,unlock_resource);\n    LuaCEmbedTable_set_method(self,UNLOAD_METHOD,unload_resurce);\n    LuaCEmbedTable_set_method(self,IS_BLOB_FUNC,resource_is_blob);\n\n    LuaCEmbedTable_set_method(self,SET_VALUE_METHOD,resource_set_value);\n    LuaCEmbedTable_set_method(self,COMMIT_METHOD,resource_commit);\n    LuaCEmbedTable_set_method(self,DESTROY_METHOD,resource_destroy);\n\n    LuaCEmbedTable_set_method(self, GET_PATH_STRING_METHOD, resource_get_path);\n\n    LuaCEmbedTable_set_method(self, SET_VALUE_IN_SUB_RESOURCE_METHOD, resource_set_value_in_sub_resource);\n    LuaCEmbedTable_set_method(self,GET_VALUE_FROM_SUB_RESOURCE_METHOD,resource_value_from_sub_resource);\n\n    LuaCEmbedTable_set_method(self,DANGEROUS_REMOVE_PROP_METHOD,dangerous_remove_schema_prop);\n    LuaCEmbedTable_set_method(self,DANGEROUS_RENAME_PROP_METHOD,dangerous_rename_schema_prop);\n    LuaCEmbedTable_set_method(self, GET_RESOURCE_MATCHING_PRIMARY_KEY_METHOD, get_resource_match_schema_by_primary_key);\n    LuaCEmbedTable_set_method(self,GET_RESOURCE_BY_NAME_ID,get_resource_by_name_id);\n\n    LuaCEmbedTable_set_method(self,RESOURCE_NEW_DATABASE_SCHEMA,resource_new_schema);\n    LuaCEmbedTable_set_method(self,SCHEMA_LIST_RESOURCE_METHOD,schema_list_resources);\n    LuaCEmbedTable_set_method(self, SCHEMA_FIND_RESOURCE_METHOD, schema_find_resource);\n    LuaCEmbedTable_set_method(self,SCHEMA_MAP_RESOURCE_METHOD,schema_map_resource);\n    LuaCEmbedTable_set_method(self,SCHEMA_COUNT_RESOURCE_METHOD,schema_count_resource);\n    LuaCEmbedTable_set_method(self, SCHEMA_EACH_METHOD, resource_schema_each);\n    LuaCEmbedTable_set_method(self,SCHEMA_FILTER_METHOD,schema_filter_resource);\n\n    LuaCEmbedTable_set_method(self, SCHEMA_NEW_INSERTION, Resource_new_insertion);\n\n    LuaCEmbedTable_set_method(self, RESOURCE_TRY_SET_VALUE_METHOD, resource_try_set_value);\n    LuaCEmbedTable_set_method(self,RESOURCE_TRY_RENAME_METHOD,resource_try_rename);\n    LuaCEmbedTable_set_method(self,RESOURCE_TRY_DESTROY,resource_try_destroy);\n    LuaCEmbedTable_set_method(self,RESOURCE_TRY_NEW_SCHEMA,resource_try_new_schema);\n    LuaCEmbedTable_set_method(self,RESOURCE_TRY_SET_VALUE_IN_SUB_RESOURCE_METHOD,resource_try_set_value_in_sub_resource);\n    LuaCEmbedTable_set_method(self,RESOURCE_TRY_NEW_INSERTION_METHOD,Resource_try_new_insertion);\n    LuaCEmbedTable_set_method(self,TRY_GET_RESOURCE_MATCHING_PRIMARY_KEY_METHOD,try_get_resource_match_schema_by_primary_key);\n    LuaCEmbedTable_set_method(self,TRY_GET_RESOURCE_BY_NAME_ID,try_get_resource_by_name_id);\n    LuaCEmbedTable_set_method(self,TRY_DANGEROUS_RENAME_PROP_METHOD,try_dangerous_rename_schema_prop);\n    LuaCEmbedTable_set_method(self,TRY_DANGEROUS_REMOVE_PROP_METHOD,try_dangerous_remove_schema_prop);\n    LuaCEmbedTable_set_method(self,TRY_SUB_RESOURCE_METHOD,try_resource_sub_resource_method);\n    LuaCEmbedTable_set_method(self,TRY_SUB_RESOURCE_NEXT_METHOD,try_resource_sub_resource_next);\n    LuaCEmbedTable_set_method(self,TRY_SUB_RESOURCE_NOW_METHOD,try_resource_sub_resource_now);\n    LuaCEmbedTable_set_method(self,TRY_SUB_RESOURCE_NOW_IN_UNIX,try_resource_sub_resource_now_in_unix);\n    LuaCEmbedTable_set_method(self,TRY_SUB_RESOURCE_RANDON,try_resource_sub_resource_random);\n    LuaCEmbedTable_set_method(self,TRY_SCHEMA_LIST,try_schema_list_resources);\n\n    if(resource->mother ==NULL){\n        LuaCEmbedTable_set_method(self, DELETE_METHOD, free_resource);\n    }\n\n    return self;\n}\n\n\n\nLuaCEmbedResponse * create_resource(LuaCEmbed *args){\n    char *folder = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n    DtwResource *resource = new_DtwResource(folder);\n\n    LuaCEmbedTable  *self = raw_create_resource(args,resource);\n    return LuaCEmbed_send_table(self);\n\n}"
	}, {
		"path":	"src/resource/resource/resource/resource.h",
		"is_binary":	false,
		"content":	"\n\nLuaCEmbedResponse * resource_get_path(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * resource_rename(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * resource_try_rename(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * free_resource(LuaCEmbedTable  *self, LuaCEmbed *args);\n\nLuaCEmbedResponse * resource_is_blob(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * resource_has_value(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * resource_get_type(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * resource_set_value(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * resource_try_set_value(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * resource_commit(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * resource_destroy(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * resource_try_destroy(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * unload_resurce(LuaCEmbedTable  *self, LuaCEmbed *args);\n\nLuaCEmbedResponse * lock_resource(LuaCEmbedTable  *self, LuaCEmbed *args);\n\nLuaCEmbedResponse * unlock_resource(LuaCEmbedTable  *self, LuaCEmbed *args);\n\n\n\nLuaCEmbedResponse * resource_set_value_in_sub_resource(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * resource_try_set_value_in_sub_resource(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedTable *raw_create_resource(LuaCEmbed *args,DtwResource *resource);\n\nLuaCEmbedResponse * create_resource(LuaCEmbed *args);"
	}, {
		"path":	"src/resource/resource/resource_iterable/"
	}, {
		"path":	"src/resource/resource/resource_iterable/resource_iterable.c",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse * resource_list(LuaCEmbedTable  *self,LuaCEmbed *args) {\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResourceArray  *elements = DtwResource_sub_resources(resource);\n    LuaCEmbedTable *multi_response = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable *response = LuaCembed_new_anonymous_table(args);\n\n    LuaCEmbedTable_append_table(multi_response,response);\n    LuaCEmbedTable_append_long(multi_response,elements->size);\n\n    for(int i = 0; i < elements->size; i++) {\n        DtwResource*current = elements->resources[i];\n        LuaCEmbedTable  *sub = raw_create_resource(args,current);\n        LuaCEmbedTable_append_table(response,sub);\n    }\n\n    return LuaCEmbed_send_multi_return(multi_response);\n}\n\n\nLuaCEmbedResponse * resource_foreach(LuaCEmbedTable  *self,LuaCEmbed *args) {\n\n\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResourceArray  *elements = DtwResource_sub_resources(resource);\n\n    for(int i =0; i < elements->size; i++) {\n        DtwResource *current = elements->resources[i];\n        LuaCEmbedTable  *sub = raw_create_resource(args,current);\n        LuaCEmbedTable *args_to_callback = LuaCembed_new_anonymous_table(args);\n        LuaCEmbedTable_append_table(args_to_callback,sub);\n        LuaCEmbed_run_args_lambda(args,0,args_to_callback,0);\n\n        if(LuaCEmbed_has_errors(args)){\n            char *error = LuaCEmbed_get_error_message(args);\n            return LuaCEmbed_send_error(error);\n        }\n\n    }\n    return LuaCEmbed_send_table(self);\n\n}\n\nLuaCEmbedResponse * resource_filter(LuaCEmbedTable  *self,LuaCEmbed *args) {\n    DtwResource *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResourceArray  *elements = DtwResource_sub_resources(resource);\n\n    LuaCEmbedTable * multi_response = LuaCembed_new_anonymous_table(args);\n\n    LuaCEmbedTable *response = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_append_table(multi_response,response);\n    long total = 0;\n    for(int i = 0; i < elements->size; i++) {\n        DtwResource*current = elements->resources[i];\n        LuaCEmbedTable  *sub = raw_create_resource(args,current);\n\n        LuaCEmbedTable *args_to_callback = LuaCembed_new_anonymous_table(args);\n        LuaCEmbedTable_append_table(args_to_callback,sub);\n        LuaCEmbedTable  *user_response = LuaCEmbed_run_args_lambda(args,0,args_to_callback,1);\n\n        if(LuaCEmbed_has_errors(args)){\n            char *error = LuaCEmbed_get_error_message(args);\n            return LuaCEmbed_send_error(error);\n        }\n\n        long size = LuaCEmbedTable_get_full_size(user_response);\n        bool append_element = false;\n        if(size >0){\n            append_element = LuaCEmbedTable_get_bool_by_index(user_response,0);\n        }\n\n        if(LuaCEmbed_has_errors(args)){\n            char *error = LuaCEmbed_get_error_message(args);\n            return LuaCEmbed_send_error(error);\n        }\n        if(append_element) {\n            total+=1;\n            LuaCEmbedTable_append_table(response,sub);\n        }\n\n\n\n    }\n    LuaCEmbedTable_append_long(multi_response,total);\n    return LuaCEmbed_send_multi_return(multi_response);\n}\nLuaCEmbedResponse * resource_map(LuaCEmbedTable  *self,LuaCEmbed *args) {\n    DtwResource *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResourceArray  *elements = DtwResource_sub_resources(resource);\n\n    LuaCEmbedTable * multi_response = LuaCembed_new_anonymous_table(args);\n\n    LuaCEmbedTable *response = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_append_table(multi_response,response);\n    LuaCEmbedTable_append_long(multi_response,elements->size);\n\n    for(int i = 0; i < elements->size; i++) {\n        DtwResource*current = elements->resources[i];\n        LuaCEmbedTable  *sub = raw_create_resource(args,current);\n\n        LuaCEmbedTable *args_to_callback = LuaCembed_new_anonymous_table(args);\n        LuaCEmbedTable_append_table(args_to_callback,sub);\n        LuaCEmbedTable  *user_response = LuaCEmbed_run_args_lambda(args,0,args_to_callback,1);\n\n        if(LuaCEmbed_has_errors(args)){\n            char *error = LuaCEmbed_get_error_message(args);\n            return LuaCEmbed_send_error(error);\n        }\n        long size = LuaCEmbedTable_get_full_size(user_response);\n        if(size >0){\n            LuaCEmbedTable_append_evaluation(response,\"%s[1]\",user_response->global_name);\n        }\n\n\n    }\n\n    return LuaCEmbed_send_multi_return(multi_response);\n}\n\nLuaCEmbedResponse * resource_count(LuaCEmbedTable  *self,LuaCEmbed *args) {\n    DtwResource *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResourceArray  *elements = DtwResource_sub_resources(resource);\n    long total  = 0;\n    for(int i = 0; i < elements->size; i++) {\n        DtwResource*current = elements->resources[i];\n        LuaCEmbedTable  *sub = raw_create_resource(args,current);\n\n        LuaCEmbedTable *args_to_callback = LuaCembed_new_anonymous_table(args);\n        LuaCEmbedTable_append_table(args_to_callback,sub);\n        LuaCEmbedTable  *user_response = LuaCEmbed_run_args_lambda(args,0,args_to_callback,1);\n\n        if(LuaCEmbed_has_errors(args)){\n            char *error = LuaCEmbed_get_error_message(args);\n            return LuaCEmbed_send_error(error);\n        }\n\n        long size = LuaCEmbedTable_get_full_size(user_response);\n        bool append_element = false;\n        if(size >0){\n            append_element = LuaCEmbedTable_get_bool_by_index(user_response,0);\n        }\n\n        if(LuaCEmbed_has_errors(args)){\n            char *error = LuaCEmbed_get_error_message(args);\n            return LuaCEmbed_send_error(error);\n        }\n        if(append_element) {\n            total+=1;\n        }\n    }\n    return LuaCEmbed_send_long(total);\n}\n\n\nLuaCEmbedResponse * resource_find(LuaCEmbedTable  *self,LuaCEmbed *args) {\n    DtwResource *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResourceArray  *elements = DtwResource_sub_resources(resource);\n    for(int i = 0; i < elements->size; i++) {\n        DtwResource*current = elements->resources[i];\n        LuaCEmbedTable  *sub = raw_create_resource(args,current);\n\n        LuaCEmbedTable *args_to_callback = LuaCembed_new_anonymous_table(args);\n        LuaCEmbedTable_append_table(args_to_callback,sub);\n        LuaCEmbedTable  *user_response = LuaCEmbed_run_args_lambda(args,0,args_to_callback,1);\n\n        if(LuaCEmbed_has_errors(args)){\n            char *error = LuaCEmbed_get_error_message(args);\n            return LuaCEmbed_send_error(error);\n        }\n        long size = LuaCEmbedTable_get_full_size(user_response);\n        bool append_element = false;\n        if(size >0){\n            append_element = LuaCEmbedTable_get_bool_by_index(user_response,0);\n        }\n\n        if(LuaCEmbed_has_errors(args)){\n            char *error = LuaCEmbed_get_error_message(args);\n            return LuaCEmbed_send_error(error);\n        }\n        if(append_element) {\n            return LuaCEmbed_send_table(sub);\n        }\n    }\n\n    return NULL;\n}"
	}, {
		"path":	"src/resource/resource/resource_iterable/resource_iterable.h",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse * resource_list(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * resource_foreach(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * resource_filter(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * resource_map(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * resource_count(LuaCEmbedTable  *self,LuaCEmbed *args);\n\n\nLuaCEmbedResponse * resource_find(LuaCEmbedTable  *self,LuaCEmbed *args);"
	}, {
		"path":	"src/resource/resource/schema/"
	}, {
		"path":	"src/resource/resource/schema/schema.c",
		"is_binary":	false,
		"content":	"//\n// Created by mateusmoutinho on 22/05/24.\n//\n\nLuaCEmbedResponse * resource_new_schema(LuaCEmbedTable  *self, LuaCEmbed *args){\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwDatabaseSchema *schema = DtwResource_newDatabaseSchema(resource);\n    if(DtwResource_error(resource)){\n        char *error_mensage = DtwResource_get_error_message(resource);\n        LuaCEmbedResponse *response = LuaCEmbed_send_error(error_mensage);\n        DtwResource_clear_errors(resource);\n        return  response;\n    }\n\n    LuaCEmbedTable  *created = raw_create_database_schema(args,schema);\n    return LuaCEmbed_send_table(created);\n\n}\n\nLuaCEmbedResponse * resource_try_new_schema(LuaCEmbedTable  *self, LuaCEmbed *args) {\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwDatabaseSchema *schema = DtwResource_newDatabaseSchema(resource);\n    LuaCEmbedTable *multi_response = LuaCembed_new_anonymous_table(args);\n\n    resource_protect(resource,args)\n\n    LuaCEmbedTable_append_bool(multi_response,true);\n    LuaCEmbedTable  *created = raw_create_database_schema(args,schema);\n    LuaCEmbedTable_append_table(multi_response,created);\n    return  LuaCEmbed_send_multi_return(multi_response);\n\n}\n\nLuaCEmbedResponse  * Resource_new_insertion(LuaCEmbedTable *self, LuaCEmbed *args){\n    DtwResource *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResource  *created = DtwResource_new_schema_insertion(resource);\n    if(DtwResource_error(resource)){\n        char *message = DtwResource_get_error_message(resource);\n        LuaCEmbedResponse *response = LuaCEmbed_send_error(message);\n        DtwResource_clear_errors(resource);\n        return  response;\n    }\n\n    LuaCEmbedTable  *sub = raw_create_resource(args,created);\n\n    return LuaCEmbed_send_table(sub);\n}\nLuaCEmbedResponse  * Resource_try_new_insertion(LuaCEmbedTable *self, LuaCEmbed *args) {\n    DtwResource *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResource  *created = DtwResource_new_schema_insertion(resource);\n    resource_protect(resource,args)\n    LuaCEmbedTable *multi_response =  LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_append_bool(multi_response,true);\n    LuaCEmbedTable  *sub = raw_create_resource(args,created);\n    LuaCEmbedTable_append_table(multi_response,sub);\n    return  LuaCEmbed_send_multi_return(multi_response);\n\n}\n\n\nLuaCEmbedResponse  * get_resource_match_schema_by_primary_key(LuaCEmbedTable *self, LuaCEmbed *args){\n    char *key = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n    Writeble  *write_obj = create_writeble(args,1);\n    if(write_obj->error){\n        LuaCEmbedResponse *response =  write_obj->error;\n        Writeble_free(write_obj);\n        return  response;\n    }\n    DtwResource *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n\n    DtwResource *founded = DtwResource_find_by_primary_key_with_binary(resource,key,write_obj->content,write_obj->size);\n    Writeble_free(write_obj);\n    if(DtwResource_error(resource)){\n        char *message = DtwResource_get_error_message(resource);\n        LuaCEmbedResponse *response = LuaCEmbed_send_error(message);\n        DtwResource_clear_errors(resource);\n        return  response;\n    }\n    if(founded ==NULL){\n        return NULL;\n    }\n    LuaCEmbedTable  *sub = raw_create_resource(args,founded);\n    return LuaCEmbed_send_table(sub);\n}\n\nLuaCEmbedResponse  * try_get_resource_match_schema_by_primary_key(LuaCEmbedTable *self, LuaCEmbed *args) {\n    char *key = LuaCEmbed_get_str_arg(args,0);\n    args_protect(args)\n    Writeble  *write_obj = create_writeble(args,1);\n    writeble_protect(write_obj,args)\n    DtwResource *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResource *founded = DtwResource_find_by_primary_key_with_binary(resource,key,write_obj->content,write_obj->size);\n    Writeble_free(write_obj);\n    resource_protect(resource,args)\n    LuaCEmbedTable *multi_response =  LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_append_bool(multi_response,true);\n    if(founded== NULL){\n        return  LuaCEmbed_send_multi_return(multi_response);\n    }\n\n    LuaCEmbedTable  *sub = raw_create_resource(args,founded);\n    LuaCEmbedTable_append_table(multi_response,sub);\n    return  LuaCEmbed_send_multi_return(multi_response);\n}\n\nLuaCEmbedResponse  * get_resource_by_name_id(LuaCEmbedTable *self, LuaCEmbed *args){\n    char *name_id = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n\n    DtwResource *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResource *founded = DtwResource_find_by_name_id(resource,name_id);\n    if(DtwResource_error(resource)){\n        char *message = DtwResource_get_error_message(resource);\n        LuaCEmbedResponse *response = LuaCEmbed_send_error(message);\n        DtwResource_clear_errors(resource);\n        return  response;\n    }\n    if(founded ==NULL){\n        return NULL;\n    }\n    LuaCEmbedTable  *sub = raw_create_resource(args,founded);\n    return LuaCEmbed_send_table(sub);\n\n}\n\nLuaCEmbedResponse  * try_get_resource_by_name_id(LuaCEmbedTable *self, LuaCEmbed *args) {\n    char *name_id = LuaCEmbed_get_str_arg(args,0);\n    args_protect(args)\n    DtwResource *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResource *founded = DtwResource_find_by_name_id(resource,name_id);\n   resource_protect(resource,args)\n    LuaCEmbedTable *multi_response =  LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_append_bool(multi_response,true);\n    if(founded== NULL){\n        return  LuaCEmbed_send_multi_return(multi_response);\n    }\n\n    LuaCEmbedTable  *sub = raw_create_resource(args,founded);\n    LuaCEmbedTable_append_table(multi_response,sub);\n    return  LuaCEmbed_send_multi_return(multi_response);\n}\n\n\nLuaCEmbedResponse  * dangerous_rename_schema_prop(LuaCEmbedTable *self,LuaCEmbed *args){\n    char *key = LuaCEmbed_get_str_arg(args,0);\n    char *new_name = LuaCEmbed_get_str_arg(args,1);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n\n\n    DtwResource *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResource_dangerous_rename_schema_prop(resource,key,new_name);\n    if(DtwResource_error(resource)){\n        char *message = DtwResource_get_error_message(resource);\n        LuaCEmbedResponse *response = LuaCEmbed_send_error(message);\n        DtwResource_clear_errors(resource);\n        return  response;\n    }\n    return LuaCEmbed_send_table(self);\n}\nLuaCEmbedResponse  * try_dangerous_rename_schema_prop(LuaCEmbedTable *self,LuaCEmbed *args) {\n    char *key = LuaCEmbed_get_str_arg(args,0);\n    char *new_name = LuaCEmbed_get_str_arg(args,1);\n    args_protect(args)\n\n    DtwResource *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResource_dangerous_rename_schema_prop(resource,key,new_name);\n    resource_protect(resource,args)\n    LuaCEmbedTable *multi_response =  LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_append_bool(multi_response,true);\n    return LuaCEmbed_send_multi_return(multi_response);\n}\n\nLuaCEmbedResponse  * dangerous_remove_schema_prop(LuaCEmbedTable *self,LuaCEmbed *args){\n    char *key_to_remove = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n\n    DtwResource *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResource_dangerous_remove_schema_prop(resource,key_to_remove);\n    if(DtwResource_error(resource)){\n        char *message = DtwResource_get_error_message(resource);\n        LuaCEmbedResponse *response = LuaCEmbed_send_error(message);\n        DtwResource_clear_errors(resource);\n        return  response;\n    }\n    return LuaCEmbed_send_table(self);\n}\nLuaCEmbedResponse  * try_dangerous_remove_schema_prop(LuaCEmbedTable *self,LuaCEmbed *args) {\n    char *key_to_remove = LuaCEmbed_get_str_arg(args,0);\n    args_protect(args)\n\n    DtwResource *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResource_dangerous_remove_schema_prop(resource,key_to_remove);\n    LuaCEmbedTable *multi_response =  LuaCembed_new_anonymous_table(args);\n    resource_protect(resource,args)\n    LuaCEmbedTable_append_bool(multi_response,true);\n    return LuaCEmbed_send_multi_return(multi_response);\n}\n\n\n\n"
	}, {
		"path":	"src/resource/resource/schema/schema.h",
		"is_binary":	false,
		"content":	"//\n// Created by mateusmoutinho on 22/05/24.\n//\nLuaCEmbedResponse * resource_new_schema(LuaCEmbedTable  *self, LuaCEmbed *args);\n\nLuaCEmbedResponse * resource_try_new_schema(LuaCEmbedTable  *self, LuaCEmbed *args);\n\n\nLuaCEmbedResponse  * Resource_new_insertion(LuaCEmbedTable *self, LuaCEmbed *args);\n\nLuaCEmbedResponse  * Resource_try_new_insertion(LuaCEmbedTable *self, LuaCEmbed *args);\n\n\nLuaCEmbedResponse  * get_resource_match_schema_by_primary_key(LuaCEmbedTable *self, LuaCEmbed *args);\n\nLuaCEmbedResponse  * try_get_resource_match_schema_by_primary_key(LuaCEmbedTable *self, LuaCEmbed *args);\n\nLuaCEmbedResponse  * get_resource_by_name_id(LuaCEmbedTable *self, LuaCEmbed *args);\n\nLuaCEmbedResponse  * try_get_resource_by_name_id(LuaCEmbedTable *self, LuaCEmbed *args);\n\nLuaCEmbedResponse  * dangerous_rename_schema_prop(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse  * try_dangerous_rename_schema_prop(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse  * dangerous_remove_schema_prop(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse  * try_dangerous_remove_schema_prop(LuaCEmbedTable *self,LuaCEmbed *args);\n\n"
	}, {
		"path":	"src/resource/resource/schema_iterable/"
	}, {
		"path":	"src/resource/resource/schema_iterable/schema_iterable.c",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse * schema_list_resources(LuaCEmbedTable *self,LuaCEmbed *args){\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResourceArray  *elements = DtwResource_get_schema_values(resource);\n\n    if(DtwResource_error(resource)){\n        char *error_mensage = DtwResource_get_error_message(resource);\n        LuaCEmbedResponse *response = LuaCEmbed_send_error(error_mensage);\n        DtwResource_clear_errors(resource);\n        return  response;\n    }\n\n    LuaCEmbedTable *multi_response = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable *response = LuaCembed_new_anonymous_table(args);\n\n    LuaCEmbedTable_append_table(multi_response,response);\n    LuaCEmbedTable_append_long(multi_response,elements->size);\n\n    for(int i = 0; i < elements->size; i++) {\n        DtwResource*current = elements->resources[i];\n        LuaCEmbedTable  *sub = raw_create_resource(args,current);\n        LuaCEmbedTable_append_table(response,sub);\n    }\n\n    return LuaCEmbed_send_multi_return(multi_response);\n}\n\nLuaCEmbedResponse * try_schema_list_resources(LuaCEmbedTable *self,LuaCEmbed *args) {\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResourceArray  *elements = DtwResource_get_schema_values(resource);\n\n    resource_protect(resource,args)\n    LuaCEmbedTable *multi_response =  LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_append_bool(multi_response,true);\n\n    LuaCEmbedTable *listage = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_append_table(multi_response,listage);\n    LuaCEmbedTable_append_long(multi_response,elements->size);\n\n    for(int i = 0; i < elements->size; i++) {\n        DtwResource*current = elements->resources[i];\n        LuaCEmbedTable  *sub = raw_create_resource(args,current);\n        LuaCEmbedTable_append_table(listage,sub);\n    }\n\n    return  LuaCEmbed_send_multi_return(multi_response);\n\n}\n\nLuaCEmbedResponse * schema_find_resource(LuaCEmbedTable *self,LuaCEmbed *args){\n\n    DtwResource *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n\n    DtwResourceArray  *elements = DtwResource_get_schema_values(resource);\n    if(DtwResource_error(resource)){\n        char *error_mensage = DtwResource_get_error_message(resource);\n        LuaCEmbedResponse *response = LuaCEmbed_send_error(error_mensage);\n        DtwResource_clear_errors(resource);\n        return  response;\n    }\n\n\n    for(int i = 0; i < elements->size; i++) {\n        DtwResource*current = elements->resources[i];\n        LuaCEmbedTable  *sub = raw_create_resource(args,current);\n\n        LuaCEmbedTable *args_to_callback = LuaCembed_new_anonymous_table(args);\n        LuaCEmbedTable_append_table(args_to_callback,sub);\n        LuaCEmbedTable  *user_response = LuaCEmbed_run_args_lambda(args,0,args_to_callback,1);\n\n        if(LuaCEmbed_has_errors(args)){\n            char *error = LuaCEmbed_get_error_message(args);\n            return LuaCEmbed_send_error(error);\n        }\n        long size = LuaCEmbedTable_get_full_size(user_response);\n        bool return_element = false;\n        if(size > 0 ){\n            return_element = LuaCEmbedTable_get_bool_by_index(user_response,0);\n        }\n        if(LuaCEmbed_has_errors(args)){\n\n            char *error = LuaCEmbed_get_error_message(args);\n            return LuaCEmbed_send_error(error);\n        }\n\n        if(return_element) {\n            return LuaCEmbed_send_table(sub);\n        }\n    }\n\n    return NULL;\n}\n\n\n\nLuaCEmbedResponse * schema_count_resource(LuaCEmbedTable *self,LuaCEmbed *args){\n    DtwResource *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n\n    DtwResourceArray  *elements = DtwResource_get_schema_values(resource);\n    if(DtwResource_error(resource)){\n        char *error_mensage = DtwResource_get_error_message(resource);\n        LuaCEmbedResponse *response = LuaCEmbed_send_error(error_mensage);\n        DtwResource_clear_errors(resource);\n        return  response;\n    }\n\n    long total = 0;\n    for(int i = 0; i < elements->size; i++) {\n        DtwResource*current = elements->resources[i];\n        LuaCEmbedTable  *sub = raw_create_resource(args,current);\n\n        LuaCEmbedTable *args_to_callback = LuaCembed_new_anonymous_table(args);\n        LuaCEmbedTable_append_table(args_to_callback,sub);\n        LuaCEmbedTable  *user_response = LuaCEmbed_run_args_lambda(args,0,args_to_callback,1);\n\n        if(LuaCEmbed_has_errors(args)){\n            char *error = LuaCEmbed_get_error_message(args);\n            return LuaCEmbed_send_error(error);\n        }\n        long size = LuaCEmbedTable_get_full_size(user_response);\n        bool append_element = false;\n        if(size > 0 ){\n            append_element = LuaCEmbedTable_get_bool_by_index(user_response,0);\n        }\n        if(LuaCEmbed_has_errors(args)){\n\n            char *error = LuaCEmbed_get_error_message(args);\n            return LuaCEmbed_send_error(error);\n        }\n\n        if(append_element) {\n            total+=1;\n        }\n    }\n\n    return LuaCEmbed_send_long(total);\n}\nLuaCEmbedResponse * schema_filter_resource(LuaCEmbedTable *self,LuaCEmbed *args){\n    DtwResource *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n\n\n    DtwResourceArray  *elements = DtwResource_get_schema_values(resource);\n    if(DtwResource_error(resource)){\n        char *error_mensage = DtwResource_get_error_message(resource);\n        LuaCEmbedResponse *response = LuaCEmbed_send_error(error_mensage);\n        DtwResource_clear_errors(resource);\n        return  response;\n    }\n    LuaCEmbedTable * multi_response = LuaCembed_new_anonymous_table(args);\n\n    LuaCEmbedTable *response = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_append_table(multi_response,response);\n    long total = 0;\n    for(int i = 0; i < elements->size; i++) {\n        DtwResource*current = elements->resources[i];\n        LuaCEmbedTable  *sub = raw_create_resource(args,current);\n\n        LuaCEmbedTable *args_to_callback = LuaCembed_new_anonymous_table(args);\n        LuaCEmbedTable_append_table(args_to_callback,sub);\n        LuaCEmbedTable  *user_response = LuaCEmbed_run_args_lambda(args,0,args_to_callback,1);\n\n        if(LuaCEmbed_has_errors(args)){\n            char *error = LuaCEmbed_get_error_message(args);\n            return LuaCEmbed_send_error(error);\n        }\n\n        long size = LuaCEmbedTable_get_full_size(user_response);\n        bool append_element = false;\n        if(size ==1){\n            append_element = LuaCEmbedTable_get_bool_by_index(user_response,0);\n        }\n\n        if(LuaCEmbed_has_errors(args)){\n            char *error = LuaCEmbed_get_error_message(args);\n            return LuaCEmbed_send_error(error);\n        }\n        if(append_element) {\n            total+=1;\n            LuaCEmbedTable_append_table(response,sub);\n        }\n\n\n    }\n    LuaCEmbedTable_append_long(multi_response,total);\n    return LuaCEmbed_send_multi_return(multi_response);\n}\n\nLuaCEmbedResponse * schema_map_resource(LuaCEmbedTable *self,LuaCEmbed *args){\n    DtwResource *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n\n\n    DtwResourceArray  *elements = DtwResource_get_schema_values(resource);\n    if(DtwResource_error(resource)){\n        char *error_mensage = DtwResource_get_error_message(resource);\n        LuaCEmbedResponse *response = LuaCEmbed_send_error(error_mensage);\n        DtwResource_clear_errors(resource);\n        return  response;\n    }\n    LuaCEmbedTable * multi_response = LuaCembed_new_anonymous_table(args);\n\n    LuaCEmbedTable *response = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_append_table(multi_response,response);\n    LuaCEmbedTable_append_long(multi_response,elements->size);\n\n    for(int i = 0; i < elements->size; i++) {\n        DtwResource*current = elements->resources[i];\n        LuaCEmbedTable  *sub = raw_create_resource(args,current);\n\n        LuaCEmbedTable *args_to_callback = LuaCembed_new_anonymous_table(args);\n        LuaCEmbedTable_append_table(args_to_callback,sub);\n        LuaCEmbedTable  *user_response = LuaCEmbed_run_args_lambda(args,0,args_to_callback,1);\n\n        if(LuaCEmbed_has_errors(args)){\n            char *error = LuaCEmbed_get_error_message(args);\n            return LuaCEmbed_send_error(error);\n        }\n        long size = LuaCEmbedTable_get_full_size(user_response);\n        if(size >0){\n            LuaCEmbedTable_append_evaluation(response,\"%s[1]\",user_response->global_name);\n        }\n\n\n    }\n\n    return LuaCEmbed_send_multi_return(multi_response);\n}\n\nLuaCEmbedResponse * resource_schema_each(LuaCEmbedTable *self, LuaCEmbed *args){\n    DtwResource *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n\n    DtwResourceArray  *elements = DtwResource_get_schema_values(resource);\n    if(DtwResource_error(resource)){\n        char *error_mensage = DtwResource_get_error_message(resource);\n        LuaCEmbedResponse *response = LuaCEmbed_send_error(error_mensage);\n        DtwResource_clear_errors(resource);\n        return  response;\n    }\n\n    if(DtwResource_error(resource)){\n        char *message = DtwResource_get_error_message(resource);\n        return LuaCEmbed_send_error(message);\n    }\n\n    for(int i = 0; i < elements->size; i++) {\n        DtwResource*current = elements->resources[i];\n        LuaCEmbedTable  *sub = raw_create_resource(args,current);\n        LuaCEmbedTable *args_to_callback = LuaCembed_new_anonymous_table(args);\n        LuaCEmbedTable_append_table(args_to_callback,sub);\n        LuaCEmbed_run_args_lambda(args,0,args_to_callback,0);\n    }\n    if(LuaCEmbed_has_errors(args)){\n        printf(\"%s\\n\",LuaCEmbed_get_error_message(args));\n    }\n\n    return NULL;\n}\n"
	}, {
		"path":	"src/resource/resource/schema_iterable/schema_iterable.h",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse * schema_list_resources(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * try_schema_list_resources(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * schema_find_resource(LuaCEmbedTable *self,LuaCEmbed *args);\n\n\nLuaCEmbedResponse * schema_count_resource(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * schema_filter_resource(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * schema_map_resource(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * resource_schema_each(LuaCEmbedTable *self, LuaCEmbed *args);\n"
	}, {
		"path":	"src/resource/resource/sub_resource/"
	}, {
		"path":	"src/resource/resource/sub_resource/sub_resource.c",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse * resource_sub_resource_raw(LuaCEmbedTable  *self, LuaCEmbed *args,const char *src){\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResource *sub_resource = DtwResource_sub_resource(resource,\"%s\",src);\n    if(DtwResource_error(resource)){\n        char *message = DtwResource_get_error_message(resource);\n        LuaCEmbedResponse *response = LuaCEmbed_send_error(message);\n        DtwResource_clear_errors(resource);\n        return  response;\n    }\n    LuaCEmbedTable  *sub = raw_create_resource(args,sub_resource);\n    return LuaCEmbed_send_table(sub);\n}\nLuaCEmbedResponse * try_resource_sub_resource_raw(LuaCEmbedTable  *self, LuaCEmbed *args,const char *src) {\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResource *sub_resource = DtwResource_sub_resource(resource,\"%s\",src);\n\n    LuaCEmbedTable *multi_response =  LuaCembed_new_anonymous_table(args);\n    if(DtwResource_error(resource)){\n        char *error_mensage = DtwResource_get_error_message(resource);\n        LuaCEmbedTable_append_bool(multi_response,false);\n        LuaCEmbedTable_append_string(multi_response,error_mensage);\n        DtwResource_clear_errors(resource);\n        return  LuaCEmbed_send_multi_return(multi_response);\n    }\n    LuaCEmbedTable_append_bool(multi_response,true);\n    LuaCEmbedTable  *sub = raw_create_resource(args,sub_resource);\n    LuaCEmbedTable_append_table(multi_response,sub);\n    return  LuaCEmbed_send_multi_return(multi_response);\n\n\n}\n\nLuaCEmbedResponse * resource_sub_resource_method(LuaCEmbedTable  *self, LuaCEmbed *args){\n    char *src = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n    return resource_sub_resource_raw(self,args,src);\n}\n\n\nLuaCEmbedResponse * try_resource_sub_resource_method(LuaCEmbedTable  *self, LuaCEmbed *args){\n    char *src = LuaCEmbed_get_str_arg(args,0);\n   args_protect(args)\n    return try_resource_sub_resource_raw(self,args,src);\n}\n\nLuaCEmbedResponse * resource_sub_resource_index(LuaCEmbedTable  *self, LuaCEmbed *args){\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n\n    int type = LuaCEmbed_get_arg_type(args,1);\n    if(type == LUA_CEMBED_NUMBER){\n        long raw_index =  LuaCEmbed_get_long_arg(args,1);\n        long  i = raw_index-1;\n        DtwResourceArray  *elements = DtwResource_sub_resources(resource);\n\n        if(i >=elements->size || i  < 0){\n            return NULL;\n        }\n        DtwResource *current = elements->resources[i];\n        LuaCEmbedTable  *sub = raw_create_resource(args,current);\n        LuaCEmbedTable *response = LuaCembed_new_anonymous_table(args);\n        LuaCEmbedTable_append_long(response,raw_index);\n        LuaCEmbedTable_append_table(response,sub);\n        return LuaCEmbed_send_multi_return(response);\n    }\n\n    char *src = LuaCEmbed_get_str_arg(args,1);\n    if(DtwResource_error(resource)){\n        char *message = DtwResource_get_error_message(resource);\n        LuaCEmbedResponse *response = LuaCEmbed_send_error(message);\n        DtwResource_clear_errors(resource);\n        return  response;\n    }\n    return resource_sub_resource_raw(self,args,src);\n}\n\n\n\n\nLuaCEmbedResponse * resource_sub_resource_next(LuaCEmbedTable  *self,LuaCEmbed *args){\n    const char *src = \"\";\n    if(LuaCEmbed_get_total_args(args) > 0){\n        src  = LuaCEmbed_get_str_arg(args,0);\n    }\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResource *sub_resource = DtwResource_sub_resource_next(resource,src);\n    if(DtwResource_error(resource)){\n        char *message = DtwResource_get_error_message(resource);\n        LuaCEmbedResponse *response = LuaCEmbed_send_error(message);\n        DtwResource_clear_errors(resource);\n        return  response;\n    }\n    LuaCEmbedTable  *sub = raw_create_resource(args,sub_resource);\n\n    return LuaCEmbed_send_table(sub);\n}\n\nLuaCEmbedResponse * try_resource_sub_resource_next(LuaCEmbedTable  *self,LuaCEmbed *args){\n    const char *src = \"\";\n    if(LuaCEmbed_get_total_args(args) > 0){\n        src  = LuaCEmbed_get_str_arg(args,0);\n    }\n    args_protect(args)\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResource *sub_resource = DtwResource_sub_resource_next(resource,src);\n\n    LuaCEmbedTable *multi_response =  LuaCembed_new_anonymous_table(args);\n    resource_protect(resource,args)\n    LuaCEmbedTable_append_bool(multi_response,true);\n    LuaCEmbedTable  *sub = raw_create_resource(args,sub_resource);\n    LuaCEmbedTable_append_table(multi_response,sub);\n    return  LuaCEmbed_send_multi_return(multi_response);\n}\n\nLuaCEmbedResponse * resource_sub_resource_now(LuaCEmbedTable  *self,LuaCEmbed *args){\n    const char *src = \"\";\n    if(LuaCEmbed_get_total_args(args) > 0){\n        src  = LuaCEmbed_get_str_arg(args,0);\n    }\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResource *sub_resource = DtwResource_sub_resource_now(resource,src);\n    if(DtwResource_error(resource)){\n        char *message = DtwResource_get_error_message(resource);\n        LuaCEmbedResponse *response = LuaCEmbed_send_error(message);\n        DtwResource_clear_errors(resource);\n        return  response;\n    }\n    LuaCEmbedTable  *sub = raw_create_resource(args,sub_resource);\n    return LuaCEmbed_send_table(sub);\n}\n\nLuaCEmbedResponse * try_resource_sub_resource_now(LuaCEmbedTable  *self,LuaCEmbed *args){\n    const char *src = \"\";\n    if(LuaCEmbed_get_total_args(args) > 0){\n        src  = LuaCEmbed_get_str_arg(args,0);\n    }\n    args_protect(args)\n\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResource *sub_resource = DtwResource_sub_resource_now(resource,src);\n    resource_protect(resource,args)\n    LuaCEmbedTable *multi_response =  LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_append_bool(multi_response,true);\n    LuaCEmbedTable  *sub = raw_create_resource(args,sub_resource);\n    LuaCEmbedTable_append_table(multi_response,sub);\n    return  LuaCEmbed_send_multi_return(multi_response);\n}\n\nLuaCEmbedResponse * resource_sub_resource_now_in_unix(LuaCEmbedTable  *self,LuaCEmbed *args){\n    const char *src = \"\";\n    if(LuaCEmbed_get_total_args(args) > 0){\n        src  = LuaCEmbed_get_str_arg(args,0);\n    }\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResource *sub_resource = DtwResource_sub_resource_now_in_unix(resource,src);\n\n    if(DtwResource_error(resource)){\n        char *message = DtwResource_get_error_message(resource);\n        LuaCEmbedResponse *response = LuaCEmbed_send_error(message);\n        DtwResource_clear_errors(resource);\n        return  response;\n    }\n\n    LuaCEmbedTable  *sub = raw_create_resource(args,sub_resource);\n    return LuaCEmbed_send_table(sub);\n}\n\n\nLuaCEmbedResponse * try_resource_sub_resource_now_in_unix(LuaCEmbedTable  *self,LuaCEmbed *args){\n    const char *src = \"\";\n    if(LuaCEmbed_get_total_args(args) > 0){\n        src  = LuaCEmbed_get_str_arg(args,0);\n    }\n    args_protect(args)\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResource *sub_resource = DtwResource_sub_resource_now_in_unix(resource,src);\n    resource_protect(resource,args)\n    LuaCEmbedTable *multi_response =  LuaCembed_new_anonymous_table(args);\n\n    LuaCEmbedTable_append_bool(multi_response,true);\n    LuaCEmbedTable  *sub = raw_create_resource(args,sub_resource);\n    LuaCEmbedTable_append_table(multi_response,sub);\n    return  LuaCEmbed_send_multi_return(multi_response);\n}\n\n\nLuaCEmbedResponse * resource_sub_resource_random(LuaCEmbedTable  *self,LuaCEmbed *args) {\n    const char *src = \"\";\n    if(LuaCEmbed_get_total_args(args) > 0){\n        src  = LuaCEmbed_get_str_arg(args,0);\n    }\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResource *sub_resource = DtwResource_sub_resource_random(resource,src);\n\n    if(DtwResource_error(resource)){\n        char *message = DtwResource_get_error_message(resource);\n        LuaCEmbedResponse *response = LuaCEmbed_send_error(message);\n        DtwResource_clear_errors(resource);\n        return  response;\n    }\n\n    LuaCEmbedTable  *sub = raw_create_resource(args,sub_resource);\n    return LuaCEmbed_send_table(sub);\n}\n\nLuaCEmbedResponse * try_resource_sub_resource_random(LuaCEmbedTable  *self,LuaCEmbed *args) {\n    const char *src = \"\";\n    if(LuaCEmbed_get_total_args(args) > 0){\n        src  = LuaCEmbed_get_str_arg(args,0);\n    }\n    args_protect(args)\n\n    DtwResource  *resource = (DtwResource*)LuaCembedTable_get_long_prop(self,RESOURCE_POINTER);\n    DtwResource *sub_resource = DtwResource_sub_resource_random(resource,src);\n\n    LuaCEmbedTable *multi_response =  LuaCembed_new_anonymous_table(args);\n    resource_protect(resource,args)\n    LuaCEmbedTable_append_bool(multi_response,true);\n    LuaCEmbedTable  *sub = raw_create_resource(args,sub_resource);\n    LuaCEmbedTable_append_table(multi_response,sub);\n    return  LuaCEmbed_send_multi_return(multi_response);\n}\n"
	}, {
		"path":	"src/resource/resource/sub_resource/sub_resource.h",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse * resource_sub_resource_raw(LuaCEmbedTable  *self, LuaCEmbed *args,const char *src);\n\nLuaCEmbedResponse * try_resource_sub_resource_raw(LuaCEmbedTable  *self, LuaCEmbed *args,const char *src);\n\nLuaCEmbedResponse * resource_sub_resource_method(LuaCEmbedTable  *self, LuaCEmbed *args);\n\n\nLuaCEmbedResponse * resource_sub_resource_index(LuaCEmbedTable  *self, LuaCEmbed *args);\n\n\n\nLuaCEmbedResponse * try_resource_sub_resource_method(LuaCEmbedTable  *self, LuaCEmbed *args);\n\nLuaCEmbedResponse * resource_sub_resource_next(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * try_resource_sub_resource_next(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * resource_sub_resource_now(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * try_resource_sub_resource_now(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * resource_sub_resource_now_in_unix(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * try_resource_sub_resource_now_in_unix(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * resource_sub_resource_random(LuaCEmbedTable  *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * try_resource_sub_resource_random(LuaCEmbedTable  *self,LuaCEmbed *args);\n"
	}, {
		"path":	"src/resource/schemas/"
	}, {
		"path":	"src/resource/schemas/schemas.c",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse  * set_schema_index_name(LuaCEmbedTable *self,LuaCEmbed *args) {\n    char *index_name =  LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)) {\n        char *error_msg = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error_msg);\n    }\n    DtwSchema *schema = (DtwSchema*)LuaCembedTable_get_long_prop(self,SCHEMA_POINTER);\n    schema->index_name =index_name;\n    return LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse  * set_schema_value_name(LuaCEmbedTable *self,LuaCEmbed *args) {\n    char *value_name =  LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)) {\n        char *error_msg = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error_msg);\n    }\n    DtwSchema *schema = (DtwSchema*)LuaCembedTable_get_long_prop(self,SCHEMA_POINTER);\n    schema->value_name =value_name;\n    return LuaCEmbed_send_table(self);\n}\n\n\nLuaCEmbedResponse  * add_schema_primary_keys(LuaCEmbedTable *self,LuaCEmbed *args){\n\n    DtwSchema *schema = (DtwSchema*)LuaCembedTable_get_long_prop(self,SCHEMA_POINTER);\n    int arg_type = LuaCEmbed_get_arg_type(args,0);\n    if(arg_type == LUA_CEMBED_STRING){\n        char *value = LuaCEmbed_get_str_arg(args,0);\n        DtwSchema_add_primary_key(schema,value);\n        return LuaCEmbed_send_table(self);\n    }\n\n    if(arg_type != LUA_CEMBED_TABLE){\n        return LuaCEmbed_send_error(ARGUMENT_NOT_IN_STRING_OR_STRING_ARRAY);\n    }\n\n    LuaCEmbedTable *string_array = LuaCEmbed_get_arg_table(args,0);\n    long size = LuaCEmbedTable_get_full_size(string_array);\n    for(int i = 0; i < size;i++){\n        int current_type = LuaCEmbedTable_get_type_by_index(string_array,i);\n        if(current_type != LUA_CEMBED_STRING){\n            return LuaCEmbed_send_error(ARGUMENT_NOT_IN_STRING_OR_STRING_ARRAY);\n        }\n    }\n\n    for(int i = 0; i < size;i++){\n        char *current_value = LuaCEmbedTable_get_string_by_index(string_array,i);\n        DtwSchema_add_primary_key(schema,current_value);\n    }\n    return LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse  * schema_add_sub_schema(LuaCEmbedTable *self,LuaCEmbed *args){\n    char *name = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *message = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(message);\n    }\n\n    DtwSchema *schema = (DtwSchema*)LuaCembedTable_get_long_prop(self,SCHEMA_POINTER);\n    DtwSchema *sub_schmea = DtwSchema_new_subSchema(schema,name);\n    LuaCEmbedTable *created_table = raw_create_schema(args,sub_schmea);\n    return LuaCEmbed_send_table(created_table);\n}\n\nLuaCEmbedTable  * raw_create_schema(LuaCEmbed *args,DtwSchema *schema){\n    LuaCEmbedTable *created= LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_set_long_prop(created,SCHEMA_POINTER,(long long )schema);\n    LuaCEmbedTable_set_method(created,ADD_PRIMARY_KEYS,add_schema_primary_keys);\n    LuaCEmbedTable_set_method(created,ADD_SUB_SCHEMA_METHOD,schema_add_sub_schema);\n    LuaCEmbedTable_set_method(created,SET_INDEX_NAME_METHOD,set_schema_index_name);\n    LuaCEmbedTable_set_method(created,SET_VALUE_NAME_METHOD,set_schema_value_name);\n    return created;\n}\n\n"
	}, {
		"path":	"src/resource/schemas/schemas.h",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse  * set_schema_index_name(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse  * set_schema_value_name(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse  * add_schema_primary_keys(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse  * schema_add_sub_schema(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedTable  * raw_create_schema(LuaCEmbed *args,DtwSchema *schema);\n\n"
	}, {
		"path":	"src/sha/"
	}, {
		"path":	"src/sha/sha.c",
		"is_binary":	false,
		"content":	"\n\nLuaCEmbedResponse  * generate_sha_from_file(LuaCEmbed *args){\n    char *source = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n\n    char *sha = dtw_generate_sha_from_file(source);\n    if(sha == NULL){\n        return NULL;\n    }\n    LuaCEmbedResponse *response = LuaCEmbed_send_str(sha);\n    free(sha);\n    return response;\n}\nLuaCEmbedResponse  * generate_sha_from_folder_by_content(LuaCEmbed *args){\n    char *source = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n\n    DtwHash *hash = newDtwHash();\n    bool result = DtwHash_digest_folder_by_content(hash,source);\n    if(!result){\n        DtwHash_free(hash);\n        return NULL;\n    }\n\n    LuaCEmbedResponse *response = LuaCEmbed_send_str(hash->hash);\n    DtwHash_free(hash);\n    return response;\n}\n\nLuaCEmbedResponse  * generate_sha_from_folder_by_last_modification(LuaCEmbed *args){\n    char *source = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n\n    DtwHash *hash = newDtwHash();\n    bool result = DtwHash_digest_folder_by_last_modification(hash,source);\n    if(!result){\n        char *content = private_LuaCembed_format(FILE_NOT_FOUND,source);\n        LuaCEmbedResponse*response = LuaCEmbed_send_error(content);\n        free(content);\n        DtwHash_free(hash);\n        return response;\n    }\n    LuaCEmbedResponse *response = LuaCEmbed_send_str(hash->hash);\n    DtwHash_free(hash);\n    return response;\n}\n\nLuaCEmbedResponse  * generate_sha(LuaCEmbed *args){\n    Writeble  *write_obj = create_writeble(args,0);\n    if(write_obj->error){\n        LuaCEmbedResponse *response =  write_obj->error;\n        Writeble_free(write_obj);\n        return  response;\n    }\n    char  *sha = dtw_generate_sha_from_any(write_obj->content,write_obj->size);\n    LuaCEmbedResponse *response = LuaCEmbed_send_str(sha);\n    free(sha);\n    Writeble_free(write_obj);\n    return response;\n}\n\n"
	}, {
		"path":	"src/sha/sha.h",
		"is_binary":	false,
		"content":	"\n\nLuaCEmbedResponse  * generate_sha_from_file(LuaCEmbed *args);\n\nLuaCEmbedResponse  * generate_sha_from_folder_by_content(LuaCEmbed *args);\n\nLuaCEmbedResponse  * generate_sha_from_folder_by_last_modification(LuaCEmbed *args);\n\nLuaCEmbedResponse  * generate_sha(LuaCEmbed *args);\n\n"
	}, {
		"path":	"src/transaction/"
	}, {
		"path":	"src/transaction/action_transactions/"
	}, {
		"path":	"src/transaction/action_transactions/action_transaction.c",
		"is_binary":	false,
		"content":	"\n\nLuaCEmbedResponse  *action_transaction_get_transaction_type_code(LuaCEmbedTable *self,LuaCEmbed *args){\n    DtwActionTransaction *transaction = (DtwActionTransaction *) LuaCembedTable_get_long_prop(self,ACTION_TRANSACTION_POINTER);\n    return LuaCEmbed_send_long(transaction->action_type);\n}\n\nLuaCEmbedResponse  *action_transaction_get_transaction_type(LuaCEmbedTable *self,LuaCEmbed *args){\n    DtwActionTransaction *transaction = (DtwActionTransaction *) LuaCembedTable_get_long_prop(self,ACTION_TRANSACTION_POINTER);\n   int type = transaction->action_type;\n   const char *converted = DtwActionTransaction_convert_action_to_string(type);\n   return LuaCEmbed_send_str_reference(converted);\n}\n\n\nLuaCEmbedResponse  *action_transaction_get_content(LuaCEmbedTable *self,LuaCEmbed *args){\n    DtwActionTransaction *transaction = (DtwActionTransaction *) LuaCembedTable_get_long_prop(self,ACTION_TRANSACTION_POINTER);\n    if(!transaction->content){\n        return NULL;\n    }\n    return LuaCEmbed_send_raw_string_reference((char*)transaction->content, transaction->size);\n}\n\n\nLuaCEmbedResponse  *action_transaction_set_content(LuaCEmbedTable *self,LuaCEmbed *args){\n    Writeble  *write_obj = create_writeble(args,0);\n    if(write_obj->error){\n        LuaCEmbedResponse *response =  write_obj->error;\n        Writeble_free(write_obj);\n        return  response;\n    }\n    DtwActionTransaction *transaction = (DtwActionTransaction *) LuaCembedTable_get_long_prop(self,ACTION_TRANSACTION_POINTER);\n\n    if(transaction->content){\n        free(transaction->content);\n    }\n    transaction->content = (unsigned  char *)malloc((write_obj->size + 1)* sizeof(unsigned  char));\n    memcpy(transaction->content,write_obj->content,write_obj->size);\n    transaction->size = write_obj->size;\n    Writeble_free(write_obj);\n    return NULL;\n}\n\n\nLuaCEmbedResponse  *action_transaction_set_source(LuaCEmbedTable *self,LuaCEmbed *args){\n    char *new_source = LuaCEmbed_get_str_arg(args, 0);\n\n    if (LuaCEmbed_has_errors(args)) {\n        char *error = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error);\n    }\n\n    DtwActionTransaction *transaction = (DtwActionTransaction *) LuaCembedTable_get_long_prop(self,\n                                                                                          ACTION_TRANSACTION_POINTER);\n\n    if (transaction->source != NULL) {\n        free(transaction->source);\n    }\n    transaction->source = strdup(new_source);\n\n    return NULL;\n}\n\nLuaCEmbedResponse  *action_transaction_set_dest(LuaCEmbedTable *self,LuaCEmbed *args){\n\n    char *new_dest = LuaCEmbed_get_str_arg(args,0);\n\n    if(LuaCEmbed_has_errors(args)) {\n        char * error = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error);\n    }\n    DtwActionTransaction *transaction = (DtwActionTransaction *) LuaCembedTable_get_long_prop(self,ACTION_TRANSACTION_POINTER);\n\n    if (transaction->dest != NULL) {\n        free(transaction->dest);\n    }\n    transaction->dest = strdup(new_dest);\n\n    return NULL;\n}\n\nLuaCEmbedResponse  *action_transaction_get_source(LuaCEmbedTable *self,LuaCEmbed *args){\n\n    DtwActionTransaction *transaction = (DtwActionTransaction *) LuaCembedTable_get_long_prop(self,\n                                                                                          ACTION_TRANSACTION_POINTER);\n    if (transaction->source) {\n        return LuaCEmbed_send_str_reference(transaction->source);\n    }\n    return NULL;\n}\n\nLuaCEmbedResponse  *action_transaction_get_dest(LuaCEmbedTable *self,LuaCEmbed *args){\n    DtwActionTransaction *transaction = (DtwActionTransaction*)LuaCembedTable_get_long_prop(self,ACTION_TRANSACTION_POINTER);\n    if(transaction->dest){\n        return LuaCEmbed_send_str_reference(transaction->dest);\n    }\n    return  NULL;\n}\n\nLuaCEmbedTable *raw_create_action_transaction(LuaCEmbed *args,DtwActionTransaction *transaction){\n    LuaCEmbedTable * table = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_set_long_prop(table,DTW_TYPE,DTW_ACTION_TRANSACTION_TYPE);\n    LuaCEmbedTable_set_long_prop(table,ACTION_TRANSACTION_POINTER,(long long)transaction);\n    LuaCEmbedTable_set_method(table,LUA_DO_THE_WORLD_GET_DEST,action_transaction_get_dest);\n    LuaCEmbedTable_set_method(table,LUA_DO_THE_WORLD_SET_DEST,action_transaction_set_dest);\n    LuaCEmbedTable_set_method(table,LUA_DO_THE_WORLD_GET_SOURCE,action_transaction_get_source);\n    LuaCEmbedTable_set_method(table, LUA_DO_THE_WORLD_SET_SOURCE, action_transaction_set_source);\n    LuaCEmbedTable_set_method(table, LUA_DO_THE_WORLD_GET_TRANSACTION_TYPE_TEXT, action_transaction_get_transaction_type);\n    LuaCEmbedTable_set_method(table, LUA_DO_THE_WORLD_GET_TRANSACTION_TYPE_CODE,action_transaction_get_transaction_type_code);\n    LuaCEmbedTable_set_method(table, LUA_DO_THE_WORLD_GET_CONTENT, action_transaction_get_content);\n    LuaCEmbedTable_set_method(table, LUA_DO_THE_WORLD_SET_CONTENT, action_transaction_set_content);\n\n    return  table;\n}"
	}, {
		"path":	"src/transaction/action_transactions/action_transaction.h",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse  *action_transaction_get_transaction_type_code(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse  *action_transaction_get_transaction_type(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse  *action_transaction_get_content(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse  *action_transaction_set_content(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse  *action_transaction_set_source(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse  *action_transaction_set_dest(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse  *action_transaction_get_source(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse  *action_transaction_get_dest(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedTable *raw_create_action_transaction(LuaCEmbed *args,DtwActionTransaction *transaction);\n"
	}, {
		"path":	"src/transaction/declaration.h",
		"is_binary":	false,
		"content":	"#include \"action_transactions/action_transaction.h\"\n#include \"transactions/declaration.h\"\n"
	}, {
		"path":	"src/transaction/definition.h",
		"is_binary":	false,
		"content":	"#include \"action_transactions/action_transaction.c\"\n#include \"transactions/definitions.h\""
	}, {
		"path":	"src/transaction/transactions/"
	}, {
		"path":	"src/transaction/transactions/actions/"
	}, {
		"path":	"src/transaction/transactions/actions/actions.c",
		"is_binary":	false,
		"content":	"LuaCEmbedResponse * transaction_write(LuaCEmbedTable *self,LuaCEmbed *args){\n\n    char *filename = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n\n\n    Writeble  *write_obj = create_writeble(args,1);\n    if(write_obj->error){\n        LuaCEmbedResponse *response =  write_obj->error;\n        Writeble_free(write_obj);\n        return  response;\n    }\n\n    DtwTransaction *t = (DtwTransaction*)LuaCembedTable_get_long_prop(self,TRANSACTION_POINTER);\n    DtwTransaction_write_any(t,filename,write_obj->content,write_obj->size,write_obj->is_binary);\n    Writeble_free(write_obj);\n    return  LuaCEmbed_send_table(self);\n}\n\n\nLuaCEmbedResponse * transaction_remove_any(LuaCEmbedTable *self,LuaCEmbed *args) {\n    char *source = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n    DtwTransaction *t = (DtwTransaction*)LuaCembedTable_get_long_prop(self,TRANSACTION_POINTER);\n    DtwTransaction_delete_any(t,source);\n    return  LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse * transaction_copy_any(LuaCEmbedTable *self,LuaCEmbed *args) {\n    char *source = LuaCEmbed_get_str_arg(args,0);\n    char *dest = LuaCEmbed_get_str_arg(args,1);\n\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n    DtwTransaction *t = (DtwTransaction*)LuaCembedTable_get_long_prop(self,TRANSACTION_POINTER);\n    DtwTransaction_copy_any(t,source,dest);\n    return  LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse * transaction_move_any(LuaCEmbedTable *self,LuaCEmbed *args) {\n    char *source = LuaCEmbed_get_str_arg(args,0);\n    char *dest = LuaCEmbed_get_str_arg(args,1);\n\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n    DtwTransaction *t = (DtwTransaction*)LuaCembedTable_get_long_prop(self,TRANSACTION_POINTER);\n    DtwTransaction_move_any(t,source,dest);\n    return  LuaCEmbed_send_table(self);\n}\n"
	}, {
		"path":	"src/transaction/transactions/actions/actions.h",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse * transaction_write(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * transaction_remove_any(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * transaction_copy_any(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * transaction_move_any(LuaCEmbedTable *self,LuaCEmbed *args);\n"
	}, {
		"path":	"src/transaction/transactions/basic/"
	}, {
		"path":	"src/transaction/transactions/basic/basic.c",
		"is_binary":	false,
		"content":	"\n\n\n\n\n\nLuaCEmbedResponse * transaction_commit(LuaCEmbedTable *self,LuaCEmbed *args) {\n\n    const char *path = NULL;\n    if(LuaCEmbed_get_total_args(args) > 0){\n        path  = LuaCEmbed_get_str_arg(args,0);\n    }\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n    DtwTransaction *t = (DtwTransaction*)LuaCembedTable_get_long_prop(self,TRANSACTION_POINTER);\n    DtwTransaction_commit(t,path);\n    return  LuaCEmbed_send_table(self);\n}\n\n\n\nLuaCEmbedResponse * transaction_delete(LuaCEmbedTable *self,LuaCEmbed *args) {\n    DtwTransaction *t = (DtwTransaction*)LuaCembedTable_get_long_prop(self,TRANSACTION_POINTER);\n    bool ref = LuaCembedTable_get_bool_prop(self,IS_A_REF);\n\n    if(!ref){\n        DtwTransaction_free(t);\n    }\n    return  NULL;\n}\n\n\nvoid  private_transaction_add_base_methods(LuaCEmbedTable *self,DtwTransaction *transaction){\n    LuaCEmbedTable_set_long_prop(self,TRANSACTION_POINTER,(long long)transaction);\n    LuaCEmbedTable_set_method(self,WRITE_METHOD,transaction_write);\n    LuaCEmbedTable_set_method(self,COPY_ANY_METHOD,transaction_copy_any);\n    LuaCEmbedTable_set_method(self,REMOVE_ANY_METHOD,transaction_remove_any);\n    LuaCEmbedTable_set_method(self,MOVE_ANY_METHOD,transaction_move_any);\n    LuaCEmbedTable_set_method(self,COPY_ANY_METHOD,transaction_copy_any);\n    LuaCEmbedTable_set_method(self,COMMIT_METHOD,transaction_commit);\n    LuaCEmbedTable_set_method(self,DUMP_TO_JSON_FILE_METHOD,transaction_dumps_to_json_file);\n    LuaCEmbedTable_set_method(self,DUMP_TO_JSON_STRING,transaction_dumps_to_json_string);\n    LuaCEmbedTable_set_method(self,LIST_METHOD,transaction_list);\n    LuaCEmbedTable_set_method(self,EACH_METHOD,transaction_foreach);\n    LuaCEmbedTable_set_method(self,MAP_METHOD,transaction_map);\n    LuaCEmbedTable_set_method(self,COUNT_METHOD,transaction_count);\n    LuaCEmbedTable_set_method(self,INDEX_METHOD,transaction_index);\n    LuaCEmbedTable_set_method(self,FIND_METHOD,transaction_find);\n    LuaCEmbedTable_set_method(self,FILTER_METHOD,transaction_filter);\n    LuaCEmbedTable_set_method(self,DELETE_METHOD,transaction_delete);\n\n}\n\n\nLuaCEmbedResponse * transaction_new_transaction(LuaCEmbed *args){\n    LuaCEmbedTable * self = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_set_bool_prop(self,IS_A_REF,false);\n    DtwTransaction *transaction = newDtwTransaction();\n    LuaCEmbedTable_set_long_prop(self,TRANSACTION_POINTER,(long)transaction);\n    if(LuaCEmbed_has_errors(self->main_object)){\n        printf(\"error %s\\n\", LuaCEmbed_get_error_message(self->main_object));\n    }\n\n    private_transaction_add_base_methods(self,transaction);\n    return LuaCEmbed_send_table(self);\n}\n"
	}, {
		"path":	"src/transaction/transactions/basic/basic.h",
		"is_binary":	false,
		"content":	"LuaCEmbedResponse * transaction_commit(LuaCEmbedTable *self,LuaCEmbed *args);\n\n\nLuaCEmbedResponse * transaction_delete(LuaCEmbedTable *self,LuaCEmbed *args);\n\nvoid  private_transaction_add_base_methods(LuaCEmbedTable *self,DtwTransaction *transaction);\n\n\nLuaCEmbedResponse * transaction_new_transaction(LuaCEmbed *args);"
	}, {
		"path":	"src/transaction/transactions/declaration.h",
		"is_binary":	false,
		"content":	"#include \"basic/basic.h\"\n#include \"json_parsment/json_parsement.h\"\n#include \"actions/actions.h\"\n#include \"iterables/iterables.h\""
	}, {
		"path":	"src/transaction/transactions/definitions.h",
		"is_binary":	false,
		"content":	"\n#include \"basic/basic.c\"\n#include \"json_parsment/json_parsement.c\"\n#include \"actions/actions.c\"\n#include \"iterables/iterables.c\""
	}, {
		"path":	"src/transaction/transactions/iterables/"
	}, {
		"path":	"src/transaction/transactions/iterables/iterables.c",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse  * transaction_list(LuaCEmbedTable *self,LuaCEmbed *args) {\n    DtwTransaction *transaction = (DtwTransaction*)LuaCembedTable_get_long_prop(self,TRANSACTION_POINTER);\n\n    LuaCEmbedTable *multi_response = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable *elements = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_append_table(multi_response,elements);\n    LuaCEmbedTable_append_long(multi_response,transaction->size);\n    for(long i = 0 ; i < transaction->size; i++){\n        DtwActionTransaction *action = transaction->actions[i];\n        LuaCEmbedTable  *table = raw_create_action_transaction(args,action);\n        LuaCEmbedTable_append_table(elements,table);\n    }\n    return LuaCEmbed_send_multi_return(multi_response);\n}\n\n\nLuaCEmbedResponse  * transaction_index(LuaCEmbedTable *self,LuaCEmbed *args){\n\n    long index = LuaCEmbed_get_long_arg(args,1);\n    if(LuaCEmbed_has_errors(args)){\n        printf(\"pegou aqui passando %s\\n\",LuaCEmbed_get_str_arg(args,1));\n        char *error = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error);\n    }\n    long converted = index -1;\n\n    DtwTransaction *transaction = (DtwTransaction*)LuaCembedTable_get_long_prop(self,TRANSACTION_POINTER);\n    if(converted >= transaction->size || converted < 0){\n        return NULL;\n    }\n    LuaCEmbedTable  *table = raw_create_action_transaction(args,transaction->actions[converted]);\n    return LuaCEmbed_send_table(table);\n}\n\nLuaCEmbedResponse  * transaction_foreach(LuaCEmbedTable *self,LuaCEmbed *args){\n    DtwTransaction *transaction = (DtwTransaction*)LuaCembedTable_get_long_prop(self,TRANSACTION_POINTER);\n    for(long i = 0 ; i < transaction->size; i++){\n        DtwActionTransaction *action = transaction->actions[i];\n        LuaCEmbedTable  *table = raw_create_action_transaction(args,action);\n        LuaCEmbedTable  * args_of_callbac = LuaCembed_new_anonymous_table(args);\n        LuaCEmbedTable_append_table(args_of_callbac,table);\n        LuaCEmbed_run_args_lambda(args,0,args_of_callbac,0);\n        if(LuaCEmbed_has_errors(args)){\n            char *error = LuaCEmbed_get_error_message(args);\n            return LuaCEmbed_send_error(error);\n        }\n    }\n    return  NULL;\n}\n\nLuaCEmbedResponse  * transaction_filter(LuaCEmbedTable *self,LuaCEmbed *args){\n\n    DtwTransaction *transaction = (DtwTransaction*)LuaCembedTable_get_long_prop(self,TRANSACTION_POINTER);\n\n    LuaCEmbedTable *multi_response = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable *final_map = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_append_table(multi_response,final_map);\n    long total = 0;\n    for(long i = 0 ; i < transaction->size; i++){\n        DtwActionTransaction *action = transaction->actions[i];\n        LuaCEmbedTable  *table = raw_create_action_transaction(args,action);\n        LuaCEmbedTable  * args_of_callbac = LuaCembed_new_anonymous_table(args);\n        LuaCEmbedTable_append_table(args_of_callbac,table);\n        LuaCEmbedTable * user_response = LuaCEmbed_run_args_lambda(args,0,args_of_callbac,1);\n        if(LuaCEmbed_has_errors(args)){\n\n            char *error = LuaCEmbed_get_error_message(args);\n            return LuaCEmbed_send_error(error);\n        }\n        long size = LuaCEmbedTable_get_full_size(user_response);\n        bool append_element = false;\n        if(size ==1){\n            append_element = LuaCEmbedTable_get_bool_by_index(user_response,0);\n        }\n\n        if(LuaCEmbed_has_errors(args)){\n            char *error = LuaCEmbed_get_error_message(args);\n            return LuaCEmbed_send_error(error);\n        }\n        if(append_element) {\n            total+=1;\n            LuaCEmbedTable_append_table(final_map,table);\n        }\n\n    }\n    LuaCEmbedTable_append_long(multi_response,total);\n\n    return  LuaCEmbed_send_multi_return(multi_response);\n\n}\nLuaCEmbedResponse  * transaction_map(LuaCEmbedTable *self,LuaCEmbed *args){\n\n    DtwTransaction *transaction = (DtwTransaction*)LuaCembedTable_get_long_prop(self,TRANSACTION_POINTER);\n\n    LuaCEmbedTable *multi_response = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable *final_map = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_append_table(multi_response,final_map);\n    LuaCEmbedTable_append_long(multi_response,transaction->size);\n\n    for(long i = 0 ; i < transaction->size; i++){\n        DtwActionTransaction *action = transaction->actions[i];\n        LuaCEmbedTable  *table = raw_create_action_transaction(args,action);\n        LuaCEmbedTable  * args_of_callbac = LuaCembed_new_anonymous_table(args);\n        LuaCEmbedTable_append_table(args_of_callbac,table);\n        LuaCEmbedTable * response_values = LuaCEmbed_run_args_lambda(args,0,args_of_callbac,1);\n        if(LuaCEmbed_has_errors(args)){\n\n            char *error = LuaCEmbed_get_error_message(args);\n            return LuaCEmbed_send_error(error);\n        }\n\n        long size = LuaCEmbedTable_get_full_size(response_values);\n        if(size > 0){\n            LuaCEmbedTable_append_evaluation(final_map,\"%s[1]\",response_values->global_name);\n        }\n    }\n\n    return  LuaCEmbed_send_multi_return(multi_response);\n\n}\n\nLuaCEmbedResponse  * transaction_find(LuaCEmbedTable *self,LuaCEmbed *args){\n\n    DtwTransaction *transaction = (DtwTransaction*)LuaCembedTable_get_long_prop(self,TRANSACTION_POINTER);\n    for(long i = 0 ; i < transaction->size; i++){\n        DtwActionTransaction *action = transaction->actions[i];\n        LuaCEmbedTable  *table = raw_create_action_transaction(args,action);\n        LuaCEmbedTable  * args_of_callbac = LuaCembed_new_anonymous_table(args);\n        LuaCEmbedTable_append_table(args_of_callbac,table);\n        LuaCEmbedTable * response_values = LuaCEmbed_run_args_lambda(args,0,args_of_callbac,1);\n        if(LuaCEmbed_has_errors(args)){\n            char *error = LuaCEmbed_get_error_message(args);\n            return LuaCEmbed_send_error(error);\n        }\n        long size = LuaCEmbedTable_get_full_size(response_values);\n        bool return_element = false;\n        if(size > 0 ){\n            return_element = LuaCEmbedTable_get_bool_by_index(response_values,0);\n        }\n        if(LuaCEmbed_has_errors(args)){\n\n            char *error = LuaCEmbed_get_error_message(args);\n            return LuaCEmbed_send_error(error);\n        }\n\n        if(return_element) {\n            return LuaCEmbed_send_table(table);\n        }\n    }\n\n    return  NULL;\n}\n\n\nLuaCEmbedResponse  * transaction_count(LuaCEmbedTable *self,LuaCEmbed *args){\n\n    DtwTransaction *transaction = (DtwTransaction*)LuaCembedTable_get_long_prop(self,TRANSACTION_POINTER);\n    long total  = 0;\n    for(long i = 0 ; i < transaction->size; i++){\n        DtwActionTransaction *action = transaction->actions[i];\n        LuaCEmbedTable  *table = raw_create_action_transaction(args,action);\n        LuaCEmbedTable  * args_of_callbac = LuaCembed_new_anonymous_table(args);\n        LuaCEmbedTable_append_table(args_of_callbac,table);\n        LuaCEmbedTable * response_values = LuaCEmbed_run_args_lambda(args,0,args_of_callbac,1);\n        if(LuaCEmbed_has_errors(args)){\n            char *error = LuaCEmbed_get_error_message(args);\n            return LuaCEmbed_send_error(error);\n        }\n        long size = LuaCEmbedTable_get_full_size(response_values);\n        bool append_element = false;\n        if(size >0){\n            append_element = LuaCEmbedTable_get_bool_by_index(response_values,0);\n        }\n\n        if(LuaCEmbed_has_errors(args)){\n            char *error = LuaCEmbed_get_error_message(args);\n            return LuaCEmbed_send_error(error);\n        }\n        if(append_element) {\n            total+=1;\n        }\n\n    }\n\n    return  LuaCEmbed_send_long(total);\n}\n\n"
	}, {
		"path":	"src/transaction/transactions/iterables/iterables.h",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse  * transaction_list(LuaCEmbedTable *self,LuaCEmbed *args);\n\n\nLuaCEmbedResponse  * transaction_index(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse  * transaction_foreach(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse  * transaction_filter(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse  * transaction_map(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse  * transaction_find(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse  * transaction_count(LuaCEmbedTable *self,LuaCEmbed *args);\n"
	}, {
		"path":	"src/transaction/transactions/json_parsment/"
	}, {
		"path":	"src/transaction/transactions/json_parsment/json_parsement.c",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse * transaction_dumps_to_json_file(LuaCEmbedTable *self,LuaCEmbed *args) {\n\n    char *filename = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n    DtwTransaction *t = (DtwTransaction*)LuaCembedTable_get_long_prop(self,TRANSACTION_POINTER);\n    DtwTransaction_dumps_to_json_file(t,filename);\n\n    return  LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse * transaction_dumps_to_json_string(LuaCEmbedTable *self,LuaCEmbed *args) {\n\n    DtwTransaction *t = (DtwTransaction*)LuaCembedTable_get_long_prop(self,TRANSACTION_POINTER);\n    cJSON *parsed = DtwTransaction_dumps_to_json(t);\n    char * content = cJSON_Print(parsed);\n\n    LuaCEmbedResponse  *response = LuaCEmbed_send_str(content);\n    cJSON_Delete(parsed);\n    free(content);\n    return response;\n}\n\nLuaCEmbedResponse * create_transaction_from_json_string(LuaCEmbed *args) {\n\n    char *content = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n    UniversalGarbage *garbage = newUniversalGarbage();\n\n    cJSON * parsed = cJSON_Parse(content);\n    UniversalGarbage_add(garbage,cJSON_Delete,parsed);\n    if(parsed == NULL) {\n        LuaCEmbedResponse *response  = LuaCEmbed_send_error(INVALID_JSON_STRING);\n        UniversalGarbage_free(garbage);\n        return  response;\n    }\n\n    DtwTransaction * transaction_obj = newDtwTransaction_from_json(parsed);\n    if(transaction_obj == NULL) {\n        DtwJsonTransactionError * error =  dtw_validate_json_transaction(parsed);\n        UniversalGarbage_add(garbage,DtwJsonTransactionError_free,error);\n        LuaCEmbedResponse *response  = LuaCEmbed_send_error(error->mensage);\n        UniversalGarbage_free(garbage);\n        return  response;\n    }\n\n    LuaCEmbedTable * self = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_set_bool_prop(self,IS_A_REF,false);\n    private_transaction_add_base_methods(self,transaction_obj);\n    UniversalGarbage_free(garbage);\n    return LuaCEmbed_send_table(self);\n\n\n}\nLuaCEmbedResponse * try_create_transaction_from_json_string(LuaCEmbed *args) {\n\n    char *content = LuaCEmbed_get_str_arg(args,0);\n    args_protect(args)\n    UniversalGarbage *garbage = newUniversalGarbage();\n\n    cJSON * parsed = cJSON_Parse(content);\n    UniversalGarbage_add(garbage,cJSON_Delete,parsed);\n\n    if(parsed == NULL) {\n        LuaCEmbedTable *multiresponse = LuaCembed_new_anonymous_table(args);\n        LuaCEmbedTable_append_bool(multiresponse,false);\n        LuaCEmbedTable_append_string(multiresponse,INVALID_JSON_STRING);\n        UniversalGarbage_free(garbage);\n        return  LuaCEmbed_send_multi_return(multiresponse);\n    }\n\n    DtwTransaction * transaction_obj = newDtwTransaction_from_json(parsed);\n    if(transaction_obj == NULL) {\n        LuaCEmbedTable *multiresponse = LuaCembed_new_anonymous_table(args);\n        DtwJsonTransactionError * error =  dtw_validate_json_transaction(parsed);\n        UniversalGarbage_add(garbage,DtwJsonTransactionError_free,error);\n        LuaCEmbedTable_append_bool(multiresponse,false);\n        LuaCEmbedTable_append_string(multiresponse,error->mensage);\n        UniversalGarbage_free(garbage);\n        return  LuaCEmbed_send_multi_return(multiresponse);\n    }\n\n    LuaCEmbedTable *multiresponse = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_append_bool(multiresponse,true);\n    LuaCEmbedTable * self = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_append_table(multiresponse,self);\n    LuaCEmbedTable_set_bool_prop(self,IS_A_REF,false);\n    private_transaction_add_base_methods(self,transaction_obj);\n    UniversalGarbage_free(garbage);\n    return  LuaCEmbed_send_multi_return(multiresponse);\n}\n\n\nLuaCEmbedResponse * create_transaction_from_json_file(LuaCEmbed *args) {\n    char *filename = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_message = LuaCEmbed_get_error_message(args);\n        return  LuaCEmbed_send_error(error_message);\n    }\n    UniversalGarbage *garbage = newUniversalGarbage();\n\n    char *content = dtw_load_string_file_content(filename);\n    UniversalGarbage_add_simple(garbage,content);\n\n    if(content == NULL) {\n        char *error = private_LuaCembed_format(FILE_NOT_FOUND,filename);\n        UniversalGarbage_add_simple(garbage,error);\n        LuaCEmbedResponse *response  = LuaCEmbed_send_error(error);\n        UniversalGarbage_free(garbage);\n        return  response;\n    }\n    cJSON * parsed = cJSON_Parse(content);\n    UniversalGarbage_add(garbage,cJSON_Delete,parsed);\n\n\n    if(parsed == NULL) {\n        char *error = private_LuaCembed_format(INVALID_JSON_FILE,filename);\n        UniversalGarbage_add_simple(garbage,error);\n        LuaCEmbedResponse *response  = LuaCEmbed_send_error(error);\n        UniversalGarbage_free(garbage);\n        return  response;\n    }\n\n\n    DtwTransaction * transaction_obj = newDtwTransaction_from_json(parsed);\n    if(transaction_obj == NULL) {\n        DtwJsonTransactionError * error =  dtw_validate_json_transaction(parsed);\n        UniversalGarbage_add(garbage,DtwJsonTransactionError_free,error);\n        LuaCEmbedResponse *response  = LuaCEmbed_send_error(error->mensage);\n        UniversalGarbage_free(garbage);\n        return  response;\n    }\n\n    LuaCEmbedTable * self = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_set_bool_prop(self,IS_A_REF,false);\n    private_transaction_add_base_methods(self,transaction_obj);\n    UniversalGarbage_free(garbage);\n    return LuaCEmbed_send_table(self);\n\n\n}\nLuaCEmbedResponse * try_create_transaction_from_json_file(LuaCEmbed *args) {\n\n    char *filename = LuaCEmbed_get_str_arg(args,0);\n    args_protect(args)\n    UniversalGarbage *garbage = newUniversalGarbage();\n\n    char *content = dtw_load_string_file_content(filename);\n    UniversalGarbage_add_simple(garbage,content);\n\n    if(content == NULL) {\n        LuaCEmbedTable * multi_response = LuaCembed_new_anonymous_table(args);\n        char *error = private_LuaCembed_format(FILE_NOT_FOUND,filename);\n        UniversalGarbage_add_simple(garbage,error);\n        LuaCEmbedTable_append_bool(multi_response,false);\n        LuaCEmbedTable_append_string(multi_response,error);\n        UniversalGarbage_free(garbage);\n        return  LuaCEmbed_send_multi_return(multi_response);\n    }\n    cJSON * parsed = cJSON_Parse(content);\n    UniversalGarbage_add(garbage,cJSON_Delete,parsed);\n\n\n    if(parsed == NULL) {\n        LuaCEmbedTable * multi_response = LuaCembed_new_anonymous_table(args);\n        char *error = private_LuaCembed_format(INVALID_JSON_FILE,filename);\n        UniversalGarbage_add_simple(garbage,error);\n        LuaCEmbedTable_append_bool(multi_response,false);\n        LuaCEmbedTable_append_string(multi_response,error);\n        UniversalGarbage_free(garbage);\n        return  LuaCEmbed_send_multi_return(multi_response);\n    }\n\n\n    DtwTransaction * transaction_obj = newDtwTransaction_from_json(parsed);\n    if(transaction_obj == NULL) {\n        LuaCEmbedTable * multi_response = LuaCembed_new_anonymous_table(args);\n        DtwJsonTransactionError * error =  dtw_validate_json_transaction(parsed);\n        UniversalGarbage_add(garbage,DtwJsonTransactionError_free,error);\n        LuaCEmbedTable_append_bool(multi_response,false);\n        LuaCEmbedTable_append_string(multi_response,error->mensage);\n        UniversalGarbage_free(garbage);\n        return  LuaCEmbed_send_multi_return(multi_response);\n    }\n    LuaCEmbedTable * multi_response = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_append_bool(multi_response,true);\n    LuaCEmbedTable * self = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_append_table(multi_response,self);\n    LuaCEmbedTable_set_bool_prop(self,IS_A_REF,false);\n    private_transaction_add_base_methods(self,transaction_obj);\n    UniversalGarbage_free(garbage);\n    return LuaCEmbed_send_multi_return(multi_response);\n\n\n}"
	}, {
		"path":	"src/transaction/transactions/json_parsment/json_parsement.h",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse * transaction_dumps_to_json_file(LuaCEmbedTable *self,LuaCEmbed *args);\n\n\n\nLuaCEmbedResponse * transaction_dumps_to_json_string(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * create_transaction_from_json_string(LuaCEmbed *args);\n\nLuaCEmbedResponse * try_create_transaction_from_json_string(LuaCEmbed *args);\n\nLuaCEmbedResponse * create_transaction_from_json_file(LuaCEmbed *args);\n\nLuaCEmbedResponse * try_create_transaction_from_json_file(LuaCEmbed *args);\n"
	}, {
		"path":	"src/tree/"
	}, {
		"path":	"src/tree/declaration.h",
		"is_binary":	false,
		"content":	"#include \"tree_part/tree_part.h\"\n#include  \"tree/declaration.h\""
	}, {
		"path":	"src/tree/definition.h",
		"is_binary":	false,
		"content":	"#include \"tree_part/tree_part.c\"\n#include  \"tree/definition.h\""
	}, {
		"path":	"src/tree/tree/"
	}, {
		"path":	"src/tree/tree/basic/"
	}, {
		"path":	"src/tree/tree/basic/basic.c",
		"is_binary":	false,
		"content":	"\n\n#include \"../iterables/iterables.h\"\n\nLuaCEmbedResponse *hardware_commit_tree(LuaCEmbedTable *self, LuaCEmbed *args){\n    DtwTree *self_tree = (DtwTree*)LuaCembedTable_get_long_prop(self,TREE_POINTER);\n    DtwTree_hardware_commit_tree(self_tree);\n    return  LuaCEmbed_send_table(self);\n}\n\n\nLuaCEmbedResponse *tree_get_size(LuaCEmbedTable *self, LuaCEmbed *args){\n    DtwTree *self_tree = (DtwTree*)LuaCembedTable_get_long_prop(self,TREE_POINTER);\n    return LuaCEmbed_send_long(self_tree->size);\n}\n\n\n\nLuaCEmbedResponse *insecure_hardware_write_tree(LuaCEmbedTable *self, LuaCEmbed *args){\n    DtwTree *self_tree = (DtwTree*)LuaCembedTable_get_long_prop(self,TREE_POINTER);\n    DtwTree_insecure_hardware_write_tree(self_tree);\n    return LuaCEmbed_send_table(self);\n}\n\n\nLuaCEmbedResponse *insecure_hardware_remove_tree(LuaCEmbedTable *self, LuaCEmbed *args){\n    DtwTree *self_tree = (DtwTree*)LuaCembedTable_get_long_prop(self,TREE_POINTER);\n    DtwTree_insecure_hardware_remove_tree(self_tree);\n    return LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse * tree_delete(LuaCEmbedTable *self,LuaCEmbed *args){\n    DtwTree *self_tree = (DtwTree*)LuaCembedTable_get_long_prop(self,TREE_POINTER);\n    DtwTree_free(self_tree);\n    return  NULL;\n}\n\nLuaCEmbedTable * raw_create_tree(LuaCEmbed *args,DtwTree *tree){\n    LuaCEmbedTable *self = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_set_long_prop(self,TREE_POINTER,(long long)tree);\n    LuaCEmbedTable_set_method(self,TREE_NEW_TREE_PART_EMPTY,new_tree_part_empty);\n    LuaCEmbedTable_set_method(self,TREE_NEW_TREE_PART_LOADING,new_tree_part_loading);\n    LuaCEmbedTable_set_method(self,GET_TREE_PART_BY_INDEX_METHOD,get_tree_part_by_index);\n    LuaCEmbedTable_set_method(self,INSECURE_HARDWARE_WRITE_TREE,insecure_hardware_write_tree);\n    LuaCEmbedTable_set_method(self,INSECURE_HARDWARE_REMOVE_TREE,insecure_hardware_remove_tree);\n    LuaCEmbedTable_set_method(self,COMMIT_METHOD,hardware_commit_tree);\n    LuaCEmbedTable_set_method(self,GET_SIZE_METHOD,tree_get_size);\n    LuaCEmbedTable_set_method(self,GET_TREE_PART_BY_NAME,tree_get_tree_part_by_name);\n    LuaCEmbedTable_set_method(self,GET_TREE_PART_BY_PATH,tree_get_tree_part_by_path);\n    LuaCEmbedTable_set_method(self,LIST_METHOD,tree_list);\n    LuaCEmbedTable_set_method(self,FIND_METHOD,tree_find);\n    LuaCEmbedTable_set_method(self,COUNT_METHOD,tree_count);\n    LuaCEmbedTable_set_method(self,MAP_METHOD,tree_map);\n    LuaCEmbedTable_set_method(self,EACH_METHOD,tree_foreach);\n    LuaCEmbedTable_set_method(self,FILTER_METHOD,tree_filter);\n    LuaCEmbedTable_set_method(self,DUMP_TO_JSON_STRING,tree_dump_to_json_string);\n    LuaCEmbedTable_set_method(self,DUMP_TO_JSON_FILE_METHOD,tree_dump_to_json_file);\n    LuaCEmbedTable_set_method(self,DELETE_METHOD,tree_delete);\n    return self;\n}\n\nLuaCEmbedResponse * create_empty_tree(LuaCEmbed *args){\n    DtwTree * tree = newDtwTree();\n    LuaCEmbedTable *self = raw_create_tree(args,tree);\n    return LuaCEmbed_send_table(self);\n}\n\nDtwTreeProps create_tree_props(LuaCEmbedTable *user_props){\n    DtwTreeProps  tree_props = {0};\n    tree_props.content = get_table_props_or_default_bool(user_props,TREE_PROPS_CONTENT,DTW_INCLUDE) +1;\n    tree_props.content_data = get_table_props_or_default_bool(user_props,TREE_PROPS_CONTENT_DATA,DTW_INCLUDE)+1;\n    tree_props.hadware_data = get_table_props_or_default_bool(user_props,TREE_PROPS_HARDWARE_DATA,DTW_INCLUDE)+1;\n    tree_props.ignored_elements = get_table_props_or_default_bool(user_props,TREE_PROPS_IGNORED_ELEMENTS,DTW_INCLUDE)+1;\n    tree_props.minification = get_table_props_or_default_bool(user_props,TREE_PROPS_MIMIFICATION,DTW_NOT_MIMIFY)+1;\n    tree_props.path_atributes = get_table_props_or_default_bool(user_props,TREE_PROPS_PATH_ATTRIBUTES,DTW_INCLUDE)+1;\n    return tree_props;\n}\n\nLuaCEmbedResponse * create_tree_fro_hardware(LuaCEmbed *args){\n\n    char *path = LuaCEmbed_get_str_arg(args,0);\n    LuaCEmbedTable *props_table = NULL;\n    if(LuaCEmbed_get_arg_type(args,1) != LUA_CEMBED_NIL){\n        props_table = LuaCEmbed_get_arg_table(args,1);\n    }\n\n    if(LuaCEmbed_has_errors(args)){\n        char *error_msg = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error_msg);\n    }\n\n    DtwTreeProps props = create_tree_props(props_table);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_msg = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error_msg);\n    }\n    DtwTree * tree = newDtwTree();\n    LuaCEmbedTable *self = raw_create_tree(args,tree);\n    DtwTree_add_tree_from_hardware(tree,path,props);\n    return LuaCEmbed_send_table(self);\n}\n"
	}, {
		"path":	"src/tree/tree/basic/basic.h",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse *hardware_commit_tree(LuaCEmbedTable *self, LuaCEmbed *args);\n\nLuaCEmbedResponse *tree_get_size(LuaCEmbedTable *self, LuaCEmbed *args);\n\n\n\n\nLuaCEmbedResponse *insecure_hardware_write_tree(LuaCEmbedTable *self, LuaCEmbed *args);\n\n\nLuaCEmbedResponse *insecure_hardware_remove_tree(LuaCEmbedTable *self, LuaCEmbed *args);\n\n\nLuaCEmbedTable * raw_create_tree(LuaCEmbed *args,DtwTree *tree);\n\n\nLuaCEmbedResponse * create_empty_tree(LuaCEmbed *args);\n\nDtwTreeProps create_tree_props(LuaCEmbedTable *user_props);\n\nLuaCEmbedResponse * tree_delete(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * create_tree_fro_hardware(LuaCEmbed *args);\n"
	}, {
		"path":	"src/tree/tree/declaration.h",
		"is_binary":	false,
		"content":	"#include \"basic/basic.h\"\n#include \"iterables/iterables.h\"\n#include \"json_tree/json_tree.h\"\n#include \"tree_parts/tree_parts.h\""
	}, {
		"path":	"src/tree/tree/definition.h",
		"is_binary":	false,
		"content":	"#include \"basic/basic.c\"\n#include \"iterables/iterables.c\"\n#include \"json_tree/json_tree.c\"\n#include \"tree_parts/tree_parts.c\""
	}, {
		"path":	"src/tree/tree/iterables/"
	}, {
		"path":	"src/tree/tree/iterables/iterables.c",
		"is_binary":	false,
		"content":	"LuaCEmbedResponse *tree_list(LuaCEmbedTable *self, LuaCEmbed *args) {\n    DtwTree *self_tree = (DtwTree*)LuaCembedTable_get_long_prop(self,TREE_POINTER);\n    LuaCEmbedTable *multi_response = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable *elements = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_append_table(multi_response,elements);\n    LuaCEmbedTable_append_long(multi_response,self_tree->size);\n\n    for(int i =0; i < self_tree->size;i++){\n        LuaCEmbedTable *tree_part = create_tree_part_reference(args,self_tree->tree_parts[i]);\n        LuaCEmbedTable_append_table(elements,tree_part);\n    }\n\n    return LuaCEmbed_send_multi_return(multi_response);\n}\n\nLuaCEmbedResponse *tree_find(LuaCEmbedTable *self, LuaCEmbed *args){\n    DtwTree *self_tree = (DtwTree*)LuaCembedTable_get_long_prop(self,TREE_POINTER);\n\n    for(int i =0; i < self_tree->size;i++){\n        LuaCEmbedTable *tree_part = create_tree_part_reference(args,self_tree->tree_parts[i]);\n        LuaCEmbedTable *args_to_call = LuaCembed_new_anonymous_table(args);\n        LuaCEmbedTable_append_table(args_to_call,tree_part);\n        LuaCEmbedTable *response = LuaCEmbed_run_args_lambda(args,0,args_to_call,1);\n        if(LuaCEmbed_has_errors(args)){\n            char *error_msg = LuaCEmbed_get_error_message(args);\n            return LuaCEmbed_send_error(error_msg);\n        }\n        long size = LuaCEmbedTable_get_full_size(response);\n        bool return_element = false;\n        if(size > 0 ){\n            return_element = LuaCEmbedTable_get_bool_by_index(response,0);\n        }\n        if(LuaCEmbed_has_errors(args)){\n\n            char *error = LuaCEmbed_get_error_message(args);\n            return LuaCEmbed_send_error(error);\n        }\n\n        if(return_element) {\n            return LuaCEmbed_send_table(tree_part);\n        }\n\n    }\n    return NULL;\n}\n\n\nLuaCEmbedResponse *tree_count(LuaCEmbedTable *self, LuaCEmbed *args){\n    DtwTree *self_tree = (DtwTree*)LuaCembedTable_get_long_prop(self,TREE_POINTER);\n    long total = 0;\n    for(int i =0; i < self_tree->size;i++){\n        LuaCEmbedTable *tree_part = create_tree_part_reference(args,self_tree->tree_parts[i]);\n        LuaCEmbedTable *args_to_call = LuaCembed_new_anonymous_table(args);\n        LuaCEmbedTable_append_table(args_to_call,tree_part);\n        LuaCEmbedTable *user_response = LuaCEmbed_run_args_lambda(args,0,args_to_call,1);\n        if(LuaCEmbed_has_errors(args)){\n            char *error_msg = LuaCEmbed_get_error_message(args);\n            return LuaCEmbed_send_error(error_msg);\n        }\n        long size = LuaCEmbedTable_get_full_size(user_response);\n        bool return_element = false;\n        if(size > 0 ){\n            return_element = LuaCEmbedTable_get_bool_by_index(user_response,0);\n        }\n        if(LuaCEmbed_has_errors(args)){\n\n            char *error = LuaCEmbed_get_error_message(args);\n            return LuaCEmbed_send_error(error);\n        }\n\n        if(return_element) {\n            total+=1;\n        }\n\n    }\n    return LuaCEmbed_send_long(total);\n}\n\nLuaCEmbedResponse *tree_filter(LuaCEmbedTable *self, LuaCEmbed *args){\n\n    DtwTree *self_tree = (DtwTree*)LuaCembedTable_get_long_prop(self,TREE_POINTER);\n    LuaCEmbedTable *multi_response = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable *final_map = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_append_table(multi_response,final_map);\n    long total = 0;\n\n\n    for(int i =0; i < self_tree->size;i++){\n        LuaCEmbedTable *tree_part = create_tree_part_reference(args,self_tree->tree_parts[i]);\n        LuaCEmbedTable *args_to_call = LuaCembed_new_anonymous_table(args);\n        LuaCEmbedTable_append_table(args_to_call,tree_part);\n        LuaCEmbedTable *user_response = LuaCEmbed_run_args_lambda(args,0,args_to_call,1);\n\n        if(LuaCEmbed_has_errors(args)){\n            char *error = LuaCEmbed_get_error_message(args);\n            return LuaCEmbed_send_error(error);\n        }\n        long size = LuaCEmbedTable_get_full_size(user_response);\n        bool append_element = false;\n        if(size >0){\n            append_element = LuaCEmbedTable_get_bool_by_index(user_response,0);\n        }\n\n        if(LuaCEmbed_has_errors(args)){\n            char *error = LuaCEmbed_get_error_message(args);\n            return LuaCEmbed_send_error(error);\n        }\n        if(append_element) {\n            total+=1;\n            LuaCEmbedTable_append_table(final_map,tree_part);\n        }\n\n    }\n    LuaCEmbedTable_append_long(multi_response,total);\n\n    return  LuaCEmbed_send_multi_return(multi_response);\n}\n\n\nLuaCEmbedResponse *tree_map(LuaCEmbedTable *self, LuaCEmbed *args){\n\n    DtwTree *self_tree = (DtwTree*)LuaCembedTable_get_long_prop(self,TREE_POINTER);\n    LuaCEmbedTable *multi_response = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable *final_map = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_append_table(multi_response,final_map);\n    LuaCEmbedTable_append_long(multi_response,self_tree->size);\n\n\n    for(int i =0; i < self_tree->size;i++){\n        LuaCEmbedTable *tree_part = create_tree_part_reference(args,self_tree->tree_parts[i]);\n        LuaCEmbedTable *args_to_call = LuaCembed_new_anonymous_table(args);\n        LuaCEmbedTable_append_table(args_to_call,tree_part);\n        LuaCEmbedTable *user_response = LuaCEmbed_run_args_lambda(args,0,args_to_call,1);\n\n        if(LuaCEmbed_has_errors(args)){\n            char *error = LuaCEmbed_get_error_message(args);\n            return LuaCEmbed_send_error(error);\n        }\n        long size = LuaCEmbedTable_get_full_size(user_response);\n        if(size >0){\n            LuaCEmbedTable_append_evaluation(final_map,\"%s[1]\",user_response->global_name);\n        }\n\n    }\n    return  LuaCEmbed_send_multi_return(multi_response);\n}\n\n\n\n\nLuaCEmbedResponse *tree_foreach(LuaCEmbedTable *self, LuaCEmbed *args){\n\n    DtwTree *self_tree = (DtwTree*)LuaCembedTable_get_long_prop(self,TREE_POINTER);\n\n    for(int i =0; i < self_tree->size;i++){\n        LuaCEmbedTable *tree_part = create_tree_part_reference(args,self_tree->tree_parts[i]);\n        LuaCEmbedTable *args_to_call = LuaCembed_new_anonymous_table(args);\n        LuaCEmbedTable_append_table(args_to_call,tree_part);\n        LuaCEmbed_run_args_lambda(args,0,args_to_call,1);\n        if(LuaCEmbed_has_errors(args)){\n            char *error_msg = LuaCEmbed_get_error_message(args);\n            printf(\"pegou aqui\\n\");\n            return LuaCEmbed_send_error(error_msg);\n        }\n\n    }\n    return NULL;\n}\n"
	}, {
		"path":	"src/tree/tree/iterables/iterables.h",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse *tree_list(LuaCEmbedTable *self, LuaCEmbed *args);\n\nLuaCEmbedResponse *tree_find(LuaCEmbedTable *self, LuaCEmbed *args);\n\nLuaCEmbedResponse *tree_count(LuaCEmbedTable *self, LuaCEmbed *args);\n\nLuaCEmbedResponse *tree_map(LuaCEmbedTable *self, LuaCEmbed *args);\n\nLuaCEmbedResponse *tree_filter(LuaCEmbedTable *self, LuaCEmbed *args);\n\nLuaCEmbedResponse *tree_foreach(LuaCEmbedTable *self, LuaCEmbed *args);\n\n"
	}, {
		"path":	"src/tree/tree/json_tree/"
	}, {
		"path":	"src/tree/tree/json_tree/json_tree.c",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse * create_tree_from_json_tree_string(LuaCEmbed *args){\n    char *content = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_msg = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error_msg);\n    }\n    UniversalGarbage *garbage =  newUniversalGarbage();\n    DtwTree *tree = newDtwTree();\n    UniversalGarbage_add_return(garbage,DtwTree_free,tree);\n\n   bool result = DtwTree_loads_json_tree(tree,content);\n\n    if(result ==false){\n        DtwTree_free(tree);\n        DtwJsonTreeError *error_tree = DtwJsonTreeError_validate_json_tree_by_content(content);\n        UniversalGarbage_add(garbage,DtwJsonTreeError_free,error_tree);\n\n        LuaCEmbedResponse *response = LuaCEmbed_send_error(\n            \"%s at index %d\",\n                error_tree->menssage,\n                error_tree->position\n            );\n        UniversalGarbage_free_including_return(garbage);\n        return response;\n    }\n    LuaCEmbedTable * self = raw_create_tree(args,tree);\n    UniversalGarbage_free(garbage);\n    return LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse * create_tree_from_json_tree_file(LuaCEmbed *args){\n\n    char *path = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_msg = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error_msg);\n    }\n    UniversalGarbage *garbage = newUniversalGarbage();\n\n    char *content = dtw_load_string_file_content(path);\n    UniversalGarbage_add_simple(garbage,content);\n    if(content == NULL){\n        UniversalGarbage_free(garbage);\n        return LuaCEmbed_send_error(FILE_NOT_FOUND,path);\n    }\n\n    DtwTree *tree = newDtwTree();\n    UniversalGarbage_add_return(garbage,DtwTree_free,tree);\n\n    bool result = DtwTree_loads_json_tree(tree,content);\n\n    if(result ==false){\n        DtwTree_free(tree);\n        DtwJsonTreeError *error_tree = DtwJsonTreeError_validate_json_tree_by_content(content);\n        UniversalGarbage_add(garbage,DtwJsonTreeError_free,error_tree);\n        LuaCEmbedResponse *response = LuaCEmbed_send_error(\n            \"%s at index %d\",\n                error_tree->menssage,\n                error_tree->position\n            );\n\n        UniversalGarbage_free_including_return(garbage);\n        return response;\n    }\n    LuaCEmbedTable * self = raw_create_tree(args,tree);\n    UniversalGarbage_free(garbage);\n    return LuaCEmbed_send_table(self);\n}\n\n\nLuaCEmbedResponse *tree_dump_to_json_string(LuaCEmbedTable *self, LuaCEmbed *args){\n    LuaCEmbedTable *props_table = NULL;\n    if(LuaCEmbed_get_arg_type(args,0) != LUA_CEMBED_NIL){\n        props_table = LuaCEmbed_get_arg_table(args,0);\n    }\n    if(LuaCEmbed_has_errors(args)){\n        char *error_msg = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error_msg);\n    }\n\n    DtwTreeProps props = create_tree_props(props_table);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_msg = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error_msg);\n    }\n    DtwTree *self_tree = (DtwTree*)LuaCembedTable_get_long_prop(self,TREE_POINTER);\n    char *result = DtwTree_dumps_tree_json(self_tree,props);\n    LuaCEmbedResponse *response = LuaCEmbed_send_str(result);\n    free(result);\n    return  response;\n}\n\nLuaCEmbedResponse *tree_dump_to_json_file(LuaCEmbedTable *self, LuaCEmbed *args){\n    char *path = LuaCEmbed_get_str_arg(args,0);\n    LuaCEmbedTable *props_table = NULL;\n    if(LuaCEmbed_get_arg_type(args,1) != LUA_CEMBED_NIL){\n        props_table = LuaCEmbed_get_arg_table(args,1);\n    }\n    if(LuaCEmbed_has_errors(args)){\n        char *error_msg = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error_msg);\n    }\n\n    DtwTreeProps props = create_tree_props(props_table);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_msg = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error_msg);\n    }\n    DtwTree *self_tree = (DtwTree*)LuaCembedTable_get_long_prop(self,TREE_POINTER);\n    DtwTree_dumps_tree_json_to_file(self_tree,path,props);\n\n    return  LuaCEmbed_send_table(self);\n}"
	}, {
		"path":	"src/tree/tree/json_tree/json_tree.h",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse * create_tree_from_json_tree_string(LuaCEmbed *args);\n\nLuaCEmbedResponse * create_tree_from_json_tree(LuaCEmbed *args);\n\nLuaCEmbedResponse *tree_dump_to_json_string(LuaCEmbedTable *self, LuaCEmbed *args);\n\nLuaCEmbedResponse *tree_dump_to_json_file(LuaCEmbedTable *self, LuaCEmbed *args);\n"
	}, {
		"path":	"src/tree/tree/tree_parts/"
	}, {
		"path":	"src/tree/tree/tree_parts/tree_parts.c",
		"is_binary":	false,
		"content":	"\nLuaCEmbedResponse *new_tree_part(LuaCEmbedTable *self, LuaCEmbed *args){\n    char *path = LuaCEmbed_get_str_arg(args,0);\n\n    LuaCEmbedTable *props_table = NULL;\n    if(LuaCEmbed_get_arg_type(args,1) != LUA_CEMBED_NIL){\n        props_table = LuaCEmbed_get_arg_table(args,1);\n    }\n    if(LuaCEmbed_has_errors(args)){\n        char *error_msg = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error_msg);\n    }\n\n\n    if(LuaCEmbed_has_errors(args)){\n        char *error_msg = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error_msg);\n    }\n\n    DtwTree *self_tree = (DtwTree*)LuaCembedTable_get_long_prop(self,TREE_POINTER);\n    DtwTreeProps props = create_tree_props(props_table);\n    DtwTreePart *tree_part = newDtwTreePart(path,props);\n    DtwTree_add_tree_part_getting_onwership(self_tree,tree_part);\n    LuaCEmbedTable *tree_part_table = create_tree_part_reference(args,tree_part);\n    return LuaCEmbed_send_table(tree_part_table);\n}\n\nLuaCEmbedResponse *new_tree_part_loading(LuaCEmbedTable *self, LuaCEmbed *args){\n    char *path = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_msg = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error_msg);\n    }\n    DtwTree *self_tree = (DtwTree*)LuaCembedTable_get_long_prop(self,TREE_POINTER);\n    DtwTreePart *tree_part = newDtwTreePartLoading(path);\n    DtwTree_add_tree_part_getting_onwership(self_tree,tree_part);\n    LuaCEmbedTable *tree_part_table = create_tree_part_reference(args,tree_part);\n    return LuaCEmbed_send_table(tree_part_table);\n}\n\nLuaCEmbedResponse *new_tree_part_empty(LuaCEmbedTable *self, LuaCEmbed *args){\n\n    char *path = LuaCEmbed_get_str_arg(args,0);\n    if(LuaCEmbed_has_errors(args)){\n        char *error_msg = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error_msg);\n    }\n    DtwTree *self_tree = (DtwTree*)LuaCembedTable_get_long_prop(self,TREE_POINTER);\n    DtwTreePart *tree_part = newDtwTreePartEmpty(path);\n    DtwTree_add_tree_part_getting_onwership(self_tree,tree_part);\n    LuaCEmbedTable *tree_part_table = create_tree_part_reference(args,tree_part);\n    return LuaCEmbed_send_table(tree_part_table);\n}\n\nLuaCEmbedResponse *get_tree_part_by_index(LuaCEmbedTable *self, LuaCEmbed *args){\n\n    long index = LuaCEmbed_get_long_arg(args,0)-1;\n    if(LuaCEmbed_has_errors(args)){\n        char *error_msg = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error_msg);\n    }\n\n    DtwTree *self_tree = (DtwTree*)LuaCembedTable_get_long_prop(self,TREE_POINTER);\n    if(index>=self_tree->size){\n        return NULL;\n    }\n\n    LuaCEmbedTable *result  = create_tree_part_reference(args,self_tree->tree_parts[index]);\n    return  LuaCEmbed_send_table(result);\n}\n\n\n\nLuaCEmbedResponse *tree_get_tree_part_by_name(LuaCEmbedTable *self, LuaCEmbed *args){\n    char *name = LuaCEmbed_get_str_arg(args,0);\n\n    if(LuaCEmbed_has_errors(args)){\n        char *error_msg = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error_msg);\n    }\n\n    DtwTree *self_tree = (DtwTree*)LuaCembedTable_get_long_prop(self,TREE_POINTER);\n    DtwTreePart * possible = DtwTree_find_tree_part_by_name(self_tree,name);\n    if(possible == NULL){\n        return NULL;\n    }\n    LuaCEmbedTable *created_table = create_tree_part_reference(args,possible);\n    return LuaCEmbed_send_table(created_table);\n}\n\n\n\nLuaCEmbedResponse *tree_get_tree_part_by_path(LuaCEmbedTable *self, LuaCEmbed *args){\n    char *path = LuaCEmbed_get_str_arg(args,0);\n\n    if(LuaCEmbed_has_errors(args)){\n        char *error_msg = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error_msg);\n    }\n\n    DtwTree *self_tree = (DtwTree*)LuaCembedTable_get_long_prop(self,TREE_POINTER);\n    DtwTreePart * possible = DtwTree_find_tree_part_by_path(self_tree,path);\n    if(possible == NULL){\n        return NULL;\n    }\n    LuaCEmbedTable *created_table = create_tree_part_reference(args,possible);\n    return LuaCEmbed_send_table(created_table);\n}\n\n"
	}, {
		"path":	"src/tree/tree/tree_parts/tree_parts.h",
		"is_binary":	false,
		"content":	"\n\n\nLuaCEmbedResponse *new_tree_part(LuaCEmbedTable *self, LuaCEmbed *args);\n\nLuaCEmbedResponse *new_tree_part_loading(LuaCEmbedTable *self, LuaCEmbed *args);\n\nLuaCEmbedResponse *new_tree_part_empty(LuaCEmbedTable *self, LuaCEmbed *args);\n\nLuaCEmbedResponse *get_tree_part_by_index(LuaCEmbedTable *self, LuaCEmbed *args);\n\nLuaCEmbedResponse *tree_get_tree_part_by_name(LuaCEmbedTable *self, LuaCEmbed *args);\n\n\nLuaCEmbedResponse *tree_get_tree_part_by_path(LuaCEmbedTable *self, LuaCEmbed *args);\n\n"
	}, {
		"path":	"src/tree/tree_part/"
	}, {
		"path":	"src/tree/tree_part/tree_part.c",
		"is_binary":	false,
		"content":	"\n\nLuaCEmbedResponse * tree_part_exist_in_hardware(LuaCEmbedTable *self,LuaCEmbed *args) {\n    DtwTreePart *self_part  = (DtwTreePart*)LuaCembedTable_get_long_prop(self,TREE_PART_POINTER);\n    return  LuaCEmbed_send_bool(self_part->content_exist_in_hardware);\n}\n\n\nLuaCEmbedResponse * tree_part_exis(LuaCEmbedTable *self,LuaCEmbed *args) {\n    DtwTreePart *self_part  = (DtwTreePart*)LuaCembedTable_get_long_prop(self,TREE_PART_POINTER);\n    if(self_part->content_exist_in_hardware) {\n        return  LuaCEmbed_send_bool(true);\n    }\n    if(self_part->content) {\n        return  LuaCEmbed_send_bool(true);\n    }\n    return LuaCEmbed_send_bool(false);\n\n}\n\n\nLuaCEmbedResponse * tree_part_get_value(LuaCEmbedTable *self,LuaCEmbed *args){\n    DtwTreePart *self_part  = (DtwTreePart*)LuaCembedTable_get_long_prop(self,TREE_PART_POINTER);\n\n    if(self_part->content){\n        return LuaCEmbed_send_raw_string((char*)self_part->content,self_part->content_size);\n    }\n    return NULL;\n}\n\nLuaCEmbedResponse * tree_part_to_string(LuaCEmbedTable *self,LuaCEmbed *args){\n    DtwTreePart *self_part  = (DtwTreePart*)LuaCembedTable_get_long_prop(self,TREE_PART_POINTER);\n\n    if(self_part->content){\n        return LuaCEmbed_send_raw_string((char*)self_part->content,self_part->content_size);\n    }\n    return LuaCEmbed_send_str(DtwPath_get_path(self_part->path));\n}\n\nLuaCEmbedResponse * tree_part_set_value(LuaCEmbedTable *self,LuaCEmbed *args){\n    Writeble  *write_obj = create_writeble(args,0);\n    if(write_obj->error){\n        LuaCEmbedResponse *response =  write_obj->error;\n        Writeble_free(write_obj);\n        return  response;\n    }\n    DtwTreePart *self_part  = (DtwTreePart*)LuaCembedTable_get_long_prop(self,TREE_PART_POINTER);\n    DtwTreePart_set_any_content(self_part,write_obj->content,write_obj->size,write_obj->is_binary);\n    Writeble_free(write_obj);\n    return LuaCEmbed_send_table(self);\n}\n\n\nLuaCEmbedResponse * tree_part_hardware_remove(LuaCEmbedTable *self,LuaCEmbed *args){\n    bool set_as_action = true;\n    if(LuaCEmbed_get_arg_type(args,0) != LUA_CEMBED_NIL){\n        set_as_action = LuaCEmbed_get_bool_arg(args,0);\n    }\n\n    if(LuaCEmbed_has_errors(args)){\n        const char *error_menssage = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error_menssage);\n    }\n\n    DtwTreePart *self_part  = (DtwTreePart*)LuaCembedTable_get_long_prop(self,TREE_PART_POINTER);\n    DtwTreePart_hardware_remove(self_part,set_as_action);\n    return LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse * tree_part_hardware_write(LuaCEmbedTable *self,LuaCEmbed *args){\n\n    bool set_as_action = true;\n    if(LuaCEmbed_get_arg_type(args,0) != LUA_CEMBED_NIL){\n        set_as_action = LuaCEmbed_get_bool_arg(args,0);\n    }\n\n    if(LuaCEmbed_has_errors(args)){\n        const char *error_menssage = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error_menssage);\n    }\n\n\n    DtwTreePart *self_part  = (DtwTreePart*)LuaCembedTable_get_long_prop(self,TREE_PART_POINTER);\n    DtwTreePart_hardware_write(self_part,set_as_action);\n    return LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse * tree_part_hardware_modify(LuaCEmbedTable *self,LuaCEmbed *args){\n\n    bool set_as_action = true;\n    if(LuaCEmbed_get_arg_type(args,0) != LUA_CEMBED_NIL){\n        set_as_action = LuaCEmbed_get_bool_arg(args,0);\n    }\n\n    if(LuaCEmbed_has_errors(args)){\n        const char *error_menssage = LuaCEmbed_get_error_message(args);\n        return LuaCEmbed_send_error(error_menssage);\n    }\n\n    DtwTreePart *self_part  = (DtwTreePart*)LuaCembedTable_get_long_prop(self,TREE_PART_POINTER);\n    DtwTreePart_hardware_modify(self_part,set_as_action);\n    return LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse * tree_part_get_content_sha(LuaCEmbedTable *self,LuaCEmbed *args){\n    DtwTreePart *self_part  = (DtwTreePart*)LuaCembedTable_get_long_prop(self,TREE_PART_POINTER);\n    if(self_part->current_sha){\n        return LuaCEmbed_send_str(self_part->current_sha);\n    }\n    return NULL;\n}\n\n\nLuaCEmbedResponse * tree_part_unload_content(LuaCEmbedTable *self,LuaCEmbed *args){\n    DtwTreePart *self_part  = (DtwTreePart*)LuaCembedTable_get_long_prop(self,TREE_PART_POINTER);\n    DtwTreePart_free_content(self_part);\n    return LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse * tree_part_load_content(LuaCEmbedTable *self,LuaCEmbed *args){\n    DtwTreePart *self_part  = (DtwTreePart*)LuaCembedTable_get_long_prop(self,TREE_PART_POINTER);\n    DtwTreePart_load_content_from_hardware(self_part);\n    return LuaCEmbed_send_table(self);\n}\n\nLuaCEmbedResponse *tree_part_is_blob(LuaCEmbedTable *self, LuaCEmbed *args){\n    DtwTreePart *self_part  = (DtwTreePart*)LuaCembedTable_get_long_prop(self,TREE_PART_POINTER);\n    return  LuaCEmbed_send_bool(self_part->is_binary);\n}\n\nLuaCEmbedTable * create_tree_part_reference(LuaCEmbed *args,DtwTreePart *part){\n    LuaCEmbedTable *self = LuaCembed_new_anonymous_table(args);\n    LuaCEmbedTable_set_long_prop(self,TREE_PART_POINTER,(long long)part);\n    LuaCEmbedTable_set_long_prop(self,DTW_TYPE,DTW_TREE_PART_TYPE);\n    LuaCEmbedTable *path = create_path_reference(args,part->path);\n    LuaCEmbedTable_set_sub_table_prop(self,PATH_PROPS,path);\n    LuaCEmbedTable_set_method(self,GET_VALUE_METHOD,tree_part_get_value);\n    LuaCEmbedTable_set_method(self,SET_VALUE_METHOD,tree_part_set_value);\n    LuaCEmbedTable_set_method(self,HARDWARE_REMOVE_METHOD,tree_part_hardware_remove);\n    LuaCEmbedTable_set_method(self,HARDWARE_MODIFY_METHOD,tree_part_hardware_modify);\n    LuaCEmbedTable_set_method(self,HARWARE_WRITE_METHOD,tree_part_hardware_write);\n    LuaCEmbedTable_set_method(self,GET_SHA_METHOD,tree_part_get_content_sha);\n    LuaCEmbedTable_set_method(self,UNLOAD_METHOD,tree_part_unload_content);\n    LuaCEmbedTable_set_method(self,TO_STRING_METHOD,tree_part_to_string);\n    LuaCEmbedTable_set_method(self,IS_BLOB_FUNC,tree_part_is_blob);\n    LuaCEmbedTable_set_method(self,LOAD_METHOD,tree_part_load_content);\n    LuaCEmbedTable_set_method(self,TREE_PART_CONTENT_EXIST,tree_part_exis);\n    LuaCEmbedTable_set_method(self,TREE_PART_CONTENT_EXIST_IN_HARDWARE,tree_part_exist_in_hardware);\n    return self;\n}\n\n\n\n"
	}, {
		"path":	"src/tree/tree_part/tree_part.h",
		"is_binary":	false,
		"content":	"\n\nLuaCEmbedResponse * tree_part_get_value(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * tree_part_exist_in_hardware(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * tree_part_exis(LuaCEmbedTable *self,LuaCEmbed *args);\n\n\nLuaCEmbedResponse * tree_part_to_string(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse *tree_part_is_blob(LuaCEmbedTable *self, LuaCEmbed *args);\n\n\nLuaCEmbedResponse * tree_part_set_value(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * tree_part_hardware_remove(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * tree_part_hardware_write(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * tree_part_hardware_modify(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * tree_part_get_content_sha(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * tree_part_unload_content(LuaCEmbedTable *self,LuaCEmbed *args);\n\nLuaCEmbedResponse * tree_part_load_content(LuaCEmbedTable *self,LuaCEmbed *args);\n\n\n\nLuaCEmbedTable * create_tree_part_reference(LuaCEmbed *args,DtwTreePart *part);\n"
	}, {
		"path":	"src/types/"
	}, {
		"path":	"src/types/types.c",
		"is_binary":	false,
		"content":	"\n\n\n\nLuaCEmbedResponse * ensure_table_type(LuaCEmbedTable *table,int expected_type,const char *expected_type_string){\n\n    if(LuaCEmbedTable_get_type_prop(table,DTW_TYPE) != LUA_CEMBED_NUMBER){\n        char formated_error[100] = {0};\n        sprintf(formated_error,NOT_EXPECTED_TYPE,expected_type_string);\n        return LuaCEmbed_send_error(formated_error);\n    }\n    long type = LuaCembedTable_get_long_prop(table,DTW_TYPE);\n    if(type !=  expected_type){\n        char formated_error[100] = {0};\n        sprintf(formated_error,NOT_EXPECTED_TYPE,expected_type_string);\n        return LuaCEmbed_send_error(formated_error);\n    }\n    return NULL;\n}\n"
	}, {
		"path":	"src/types/types.h",
		"is_binary":	false,
		"content":	"\n\n\n\nLuaCEmbedResponse * ensure_table_type(LuaCEmbedTable *table,int expected_type,const char *expected_type_string);"
	}, {
		"path":	"src/writeble/"
	}, {
		"path":	"src/writeble/writble.c",
		"is_binary":	false,
		"content":	"\nbool handle_table_writble(Writeble *self,LuaCEmbed *args,int index){\n    LuaCEmbedTable * element = LuaCEmbed_get_arg_table(args,index);\n    if(LuaCEmbedTable_get_type_prop(element,DTW_TYPE) != LUA_CEMBED_NUMBER){\n        return false;\n    }\n\n    int type = LuaCembedTable_get_long_prop(element,DTW_TYPE);\n\n\n    if(type == DTW_RESOURCE_TYPE) {\n        DtwResource *resource = (DtwResource *) LuaCembedTable_get_long_prop(element, RESOURCE_POINTER);\n        self->content = DtwResource_get_any(resource, &self->size, &self->is_binary);\n        if (DtwResource_error(resource)) {\n            char *message = DtwResource_get_error_message(resource);\n            self->error = LuaCEmbed_send_error(message);\n            DtwResource_clear_errors(resource);\n            return false;\n        }\n        return true;\n    }\n\n    if(type == DTW_TREE_PART_TYPE){\n        DtwTreePart *part = (DtwTreePart*)LuaCembedTable_get_long_prop(element,TREE_PART_POINTER);\n        DtwTreePart_load_content_from_hardware(part);\n        if(part->content==NULL){\n            return false;\n        }\n        self->content = part->content;\n        self->size =part->content_size;\n        self->is_binary = part->content_size;\n        return true;\n    }\n    if(type == DTW_ACTION_TRANSACTION_TYPE){\n        DtwActionTransaction *transaction= (DtwActionTransaction*)LuaCembedTable_get_long_prop(element,TRANSACTION_POINTER);\n        if(transaction->content == NULL){\n            return false;\n        }\n        self->content = transaction->content;\n        self->size=  transaction->size;\n        self->is_binary =transaction->is_binary;\n        return true;\n    }\n\n    return false;\n\n}\nWriteble  * create_writeble(LuaCEmbed *args,int index){\n    Writeble *self =  (Writeble*)malloc(sizeof(Writeble));\n    *self = (Writeble){0};\n    long total_args = LuaCEmbed_get_total_args(args);\n    if(total_args == 0){\n        self->error = LuaCEmbed_send_error(ARGUMENT_NOT_PROVIDED);\n        return self;\n    }\n\n    int type_to_write = LuaCEmbed_get_arg_type(args,index);\n    bool writeble = false;\n    if(type_to_write == LUA_CEMBED_STRING){\n        self->content = (unsigned  char*)LuaCEmbed_get_raw_str_arg(args,&self->size,index);\n        for(long i = 0; i < self->size;i++){\n            if(self->content[i] == 0){\n                self->is_binary = true;\n                break;\n            }\n        }\n\n        writeble = true;\n    }\n\n    if(type_to_write == LUA_CEMBED_NUMBER){\n        self->clear_content = true;\n        double content = LuaCEmbed_get_double_arg(args,index);\n        double rest = content - (double)(long ) content;\n        if(rest == 0){\n            char formatted[20] = {0};\n            sprintf(formatted,\"%ld\",(long)content);\n            self->content = (unsigned char*)strdup(formatted);\n            self->size = (long)strlen(formatted);\n        }\n        else{\n            char formatted[20] = {0};\n            sprintf(formatted,\"%lf\",content);\n            self->content = (unsigned char*)strdup(formatted);\n            self->size = (long)strlen(formatted);\n        }\n        writeble = true;\n    }\n    if(type_to_write == LUA_CEMBED_BOOL){\n        bool content  = LuaCEmbed_get_bool_arg(args,index);\n        const char *converted = content ? \"true\":\"false\";\n        self->content = (unsigned char*)converted;\n        self->size = (long)strlen(converted);\n        writeble = true;\n    }\n\n    if(type_to_write == LUA_CEMBED_TABLE){\n        writeble = handle_table_writble(self,args,index);\n    }\n\n    bool its_not_writible_and_no_other_errors = !writeble && self->error == NULL;\n    if(its_not_writible_and_no_other_errors){\n        char *error = private_LuaCembed_format(NOT_WRITEBLE_ELEMENT,LuaCembed_convert_arg_code(type_to_write));\n        self->error = LuaCEmbed_send_error(error);\n        free(error);\n        return self;\n    }\n\n    return self;\n}\nvoid Writeble_free(Writeble *self){\n    if(self->clear_content){\n        free(self->content);\n    }\n    free(self);\n}"
	}, {
		"path":	"src/writeble/writble.h",
		"is_binary":	false,
		"content":	"\n\ntypedef struct{\n    unsigned  char *content;\n    bool clear_content;\n    long size;\n    bool is_binary;\n    LuaCEmbedResponse  *error;\n}Writeble;\n\nWriteble  *create_writeble(LuaCEmbed *args,int index);\n\nvoid Writeble_free(Writeble *self);"
	}]